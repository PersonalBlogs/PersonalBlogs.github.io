{"meta":{"title":"Hexo-Blog","subtitle":"","description":"","author":"廖家龙-13176171912","url":"http://example.com","root":"/"},"pages":[{"title":"「分类、标签」","date":"2020-09-07T08:06:00.000Z","updated":"2021-05-20T09:01:17.871Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"「网站信息」","date":"2020-11-28T15:37:27.000Z","updated":"2021-05-20T08:58:15.123Z","comments":true,"path":"网站信息/index.html","permalink":"http://example.com/%E7%BD%91%E7%AB%99%E4%BF%A1%E6%81%AF/index.html","excerpt":"","text":"本站是一个博客类型的静态网站，部署在GitHub服务器上，有时候访问速度会比较慢 想要搭建这个网站是因为CSDN、简书等平台的简洁度不太能满足我的要求，本站的主要目的是为了保存我学习计算机过程中所写的‘博客’和‘笔记’，这是一个极度简洁的网站！ ‘首页’部分列出了本站所有的文章，并且是按照时间倒序排列的 ‘分类、标签’板块可以清晰的看出本站文章有哪些分类，有哪些标签，点击分类和标签可以跳转到对应内容 本站每篇文章都只属于一个分类下的一个标签，不存在一篇文章同属于多个分类、多个标签的情况 分类类似于一个文件夹，标签类似于该文件夹下的一个小文件夹，文章就是该小文件夹下的一个文件"}],"posts":[{"title":"本地项目上传至GitHub_GitLab","slug":"Apple、Linux/macOS/本地项目上传至GitHub_GitLab","date":"2021-05-10T16:00:00.000Z","updated":"2021-05-11T09:36:01.236Z","comments":true,"path":"2021/05/11/Apple、Linux/macOS/本地项目上传至GitHub_GitLab/","link":"","permalink":"http://example.com/2021/05/11/Apple%E3%80%81Linux/macOS/%E6%9C%AC%E5%9C%B0%E9%A1%B9%E7%9B%AE%E4%B8%8A%E4%BC%A0%E8%87%B3GitHub_GitLab/","excerpt":"","text":"首次使用 配置SSH ⭐️cd 项目文件夹 ⭐️git init ⭐️ssh-keygen -t rsa -C “&#x32;&#54;&#x36;&#56;&#56;&#x30;&#50;&#x35;&#x37;&#x30;&#x40;&#x71;&#113;&#46;&#99;&#111;&#109;“ ⭐️pbcopy &lt; ~/.ssh/id_rsa.pub #将ssh代码复制到剪贴板 ⭐️回到GitHub/GitLab界面，将刚才生成的ssh配置到GitHub/GitLab里 ⭐️ssh -T &#103;&#x69;&#116;&#x40;&#103;&#x69;&#116;&#x68;&#117;&#x62;&#x2e;&#x63;&#111;&#x6d; #验证是否添加ssh成功了 开始上传代码 ⭐️git clone 仓库地址 ⭐️cd 仓库 ⭐️git add –all ⭐️git commit -m “第1次上传” ⭐️git push 以后使用 ⭐️cd 项目文件夹 ⭐️执行步骤2","categories":[{"name":"Apple、Linux","slug":"Apple、Linux","permalink":"http://example.com/categories/Apple%E3%80%81Linux/"}],"tags":[{"name":"macOS","slug":"macOS","permalink":"http://example.com/tags/macOS/"}]},{"title":"UIView的外观属性","slug":"代码仓库/iOS-功能demo/UIView的外观属性","date":"2021-04-29T16:00:00.000Z","updated":"2021-04-26T08:17:14.000Z","comments":true,"path":"2021/04/30/代码仓库/iOS-功能demo/UIView的外观属性/","link":"","permalink":"http://example.com/2021/04/30/%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93/iOS-%E5%8A%9F%E8%83%BDdemo/UIView%E7%9A%84%E5%A4%96%E8%A7%82%E5%B1%9E%E6%80%A7/","excerpt":"","text":"12345678910111213141516171819202122232425262728//UIView的外观属性：背景颜色、切边、透明度、显示与隐藏 let view = UIView(frame: CGRect(x: 40, y: 80, width: 240, height: 240)) view.backgroundColor = UIColor.black /* 将一张图片作为视图的背景颜色 let view = UIView(frame: CGRect(x: 40, y: 80, width: 240, height: 240)) let image = UIImage(named: &quot;logo&quot;) view.backgroundColor = UIColor.init(patternImage: image!) self.view.addSubview(view) //使用UIColor类的init方法将加载的图片作为图案平铺在视图的背景中 */ view.alpha = 0.3 //透明度 //当把alpha的值设置成0以后：当前的UIView及其子视图都会被隐藏，而不管子视图的alpha值为多少；当前的UIView会从响应者链中移除，而响应者链中的下一个会成为第一响应者 view.isHidden = false //表示UIView视图是否处于隐藏的状态 //当把值设为true时，当前的UIView及其子视图都会被隐藏，而不管子视图的hidden值为多少；当前的UIView会从响应者链中移除，而响应者链中的下一个会成为第一响应者 let subView = UIView(frame: CGRect(x: 40, y: 40, width: 240, height: 240)) subView.backgroundColor = UIColor.green view.addSubview(subView) view.clipsToBounds = true //在默认情况下，当向一个视图中添加一个子视图时，如果子视图的区域超出了父视图的范围，子视图超出的部分仍然会在屏幕上正常显示；如果需要限制子视图的显示范围不超过父视图的显示区域，就需要设置父视图的clipsToBounds属性 self.view.addSubview(view) //通过addSubView()方法将设置背景色之后的视图添加到当前视图控制器的根视图中","categories":[{"name":"代码仓库","slug":"代码仓库","permalink":"http://example.com/categories/%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93/"}],"tags":[{"name":"iOS-功能demo","slug":"iOS-功能demo","permalink":"http://example.com/tags/iOS-%E5%8A%9F%E8%83%BDdemo/"}]},{"title":"UIView的几何属性","slug":"代码仓库/iOS-功能demo/UIView的几何属性","date":"2021-04-28T16:00:00.000Z","updated":"2021-04-26T08:17:29.000Z","comments":true,"path":"2021/04/29/代码仓库/iOS-功能demo/UIView的几何属性/","link":"","permalink":"http://example.com/2021/04/29/%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93/iOS-%E5%8A%9F%E8%83%BDdemo/UIView%E7%9A%84%E5%87%A0%E4%BD%95%E5%B1%9E%E6%80%A7/","excerpt":"","text":"12345678910111213141516171819//UIView的几何属性 //frame(origin,size)属性：定义了一个矩形区域，描述一个UIView的大小和在父坐标系的位置 //bounds(origin,size)属性：同样定义了一个矩形区域，描述一个UIView的大小和自身坐标系原点的位置，bounds.origin属性默认值是(0,0)，而bounds.size和frame.size是一致的 //center属性：用于确定一个视图的中心点位置，参照系也是其父视图的坐标系统，在对视图进行放大、缩小或旋转时，该属性的值不会改变 let frame = CGRect(x: 0, y: 0, width: 250, height: 250) let view = UIView(frame: frame) view.backgroundColor = UIColor.black view.bounds = CGRect(x: -50, y: -50, width: 250, height: 250) view.bounds = CGRect(x: -50, y: -50, width: 200, height: 200) let subView = UIView(frame: CGRect(x: 0, y: 0, width: 200, height: 200)) subView.backgroundColor = UIColor.green view.addSubview(subView) self.view.addSubview(view)","categories":[{"name":"代码仓库","slug":"代码仓库","permalink":"http://example.com/categories/%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93/"}],"tags":[{"name":"iOS-功能demo","slug":"iOS-功能demo","permalink":"http://example.com/tags/iOS-%E5%8A%9F%E8%83%BDdemo/"}]},{"title":"","slug":"代码仓库/iOS-功能demo/导航控制器和标签控制器","date":"2021-04-28T03:35:35.000Z","updated":"2021-04-28T03:35:35.000Z","comments":true,"path":"2021/04/28/代码仓库/iOS-功能demo/导航控制器和标签控制器/","link":"","permalink":"http://example.com/2021/04/28/%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93/iOS-%E5%8A%9F%E8%83%BDdemo/%E5%AF%BC%E8%88%AA%E6%8E%A7%E5%88%B6%E5%99%A8%E5%92%8C%E6%A0%87%E7%AD%BE%E6%8E%A7%E5%88%B6%E5%99%A8/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"UIView的嵌套和层次关系","slug":"代码仓库/iOS-功能demo/UIView的嵌套和层次关系","date":"2021-04-27T16:00:00.000Z","updated":"2021-04-26T08:17:44.000Z","comments":true,"path":"2021/04/28/代码仓库/iOS-功能demo/UIView的嵌套和层次关系/","link":"","permalink":"http://example.com/2021/04/28/%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93/iOS-%E5%8A%9F%E8%83%BDdemo/UIView%E7%9A%84%E5%B5%8C%E5%A5%97%E5%92%8C%E5%B1%82%E6%AC%A1%E5%85%B3%E7%B3%BB/","excerpt":"","text":"123456789101112131415161718192021222324252627//UIView的嵌套和层次关系 let firstView = UIView(frame: CGRect(x: 20, y: 40, width: 200, height: 200)) firstView.backgroundColor = UIColor.black let secondView = UIView(frame: CGRect(x: 50, y: 70, width: 200, height: 200)) secondView.backgroundColor = UIColor.red let thirdView = UIView(frame: CGRect(x: 80, y: 100, width: 200, height: 200)) thirdView.backgroundColor = UIColor.green self.view.addSubview(firstView) self.view.addSubview(secondView) self.view.addSubview(thirdView) //self.view.insertSubview(secondView, at: 2) //在指定的位置上插入视图 //self.view.insertSubview(thirdView, aboveSubview: secondView) //将第三个视图插入第二个视图的上方 //self.view.insertSubview(thirdView, belowSubview: secondView) //将第三个视图插入第二个视图的下方 //self.view.bringSubviewToFront(firstView) //将第一个视图放置在所有子视图的上方 //self.view.exchangeSubview(at: 2, withSubviewAt: 3) //交换两个指定位置的子视图在父视图中的位置 //firstView.removeFromSuperview() //将第一个视图从其父视图中删除","categories":[{"name":"代码仓库","slug":"代码仓库","permalink":"http://example.com/categories/%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93/"}],"tags":[{"name":"iOS-功能demo","slug":"iOS-功能demo","permalink":"http://example.com/tags/iOS-%E5%8A%9F%E8%83%BDdemo/"}]},{"title":"UIView的交互属性","slug":"代码仓库/iOS-功能demo/UIView的交互属性","date":"2021-04-26T16:00:00.000Z","updated":"2021-04-26T08:17:57.000Z","comments":true,"path":"2021/04/27/代码仓库/iOS-功能demo/UIView的交互属性/","link":"","permalink":"http://example.com/2021/04/27/%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93/iOS-%E5%8A%9F%E8%83%BDdemo/UIView%E7%9A%84%E4%BA%A4%E4%BA%92%E5%B1%9E%E6%80%A7/","excerpt":"","text":"12345678910111213141516171819202122232425262728import UIKitclass ViewController: UIViewController &#123; override func viewDidLoad() &#123; super.viewDidLoad() // Do any additional setup after loading the view. //UIView的交互属性 let touchView = UIView(frame: CGRect(x: 60, y: 60, width: 200, height: 200)) touchView.backgroundColor = UIColor.black self.view.addSubview(touchView) let guesture = UITapGestureRecognizer(target: self, action: #selector(ViewController.SingleTap)) //创建了一个UITapGestureRecognizer手势对象 touchView.addGestureRecognizer(guesture) //通过addGestureRecognizer方法将手势对象指定给视图对象 &#125; @objc func SingleTap() &#123; print(&quot;You touched me.&quot;) &#125;&#125;","categories":[{"name":"代码仓库","slug":"代码仓库","permalink":"http://example.com/categories/%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93/"}],"tags":[{"name":"iOS-功能demo","slug":"iOS-功能demo","permalink":"http://example.com/tags/iOS-%E5%8A%9F%E8%83%BDdemo/"}]},{"title":"UIView的变形操作","slug":"代码仓库/iOS-功能demo/UIView的变形操作","date":"2021-04-25T16:00:00.000Z","updated":"2021-04-26T10:10:08.000Z","comments":true,"path":"2021/04/26/代码仓库/iOS-功能demo/UIView的变形操作/","link":"","permalink":"http://example.com/2021/04/26/%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93/iOS-%E5%8A%9F%E8%83%BDdemo/UIView%E7%9A%84%E5%8F%98%E5%BD%A2%E6%93%8D%E4%BD%9C/","excerpt":"","text":"1234567891011121314151617181920//UIView的变形操作 let view = UIView(frame: CGRect(x: 0, y: 0, width: 200, height: 50)) view.center = self.view.center view.backgroundColor = UIColor.black self.view.addSubview(view) let transform = view.transform view.transform = transform.translatedBy(x: 0, y: 100) //垂直方向上将视图的矩阵向下平移了100 view.transform = transform.scaledBy(x: 1.5, y: 1.5) //缩放仿射变换 view.transform = transform.rotated(by: 3.14/4) //参数angle表示在顺时针方向上旋转的角度，顺时针旋转45度 //a、d：缩放；tx、ty：平移 //在水平和垂直方向上进行斜切操作 view.transform.b = 0.5 view.transform.c = 0.5","categories":[{"name":"代码仓库","slug":"代码仓库","permalink":"http://example.com/categories/%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93/"}],"tags":[{"name":"iOS-功能demo","slug":"iOS-功能demo","permalink":"http://example.com/tags/iOS-%E5%8A%9F%E8%83%BDdemo/"}]},{"title":"CALayer边框","slug":"代码仓库/iOS-功能demo/CALayer边框","date":"2021-04-24T16:00:00.000Z","updated":"2021-04-27T02:18:29.000Z","comments":true,"path":"2021/04/25/代码仓库/iOS-功能demo/CALayer边框/","link":"","permalink":"http://example.com/2021/04/25/%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93/iOS-%E5%8A%9F%E8%83%BDdemo/CALayer%E8%BE%B9%E6%A1%86/","excerpt":"","text":"123456789101112//CALayer边框 let view = UIView(frame: CGRect(x: 60, y: 60, width: 200, height: 200)) view.backgroundColor = UIColor.black view.layer.borderWidth = 20 //设置层的边缘宽度borderWidth为20 view.layer.borderColor = UIColor.lightGray.cgColor //设置层的边缘颜色的值为浅灰色 //因为UIColor是定义在UIKit框架中的，只能在iOS中使用，而CALayer是定义在QuartzCore框架中的，所以需要使用具有跨平台特性的CGColorRef数据类型 self.view.addSubview(view)","categories":[{"name":"代码仓库","slug":"代码仓库","permalink":"http://example.com/categories/%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93/"}],"tags":[{"name":"iOS-功能demo","slug":"iOS-功能demo","permalink":"http://example.com/tags/iOS-%E5%8A%9F%E8%83%BDdemo/"}]},{"title":"CALayer投影","slug":"代码仓库/iOS-功能demo/CALayer投影","date":"2021-04-23T16:00:00.000Z","updated":"2021-04-27T02:29:48.000Z","comments":true,"path":"2021/04/24/代码仓库/iOS-功能demo/CALayer投影/","link":"","permalink":"http://example.com/2021/04/24/%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93/iOS-%E5%8A%9F%E8%83%BDdemo/CALayer%E6%8A%95%E5%BD%B1/","excerpt":"","text":"123456789101112//CALayer投影 let view = UIView(frame: CGRect(x: 60, y: 60, width: 200, height: 200)) view.backgroundColor = UIColor.black view.layer.shadowColor = UIColor.black.cgColor //设置阴影颜色为黑色 view.layer.shadowOffset = CGSize(width: 10.0, height: 10.0) //设置阴影的偏移值，即在水平方向上向右侧偏移10，在垂直方向上向下偏移10，默认值为(0.0,-3.0) view.layer.shadowOpacity = 0.45 //设置阴影的不透明度值，默认值为0.0 view.layer.shadowRadius = 5.0 //设置阴影的模糊半径，用来实现阴影的模糊效果，使阴影更加柔和、自然，默认值为3.0 self.view.addSubview(view)","categories":[{"name":"代码仓库","slug":"代码仓库","permalink":"http://example.com/categories/%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93/"}],"tags":[{"name":"iOS-功能demo","slug":"iOS-功能demo","permalink":"http://example.com/tags/iOS-%E5%8A%9F%E8%83%BDdemo/"}]},{"title":"CALayer圆角","slug":"代码仓库/iOS-功能demo/CALayer圆角","date":"2021-04-22T16:00:00.000Z","updated":"2021-04-27T02:43:45.000Z","comments":true,"path":"2021/04/23/代码仓库/iOS-功能demo/CALayer圆角/","link":"","permalink":"http://example.com/2021/04/23/%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93/iOS-%E5%8A%9F%E8%83%BDdemo/CALayer%E5%9C%86%E8%A7%92/","excerpt":"","text":"12345678910111213141516171819//CALayer圆角 let view = UIView(frame: CGRect(x: 60, y: 60, width: 200, height: 200)) view.backgroundColor = UIColor.black view.layer.cornerRadius = 40 //设置层的圆角半径为40 //从模拟器中的效果可以看出，虽然给黑色视图添加了圆角效果，但是由于子视图的存在，无法看到上方两个顶点的圆角效果，这是因为圆角效果只对视图的背景颜色和层的边框起作用，而不会对层中的内容起作用 //view.layer.cornerRadius = 100 //设置圆角半径时，如果设置为正方形宽度的一半，那么将会创建一个正圆形 //view.layer.cornerRadius = 200 view.layer.masksToBounds = true //这行代码会沿着圆角边缘对视图中的内容进行裁切 let subView = UIView(frame: CGRect(x: 0, y: 0, width: 200, height: 100)) subView.backgroundColor = UIColor.gray view.addSubview(subView) self.view.addSubview(view)","categories":[{"name":"代码仓库","slug":"代码仓库","permalink":"http://example.com/categories/%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93/"}],"tags":[{"name":"iOS-功能demo","slug":"iOS-功能demo","permalink":"http://example.com/tags/iOS-%E5%8A%9F%E8%83%BDdemo/"}]},{"title":"CALayer渐变","slug":"代码仓库/iOS-功能demo/CALayer渐变","date":"2021-04-21T16:00:00.000Z","updated":"2021-04-27T03:04:03.000Z","comments":true,"path":"2021/04/22/代码仓库/iOS-功能demo/CALayer渐变/","link":"","permalink":"http://example.com/2021/04/22/%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93/iOS-%E5%8A%9F%E8%83%BDdemo/CALayer%E6%B8%90%E5%8F%98/","excerpt":"","text":"1234567891011121314151617181920212223242526//CALayer渐变 //CALayer和UIView相似地方是，CALayer层也可以嵌套多个子CALayer层，从而实现多种多样的效果 let rect = CGRect(x: 20, y: 60, width: 240, height: 240) let gradientView = UIView(frame: rect) //创建了一个渐变层，并设置渐变层的frame属性与视图的frame属性相同 let gradientLayer = CAGradientLayer() gradientLayer.frame = gradientView.frame //这三个颜色将作为渐变线上的起始颜色、中间颜色、结束颜色 let fromColor = UIColor.yellow.cgColor let midColor = UIColor.blue.cgColor let toColor = UIColor.red.cgColor gradientLayer.colors = [fromColor,midColor,toColor] gradientLayer.startPoint = CGPoint(x: 0, y: 0) //渐变层的起始位置 gradientLayer.endPoint = CGPoint(x: 1, y: 1) //渐变层的终点位置 gradientLayer.locations = [0,0.3,1] //设置了渐变层的各颜色点在颜色线中的分布情况：蓝色将位于渐变线30%的位置 gradientView.layer.addSublayer(gradientLayer) self.view.addSubview(gradientView)","categories":[{"name":"代码仓库","slug":"代码仓库","permalink":"http://example.com/categories/%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93/"}],"tags":[{"name":"iOS-功能demo","slug":"iOS-功能demo","permalink":"http://example.com/tags/iOS-%E5%8A%9F%E8%83%BDdemo/"}]},{"title":"以模态方式弹出视图控制器并传参","slug":"代码仓库/iOS-功能demo/以模态方式弹出视图控制器并传参","date":"2021-04-20T16:00:00.000Z","updated":"2021-04-27T04:12:53.000Z","comments":true,"path":"2021/04/21/代码仓库/iOS-功能demo/以模态方式弹出视图控制器并传参/","link":"","permalink":"http://example.com/2021/04/21/%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93/iOS-%E5%8A%9F%E8%83%BDdemo/%E4%BB%A5%E6%A8%A1%E6%80%81%E6%96%B9%E5%BC%8F%E5%BC%B9%E5%87%BA%E8%A7%86%E5%9B%BE%E6%8E%A7%E5%88%B6%E5%99%A8%E5%B9%B6%E4%BC%A0%E5%8F%82/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import UIKitclass ViewController: UIViewController &#123; var label: UILabel! //该标签用来显示从模态窗口中返回的数据 override func viewDidLoad() &#123; super.viewDidLoad() // Do any additional setup after loading the view. //UIViewController:视图控制器 //UITabBarController:标签控制器 //UINavigationController:导航控制器 //以模态方式弹出视图控制器并传参 //在ViewController.swift中添加一个按钮，当用户点击按钮时，以模态的方式弹出另一个视图控制器，同时向该视图控制器中传入参数 self.view.backgroundColor = UIColor.brown label = UILabel(frame: CGRect(x: 40, y: 100, width: 240, height: 44)) label.text = &quot;&quot; self.view.addSubview(label) let button = UIButton(frame: CGRect(x: 40, y: 180, width: 240, height: 44)) button.setTitle(&quot;打开新的视图控制器&quot;, for: .normal) button.backgroundColor = UIColor.black //给按钮绑定了点击事件，当用户点击该按钮时，将调用相应的方法 button.addTarget(self, action: #selector(ViewController.openViewController), for: .touchUpInside) self.view.addSubview(button) &#125; @objc func openViewController() &#123; let newViewController = NewViewController() newViewController.labelTxt = &quot;传递的参数!&quot; newViewController.viewController = self //设置viewController属性为当前的视图控制器，该属性将被用来从模态视图控制器向当前的视图控制器中返回数据 self.present(newViewController, animated: true, completion: nil) //以模态的方式显示新的视图控制器，第一个参数表示需要打开的视图控制器实例，第二个参数表示是否以动画的方式打开视图控制器，第三个参数表示视图控制器被打开后的回调方法 &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940import UIKitclass NewViewController: UIViewController &#123; weak var viewController: ViewController? //弹出当前视图控制器的源视图控制器 var labelTxt = &quot;&quot; //表示从源视图控制器中传进来的数据 override func viewDidLoad() &#123; super.viewDidLoad() // Do any additional setup after loading the view. //在该类中添加一个标签对象的属性，用来显示从前一个视图控制器传递进来的数据 //还需要添加一个按钮对象，当用户点击该按钮时，退出当前的视图控制器，并返回原来的视图控制器，同时向原来的视图控制器返回数据 self.view.backgroundColor = UIColor.purple let label = UILabel(frame: CGRect(x: 40, y: 100, width: 240, height: 44)) label.text = labelTxt self.view.addSubview(label) let button = UIButton(frame: CGRect(x: 40, y: 180, width: 240, height: 44)) button.setTitle(&quot;关闭&quot;, for: .normal) button.backgroundColor = UIColor.black //当用户点击按钮时，将退出当前的视图控制器，并返回源视图控制器 button.addTarget(self, action: #selector(NewViewController.dismissSelf), for: .touchUpInside) self.view.addSubview(button) &#125; @objc func dismissSelf() &#123; viewController?.label.text = &quot;返回的参数.&quot; self.dismiss(animated: true, completion: nil) &#125;&#125;","categories":[{"name":"代码仓库","slug":"代码仓库","permalink":"http://example.com/categories/%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93/"}],"tags":[{"name":"iOS-功能demo","slug":"iOS-功能demo","permalink":"http://example.com/tags/iOS-%E5%8A%9F%E8%83%BDdemo/"}]},{"title":"UIScrollView","slug":"代码仓库/iOS-功能demo/UIScrollView","date":"2021-04-19T16:00:00.000Z","updated":"2021-04-27T07:37:51.000Z","comments":true,"path":"2021/04/20/代码仓库/iOS-功能demo/UIScrollView/","link":"","permalink":"http://example.com/2021/04/20/%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93/iOS-%E5%8A%9F%E8%83%BDdemo/UIScrollView/","excerpt":"","text":"123456789101112131415import UIKitclass FirstViewController: UIViewController &#123; override func viewDidLoad() &#123; super.viewDidLoad() // Do any additional setup after loading the view. self.view.backgroundColor = UIColor.brown &#125;&#125; 123456789101112131415import UIKitclass SecondViewController: UIViewController &#123; override func viewDidLoad() &#123; super.viewDidLoad() // Do any additional setup after loading the view. self.view.backgroundColor = UIColor.purple &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990import UIKit//让该类遵循UIScrollViewDelegate协议，从而可以检测滚动视图的状态class PageControlViewController: UIViewController, UIScrollViewDelegate &#123; //在滚动ScrollView时可通过PageControl中的小白点来观察当前页面的位置，也可通过点击PageControl中的小白点来滚动到指定的页面 var scrollView = UIScrollView() //滚动视图对象 var pageControl = UIPageControl() //页面控制对象 var isPageControlUsed = false //用来判断是否使用了pageControl对象，如果没有使用pageControl对象，而是使用手指滑动scrollView进行内容的滚动查看，则在查看内容时可实时更新pageControl对象的状态 override func viewDidLoad() &#123; super.viewDidLoad() // Do any additional setup after loading the view. //UIScrollView：UIScrollView是一个能够滚动的视图控件，可以用来展示大量内容，用户可通过在UIScrollView上滑动手指查看多个视图控制器中的内容 //获得当前屏幕的frame属性以及相应的宽度和高度信息 var screenFrame = UIScreen.main.bounds let screenWidth = screenFrame.size.width let screenHeight = screenFrame.size.height scrollView.frame = screenFrame //设置scrollView的显示区域与屏幕尺寸相同，以进行全屏显示 scrollView.isPagingEnabled = true //即scrollView将以一整页为单位进行翻页操作 scrollView.contentSize = CGSize(width: screenWidth*2, height: screenHeight) //因为我们需要scrollView在两个页面中分别显示两个视图控制器的内容 scrollView.backgroundColor = UIColor.black scrollView.delegate = self //设置scrollView的代理对象为当前的视图控制器对象 //设置pageControl的显示区域位于屏幕的底部 let pcHeight: CGFloat = 50.0 let pcRect = CGRect(x: 0, y: screenHeight-pcHeight, width: screenWidth, height: pcHeight) pageControl.frame = pcRect pageControl.numberOfPages = 2 //设置pageControl拥有两个小白点，以标识两页的内容 pageControl.currentPage = 0 //当前处于第一页 pageControl.backgroundColor = UIColor.gray pageControl.addTarget(self, action: #selector(PageControlViewController.pageControlDidChanged(_:)), for: UIControl.Event.valueChanged) //FirstViewController对象将位于scrollView中的第一页 let firstController = FirstViewController() screenFrame.origin.x = 0 firstController.view.frame = screenFrame //SecondViewController对象将位于scrollView中的第二页 let secondController = SecondViewController() screenFrame.origin.x = screenFrame.size.width secondController.view.frame = screenFrame scrollView.addSubview(firstController.view) scrollView.addSubview(secondController.view) self.view.addSubview(scrollView) self.view.addSubview(pageControl) &#125; @objc func pageControlDidChanged(_ sender: AnyObject) &#123; let crtPage = (CGFloat)(pageControl.currentPage) //首先获得pageControl对象当前的页码 var frame = scrollView.frame frame.origin.x = frame.size.width * crtPage frame.origin.y = 0 scrollView.scrollRectToVisible(frame, animated: true) //将scrollView滚动到目标区域 isPageControlUsed = true &#125; //实现UIScrollViewDelegate协议中的scrollViewDidScroll方法，当用户使用手指滑动scrollView时将调用该方法 func scrollViewDidScroll(_ scrollView: UIScrollView) &#123; if !isPageControlUsed &#123; //首先判断是否通过用户的手指进行scrollView的滑动 //如果是，就监控scrollView在水平方向上的偏移值，当scrollView在水平方向上被拖动超过屏幕宽度一半距离时，计算pageControl对应的页码 let pageWidth = scrollView.frame.size.width let page = floor((scrollView.contentOffset.x - pageWidth/2)/pageWidth) + 1 pageControl.currentPage = Int(page) &#125; &#125; //实现UIScrollViewDelegate协议中的scrollViewDidEndDecelerating方法 //该方法将在scrollView减速至停止滚动时被调用 func scrollViewDidEndDecelerating(_ scrollView: UIScrollView) &#123; isPageControlUsed = false &#125;&#125; 12345678910111213class AppDelegate: UIResponder, UIApplicationDelegate &#123; var window: UIWindow? func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -&gt; Bool &#123; // Override point for customization after application launch. self.window?.rootViewController = PageControlViewController() //修改当前窗口的根视图控制器 return true &#125; 最后别忘了设置默认启动界面！","categories":[{"name":"代码仓库","slug":"代码仓库","permalink":"http://example.com/categories/%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93/"}],"tags":[{"name":"iOS-功能demo","slug":"iOS-功能demo","permalink":"http://example.com/tags/iOS-%E5%8A%9F%E8%83%BDdemo/"}]},{"title":"UITabBarController","slug":"代码仓库/iOS-功能demo/UITabBarController","date":"2021-04-18T16:00:00.000Z","updated":"2021-04-28T02:42:45.000Z","comments":true,"path":"2021/04/19/代码仓库/iOS-功能demo/UITabBarController/","link":"","permalink":"http://example.com/2021/04/19/%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93/iOS-%E5%8A%9F%E8%83%BDdemo/UITabBarController/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536import UIKitclass FirstViewController: UIViewController &#123; override func viewDidLoad() &#123; super.viewDidLoad() // Do any additional setup after loading the view. self.view.backgroundColor = UIColor.brown self.title = &quot;Item #1&quot; //该标题将显示在Tab上 self.tabBarItem.image = UIImage(named: &quot;Tab1&quot;) let label = UILabel(frame: CGRect(x: 40, y: 150, width: 240, height: 44)) label.text = &quot;第一页&quot; label.textAlignment = NSTextAlignment.center label.font = UIFont(name: &quot;Arial&quot;, size: 36) //当用户点击该按钮时，跳转到UITabBarController实例中的第二个界面 let button = UIButton(frame: CGRect(x: 40, y: 220, width: 240, height: 44)) button.setTitle(&quot;进入第二页&quot;, for: UIControl.State()) button.backgroundColor = UIColor.black button.addTarget(self, action: #selector(FirstViewController.enterPage2), for: .touchUpInside) self.view.addSubview(button) self.view.addSubview(label) &#125; //当用户点击按钮时，首先通过tabBarController属性获得当前视图控制器所属的tabBarController，然后设置tabBarController对象的selectedIndex属性的值为1，即可进入tabBarController中的第二个界面 @objc func enterPage2() &#123; self.tabBarController?.selectedIndex = 1 &#125;&#125; 123456789101112131415161718192021222324252627import UIKitclass SecondViewController: UIViewController &#123; override func viewDidLoad() &#123; super.viewDidLoad() // Do any additional setup after loading the view. self.view.backgroundColor = UIColor.green self.title = &quot;Item #2&quot; //该标题将显示在Tab上 self.tabBarItem.image = UIImage(named: &quot;Tab2&quot;) let label = UILabel(frame: CGRect(x: 40, y: 150, width: 240, height: 44)) label.text = &quot;第二页&quot; label.textAlignment = NSTextAlignment.center label.font = UIFont(name: &quot;Arial&quot;, size: 36) self.view.addSubview(label) //在Tab图标上显示角标 self.tabBarItem.badgeValue = &quot;8&quot; &#125;&#125; 123456789101112131415161718192021222324import UIKitclass ThirdViewController: UIViewController &#123; override func viewDidLoad() &#123; super.viewDidLoad() // Do any additional setup after loading the view. self.view.backgroundColor = UIColor.red self.title = &quot;Item #3&quot; //该标题将显示在Tab上 self.tabBarItem.image = UIImage(named: &quot;Tab3&quot;) let label = UILabel(frame: CGRect(x: 40, y: 150, width: 240, height: 44)) label.text = &quot;第三页&quot; label.textAlignment = NSTextAlignment.center label.font = UIFont(name: &quot;Arial&quot;, size: 36) self.view.addSubview(label) &#125;&#125; 12345678910111213141516171819202122class AppDelegate: UIResponder, UIApplicationDelegate &#123; var window: UIWindow? func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -&gt; Bool &#123; // Override point for customization after application launch. //这三个视图控制器将作为UITabBarController的子视图控制器 let firstViewController = FirstViewController() let secondViewController = SecondViewController() let thirdViewController = ThirdViewController() let tabViewController = UITabBarController() tabViewController.viewControllers = [firstViewController, secondViewController, thirdViewController] self.window?.rootViewController = tabViewController return true &#125; 因为有三个界面，所以要有三个viewController + 一个Tab Bar Controller属性【连线选择view controllers】","categories":[{"name":"代码仓库","slug":"代码仓库","permalink":"http://example.com/categories/%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93/"}],"tags":[{"name":"iOS-功能demo","slug":"iOS-功能demo","permalink":"http://example.com/tags/iOS-%E5%8A%9F%E8%83%BDdemo/"}]},{"title":"UINavigationController","slug":"代码仓库/iOS-功能demo/UINavigationController","date":"2021-04-17T16:00:00.000Z","updated":"2021-04-28T03:23:39.000Z","comments":true,"path":"2021/04/18/代码仓库/iOS-功能demo/UINavigationController/","link":"","permalink":"http://example.com/2021/04/18/%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93/iOS-%E5%8A%9F%E8%83%BDdemo/UINavigationController/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import UIKitclass FirstViewController: UIViewController &#123; override func viewDidLoad() &#123; super.viewDidLoad() // Do any additional setup after loading the view. //UINavigationController与UITabBarController的主要区别：UINavigationController是作为栈来实现的，它更适合用于处理和显示分层的数据 self.title = &quot;第1页&quot; //该属性的内容将显示在顶部的导航栏中 self.view.backgroundColor = UIColor.brown //重新创建了一个导航按钮UIBarButtonItem，并替换默认的导航栏右侧的按钮 self.navigationItem.rightBarButtonItem = UIBarButtonItem(title: &quot;下一页&quot;, style: UIBarButtonItem.Style.plain, target: self, action: #selector(FirstViewController.nextPage)) &#125; //导航控制器拥有顶部的导航栏和底部的工具(标签)栏，在默认状态下，底部的工具栏处于隐藏状态 override func viewWillAppear(_ animated: Bool) &#123; super.viewWillAppear(animated) self.navigationController?.setToolbarHidden(false, animated: false) //第一个参数表示工具条的可见性状态，第二个参数表示是否以动态的方式切换工具条的可见性状态 self.navigationController?.setNavigationBarHidden(false, animated: true) //将顶部的导航栏显示 self.navigationItem.prompt = &quot;正在载入...&quot; //UIBarButtonSystemItem是枚举类型，共包含24种按钮样式 self.navigationItem.leftBarButtonItem = UIBarButtonItem(barButtonSystemItem: .refresh, target: self, action: #selector(FirstViewController.refresh)) self.navigationController?.navigationBar.isTranslucent = true //设置导航栏的背景为透明 self.navigationController?.navigationBar.barStyle = UIBarStyle.black //设置导航栏的样式为黑色主题 self.navigationController?.navigationBar.tintColor = UIColor.orange //导航栏两侧的按钮为橙色 &#125; @objc func nextPage() &#123; //将实例化SecondViewController对象，然后获得当前视图控制器的导航控制器navigationController属性，并调用该属性的pushViewController方法加载新的视图控制器 let viewController = SecondViewController() self.navigationController?.pushViewController(viewController, animated: true) &#125; @objc func refresh() &#123; print(&quot;刷新数据.&quot;) &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566import UIKitvar pageNum = 1 //作为当前视图控制器的序号class SecondViewController: UIViewController &#123; override func viewDidLoad() &#123; super.viewDidLoad() // Do any additional setup after loading the view. pageNum = pageNum + 1 //每当SecondViewController视图控制器被创建新的实例时，将pageNum变量+1 self.title = &quot;第\\(pageNum)页&quot; self.view.backgroundColor = UIColor.purple //将新的视图控制器Push到导航控制器的栈中 let push = UIButton(frame: CGRect(x: 40, y: 120, width: 240, height: 40)) push.setTitle(&quot;Push Page&quot;, for: UIControl.State()) push.backgroundColor = UIColor.orange push.addTarget(self, action: #selector(SecondViewController.pushPage), for: UIControl.Event.touchUpInside) self.view.addSubview(push) //将位于栈顶的视图控制器从导航控制器中Pop移除 let pop = UIButton(frame: CGRect(x: 40, y: 180, width: 240, height: 40)) pop.setTitle(&quot;Pop Page&quot;, for: UIControl.State()) pop.backgroundColor = UIColor.orange pop.addTarget(self, action: #selector(SecondViewController.popPage), for: UIControl.Event.touchUpInside) self.view.addSubview(pop) //将依次Pop位于栈顶的视图控制器，直至index所指定的位置 let index = UIButton(frame: CGRect(x: 40, y: 280, width: 240, height: 40)) index.setTitle(&quot;Goto Index Page&quot;, for: UIControl.State()) index.backgroundColor = UIColor.orange index.addTarget(self, action: #selector(SecondViewController.gotoIndexPage), for: UIControl.Event.touchUpInside) self.view.addSubview(index) //将Pop导航控制器堆栈中所有的视图控制器，仅保留根视图控制器 let root = UIButton(frame: CGRect(x: 40, y: 340, width: 240, height: 40)) root.setTitle(&quot;Goto Root Page&quot;, for: UIControl.State()) root.backgroundColor = UIColor.orange root.addTarget(self, action: #selector(SecondViewController.gotoRootPage), for: UIControl.Event.touchUpInside) self.view.addSubview(root) &#125; @objc func pushPage() &#123; let viewController = SecondViewController() self.navigationController?.pushViewController(viewController, animated: true) &#125; @objc func popPage() &#123; self.navigationController?.popViewController(animated: true) &#125; @objc func gotoIndexPage() &#123; let viewController = self.navigationController?.viewControllers[1] self.navigationController?.popToViewController(viewController!, animated: true) &#125; @objc func gotoRootPage() &#123; self.navigationController?.popViewController(animated: true) &#125;&#125; 123456789101112131415161718class AppDelegate: UIResponder, UIApplicationDelegate &#123; var window: UIWindow? func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -&gt; Bool &#123; // Override point for customization after application launch. //将FirstViewController视图控制器作为导航视图控制器的根视图控制器 let viewController = FirstViewController() let navigationController = UINavigationController(rootViewController: viewController) //将导航控制器作为当前应用程序窗口的根视图控制器 self.window?.rootViewController = navigationController return true &#125; 只有一个viewController + Navigation Controller属性","categories":[{"name":"代码仓库","slug":"代码仓库","permalink":"http://example.com/categories/%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93/"}],"tags":[{"name":"iOS-功能demo","slug":"iOS-功能demo","permalink":"http://example.com/tags/iOS-%E5%8A%9F%E8%83%BDdemo/"}]},{"title":"UIButton","slug":"代码仓库/iOS-功能demo/UIButton","date":"2021-04-15T16:00:00.000Z","updated":"2021-04-28T09:02:06.000Z","comments":true,"path":"2021/04/16/代码仓库/iOS-功能demo/UIButton/","link":"","permalink":"http://example.com/2021/04/16/%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93/iOS-%E5%8A%9F%E8%83%BDdemo/UIButton/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879import UIKitclass ViewController: UIViewController &#123; override func viewDidLoad() &#123; super.viewDidLoad() // Do any additional setup after loading the view. /* //依次创建了6种不同样式的UIButton按钮 let buttonTypes: [UIButton.ButtonType] = [.system, .contactAdd, .detailDisclosure, .infoDark, .infoLight, .roundedRect] for i in 0..&lt;buttonTypes.count &#123; let button = UIButton(type: buttonTypes[i]) button.frame = CGRect(x: 100, y: 50 + i*50, width: 120, height: 30) if i == 0 || i == 5 &#123; button.setTitle(&quot;Button \\(i+1)&quot;, for: .normal) &#125; self.view.addSubview(button) &#125;*/ /* //UIButton按钮的状态 let titleStates: [String] = [&quot;正常状态&quot;, &quot;高亮状态&quot;, &quot;选中状态&quot;, &quot;失效状态&quot;] let buttonStates: [UIControl.State] = [.normal, .highlighted, .selected, .disabled] let button1 = UIButton(type: .system) button1.frame = CGRect(x: 80, y: 50, width: 140, height: 30) button1.setTitle(titleStates[0], for: buttonStates[0]) self.view.addSubview(button1) //设置按钮的背景图片 //button1.setBackgroundImage(UIImage(named: &quot;&quot;), for: UIControl.State.normal) let button2 = UIButton(type: .system) button2.frame = CGRect(x: 80, y: 100, width: 140, height: 30) button2.setTitle(titleStates[1], for: buttonStates[1]) button2.isHighlighted = true //将按钮设置为高亮状态 self.view.addSubview(button2) let button3 = UIButton(type: .system) button3.frame = CGRect(x: 80, y: 150, width: 140, height: 30) button3.setTitle(titleStates[2], for: buttonStates[2]) button3.isSelected = true //将按钮设置为选中状态 self.view.addSubview(button3) let button4 = UIButton(type: .system) button4.frame = CGRect(x: 80, y: 200, width: 140, height: 30) button4.setTitle(titleStates[3], for: buttonStates[3]) button4.isEnabled = false //将按钮设置为失效状态 self.view.addSubview(button4) */ //UIButton按钮使用Target-Action(目标-动作)设计模式来响应用户的触摸事件，该设计模式可以让代码解耦，使代码之间关联性降低，以便于后期的维护 let button = UIButton(type: UIButton.ButtonType.roundedRect) button.frame = CGRect(x: 20, y: 100, width: 280, height: 44) button.backgroundColor = UIColor.purple button.tintColor = UIColor.yellow //按钮的前景颜色 button.setTitle(&quot;Tap Me&quot;, for: .normal) //当用户按下按钮并抬起手指时，触发该事件执行buttonTapped方法 button.addTarget(self, action: #selector(ViewController.buttonTapped(_ :)), for: UIControl.Event.touchUpInside) self.view.addSubview(button) &#125; @objc func buttonTapped(_ button:UIButton) &#123; button.setTitle(&quot;The button is tapped.&quot;, for: .normal) button.isEnabled = false &#125;&#125;","categories":[{"name":"代码仓库","slug":"代码仓库","permalink":"http://example.com/categories/%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93/"}],"tags":[{"name":"iOS-功能demo","slug":"iOS-功能demo","permalink":"http://example.com/tags/iOS-%E5%8A%9F%E8%83%BDdemo/"}]},{"title":"UILabel","slug":"代码仓库/iOS-功能demo/UILabel","date":"2021-04-14T16:00:00.000Z","updated":"2021-04-28T10:00:02.000Z","comments":true,"path":"2021/04/15/代码仓库/iOS-功能demo/UILabel/","link":"","permalink":"http://example.com/2021/04/15/%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93/iOS-%E5%8A%9F%E8%83%BDdemo/UILabel/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import UIKitclass ViewController: UIViewController &#123; override func viewDidLoad() &#123; super.viewDidLoad() // Do any additional setup after loading the view. /* let label = UILabel(frame: CGRect(x: 20, y: 100, width: 280, height: 80)) label.text = &quot;Hello,Xcode and Swift!&quot; label.font = UIFont(name: &quot;Arial&quot;, size: 24) //设置文字的字体和尺寸 label.textAlignment = NSTextAlignment.right //设置文字的对齐方式为右对齐 label.textColor = UIColor.purple label.backgroundColor = UIColor.yellow label.shadowColor = UIColor.lightGray //给标签中的文字添加了一个投影效果，阴影的颜色为浅灰色 label.shadowOffset = CGSize(width: 2, height: 2) //阴影的偏移距离为2 self.view.addSubview(label) */ /* //UILabel在默认状态下只显示一行文字内容 let label = UILabel(frame: CGRect(x: 10, y: 100, width: 300, height: 150)) label.text = &quot;Love you、think of you.love you secretly,love you eagerly,wait,feel disappointed,try hard,lose,and feel sad,go apart,and recall.these are for sake of you.And I will regret for it.&quot; label.backgroundColor = UIColor.yellow label.textColor = UIColor.purple label.textAlignment = NSTextAlignment.left label.numberOfLines = 0 //将它设置为一个大于1的值，文本的行数将会被限制为这个指定的值，若设置为0，则UILabel不管文本占多少行都可以显示所有的文字内容 label.lineBreakMode = NSLineBreakMode.byTruncatingTail //结尾部分的内容以...方式省略 //换行模式： //byWordWrapping：默认状态，当单词本身不适合一行显示时，换行将发生在单词的边界上 //byCharWrapping：换行发生在到达标签边界的第一个字符之前 //byClipping：超过文本容器边界的文本行的内容将不会被绘制 //byTruncatingHead：在行首进行剪切，并以...表示被剪切的文字 //byTruncatingTail：在行尾进行剪切，并以...表示被剪切的文字 //byTruncatingMiddle：在行中进行剪切，并以...表示被剪切的文字 self.view.addSubview(label) */ //在一个UILabel中使用不同的颜色、不同的字体样式来设置字符串中的不同区域的文字 let attributedText = NSMutableAttributedString(string: &quot;coolketang.com&quot;) //设置字符串的前4个字符的样式为加粗的48号字体 attributedText.addAttribute(NSAttributedString.Key.font, value: UIFont.boldSystemFont(ofSize: 48), range: NSMakeRange(0, 4)) //设置字符串第5～11个字符的字体颜色为紫色 attributedText.addAttribute(NSAttributedString.Key.foregroundColor, value: UIColor.purple, range: NSMakeRange(4, 7)) //设置字符串最后三个字符的背景颜色为橙色 attributedText.addAttribute(NSAttributedString.Key.backgroundColor, value: UIColor.orange, range: NSMakeRange(11, 3)) let rect = CGRect(x: 20, y: 100, width: 280, height: 60) let label = UILabel(frame: rect) label.attributedText = attributedText self.view.addSubview(label) &#125;&#125;","categories":[{"name":"代码仓库","slug":"代码仓库","permalink":"http://example.com/categories/%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93/"}],"tags":[{"name":"iOS-功能demo","slug":"iOS-功能demo","permalink":"http://example.com/tags/iOS-%E5%8A%9F%E8%83%BDdemo/"}]},{"title":"UISwitch","slug":"代码仓库/iOS-功能demo/UISwitch","date":"2021-04-13T16:00:00.000Z","updated":"2021-04-28T10:22:57.000Z","comments":true,"path":"2021/04/14/代码仓库/iOS-功能demo/UISwitch/","link":"","permalink":"http://example.com/2021/04/14/%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93/iOS-%E5%8A%9F%E8%83%BDdemo/UISwitch/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536import UIKitclass ViewController: UIViewController &#123; override func viewDidLoad() &#123; super.viewDidLoad() // Do any additional setup after loading the view. //设置其宽度和高度的值是无意义的 let uiSwitch = UISwitch(frame: CGRect(x: 130, y: 100, width: 0, height: 0)) //三种颜色属性 uiSwitch.tintColor = UIColor.brown uiSwitch.thumbTintColor = UIColor.purple uiSwitch.onTintColor = UIColor.orange uiSwitch.setOn(true, animated: true) //设置了开关控件的默认状态为激活状态 uiSwitch.addTarget(self, action: #selector(ViewController.switchChanged(_ :)), for: UIControl.Event.valueChanged) self.view.addSubview(uiSwitch) &#125; //通过属性isOn来获取UISwitch开关对象的布尔值 @objc func switchChanged(_ uiSwitch: UISwitch) &#123; var message = &quot;Turn on the switch.&quot; if !uiSwitch.isOn &#123; message = &quot;Turn off the switch.&quot; &#125; print(message) &#125;&#125;","categories":[{"name":"代码仓库","slug":"代码仓库","permalink":"http://example.com/categories/%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93/"}],"tags":[{"name":"iOS-功能demo","slug":"iOS-功能demo","permalink":"http://example.com/tags/iOS-%E5%8A%9F%E8%83%BDdemo/"}]},{"title":"UITextField","slug":"代码仓库/iOS-功能demo/UITextField","date":"2021-04-12T16:00:00.000Z","updated":"2021-04-29T04:01:52.000Z","comments":true,"path":"2021/04/13/代码仓库/iOS-功能demo/UITextField/","link":"","permalink":"http://example.com/2021/04/13/%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93/iOS-%E5%8A%9F%E8%83%BDdemo/UITextField/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091import UIKit//遵循UITextFieldDelegate协议，这样我们就可以使用协议中的方法对UITextField对象进行状态的检测class ViewController: UIViewController, UITextFieldDelegate &#123; var textField: UITextField! //方便在键盘弹出和收起时修改UITextField对象的位置 override func viewDidLoad() &#123; super.viewDidLoad() // Do any additional setup after loading the view. /* 当创建一个UITextField对象时，在配置UITextField界面属性的同时，往往还需要设置UITextField对象的代理，通过代理可以完成很多重要的任务 1.检测用户是否被允许编辑UITextField中的内容 2.检测用户输入文本的合法性 3.检测键盘的return按钮是否被点击 4.将用户输入的文本转发到应用程序的其他部分 */ /* let textField = UITextField(frame: CGRect(x: 30, y: 80, width: 260, height: 40)) textField.borderStyle = UITextField.BorderStyle.roundedRect //边框样式：.line、.none textField.placeholder = &quot;Your Password&quot; //placeholder常用于提示用户在textField对象中输入什么样的内容 textField.autocorrectionType = UITextAutocorrectionType.no //若该值为yes，则将自动检测textField区域中的文字是不是有拼写错误或无法识别的文字内容，然后自动将错误的文字内容替换为系统建议的文字 textField.returnKeyType = UIReturnKeyType.done //UIReturnKeyType共包含done、continue、search等12个枚举值，它的主要作用是在键盘中的return key上显示指定的文字内容，仅是更改显示内容从而起到提醒用户的作用，并不会对return key的实际功能产生任何影响 textField.clearButtonMode = UITextField.ViewMode.whileEditing //在用户输入、编辑文本时，在textField输入框的右侧显示一个删除图标 textField.keyboardType = UIKeyboardType.default //UIKeyboardType共包含13个枚举值，用来适配用户名输入、手机号码输入等不同的使用场景：.emailAddress、.phonePad、.numberPad textField.keyboardAppearance = UIKeyboardAppearance.dark //设置键盘的外观为暗色模式，.light亮色模式 textField.isSecureTextEntry = true //这样输入的字符将显示为小圆点，从而起到保护内容的作用，常用于密码输入的工作环境 //在textField显示区域的左侧显示一个小图标 let lock = UIImage(named: &quot;lock&quot;) let lockView = UIImageView(image: lock) lockView.frame = CGRect(x: 0, y: 0, width: 20, height: 20) textField.leftView = lockView textField.leftViewMode = .always textField.delegate = self //设置textField对象的代理为当前的视图控制器 self.view.addSubview(textField) */ textField = UITextField(frame: CGRect(x: 30, y: 680, width: 260, height: 30)) textField.borderStyle = UITextField.BorderStyle.roundedRect textField.placeholder = &quot;Your Number&quot; textField.delegate = self self.view.addSubview(textField) //观察者模式: 一个对象的变化,能够被另一个对象知道 //使用通知的方式监测键盘的显示和隐藏，通过NotificationCenter创建两个观察者，分别监测键盘的显示和隐藏事件，当键盘显示或隐藏时，通过动态调整文字输入框的位置来避免键盘的遮挡 //对keyboardWillShowNotification事件进行观察和监听，当事件发生时，调用keyboardWillShow方法 NotificationCenter.default.addObserver(self, selector: #selector(keyboardWillShow(_ :)), name: UIResponder.keyboardWillShowNotification, object: nil) NotificationCenter.default.addObserver(self, selector: #selector(keyboardWillHide(_ :)), name: UIResponder.keyboardWillHideNotification, object: nil) &#125; /* //添加一个代理方法，用来响应键盘的return key被点击的事件，当键盘上的return key被点击时，通过resignFirstResponder()方法取消textField的焦点状态，从而隐藏键盘的显示 func textFieldShouldReturn(_ textField: UITextField) -&gt; Bool &#123; textField.resignFirstResponder() return true &#125; */ func textFieldShouldReturn(_ textField: UITextField) -&gt; Bool &#123; textField.resignFirstResponder() return true &#125; @objc func keyboardWillShow(_ notification: Notification?) &#123; textField.frame = CGRect(x: 30, y: 480, width: 260, height: 30) &#125; @objc func keyboardWillHide(_ notification: Notification?) &#123; textField.frame = CGRect(x: 30, y: 680, width: 260, height: 30) &#125;&#125;","categories":[{"name":"代码仓库","slug":"代码仓库","permalink":"http://example.com/categories/%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93/"}],"tags":[{"name":"iOS-功能demo","slug":"iOS-功能demo","permalink":"http://example.com/tags/iOS-%E5%8A%9F%E8%83%BDdemo/"}]},{"title":"UIAlertController","slug":"代码仓库/iOS-功能demo/UIAlertController","date":"2021-04-11T16:00:00.000Z","updated":"2021-04-29T08:05:31.000Z","comments":true,"path":"2021/04/12/代码仓库/iOS-功能demo/UIAlertController/","link":"","permalink":"http://example.com/2021/04/12/%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93/iOS-%E5%8A%9F%E8%83%BDdemo/UIAlertController/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182import UIKitclass ViewController: UIViewController &#123; override func viewDidLoad() &#123; super.viewDidLoad() // Do any additional setup after loading the view. //创建一个警告窗口 let button = UIButton(type: UIButton.ButtonType.system) button.frame = CGRect(x: 20, y: 120, width: 280, height: 44) button.setTitle(&quot;Question&quot;, for: .normal) //当点击该按钮时，执行一个方法以弹出警告窗口 //button.addTarget(self, action: #selector(ViewController.showAlert), for: .touchUpInside) //当点击该按钮时，执行一个方法以弹出动作表单 button.addTarget(self, action: #selector(ViewController.showActionSheet), for: .touchUpInside) button.backgroundColor = UIColor.orange self.view.addSubview(button) &#125; @objc func showAlert() &#123; //preferredStyle属性的值是一个UIAlertController.Style类型的枚举，该枚举包含UIAlertController.Style.alert和UIAlertController.Style.actionSheet，分别用来创建警告窗口和动作表单 let alert = UIAlertController(title: &quot;Information&quot;, message: &quot;Are you a student?&quot;, preferredStyle: UIAlertController.Style.alert) //UIAlertAction是指警告窗口中的供用户选择点击的选项按钮 //style是枚举类型：包含default、destructive、cancel三个不同的值 //handler是用户点击该选项按钮时所执行的动作，具体的任务在后面的闭包语句里执行 let yes = UIAlertAction(title: &quot;Yes&quot;, style: UIAlertAction.Style.default, handler: &#123; (alerts: UIAlertAction) -&gt; Void in print(&quot;Yes,I&#x27;m a student.&quot;) &#125;) let no = UIAlertAction(title: &quot;No&quot;, style: UIAlertAction.Style.destructive, handler: &#123; (alerts: UIAlertAction) -&gt; Void in print(&quot;No,I&#x27;m not a student.&quot;) &#125;) let cancel = UIAlertAction(title: &quot;Cancel&quot;, style: UIAlertAction.Style.cancel, handler: nil) //将三个选项按钮添加到警告窗口中，然后以模态的方式在当前的视图控制器中打开警告窗口 alert.addAction(yes) alert.addAction(no) alert.addAction(cancel) self.present(alert, animated: true, completion: nil) &#125; //和警告窗口不同的是，动作表单的展示形式和设备大小有关，在iPhone上，动作表单从屏幕底部升起，在iPad上，动作表单则是以弹出框的形式展现的 @objc func showActionSheet() &#123; //创建了一个动作表单 let actionSheet = UIAlertController(title: &quot;Information&quot;, message: &quot;What&#x27;s your favorite?&quot;, preferredStyle: UIAlertController.Style.actionSheet) let fishing = UIAlertAction(title: &quot;Fishing&quot;, style: UIAlertAction.Style.default, handler: &#123; (alerts: UIAlertAction) -&gt; Void in print(&quot;I like fishing.&quot;) &#125;) let hunting = UIAlertAction(title: &quot;Hunting&quot;, style: UIAlertAction.Style.destructive, handler: &#123; (alerts: UIAlertAction) -&gt; Void in print(&quot;I like hunting.&quot;) &#125;) //注意：如果动作表单中有style为cancel的按钮，那么它永远都会出现在表单列表的底部，无论添加的次序是怎样的，而其他按钮则会按照添加的次序从上往下依次显示 let nothing = UIAlertAction(title: &quot;Nothing&quot;, style: UIAlertAction.Style.cancel, handler: &#123; (alerts: UIAlertAction) -&gt; Void in print(&quot;A Life of Nonsense.&quot;) &#125;) actionSheet.addAction(fishing) actionSheet.addAction(hunting) actionSheet.addAction(nothing) self.present(actionSheet, animated: true) &#123; print(&quot;What&#x27;s your favorite?&quot;) &#125; &#125;&#125;","categories":[{"name":"代码仓库","slug":"代码仓库","permalink":"http://example.com/categories/%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93/"}],"tags":[{"name":"iOS-功能demo","slug":"iOS-功能demo","permalink":"http://example.com/tags/iOS-%E5%8A%9F%E8%83%BDdemo/"}]},{"title":"UIDatePicker","slug":"代码仓库/iOS-功能demo/UIDatePicker","date":"2021-04-10T16:00:00.000Z","updated":"2021-05-05T03:21:47.000Z","comments":true,"path":"2021/04/11/代码仓库/iOS-功能demo/UIDatePicker/","link":"","permalink":"http://example.com/2021/04/11/%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93/iOS-%E5%8A%9F%E8%83%BDdemo/UIDatePicker/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import UIKitclass ViewController: UIViewController &#123; override func viewDidLoad() &#123; super.viewDidLoad() // Do any additional setup after loading the view. //UIDatePicker是一个控制器类，封装了UIPickerView，继承自UIControl，专门用于接受日期和时间的输入 //UIDatePicker使用多个可转动的轮子来让用户选择日期和时间，当用户转动完轮子改变日期或时间的时候，UIDatePicker会发送UIControlEvents.valueChanged消息，通过桢听这个消息可以做出相应的处理 //UIDatePicker具有4种显示模式：日期和时间、日期、时间、计时 let datePicker = UIDatePicker() datePicker.center = CGPoint(x: 160, y: 200) //设置它的中心点位置 datePicker.tag = 1 //后面将通过该tag值获得这个UIDatePicker对象 datePicker.datePickerMode = UIDatePicker.Mode.dateAndTime //设置其显示模式为日期时间 //设置UIDatePicker对象的最小值和最大值，从而只允许用户设置在两个数值之间的日期和时间 datePicker.minimumDate = Date() datePicker.maximumDate = Date(timeInterval: 3*24*60*60, since: Date()) self.view.addSubview(datePicker) let button = UIButton(type: UIButton.ButtonType.roundedRect) button.frame = CGRect(x: 20, y: 360, width: 280, height: 44) button.backgroundColor = UIColor.orange button.setTitle(&quot;Get Date&quot;, for: .normal) //当点击该按钮时，获取UIDatePicker日期时间拾取器的当前值 button.addTarget(self, action: #selector(getDateTime(_ :)), for: .touchUpInside) self.view.addSubview(button) &#125; @objc func getDateTime(_ button: UIButton) &#123; let datePicker = self.view.viewWithTag(1) as! UIDatePicker //通过tag值获得日期时间拾取器 let date = datePicker.date //获得拾取的值 //将日期转换为字符串 let dateFormatter = DateFormatter() dateFormatter.dateFormat = &quot;yyyy-MM-dd HH:mm&quot; let dateAndTime = dateFormatter.string(from: date) print(dateAndTime) &#125; &#125;","categories":[{"name":"代码仓库","slug":"代码仓库","permalink":"http://example.com/categories/%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93/"}],"tags":[{"name":"iOS-功能demo","slug":"iOS-功能demo","permalink":"http://example.com/tags/iOS-%E5%8A%9F%E8%83%BDdemo/"}]},{"title":"UIStackView","slug":"代码仓库/iOS-功能demo/UIStackView","date":"2021-04-09T16:00:00.000Z","updated":"2021-05-05T04:35:18.000Z","comments":true,"path":"2021/04/10/代码仓库/iOS-功能demo/UIStackView/","link":"","permalink":"http://example.com/2021/04/10/%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93/iOS-%E5%8A%9F%E8%83%BDdemo/UIStackView/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980import UIKitclass ViewController: UIViewController &#123; var stackView: UIStackView! //作为视图的布局容器 override func viewDidLoad() &#123; super.viewDidLoad() // Do any additional setup after loading the view. //UIStackView的主要功能不是用来展示内容的，而是用来组织、布局显示内容的视图 //UIStackView类的主要属性： //axis属性：用于定义子视图的排列方向，横向或纵向 //spacing属性：用来控制子视图的间距 //alignment属性：用来定义子视图之间沿着axis方向的对齐方式，如顶部对齐、底部对齐、左对齐 //distribution属性：用来定义子视图沿着axis排列的布局规则 let view1 = UIView() let view2 = UIView() let view3 = UIView() view1.backgroundColor = .red view2.backgroundColor = .orange view3.backgroundColor = .blue stackView = UIStackView(arrangedSubviews: [view1, view2, view3]) //这三个视图对象将被添加到UIStackView容器内 stackView.frame = CGRect(x: 0, y: 0, width: 320, height: 400) stackView.axis = NSLayoutConstraint.Axis.horizontal //在水平方向上排列子视图 stackView.alignment = UIStackView.Alignment.fill //通过调整子视图的尺寸在axis设定的方向上填充stackView容器的可用空间 stackView.distribution = UIStackView.Distribution.fillEqually //约束子视图具有相同的尺寸，从而使子视图沿着axis方向上填充stackView容器的可用空间 stackView.spacing = 10 stackView.backgroundColor = .orange self.view.addSubview(stackView) let spaccing = UIButton(type: UIButton.ButtonType.roundedRect) spaccing.frame = CGRect(x: 20, y: 420, width: 280, height: 30) spaccing.setTitle(&quot;增加间距&quot;, for: .normal) spaccing.addTarget(self, action: #selector(setCustomSpacing(_ :)), for: .touchUpInside) self.view.addSubview(spaccing) let insert = UIButton(type: UIButton.ButtonType.roundedRect) insert.frame = CGRect(x: 20, y: 460, width: 280, height: 30) insert.setTitle(&quot;插入视图&quot;, for: .normal) insert.addTarget(self, action: #selector(insertArrangedSubview(_ :)), for: .touchUpInside) self.view.addSubview(insert) let remove = UIButton(type: UIButton.ButtonType.roundedRect) remove.frame = CGRect(x: 20, y: 500, width: 280, height: 30) remove.setTitle(&quot;删除视图&quot;, for: .normal) remove.addTarget(self, action: #selector(removeArrangedSubview(_ :)), for: .touchUpInside) self.view.addSubview(remove) &#125; //当点击第一个按钮时，调整第二个子视图和第三个子视图的间距 @objc func setCustomSpacing(_ button: UIButton) &#123; let view = stackView.arrangedSubviews[1] stackView.setCustomSpacing(30, after: view) &#125; //当点击第二个按钮时，在第二个子视图的右侧添加一个新的视图对象 @objc func insertArrangedSubview(_ button: UIButton) &#123; let view = UIView() view.backgroundColor = .green stackView.insertArrangedSubview(view, at: 2) &#125; //当点击第三个按钮时，删除第二个子视图 @objc func removeArrangedSubview(_ button: UIButton) &#123; let view = stackView.arrangedSubviews[1] stackView.removeArrangedSubview(view) &#125; &#125;","categories":[{"name":"代码仓库","slug":"代码仓库","permalink":"http://example.com/categories/%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93/"}],"tags":[{"name":"iOS-功能demo","slug":"iOS-功能demo","permalink":"http://example.com/tags/iOS-%E5%8A%9F%E8%83%BDdemo/"}]},{"title":"UITableView","slug":"代码仓库/iOS-功能demo/UITableView","date":"2021-04-08T16:00:00.000Z","updated":"2021-05-06T13:59:04.000Z","comments":true,"path":"2021/04/09/代码仓库/iOS-功能demo/UITableView/","link":"","permalink":"http://example.com/2021/04/09/%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93/iOS-%E5%8A%9F%E8%83%BDdemo/UITableView/","excerpt":"","text":"创建一个简单的表格12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import UIKit//添加协议，主要用来给UITableView表格提供数据来源，并用来处理数据源的变化class ViewController: UIViewController, UITableViewDataSource &#123; //由于表格默认拥有一个章节，因此在此设置了默认章节具有20行数据 func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123; return 20 &#125; //初始化和复用单元格，每当表格对象需要绘制一个单元格时，都会调用该方法 //UITableView的复用机制 func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123; let identifier = &quot;reusedCell&quot; //作为单元格的类型 var cell = tableView.dequeueReusableCell(withIdentifier: identifier) //从单元格对象池中获取指定类型并且可以重复使用的单元格 //UITableViewCell.CellStyle.default：包含一个位于单元格左侧的可选图像视图和一个左对齐的标签对象 //UITableViewCell.CellStyle.value1：包含一个位于单元格左侧的可选图像视图和一个左对齐的标签对象，在单元格的右侧还有一个灰色、右对齐的标签对象 //UITableViewCell.CellStyle.value2：包含一个位于单元格左侧的、右对齐的、蓝色文字的标签对象和一个位于右侧的左对齐标签对象 //UITableViewCell.CellStyle.subtitle：包含一个位于单元格左侧的可选图像视图和一个左对齐的标签对象，在该标签对象下方还有一个字体较小的标签对象 if cell == nil &#123; //从内存中创建一个新的单元格UITableViewCell对象 cell = UITableViewCell(style: UITableViewCell.CellStyle.default, reuseIdentifier: identifier) //使用预定义的单元格只需为标签和图标提供对应的文字内容和图像内容即可，可以使用textLabel和detailTextLabel属性来设置单元格的文字内容，使用imageView属性来设置单元格的图标 &#125; cell?.textLabel?.text = &quot;命运负责洗牌，玩牌的是我们自己！&quot; return cell! &#125; override func viewDidLoad() &#123; super.viewDidLoad() // Do any additional setup after loading the view. //UITableView用于在一栏内显示一系列对象，它是UIScorllView的子类，UIScorllView可以在任意方向上滑动内容，而UITableView仅支持在垂直方向上的滑动 //UITableView由单元格UITableViewCell组成，UITableView中的内容都是由UITableViewCell负责显示的，UITableView的行数(即UITableViewCell对象的数量)不受限制，仅由设备的内存决定 let screenRect = UIScreen.main.bounds //获得当前设备的屏幕尺寸 let tableRect = CGRect(x: 0, y: 20, width: screenRect.size.width, height: screenRect.size.height-20) let tableView = UITableView(frame: tableRect) tableView.dataSource = self //设置UITableView对象的数据源为当前的视图控制器对象，即由当前的视图控制对象实现数据源协议中定义的各种代理方法 self.view.addSubview(tableView) &#125; &#125; 自定义单元格UITableViewCell1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import UIKitclass CustomizeUITableViewCell: UITableViewCell &#123; var thumbnail: UIImageView! var title: UILabel! var detail: UIButton! //重写UITableViewCell类的初始化方式 override init(style: UITableViewCell.CellStyle, reuseIdentifier: String?) &#123; super.init(style: style, reuseIdentifier: reuseIdentifier) self.thumbnail = UIImageView(image: UIImage(named: &quot;user&quot;)) self.thumbnail.center = CGPoint(x: 30, y: 22) self.title = UILabel(frame: CGRect(x: 80, y: 0, width: 120, height: 40)) self.title.text = &quot;自定义单元格&quot; self.detail = UIButton(frame: CGRect(x: 240, y: 8, width: 60, height: 24)) self.detail.setTitle(&quot;详情&quot;, for: .normal) self.detail.backgroundColor = UIColor.gray //事件点击不了？ self.detail.addTarget(self, action: &quot;showDetail:&quot;, for: UIControl.Event.touchUpInside) self.addSubview(self.thumbnail) self.addSubview(self.title) self.addSubview(self.detail) &#125; func showDetail(_ sender: UIButton) &#123; print(&quot;显示详细信息&quot;) &#125; //实现了继承UITableViewCell类所必需的构造方法 required init?(coder: NSCoder) &#123; fatalError(&quot;init(coder:) has not been implemented&quot;) &#125; override func awakeFromNib() &#123; super.awakeFromNib() // Initialization code &#125; override func setSelected(_ selected: Bool, animated: Bool) &#123; super.setSelected(selected, animated: animated) // Configure the view for the selected state &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344import UIKit//添加协议，主要用来给UITableView表格提供数据来源，并用来处理数据源的变化class ViewController: UIViewController, UITableViewDataSource &#123; //由于表格默认拥有一个章节，因此在此设置了默认章节具有20行数据 func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123; return 20 &#125; //初始化和复用单元格，每当表格对象需要绘制一个单元格时，都会调用该方法 //UITableView的复用机制 func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123; let identifier = &quot;reusedCell&quot; //作为单元格的类型 var cell: CustomizeUITableViewCell? = tableView.dequeueReusableCell(withIdentifier: identifier) as? CustomizeUITableViewCell //从单元格对象池中获取了指定类型的并且可以重复使用的自定义单元格 if cell == nil &#123; //从内存中创建一个新的单元格UITableViewCell对象 cell = CustomizeUITableViewCell(style: UITableViewCell.CellStyle.default, reuseIdentifier: identifier) //使用预定义的单元格只需为标签和图标提供对应的文字内容和图像内容即可，可以使用textLabel和detailTextLabel属性来设置单元格的文字内容，使用imageView属性来设置单元格的图标 &#125; cell?.title?.text = &quot;客户姓名&quot; return cell! &#125; override func viewDidLoad() &#123; super.viewDidLoad() // Do any additional setup after loading the view. let screenRect = UIScreen.main.bounds //获得当前设备的屏幕尺寸 let tableRect = CGRect(x: 0, y: 20, width: screenRect.size.width, height: screenRect.size.height-20) let tableView = UITableView(frame: tableRect) tableView.dataSource = self //设置UITableView对象的数据源为当前的视图控制器对象，即由当前的视图控制对象实现数据源协议中定义的各种代理方法 self.view.addSubview(tableView) &#125; &#125; 自定义单元格的高度123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import UIKit//添加协议，主要用来给UITableView表格提供数据来源，并用来处理数据源的变化//UITableViewDelegate协议的主要用途是提供一些可选的方法，用来控制表格的选择、指定章节的头和尾的显示、单元格内容的复制和粘贴，以及协助完成单元格的排序等功能class ViewController: UIViewController, UITableViewDataSource, UITableViewDelegate &#123; //设置表格视图中指定索引位置的单元格的高度 func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -&gt; CGFloat &#123; //首先通过indexPath.row语句获得需要设置高度的单元格的所在行数，然后设置偶数行的高度为104，奇数行的高度为40 if (indexPath as NSIndexPath).row % 2 == 0 &#123; return 104 &#125; return 40 &#125; //设置表格的行数为20 func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123; return 20 &#125; func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123; let identifier = &quot;reusedCell&quot; var cell = tableView.dequeueReusableCell(withIdentifier: identifier) if cell == nil &#123; cell = UITableViewCell(style: UITableViewCell.CellStyle.default, reuseIdentifier: identifier) &#125; if (indexPath as NSIndexPath).row % 2 == 0 &#123; cell?.imageView?.image = UIImage(named: &quot;picture.png&quot;) cell?.textLabel?.text = &quot;&quot; &#125; else &#123; cell?.imageView?.image = nil cell?.textLabel?.text = &quot;每有会意，便欣然忘食！&quot; &#125; return cell! &#125; override func viewDidLoad() &#123; super.viewDidLoad() // Do any additional setup after loading the view. let screenRect = UIScreen.main.bounds //获得当前设备的屏幕尺寸 let tableRect = CGRect(x: 0, y: 20, width: screenRect.size.width, height: screenRect.size.height-20) let tableView = UITableView(frame: tableRect) tableView.dataSource = self //设置UITableView对象的数据源为当前的视图控制器对象，即由当前的视图控制对象实现数据源协议中定义的各种代理方法 tableView.delegate = self self.view.addSubview(tableView) &#125; &#125; 给表格添加章节和索引1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495import UIKitclass ViewController: UIViewController, UITableViewDataSource &#123; //前面制作的表格的数据源都是数组常量，现在演示将一个字典对象作为表格的数据源 //字典对象的键作为UITableView的Section，字典对象的值(数组)作为Section中单元格的内容 //字典对象的键A~Z将作为章节的标题，键对应的值将作为所在章节的单元格的内容 var countries: Dictionary&lt;String, [String]&gt; = [ &quot;A&quot;: [&quot;Afghanistan&quot;, &quot;Albania&quot;, &quot;Algeria&quot;, &quot;Angola&quot;, &quot;Australia&quot;, &quot;Austria&quot;, &quot;Azerbaijan&quot;], &quot;B&quot;: [&quot;Bangladesh&quot;, &quot;Belgium&quot;, &quot;Bhutan&quot;, &quot;Bolivia&quot;, &quot;Brazil&quot;, &quot;Bahrain&quot;, &quot;Bulgaria&quot;], &quot;C&quot;: [&quot;Canada&quot;, &quot;Congo&quot;, &quot;Chile&quot;, &quot;China&quot;, &quot;Colombia&quot;, &quot;Cuba&quot;], &quot;D&quot;: [&quot;Denmark&quot;, &quot;Djibouti&quot;, &quot;Dominica&quot;], &quot;E&quot;: [&quot;Egypt&quot;, &quot;Estonia&quot;, &quot;Ethiopia&quot;], &quot;F&quot;: [&quot;Fiji&quot;, &quot;Finland&quot;, &quot;France&quot;], &quot;G&quot;: [&quot;Gambia&quot;, &quot;Germany&quot;, &quot;Greece&quot;], &quot;H&quot;: [&quot;Haiti&quot;, &quot;Honduras&quot;, &quot;Hungary&quot;], &quot;I&quot;: [&quot;India&quot;, &quot;Indonesia&quot;, &quot;Iran&quot;, &quot;Ireland&quot;, &quot;Iraq&quot;, &quot;Italy&quot;], &quot;J&quot;: [&quot;Jordan&quot;, &quot;Japan&quot;], &quot;K&quot;: [&quot;Kazakhstan&quot;, &quot;Korea&quot;, &quot;Kuwait&quot;], &quot;L&quot;: [&quot;Laos&quot;, &quot;Libya&quot;, &quot;Lebanon&quot;], &quot;M&quot;: [&quot;Madagascar&quot;, &quot;Morocco&quot;, &quot;Malaysia&quot;, &quot;Mexico&quot;, &quot;Mali&quot;, &quot;Mozambique&quot;], &quot;N&quot;: [&quot;Nepal&quot;, &quot;Netherlands&quot;, &quot;Nigeria&quot;, &quot;New Zealand&quot;], &quot;O&quot;: [&quot;Oman&quot;], &quot;P&quot;: [&quot;Pakistan&quot;, &quot;Panama&quot;, &quot;Philippines&quot;, &quot;Portugal&quot;], &quot;Q&quot;: [&quot;Qatar&quot;], &quot;R&quot;: [&quot;Romania&quot;, &quot;South Africa&quot;, &quot;Russia&quot;], &quot;S&quot;: [&quot;Serbia &amp; Montenegro&quot;, &quot;Senegal&quot;, &quot;Singapore&quot;, &quot;Somalia&quot;, &quot;Switzerland&quot;], &quot;T&quot;: [&quot;Thailand&quot;, &quot;Turkmenistan&quot;, &quot;Tunisia&quot;, &quot;Turkey&quot;], &quot;U&quot;: [&quot;United Arab Emirates&quot;, &quot;United States of America&quot;, &quot;Uzbekistan&quot;], &quot;V&quot;: [&quot;Vanuatu&quot;, &quot;Venezuela&quot;, &quot;Vietnam&quot;], &quot;Y&quot;: [&quot;Yemen&quot;], &quot;Z&quot;: [&quot;Zambia&quot;, &quot;Zimbabwe&quot;] ] var keys: [String] = [] //它将用来存储按升序排列后的键名序列，这个数组的长度将作为表格中章节的数目 override func viewDidLoad() &#123; super.viewDidLoad() // Do any additional setup after loading the view, typically from a nib. //带有索引的表格和普通的表格的外观基本相同，唯一的区别是在表格的右侧显示了一个索引序列，通过点击索引序列可以在表格中快速定位到指定的位置，尤其是当表格拥有大量数据的时候 keys = Array(countries.keys).sorted() //获得countries字典对象所有的键名，并转化为一个数组对象，由于字典对象的键名是无序排列的，因此接着又调用了数组对象的sorted()方法对数组进行升序排列 let screenRect = UIScreen.main.bounds let tableRect = CGRect(x: 0, y: 20, width: screenRect.size.width, height: screenRect.size.height - 20) let tableView = UITableView(frame: tableRect) tableView.dataSource = self self.view.addSubview(tableView) &#125; //返回键名数组的长度作为表格中章节的数目 func numberOfSections(in tableView: UITableView) -&gt; Int &#123; return keys.count &#125; //在该代理方法中，首先根据section参数获得keys数组中的键名，然后根据键名获得字典对象中键名对应的键值，即国家名称的数组，最后返回数组的长度作为指定章节的单元格数量 func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int&#123; let subCountries = countries[keys[section]] return (subCountries?.count)! &#125; //该代理方法用来设置指定章节的标题文字 func tableView(_ tableView: UITableView, titleForHeaderInSection section: Int) -&gt; String? &#123; return keys[section] &#125; //该代理方法用来设置表格右侧索引序列的内容 func sectionIndexTitles(for tableView: UITableView) -&gt; [String]? &#123; return keys &#125; func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123; let identifier = &quot;reusedCell&quot; var cell = tableView.dequeueReusableCell(withIdentifier: identifier) if cell == nil &#123; cell = UITableViewCell(style: UITableViewCell.CellStyle.default, reuseIdentifier: identifier) &#125; //首先根据IndexPath参数的section值获得当前单元格所在的章节序号，然后根据章节序号获得键名数组keys中指定位置的键名， //再根据键名获得键名在字典对象countries中的键值，也就是一个由国家名称组成的数组 let subCountries = countries[keys[(indexPath as NSIndexPath).section]] //接着根据IndexPath参数的row值获得当前单元格所在章节中的行号，再根据行号获得对应的国家名称，最后设置单元格UILabel属性的值为对应的国家名称 cell?.textLabel?.text = subCountries![(indexPath as NSIndexPath).row] return cell! &#125;&#125; 单元格的选择与取消选择123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263import UIKit//前者用于设置表格的行数和初始化及复用UITableViewCell对象，后者用于具体处理单元格的选择事件class ViewController: UIViewController, UITableViewDataSource, UITableViewDelegate &#123; let diablo3Level = [&quot;普通模式&quot;, &quot;困难模式&quot;, &quot;高手模式&quot;, &quot;大师模式&quot;, &quot;痛苦模式&quot;] override func viewDidLoad() &#123; super.viewDidLoad() // Do any additional setup after loading the view, typically from a nib. let screenRect = UIScreen.main.bounds let tableRect = CGRect(x: 0, y: 20, width: screenRect.size.width, height: screenRect.size.height - 20) let tableView = UITableView(frame: tableRect) tableView.dataSource = self tableView.delegate = self self.view.addSubview(tableView) &#125; //设置表格的行数为游戏难度数组的长度 func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int&#123; return diablo3Level.count &#125; func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123; let identifier = &quot;reusedCell&quot; var cell = tableView.dequeueReusableCell(withIdentifier: identifier) if(cell == nil) &#123; cell = UITableViewCell(style: UITableViewCell.CellStyle.default, reuseIdentifier: identifier) &#125; cell?.textLabel?.text = diablo3Level[(indexPath as NSIndexPath).row] return cell! &#125; func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) &#123; let cell = tableView.cellForRow(at: indexPath) //首先通过表格对象的cellForRowAt indexPath()方法获得在表格对象中被选中的单元格，接着判断被选中的单元格当前的附件类型，若为空，则设置单元格的附件类型为checkmark if cell?.accessoryType == UITableViewCell.AccessoryType.none &#123; //UITableViewCell.AccessoryType共有4种类型：.none，.detailButton，.detailDisclosureButton，.disclosureIndicator，.checkmark cell?.accessoryType = UITableViewCell.AccessoryType.checkmark print(&quot;您选择了：\\(String(describing: cell?.textLabel?.text))&quot;) &#125; else &#123; cell?.accessoryType = UITableViewCell.AccessoryType.none print(&quot;您取消选择了：\\(String(describing: cell?.textLabel?.text))&quot;) &#125; &#125;&#125; 单元格的插入和删除1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071import UIKit//前者用于设置表格的行数和初始化及复用UITableViewCell对象，后者用于具体处理单元格的选择事件class ViewController: UIViewController, UITableViewDataSource, UITableViewDelegate &#123; var diablo3Level = [&quot;普通模式&quot;, &quot;困难模式&quot;, &quot;高手模式&quot;, &quot;大师模式&quot;, &quot;地狱模式&quot;] override func viewDidLoad() &#123; super.viewDidLoad() // Do any additional setup after loading the view, typically from a nib. //以插入单元格的功能为例，首先通过实现tableView(_ :editingStyleForRowAt:)方法设置单元格的编辑模式为插入模式，然后当用户点击编辑按钮或者执行setEditing(_ :animated:)命令后，就会在单元格的左侧显示‘+’图标；当用户点击&#x27;+&#x27;图标后，代理对象就会调用tableView(_ :editingStyle:, ForRowAt:)方法，最后在该方法中，调用表格对象的insertRowsAtIndexPath: withRowAnimation:方法实现单元格的插入功能 let screenRect = UIScreen.main.bounds let tableRect = CGRect(x: 0, y: 20, width: screenRect.size.width, height: screenRect.size.height - 20) let tableView = UITableView(frame: tableRect) tableView.dataSource = self tableView.delegate = self tableView.setEditing(true, animated: true) self.view.addSubview(tableView) &#125; //设置表格的行数为游戏难度数组的长度 func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int&#123; return diablo3Level.count &#125; func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123; let identifier = &quot;reusedCell&quot; var cell = tableView.dequeueReusableCell(withIdentifier: identifier) if cell == nil &#123; cell = UITableViewCell(style: UITableViewCell.CellStyle.default, reuseIdentifier: identifier) &#125; cell?.textLabel?.text = diablo3Level[(indexPath as NSIndexPath).row] return cell! &#125; func tableView(_ tableView: UITableView, editingStyleForRowAt indexPath: IndexPath) -&gt; UITableViewCell.EditingStyle &#123; //return UITableViewCell.EditingStyle.insert //.none，.delete return UITableViewCell.EditingStyle.delete &#125; func tableView(_ tableView: UITableView, commit editingStyle: UITableViewCell.EditingStyle, forRowAt indexPath: IndexPath) &#123; //if editingStyle == UITableViewCell.EditingStyle.insert &#123; // diablo3Level.insert(&quot;痛苦模式&quot;, at: indexPath.row) //在表格对象的数据源数组中插入一条新的数据，以保持表格视图与数据源的数据一致性 // tableView.insertRows(at: [indexPath], with: UITableView.RowAnimation.right) //在指定索引位置的单元格处插入新的单元格 //&#125; if editingStyle == UITableViewCell.EditingStyle.delete &#123; diablo3Level.remove(at: indexPath.row) tableView.deleteRows(at: [indexPath], with: UITableView.RowAnimation.right) &#125; &#125;&#125; 移动单元格的位置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475import UIKitclass ViewController: UIViewController, UITableViewDataSource, UITableViewDelegate &#123; var customers = [ &quot;[普通客户] 冮炳林&quot;, &quot;[普通客户] 扶伽霖&quot;, &quot;[普通客户] 冈皑冰&quot;, &quot;[金牌客户] 符博富&quot;, &quot;[普通客户] 范姜臣华&quot; ] override func viewDidLoad() &#123; super.viewDidLoad() // Do any additional setup after loading the view, typically from a nib. let screenRect = UIScreen.main.bounds let tableRect = CGRect(x: 0, y: 20, width: screenRect.size.width, height: screenRect.size.height - 20) let tableView = UITableView(frame: tableRect) tableView.dataSource = self tableView.delegate = self tableView.setEditing(true, animated: true) self.view.addSubview(tableView) &#125; func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int&#123; return customers.count &#125; func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123; let identifier = &quot;reusedCell&quot; var cell = tableView.dequeueReusableCell(withIdentifier: identifier) if(cell == nil)&#123; cell = UITableViewCell(style: UITableViewCell.CellStyle.default, reuseIdentifier: identifier) &#125; cell?.textLabel?.text = customers[(indexPath as NSIndexPath).row] return cell! &#125; //隐藏单元格左侧的编辑按钮 func tableView(_ tableView: UITableView, editingStyleForRowAt indexPath: IndexPath) -&gt; UITableViewCell.EditingStyle &#123; return UITableViewCell.EditingStyle.none &#125; //用来设置UITableView视图中的所有单元格都是可以被拖动的 func tableView(_ tableView: UITableView, canMoveRowAt indexPath: IndexPath) -&gt; Bool &#123; return true &#125; //当用户松开手指，释放被拖动的单元格时，调用此方法 func tableView(_ tableView: UITableView, moveRowAt sourceIndexPath: IndexPath, to destinationIndexPath: IndexPath) &#123; //首先获得单元格的原始索引位置和目标索引位置，然后获得在客户数组中被拖动的客户姓名 //接着调用数组的removeAtIndex:方法删除数组原始位置上的元素 //最后调用数组的insert(: atIndex)方法将被拖动的客户姓名插入数组中的目标位置，以保持视图层与数据源层的数据同步 let fromRow = (sourceIndexPath as NSIndexPath).row let toRow = (destinationIndexPath as NSIndexPath).row let customer = customers[fromRow] customers.remove(at: fromRow) customers.insert(customer, at: toRow) &#125; &#125; 表格之间的嵌套123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293//该表格的偶数行(行数从0开始)为普通的UITableViewCell单元格，用来显示新闻的标题文字//表格的奇数行为自定义的单元格，该单元格拥有另一个UITableView对象，用来显示网友对新闻的评论信息import UIKitclass CustomizeUITableViewCell: UITableViewCell, UITableViewDataSource, UITableViewDelegate &#123; var tableView: UITableView! var comments: [String] = [] //添加了一个字符串数组，作为tableView元素的数据源，该数组的初始值为空 override init(style: UITableViewCell.CellStyle, reuseIdentifier: String?) &#123; super.init(style: style, reuseIdentifier: reuseIdentifier) tableView = UITableView(frame: CGRect(x: 20, y: 0, width: 280, height: 90)) tableView.dataSource = self tableView.delegate = self tableView.isScrollEnabled = false //禁止tableView的滚动 self.addSubview(tableView) &#125; func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int&#123; return comments.count &#125; func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123; let identifier = &quot;reusedCell&quot; var cell = tableView.dequeueReusableCell(withIdentifier: identifier) if cell == nil &#123; cell = UITableViewCell(style: UITableViewCell.CellStyle.default, reuseIdentifier: identifier) &#125; cell?.textLabel?.text = comments[(indexPath as NSIndexPath).row] cell?.textLabel?.font = UIFont.systemFont(ofSize: 12) cell?.textLabel?.textColor = UIColor.gray cell?.textLabel?.numberOfLines = 0 //表示不限制标签对象中文字的行数 return cell! &#125; //用来设置指定索引位置的单元格的高度，这里根据该单元格将要显示的文字的多少来设置相应的高度 func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -&gt; CGFloat &#123; let subComments = comments[(indexPath as NSIndexPath).row] //根据索引位置获得数据源中指定位置的评论信息 let size = subComments.boundingRect(with: CGSize(), options: NSStringDrawingOptions.usesFontLeading, attributes: nil, context: nil); //获得绘制该字符串所需的矩形区域的大小 let cellHeight = size.height*size.width/170 //计算出显示所有评论信息所需要的单元格的高度数值 if cellHeight &lt; 30 &#123; return 30 &#125; else &#123; return cellHeight &#125; &#125; //当设置表格对象的数据源之后，需要根据数据源中评论信息的文字数量重新设置表格对象的高度数值 func setCommentsForTable(_ comments:[String]) &#123; self.comments = comments var tableHeight: CGFloat = 0 //通过一个for循环语句把表格中所有的单元格的高度都分别计算一次，然后把结果累加起来作为表格的高度，最后把累加后的高度数值赋予当前的tableView对象 for i in 0 ..&lt; comments.count &#123; let size = comments[i].boundingRect(with: CGSize(), options: NSStringDrawingOptions.usesFontLeading, attributes: nil, context: nil); tableHeight += size.height*size.width/170 &#125; tableView.frame = CGRect(x: 20, y: 0, width: 280, height: tableHeight + 50) tableView.reloadData() //调用该方法可以重新加载表格的数据源，并重新生成表格对象中的所有章节头部标题、章节尾部内容、章节序列以及单元格的内容 &#125; func getMyHeight()-&gt;CGFloat&#123; return tableView.frame.size.height &#125; required init(coder aDecoder: NSCoder) &#123; fatalError(&quot;init(code:)has not brrn implomented&quot;); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105import UIKitclass ViewController: UIViewController, UITableViewDataSource, UITableViewDelegate &#123; var articles = [ &quot;微软有哪些「黑历史」？&quot;, &quot;苹果有哪些黑科技？&quot;, &quot;巴宝莉和 Apple TV 强强联手推出天台秀直播&quot; ] var comments = [ [&quot;1.Nebraska这个梗是这样的，当年美国很多公司的呼叫中心设在nebraska（原因有两说，一说是战略空军司令部在这，所以电话线路多，一说是中西部的人说话口音比较标准. 我没考证过哪个对，或者是两个都有），那时候AT&amp;T 店大欺客，800只能打长途不能打市话. 所以八十年代各种广告后面附的电话都是除Nebraska以外，然后后面应该还有一个Nebraska专用的号码.&quot;, &quot;2.鲍尔默一直都是这种画风……&quot;, &quot;3.见多了我们的cheer leader的表演就不见怪了。内部company meeting上的那些你们没见过，还有billg出演的。还有个嘲讽非windows系统的广告，好像是和Brian Valentine一起演的，那货也是个怪咖，以前Windows的SVP。&quot;], [&quot;1.它真的黑，黑出亮。&quot;, &quot;2.在天朝，购买它所缴纳的消费税可以买一台超级本&quot;, &quot;3.这家能够操作供应链的公司，想要什么样的显卡、什么样的内存、什么样的SSD都能信手拈来；这够黑吧&quot;], [&quot;1.据巴宝莉新闻稿了解，Apple TV在直播过程中将推出购物功能，观众能直接预定秀场上出现的服装。这么看来，这个功能用在国内简直是一大引入点，可以在春晚直播的过程中购买明星同款。&quot;, &quot;2.这次怎么不用iPhone®拍摄b？&quot;] ] override func viewDidLoad() &#123; super.viewDidLoad() // Do any additional setup after loading the view, typically from a nib. let screenRect = UIScreen.main.bounds let tableRect = CGRect(x: 0, y: 20, width: screenRect.size.width, height: screenRect.size.height - 20) let tableView = UITableView(frame: tableRect) tableView.dataSource = self tableView.delegate = self tableView.separatorStyle = UITableViewCell.SeparatorStyle.none //不显示单元格之间的分隔线，以避免和内层tableView中的单元格分隔线混淆 self.view.addSubview(tableView) &#125; //设置单元格的行数为articles数组长度的2倍，这是因为我们创建的表格的偶数行用来显示新闻标题，奇数行用来显示新闻评论 func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int&#123; return articles.count * 2 &#125; func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123; //定义两个字符串变量，表示两种类型的单元格 //第一种类型的单元格为普通的UITableViewCell单元格，用于显示新闻的标题 //第二种类型的单元格为自定义的CustomizeUITableViewCell单元格，该单元格包含一个UITableView子元素，用于显示某条新闻所属的所有评论信息 let cellForArticle = &quot;cellForArticle&quot; let cellForComments = &quot;cellForComments&quot; var cell1: UITableViewCell? var cell2: CustomizeUITableViewCell? //如果当前单元格是偶数行，就创建普通的UITableViewCell单元格对象，否则就创建CustomizeUITableViewCell类型的单元格 if (indexPath as NSIndexPath).row % 2 == 0 &#123; cell1 = tableView.dequeueReusableCell(withIdentifier: cellForArticle) if cell1 == nil&#123; cell1 = UITableViewCell(style: UITableViewCell.CellStyle.default, reuseIdentifier: cellForArticle) &#125; cell1?.textLabel?.text = articles[(indexPath as NSIndexPath).row/2] cell1?.textLabel?.font = UIFont.systemFont(ofSize: 16) cell1?.textLabel?.textColor = UIColor.lightGray cell1?.backgroundColor = UIColor.black return cell1! &#125;else&#123; cell2 = tableView.dequeueReusableCell(withIdentifier: cellForComments) as? CustomizeUITableViewCell if cell2 == nil&#123; cell2 = CustomizeUITableViewCell(style: UITableViewCell.CellStyle.default, reuseIdentifier: cellForComments) &#125; let subComments = comments[(indexPath as NSIndexPath).row/2] cell2?.setCommentsForTable(subComments) //设置自定义单元格中UITableView对象的数据源为刚刚获得的评论数组对象 return cell2! &#125; &#125; //设置外层表格的单元格的高度 func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -&gt; CGFloat &#123; //对于用来显示新闻标题的单元格来说，可以将其高度设置为固定值；但是对于用来显示评论信息的单元格来说，其高度应根据评论文字内容的多少而动态变化 if (indexPath as NSIndexPath).row % 2 == 0 &#123; return 40 &#125; else &#123; let subComments = comments[(indexPath as NSIndexPath).row/2] var cellHeight:CGFloat = 0 for i in 0 ..&lt; subComments.count &#123; let size = subComments[i].boundingRect(with: CGSize(), options: NSStringDrawingOptions.usesFontLeading, attributes: nil, context: nil); cellHeight += size.height*(size.width/170) &#125; return cellHeight + 50 &#125; &#125;&#125;","categories":[{"name":"代码仓库","slug":"代码仓库","permalink":"http://example.com/categories/%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93/"}],"tags":[{"name":"iOS-功能demo","slug":"iOS-功能demo","permalink":"http://example.com/tags/iOS-%E5%8A%9F%E8%83%BDdemo/"}]},{"title":"UICollectionView","slug":"代码仓库/iOS-功能demo/UICollectionView","date":"2021-04-07T16:00:00.000Z","updated":"2021-05-06T14:56:55.000Z","comments":true,"path":"2021/04/08/代码仓库/iOS-功能demo/UICollectionView/","link":"","permalink":"http://example.com/2021/04/08/%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93/iOS-%E5%8A%9F%E8%83%BDdemo/UICollectionView/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374//UITableView最大的特点：将所有的内容都以上下相连的方式排列在一栏滚动列表中，这就使得UITableView的布局有了很大的局限性//UICollectionView用于展示集合视图，其布局更加灵活，可实现多列布局//此实例中将使用UICollectionView的UICollectionViewFlowLayout默认布局模式，除了该布局模式之外，UICollectionView还具有堆叠布局、圆形布局、Cover Flow布局模式import UIKitclass ViewController: UIViewController, UICollectionViewDataSource, UICollectionViewDelegate &#123; //该数组将作为UICollectionView对象的数据源 var images = [&quot;Pic1&quot;, &quot;Pic2&quot;, &quot;Pic3&quot;, &quot;Pic4&quot;, &quot;Pic5&quot;, &quot;Pic6&quot;, &quot;Pic7&quot;, &quot;Pic8&quot;, &quot;Pic9&quot;, &quot;Pic9&quot;, &quot;Pic9&quot;, &quot;Pic9&quot;] override func viewDidLoad() &#123; super.viewDidLoad() // Do any additional setup after loading the view, typically from a nib. let screenRect = UIScreen.main.bounds let rect = CGRect(x: 0, y: 10, width: screenRect.size.width, height: screenRect.size.height - 20) let flowLayout = UICollectionViewFlowLayout() flowLayout.itemSize = CGSize(width: 155, height: 135) //该属性用来设置cell的默认尺寸信息 flowLayout.scrollDirection = UICollectionView.ScrollDirection.vertical //垂直方向，即集合视图可以在垂直方向上进行滑动，网格只能在一个方向轴上进行滑动，要么是垂直方向，要么是水平方向 let collectionView = UICollectionView(frame: rect, collectionViewLayout: flowLayout) collectionView.dataSource = self collectionView.delegate = self //由于集合对象是通过代码生成的，而不是通过故事版或NIB文件生成，因此需要注册一个UICollectionViewCell类，不然在初始化新的UICollectionViewCell时会发生错误，同时要注意forCellWithReuseIdentifier:参数的值，该值应与创建UICollectionViewCell对象时的重用标志字符串相同 collectionView.register(UICollectionViewCell.classForCoder(), forCellWithReuseIdentifier: &quot;reusedCell&quot;) self.view.addSubview(collectionView) &#125; func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -&gt; Int &#123; return images.count &#125; //初始化并复用UICollectionViewCell对象 func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -&gt; UICollectionViewCell &#123; let identifier = &quot;reusedCell&quot; let cell = collectionView.dequeueReusableCell(withReuseIdentifier: identifier, for: indexPath) //检查cell中是否存在tag值为1的UIImageView对象，如果不存在就给cell添加一个新的UIImageView对象 let imageView: UIImageView? = cell.viewWithTag(1) as? UIImageView if imageView == nil&#123; let image = UIImage(named: images[(indexPath as NSIndexPath).row]) let imageView = UIImageView(image: image) imageView.frame = CGRect(x: 0, y: 0, width: 150, height: 135) imageView.layer.opacity = 0.5 //层的透明度 imageView.tag = 1 cell.addSubview(imageView) &#125; else &#123; imageView?.image = UIImage(named: images[(indexPath as NSIndexPath).row]) &#125; return cell &#125; //实现UICollectionViewDelegate协议中的手指触摸检测方法 func collectionView(_ collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath) &#123; let cell = collectionView.cellForItem(at: indexPath) let imageView = cell?.viewWithTag(1) imageView?.layer.opacity = 1.0 &#125;&#125;","categories":[{"name":"代码仓库","slug":"代码仓库","permalink":"http://example.com/categories/%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93/"}],"tags":[{"name":"iOS-功能demo","slug":"iOS-功能demo","permalink":"http://example.com/tags/iOS-%E5%8A%9F%E8%83%BDdemo/"}]},{"title":"对触摸事件阶段的监测","slug":"代码仓库/iOS-功能demo/对触摸事件阶段的监测","date":"2021-04-06T16:00:00.000Z","updated":"2021-05-07T02:55:01.000Z","comments":true,"path":"2021/04/07/代码仓库/iOS-功能demo/对触摸事件阶段的监测/","link":"","permalink":"http://example.com/2021/04/07/%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93/iOS-%E5%8A%9F%E8%83%BDdemo/%E5%AF%B9%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6%E9%98%B6%E6%AE%B5%E7%9A%84%E7%9B%91%E6%B5%8B/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637//在iOS中并不是所有的类都能接收并处理事件，只有继承自UIResponder类的对象才能处理触摸事件//UIResponder是UIView的父类，常用的UIView控件、UIViewController视图控制器、UIApplication都继承自UIResponder，它们都能接收并处理触摸事件import UIKitclass ViewController: UIViewController &#123; override func viewDidLoad() &#123; super.viewDidLoad() // Do any additional setup after loading the view, typically from a nib. &#125; //UIResponder处理触屏事件的4个方法 //当一个或多个手指在相关联的视图上按下时调用此方法 override func touchesBegan(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?) &#123; print(&quot;touchesBegan&quot;) &#125; //当一个或多个手指在相关联的视图上滑动时调用此方法 override func touchesMoved(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?) &#123; print(&quot;touchesMoved&quot;) &#125; //当一个或多个手指滑出相关联的视图时调用此方法 override func touchesEnded(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?) &#123; print(&quot;touchesEnded&quot;) &#125; //当由于系统事件的发生(比如来电、低电量通知等)而造成触摸事件被取消时调用此方法 override func touchesCancelled(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?) &#123; print(&quot;touchesCancelled&quot;) &#125;&#125;","categories":[{"name":"代码仓库","slug":"代码仓库","permalink":"http://example.com/categories/%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93/"}],"tags":[{"name":"iOS-功能demo","slug":"iOS-功能demo","permalink":"http://example.com/tags/iOS-%E5%8A%9F%E8%83%BDdemo/"}]},{"title":"监测是否触摸到某个视图并实现图像视图的拖动","slug":"代码仓库/iOS-功能demo/监测是否触摸到某个视图并实现图像视图的拖动","date":"2021-04-05T16:00:00.000Z","updated":"2021-05-07T07:08:17.000Z","comments":true,"path":"2021/04/06/代码仓库/iOS-功能demo/监测是否触摸到某个视图并实现图像视图的拖动/","link":"","permalink":"http://example.com/2021/04/06/%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93/iOS-%E5%8A%9F%E8%83%BDdemo/%E7%9B%91%E6%B5%8B%E6%98%AF%E5%90%A6%E8%A7%A6%E6%91%B8%E5%88%B0%E6%9F%90%E4%B8%AA%E8%A7%86%E5%9B%BE%E5%B9%B6%E5%AE%9E%E7%8E%B0%E5%9B%BE%E5%83%8F%E8%A7%86%E5%9B%BE%E7%9A%84%E6%8B%96%E5%8A%A8/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768import UIKitclass ViewController: UIViewController &#123; var imageView: UIImageView! var isTouchInImageView: Bool = false override func viewDidLoad() &#123; super.viewDidLoad() // Do any additional setup after loading the view, typically from a nib. //当用户点击某个视图时，可以通过UITouch类获得点击事件在视图中的位置，然后通过判断该位置是否在视图的frame区域中，从而判断用户是否点击了某个视图 let image = UIImage(named: &quot;Star&quot;) self.imageView = UIImageView(image: image) self.view.addSubview(self.imageView) &#125; //用来监测用户是否按下手指 override func touchesBegan(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?) &#123; let touch = touches.first //获得一个UITouch对象 let touchPoint = touch?.location(in: self.view) //获得在当前视图控制器根视图中的位置 let imageViewFrame = self.imageView.frame let minX = imageViewFrame.origin.x let minY = imageViewFrame.origin.y let maxX = minX + imageViewFrame.size.width let maxY = minY + imageViewFrame.size.height //判断用户是否点击了图像视图 if (touchPoint?.x)! &gt;= minX &amp;&amp; (touchPoint?.x)! &lt;= maxX &amp;&amp; (touchPoint?.y)! &gt;= minY &amp;&amp; (touchPoint?.y)! &lt;= maxY &#123; isTouchInImageView = true print(&quot;您捡到一枚星星&quot;) &#125; &#125; // override func touchesMoved(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?) &#123; //判断用户是否在图像视图中按下手指 if !isTouchInImageView &#123; return &#125; let touch = touches.first let touchPoint = touch?.location(in: self.view) //获得用户当前的触摸位置 let touchPrePoint = touch?.previousLocation(in: self.view) //获得上一个移动位置 //偏移距离 let disX = (touchPoint?.x)! - (touchPrePoint?.x)! let disY = (touchPoint?.y)! - (touchPrePoint?.y)! var centerPoint = self.imageView.center centerPoint.x += disX centerPoint.y += disY self.imageView.center = centerPoint &#125; override func touchesEnded(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?) &#123; isTouchInImageView = false &#125;&#125;","categories":[{"name":"代码仓库","slug":"代码仓库","permalink":"http://example.com/categories/%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93/"}],"tags":[{"name":"iOS-功能demo","slug":"iOS-功能demo","permalink":"http://example.com/tags/iOS-%E5%8A%9F%E8%83%BDdemo/"}]},{"title":"触摸手势","slug":"代码仓库/iOS-功能demo/触摸手势","date":"2021-04-04T16:00:00.000Z","updated":"2021-05-07T08:14:43.000Z","comments":true,"path":"2021/04/05/代码仓库/iOS-功能demo/触摸手势/","link":"","permalink":"http://example.com/2021/04/05/%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93/iOS-%E5%8A%9F%E8%83%BDdemo/%E8%A7%A6%E6%91%B8%E6%89%8B%E5%8A%BF/","excerpt":"","text":"实现单点触摸手势12345678910111213141516171819202122232425262728293031323334353637import UIKitclass ViewController: UIViewController &#123; var imageView: UIImageView! override func viewDidLoad() &#123; super.viewDidLoad() // Do any additional setup after loading the view, typically from a nib. //UIGestureRecognizer类对用户常用的手势操作进行了识别：UIPanGestureRecognizer拖动手势、UIPinchGestureRecognizer捏合手势、UIRotationGestureRecognizer旋转手势、UITapGestureRecognizer点击手势、UILongPressGestureRecognizer长按手势、UISwipeGestureRecognizer轻扫手势 //UIGestureRecognizer手势分为discrete gestures非连续手势和continuous gestures连续手势两种，UITapGestureRecognizer属于非连续类型的手势，其他5种手势则属于连续类型的手势 //实现单点触摸手势 let rect = CGRect(x: 0, y: 80, width: 320, height: 320) self.imageView = UIImageView(frame: rect) let image = UIImage(named: &quot;lock&quot;) imageView.image = image imageView.isUserInteractionEnabled = true //使图像视图可以接收用户的交互动作 self.view.addSubview(self.imageView) let guesture = UITapGestureRecognizer(target: self, action: #selector(ViewController.singleTap)) imageView.addGestureRecognizer(guesture) &#125; @objc func singleTap() &#123; let image = UIImage(named: &quot;unlock&quot;) imageView.image = image &#125; &#125; 实现双击触摸手势123456789101112131415161718192021222324252627282930313233343536import UIKitclass ViewController: UIViewController &#123; var imageView: UIImageView! override func viewDidLoad() &#123; super.viewDidLoad() // Do any additional setup after loading the view, typically from a nib. //实现双击触摸手势 let rect = CGRect(x: 0, y: 80, width: 320, height: 320) self.imageView = UIImageView(frame: rect) let image = UIImage(named: &quot;lock&quot;) imageView.image = image imageView.isUserInteractionEnabled = true //使图像视图可以接收用户的交互动作 self.view.addSubview(self.imageView) let guesture = UITapGestureRecognizer(target: self, action: #selector(ViewController.doubleTap)) guesture.numberOfTapsRequired = 2 //识别进行两次点击的手势，该属性的默认值为1 guesture.numberOfTouchesRequired = 1 //识别一根手指进行两次点击的手势，该属性的默认值也是1 imageView.addGestureRecognizer(guesture) &#125; @objc func doubleTap() &#123; let image = UIImage(named: &quot;unlock&quot;) imageView.image = image &#125; &#125; 实现长按手势的监测123456789101112131415161718192021222324252627282930313233343536373839import UIKitclass ViewController: UIViewController &#123; var imageView: UIImageView! override func viewDidLoad() &#123; super.viewDidLoad() // Do any additional setup after loading the view, typically from a nib. //实现长按手势的监测 let rect = CGRect(x: 0, y: 80, width: 320, height: 320) self.imageView = UIImageView(frame: rect) let image = UIImage(named: &quot;lock&quot;) imageView.image = image imageView.isUserInteractionEnabled = true //使图像视图可以接收用户的交互动作 self.view.addSubview(self.imageView) let guesture = UILongPressGestureRecognizer(target: self, action: #selector(ViewController.longPress(_ :))) guesture.minimumPressDuration = 1.0 //只有当手指按下并持续1秒钟之后，才会被识别为长按手势 guesture.allowableMovement = 20.0 //在手指处于按下状态时，若手势移动的距离超过20点，则视为非长按手势，此属性的默认值为10 imageView.addGestureRecognizer(guesture) &#125; @objc func longPress(_ gusture: UILongPressGestureRecognizer) &#123; if gusture.state == UIGestureRecognizer.State.began&#123; let image = UIImage(named: &quot;unlock&quot;) imageView.image = image &#125; &#125; &#125; 捏合手势的监测123456789101112131415161718192021222324252627282930313233343536373839import UIKitclass ViewController: UIViewController &#123; var imageView: UIImageView! override func viewDidLoad() &#123; super.viewDidLoad() // Do any additional setup after loading the view, typically from a nib. //捏合手势的监测 let rect = CGRect(x: 0, y: 80, width: 320, height: 320) self.imageView = UIImageView(frame: rect) let image = UIImage(named: &quot;Hand&quot;) imageView.image = image imageView.isUserInteractionEnabled = true //使图像视图可以接收用户的交互动作 self.view.addSubview(self.imageView) //当两个手指按下并移到一定距离时，会被识别为一个Pinch捏合手势，此时捏合手势处于begins状态。接着只要其中一个手指继续移动，捏合手势将进入changes状态，当两个手指都松开时，捏合手势将处于ends状态 let guesture = UIPinchGestureRecognizer(target: self, action: #selector(ViewController.pinchImage(_ :))) imageView.addGestureRecognizer(guesture) &#125; @objc func pinchImage(_ recognizer: UIPinchGestureRecognizer) &#123; //通过recognizer对象的view属性可以获得包含捏合手势的视图对象，然后通过recognizer对象的scale属性的值更改view对象的transform属性，从而实现图像视图的缩放功能 recognizer.view?.transform = (recognizer.view?.transform.scaledBy(x: recognizer.scale, y: recognizer.scale))! recognizer.scale = 1 //使捏合手势的缩放比例始终在1倍的基础上进行递增或递减 //recognizer.velocity 表示在进行缩放动作时的速度 &#125; &#125;","categories":[{"name":"代码仓库","slug":"代码仓库","permalink":"http://example.com/categories/%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93/"}],"tags":[{"name":"iOS-功能demo","slug":"iOS-功能demo","permalink":"http://example.com/tags/iOS-%E5%8A%9F%E8%83%BDdemo/"}]},{"title":"3D_Touch","slug":"代码仓库/iOS-功能demo/3D_Touch","date":"2021-04-03T16:00:00.000Z","updated":"2021-05-07T15:07:35.000Z","comments":true,"path":"2021/04/04/代码仓库/iOS-功能demo/3D_Touch/","link":"","permalink":"http://example.com/2021/04/04/%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93/iOS-%E5%8A%9F%E8%83%BDdemo/3D_Touch/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import UIKit@mainclass AppDelegate: UIResponder, UIApplicationDelegate &#123; func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -&gt; Bool &#123; // Override point for customization after application launch. let addEventIcon = UIApplicationShortcutIcon(type: .add) //创建了一个系统自带的类型为UIApplicationShortcutIcon.IconType.add的快捷图标，系统提供了29种快捷图标供开发者使用 let unlockEventIcon = UIApplicationShortcutIcon(templateImageName: &quot;unlockEvent&quot;) //使用项目资源文件夹中的图片创建了两个自定义的快捷图标 let listEventIcon = UIApplicationShortcutIcon(templateImageName: &quot;listEvent&quot;) //设置快捷项目的标题、图标等信息 //type：必要参数，表示快捷项目的唯一标识 //localizedTitle：必要参数，表示快捷项目的标题 //localizedSubtitle：可选参数，表示快捷项目的副标题 //icon：可选参数，表示快捷项目的图标 //userInfo：可选参数，表示app传递给动作的自定义数据信息 let addEvent = UIApplicationShortcutItem(type: &quot;com.coolketang.addMember&quot;, localizedTitle: &quot;添加会员&quot;, localizedSubtitle: &quot;Add Member&quot;, icon: addEventIcon, userInfo: nil) let unlockEvent = UIApplicationShortcutItem(type: &quot;com.coolketang.unlockMember&quot;, localizedTitle: &quot;解锁会员&quot;, localizedSubtitle: &quot;Unlock Member&quot;, icon: unlockEventIcon, userInfo: nil) let listEvent = UIApplicationShortcutItem(type: &quot;com.coolketang.memberList&quot;, localizedTitle: &quot;会员列表&quot;, localizedSubtitle: &quot;Members List&quot;, icon: listEventIcon, userInfo: nil) let shortCutItems = [addEvent, unlockEvent, listEvent] application.shortcutItems = shortCutItems return true &#125; //响应用户在快捷菜单中的点击事件 func application(_ application: UIApplication, performActionFor shortcutItem: UIApplicationShortcutItem, completionHandler: (Bool) -&gt; Void) &#123; if shortcutItem.type == &quot;com.coolketang.addMember&quot; &#123; print(&quot;跳转至添加会员页面。&quot;) &#125; else if shortcutItem.type == &quot;com.coolketang.unlockMember&quot;&#123; print(&quot;跳转至解锁会员页面。&quot;) &#125; else if shortcutItem.type == &quot;com.coolketang.memberList&quot;&#123; print(&quot;跳转至会员列表页面。&quot;) &#125; &#125; // MARK: UISceneSession Lifecycle func application(_ application: UIApplication, configurationForConnecting connectingSceneSession: UISceneSession, options: UIScene.ConnectionOptions) -&gt; UISceneConfiguration &#123; // Called when a new scene session is being created. // Use this method to select a configuration to create the new scene with. return UISceneConfiguration(name: &quot;Default Configuration&quot;, sessionRole: connectingSceneSession.role) &#125; func application(_ application: UIApplication, didDiscardSceneSessions sceneSessions: Set&lt;UISceneSession&gt;) &#123; // Called when the user discards a scene session. // If any sessions were discarded while the application was not running, this will be called shortly after application:didFinishLaunchingWithOptions. // Use this method to release any resources that were specific to the discarded scenes, as they will not return. &#125;&#125;","categories":[{"name":"代码仓库","slug":"代码仓库","permalink":"http://example.com/categories/%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93/"}],"tags":[{"name":"iOS-功能demo","slug":"iOS-功能demo","permalink":"http://example.com/tags/iOS-%E5%8A%9F%E8%83%BDdemo/"}]},{"title":"UIView动画块和和Block动画","slug":"代码仓库/iOS-功能demo/UIView动画块和和Block动画","date":"2021-04-02T16:00:00.000Z","updated":"2021-05-08T02:03:09.000Z","comments":true,"path":"2021/04/03/代码仓库/iOS-功能demo/UIView动画块和和Block动画/","link":"","permalink":"http://example.com/2021/04/03/%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93/iOS-%E5%8A%9F%E8%83%BDdemo/UIView%E5%8A%A8%E7%94%BB%E5%9D%97%E5%92%8C%E5%92%8CBlock%E5%8A%A8%E7%94%BB/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495import UIKitclass ViewController: UIViewController &#123; override func viewDidLoad() &#123; super.viewDidLoad() // Do any additional setup after loading the view, typically from a nib. //iOS中的动画实现技术主要是Core Animation和UIKit，两者都可以负责所有的滚动、旋转、缩小和放大以及所有的iOS动画效果 //其中，UIKit可以看作是对CoreAnimation的封装 //UIView拥有多种动画的实现方式：UIView动画块、UIView的Block动画，甚至包含关键帧动画，使用UIView动画时，可以通过修改以下UIView视图的属性产生平滑的动画效果：frame、bounds、center、transform、alpha、backgroundColor、contentStretch //UIView动画块、UIView的Block动画 let rect = CGRect(x: 40, y: 80, width: 240, height: 240) let view = UIView(frame: rect) view.backgroundColor = UIColor.red view.tag = 1 //UIView对象的tag表示该视图对象在父视图中的唯一标识，该视图被添加到父视图时，父视图可以通过viewWithTag(tag: Int)方法快速找到拥有该标识的子视图 self.view.addSubview(view) let button = UIButton(type: UIButton.ButtonType.system) button.frame = CGRect(x: 50, y: 400, width: 220, height: 44) button.backgroundColor = UIColor.black button.setTitle(&quot;Play&quot;, for: .normal) button.titleLabel?.font = UIFont(name: &quot;Arial&quot;, size: 24) button.addTarget(self, action: #selector(ViewController.playAnimation), for: UIControl.Event.touchUpInside) self.view.addSubview(button) &#125; /* //实现UIView动画的播放 @objc func playAnimation() &#123; UIView.beginAnimations(nil, context: nil) //启动一个动画，动画并不会立即被执行，直到调用UIView类的commitAnimations类方法，对于一个视图对象执行的介于beginAnimations方法跟commitAnimations方法之间的操作，在commitAnimations方法被执行后，才会生成并播放动画 //easeInOut：动画播放速度在开始时较慢，然后逐渐加速，在完成之前再次变慢 //easeIn：动画播放速度在开始时较慢，然后在动画播放过程中逐渐加速 //easeOut：动画播放速度在开始时较快，然后在动画播放过程中逐渐减速 //linear：动画插入速度在动画播放过程中始终保持不变 UIView.setAnimationCurve(.easeOut) //设置动画的播放速度变化曲线，该属性默认值为easeInOut UIView.setAnimationDuration(5) //设置动画块的的动画持续时间，单位为秒，默认值为0.2 UIView.setAnimationBeginsFromCurrentState(true) //设置动画是否从当前状态开始播放，默认值为false let view = self.view.viewWithTag(1) //view?.frame = CGRect(x: 40, y: 40, width: 0, height: 0) //view?.backgroundColor = UIColor.blue //view?.alpha = 0 //设置自定义的过渡动画效果 //第一个参数表示过渡效果，第二个参数表示需要应用过渡效果的视图，第三个参数表示是否为视图在过渡前后的画面进行缓存，以提高过渡效果的桢速 //flipFromLeft：视图从左向右滑入屏幕；flipFromRight：视图从右向左滑入屏幕；curlUp：视图从底部向顶部卷曲的翻页动画；curlDown：视图从顶部向底部卷曲的翻页动画；none：无过渡效果 UIView.setAnimationTransition(.curlUp, for: view!, cache: true) UIView.setAnimationDelegate(self) //设置动画的代理为当前的视图控制器，用来检测动画的播放状态 UIView.setAnimationDidStop(#selector(ViewController.animationStop)) //设置动画结束时的回调方法 UIView.commitAnimations() //结束动画块的设置，并开始播放动画 &#125; @objc func animationStop() &#123; print(&quot;Animaton stop.&quot;) self.view.viewWithTag(1)?.removeFromSuperview() &#125; */ @objc func playAnimation() &#123; //第一个参数为动画的时长 //第二个参数为动画延迟时间 //第三个参数是动画的属性设置 //第四个参数为动画的主体设置区域 //第五个参数为动画完成后的回调事件 UIView.animate(withDuration: 5, delay: 0, options: [.curveEaseOut], animations: &#123; let view = self.view.viewWithTag(1) view?.frame = CGRect(x: 40, y: 40, width: 0, height: 0) view?.backgroundColor = UIColor.blue view?.alpha = 0 &#125;, completion: &#123; (value: Bool) in print(&quot;Animation stop.&quot;) self.view.viewWithTag(1)?.removeFromSuperview() &#125;) &#125; &#125;","categories":[{"name":"代码仓库","slug":"代码仓库","permalink":"http://example.com/categories/%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93/"}],"tags":[{"name":"iOS-功能demo","slug":"iOS-功能demo","permalink":"http://example.com/tags/iOS-%E5%8A%9F%E8%83%BDdemo/"}]},{"title":"使用UIImageView播放桢动画","slug":"代码仓库/iOS-功能demo/使用UIImageView播放桢动画","date":"2021-04-01T16:00:00.000Z","updated":"2021-05-08T02:23:59.000Z","comments":true,"path":"2021/04/02/代码仓库/iOS-功能demo/使用UIImageView播放桢动画/","link":"","permalink":"http://example.com/2021/04/02/%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93/iOS-%E5%8A%9F%E8%83%BDdemo/%E4%BD%BF%E7%94%A8UIImageView%E6%92%AD%E6%94%BE%E6%A1%A2%E5%8A%A8%E7%94%BB/","excerpt":"","text":"1234567891011121314151617181920212223242526272829import UIKitclass ViewController: UIViewController &#123; override func viewDidLoad() &#123; super.viewDidLoad() // Do any additional setup after loading the view, typically from a nib. //使用UIImageView播放桢动画 //一个UIImageView图像视图可以存储一个动画图片序列，UIImageView图像视图对象的animationImages属性可以存储一个UIImage数据类型的图像数组 var images = [UIImage]() for i in 1 ... 24 &#123; images.append(UIImage(named: &quot;animation\\(i)&quot;)!) &#125; let imageView = UIImageView(frame: CGRect(x: 0, y: 60, width: 335, height: 253)) imageView.animationImages = images imageView.animationDuration = 5 imageView.animationRepeatCount = 0 //动画将进行不限次数的循环播放 imageView.startAnimating() //开始播放帧动画 self.view.addSubview(imageView) &#125; &#125;","categories":[{"name":"代码仓库","slug":"代码仓库","permalink":"http://example.com/categories/%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93/"}],"tags":[{"name":"iOS-功能demo","slug":"iOS-功能demo","permalink":"http://example.com/tags/iOS-%E5%8A%9F%E8%83%BDdemo/"}]},{"title":"位移关键帧动画的制作","slug":"代码仓库/iOS-功能demo/位移关键帧动画的制作","date":"2021-03-31T16:00:00.000Z","updated":"2021-05-08T02:51:25.000Z","comments":true,"path":"2021/04/01/代码仓库/iOS-功能demo/位移关键帧动画的制作/","link":"","permalink":"http://example.com/2021/04/01/%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93/iOS-%E5%8A%9F%E8%83%BDdemo/%E4%BD%8D%E7%A7%BB%E5%85%B3%E9%94%AE%E5%B8%A7%E5%8A%A8%E7%94%BB%E7%9A%84%E5%88%B6%E4%BD%9C/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import UIKitclass ViewController: UIViewController, CAAnimationDelegate &#123; override func viewDidLoad() &#123; super.viewDidLoad() // Do any additional setup after loading the view, typically from a nib. //位移关键帧动画的制作 //Core Animation是一组非常强大的动画处理API，使用它能做出非常绚丽的动画效果，但是Core Animation的动画只是从一个数值渐变到另一个数值，只能应付一些比较简单的动画场景，这种直线式的动画无法实现复杂的动画效果，这时我们就可以使用CAKeyFrameAnimation类进行关键帧动画的制作 //CAKeyFrameAnimation原理：通过对某个属性设置一组不同的数值，然后由系统自动生成相邻数值之间的线性过渡帧 let imageView = UIImageView(frame: CGRect(x: 40, y: 80, width: 64, height: 64)) imageView.image = UIImage(named: &quot;star&quot;) self.view.addSubview(imageView) let animation = CAKeyframeAnimation(keyPath: &quot;position&quot;) //通过指定keyPath，可以对图像视图CALayer层的该属性进行更改，从而使图像视图产生位置变化的动画效果 let point1 = CGPoint(x: 40, y: 80) let point2 = CGPoint(x: 280, y: 80) let point3 = CGPoint(x: 60, y: 300) let point4 = CGPoint(x: 280, y: 300) //values属性用来设置整个位移动画过程中的关键位置 animation.values = [NSValue(cgPoint: point1), NSValue(cgPoint: point2), NSValue(cgPoint: point3), NSValue(cgPoint: point4)] animation.keyTimes = [NSNumber(value: 0.0), NSNumber(value: 0.4), NSNumber(value: 0.6), NSNumber(value: 1.0)] animation.delegate = self animation.duration = 5.0 imageView.layer.add(animation, forKey: &quot;Move&quot;) //将动画添加到图像视图的层中，以实现动画的播放 &#125; func animationDidStart(_ anim: CAAnimation) &#123; print(&quot;The animation starts&quot;) &#125; func animationDidStop(_ anim: CAAnimation, finished flag: Bool) &#123; print(&quot;End of the animation&quot;) &#125; &#125;","categories":[{"name":"代码仓库","slug":"代码仓库","permalink":"http://example.com/categories/%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93/"}],"tags":[{"name":"iOS-功能demo","slug":"iOS-功能demo","permalink":"http://example.com/tags/iOS-%E5%8A%9F%E8%83%BDdemo/"}]},{"title":"使用System_Sound_Services播放简短声音","slug":"代码仓库/iOS-功能demo/使用System_Sound_Services播放简短声音","date":"2021-03-30T16:00:00.000Z","updated":"2021-05-08T08:41:55.000Z","comments":true,"path":"2021/03/31/代码仓库/iOS-功能demo/使用System_Sound_Services播放简短声音/","link":"","permalink":"http://example.com/2021/03/31/%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93/iOS-%E5%8A%9F%E8%83%BDdemo/%E4%BD%BF%E7%94%A8System_Sound_Services%E6%92%AD%E6%94%BE%E7%AE%80%E7%9F%AD%E5%A3%B0%E9%9F%B3/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637import UIKitimport AudioToolboxclass ViewController: UIViewController &#123; override func viewDidLoad() &#123; super.viewDidLoad() // Do any additional setup after loading the view, typically from a nib. //音频播放从形式上可以分为音效播放和音乐播放，音效主要指的是一些比较短暂的音频播放，通常作为点缀音效，对于这类音频不需要进行进度、循环等控制。后者指的是一些较长的音频，通常是主音频，对于这些音频的播放通常需要进行精确控制 //在iOS中，通常分别使用System Sound Services和AVAudioPlayer来完成音效和音乐的播放，除了这两种方式之外，还可以选择Audio Queue Services和Open AL技术，这4种音频播放技术各有自身的特点 //System Sound Services是最底层，也是最简单的音频播放服务，通过提供的C语言接口，允许开发者通过简单的调用AudioServicesPlaySystemSound方法播放一些简短的音频文件，使用此方法比较适合播放一些短暂的提示或警告声音 //AVAudioPlayer可以播放单一的音频文件，可以播放任意长度的音频文件、支持循环播放、可以同步播放多个音频文件、控制播放进度以及从音频文件的任意一点开始播放等，比如用它可以很方便的实现重复播放；它也可以很方便的调节左右声道的音量，从而实现很酷的立体声效果，因此它很适用于游戏中的音频播放；由于AVAudioPlayer没有队列这个概念，因此它只能播放一个指定路径的音频，如果需要播放多个音频，可以通过创建多个AVAudioPlayer实例来实现 //Audio Queue Services对音频进行播放可以完全实现对声音的控制，开发者可以将声音数据从文件中读取到内存缓冲区，并对声音数据进行特殊处理，比如进行声音的快速、慢速播放，或者改变声音的音色等 //Open AL是一个跨平台的开源音频处理接口，它为音频播放提供了一套更加底层、更加精细的方案，特别适合具有复杂音频使用场景的游戏开发 //使用System Sound Services播放简短声音，虽然System Sound Services无法直接实现音频文件的循环播放，但是通过System Sound Services的AudioServicesAddSystemSoundCompletion方法对音频的播放事件进行监听，当音频播放结束之后，可以重复音频的播放，从而实现音频的循环播放功能 var _soundId: SystemSoundID = 0 //声明一个系统声音标识类型的声音变量 let path = Bundle.main.path(forResource: &quot;camera&quot;, ofType: &quot;wav&quot;) //获取路径 let soundUrl = URL(fileURLWithPath: path!) //将字符串格式的文件路径转换为URL路径 AudioServicesCreateSystemSoundID(soundUrl as CFURL, &amp;_soundId) //加载指定路径的音频文件，并创建一个System sound对象 //给音频播放添加播放结束的状态监听方法 AudioServicesAddSystemSoundCompletion(_soundId, nil, nil, &#123; (soundID, clientData) -&gt; Void in print(&quot;音频播放结束之后，重复音频的播放。。。&quot;) AudioServicesPlaySystemSound(soundID) //重复音频文件的播放 &#125;, nil) AudioServicesPlaySystemSound(_soundId) //开始音频的播放 &#125; &#125;","categories":[{"name":"代码仓库","slug":"代码仓库","permalink":"http://example.com/categories/%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93/"}],"tags":[{"name":"iOS-功能demo","slug":"iOS-功能demo","permalink":"http://example.com/tags/iOS-%E5%8A%9F%E8%83%BDdemo/"}]},{"title":"使用AVAudioPlayer播放音乐","slug":"代码仓库/iOS-功能demo/使用AVAudioPlayer播放音乐","date":"2021-03-29T16:00:00.000Z","updated":"2021-05-08T09:08:01.000Z","comments":true,"path":"2021/03/30/代码仓库/iOS-功能demo/使用AVAudioPlayer播放音乐/","link":"","permalink":"http://example.com/2021/03/30/%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93/iOS-%E5%8A%9F%E8%83%BDdemo/%E4%BD%BF%E7%94%A8AVAudioPlayer%E6%92%AD%E6%94%BE%E9%9F%B3%E4%B9%90/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import UIKitimport AVFoundation//通过遵守AVAudioPlayerDelegate协议，可以实现对音乐播放状态的监测，比如音乐播放的结束事件或者被来电事件所中断的状态class ViewController: UIViewController, AVAudioPlayerDelegate &#123; var audioPlayer: AVAudioPlayer = AVAudioPlayer() override func viewDidLoad() &#123; super.viewDidLoad() // Do any additional setup after loading the view, typically from a nib. //使用AVAudioPlayer播放音乐 let path = Bundle.main.path(forResource: &quot;music&quot;, ofType: &quot;mp3&quot;) let soundUrl = URL(fileURLWithPath: path!) //从项目中获得导入的音频文件的路径，并将字符串格式的路径转换为URL类型 //AVAudioPlayer的初始化操作会抛出异常 do&#123; try audioPlayer = AVAudioPlayer(contentsOf: soundUrl) //加载指定路径的音频文件 audioPlayer.volume = 1.0 //设置音频播放的音量为最高音量1.0 audioPlayer.numberOfLoops = -1 //实现音频文件的循环播放 //audioPlayer.numberOfLoops = 1 //播放一次 audioPlayer.delegate = self audioPlayer.play() //开始播放音频文件 &#125; catch&#123; print(error) &#125; let stopMusic = UIButton(frame: CGRect(x: 20, y: 80, width: 280, height: 44)) stopMusic.backgroundColor = UIColor.purple stopMusic.setTitle(&quot;暂停/恢复音乐&quot;, for: UIControl.State.init(rawValue: 0)) stopMusic.addTarget(self, action: #selector(ViewController.pauseOrResumeMusic), for: .touchUpInside) self.view.addSubview(stopMusic) &#125; @objc func pauseOrResumeMusic()&#123; if self.audioPlayer.isPlaying &#123; self.audioPlayer.pause() //暂停音乐的播放 &#125; else&#123; self.audioPlayer.play() //开始或恢复音乐的播放 &#125; &#125; //实现AVAudioPlayerDelegate协议中的方法，当音频的播放由于来电等特殊情况而被中断时，将调用此方法 func audioPlayerBeginInterruption(_ player: AVAudioPlayer) &#123; print(&quot;音乐播放被打断。&quot;) &#125; //实现AVAudioPlayerDelegate协议中的方法，当音频的播放结束时，将调用此方法 func audioPlayerDidFinishPlaying(_ player: AVAudioPlayer, successfully flag: Bool) &#123; print(&quot;音乐播放完毕。&quot;); &#125; &#125;","categories":[{"name":"代码仓库","slug":"代码仓库","permalink":"http://example.com/categories/%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93/"}],"tags":[{"name":"iOS-功能demo","slug":"iOS-功能demo","permalink":"http://example.com/tags/iOS-%E5%8A%9F%E8%83%BDdemo/"}]},{"title":"使用AVPlayer播放影片","slug":"代码仓库/iOS-功能demo/使用AVPlayer播放影片","date":"2021-03-28T16:00:00.000Z","updated":"2021-05-09T08:26:10.000Z","comments":true,"path":"2021/03/29/代码仓库/iOS-功能demo/使用AVPlayer播放影片/","link":"","permalink":"http://example.com/2021/03/29/%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93/iOS-%E5%8A%9F%E8%83%BDdemo/%E4%BD%BF%E7%94%A8AVPlayer%E6%92%AD%E6%94%BE%E5%BD%B1%E7%89%87/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334import UIKitimport AVFoundationclass ViewController: UIViewController &#123; override func viewDidLoad() &#123; super.viewDidLoad() // Do any additional setup after loading the view, typically from a nib. //在iOS开发中，播放视频通常采用两种方式，一种是使用MPMoviePlayerController，另一种是使用AVPlayer，MPMoviePlayerController播放方式的使用更加简单，但是功能不如AVPlayer强大，而且随着iOS版本的升级，MPMoviePlayerController将逐渐被丢弃 //使用AVPlayer播放影片 let moviePath = Bundle.main.path(forResource: &quot;movie&quot;, ofType: &quot;mp4&quot;) let movieURL = URL(fileURLWithPath: moviePath!) let avPlayer = AVPlayer(url: movieURL as URL) //创建一个AVPlayer实例，并加载指定位置的视频文件 let avPlayerLayer = AVPlayerLayer(player: avPlayer) //创建一个AVPlayerLayer视频播放层，AVPlayer是一个不可见的组件，要将视频文件显示在用户界面上，需要使用AVPlayerLayer类 avPlayerLayer.frame = self.view.bounds //设置边框大小与当前视图控制器根视图的边界属性保持一致，使视频的播放区域和设备的屏幕尺寸相同 //AVLayerVideoGravity.resizeAspectFill：保留视频的宽高比，并对视频进行缩放，以填满层的范围区域 //AVLayerVideoGravity.resizeAspect：在视频层的显示范围内缩放视频大小，以保持视频的原始宽高比 //AVLayerVideoGravity.resize：将视频内容拉伸来匹配视频层的显示范围 avPlayerLayer.videoGravity = AVLayerVideoGravity.resizeAspectFill self.view.layer.addSublayer(avPlayerLayer) avPlayer.play() //开始视频的播放 &#125; &#125;","categories":[{"name":"代码仓库","slug":"代码仓库","permalink":"http://example.com/categories/%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93/"}],"tags":[{"name":"iOS-功能demo","slug":"iOS-功能demo","permalink":"http://example.com/tags/iOS-%E5%8A%9F%E8%83%BDdemo/"}]},{"title":"实现影片的画中画功能","slug":"代码仓库/iOS-功能demo/实现影片的画中画功能","date":"2021-03-27T16:00:00.000Z","updated":"2021-05-09T12:01:06.000Z","comments":true,"path":"2021/03/28/代码仓库/iOS-功能demo/实现影片的画中画功能/","link":"","permalink":"http://example.com/2021/03/28/%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93/iOS-%E5%8A%9F%E8%83%BDdemo/%E5%AE%9E%E7%8E%B0%E5%BD%B1%E7%89%87%E7%9A%84%E7%94%BB%E4%B8%AD%E7%94%BB%E5%8A%9F%E8%83%BD/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637383940import UIKitimport AVFoundationimport AVKitclass ViewController: UIViewController &#123; override func viewDidLoad() &#123; super.viewDidLoad() // Do any additional setup after loading the view, typically from a nib. //实现影片的画中画功能 //使用AVPlayer播放影片只是单纯的进行视频的播放，并不会提供视频播放控制器，如果需要对视频的播放进行暂停、继续播放等控制，就需要创建自定义的按钮了 //Apple推出了一个ViewController的子类AVPlayerViewController，其不仅可以实现视频的播放，还额外提供了对视频播放进行管理的标准控制界面，还可以轻松的实现iPad中的画中画效果 let moviePath = Bundle.main.path(forResource: &quot;Sunrise&quot;, ofType: &quot;mp4&quot;) let movieURL = URL(fileURLWithPath: moviePath!) let avPlayer = AVPlayer(url: movieURL as URL) //创建一个AVPlayerViewController视频播放视图控制器 let playerVC = AVPlayerViewController() playerVC.player = avPlayer playerVC.videoGravity = AVLayerVideoGravity.resizeAspect playerVC.allowsPictureInPicturePlayback = true //允许在iPad中进行视频播放的画中画功能 playerVC.showsPlaybackControls = true //在播放视频的过程中显示视频播放标准控制界面 playerVC.view.frame = self.view.bounds playerVC.player!.play() //实现视频的播放 self.view.addSubview(playerVC.view) //为了激活在iPad中视频播放的画中画功能，还需要对项目进行一些设置操作，打开Signing &amp; Capabilities，激活Background Modes选项，勾选Audio,Airplay,and Picture in Picture &#125; &#125;","categories":[{"name":"代码仓库","slug":"代码仓库","permalink":"http://example.com/categories/%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93/"}],"tags":[{"name":"iOS-功能demo","slug":"iOS-功能demo","permalink":"http://example.com/tags/iOS-%E5%8A%9F%E8%83%BDdemo/"}]},{"title":"使用URLSession进行网络请求","slug":"代码仓库/iOS-功能demo/使用URLSession进行网络请求","date":"2021-03-26T16:00:00.000Z","updated":"2021-05-13T01:47:52.942Z","comments":true,"path":"2021/03/27/代码仓库/iOS-功能demo/使用URLSession进行网络请求/","link":"","permalink":"http://example.com/2021/03/27/%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93/iOS-%E5%8A%9F%E8%83%BDdemo/%E4%BD%BF%E7%94%A8URLSession%E8%BF%9B%E8%A1%8C%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import UIKitclass ViewController: UIViewController &#123; var label: UILabel! &#x2F;&#x2F;用来显示接收到的网络数据 override func viewDidLoad() &#123; super.viewDidLoad() &#x2F;&#x2F; Do any additional setup after loading the view. &#x2F;&#x2F;HTTP定义了与服务器交互的不同方法，最基本的方法有4种，分别是GET、POST、PUT、DELETE，对应着对URL资源的查、改、增、删四个操作，GET一般用于获取&#x2F;查询资源信息，而POST一般用于更新资源信息 &#x2F;&#x2F;URL全称是资源描述符，一个URL地址描述一个网络上的资源 &#x2F;&#x2F;每个GET和POST都由一系列HTTP请求头组成，这些请求头定义了客户端从服务器请求了什么，而响应则是由一系列HTTP应答头和应答数据组成的，如果请求成功，就返回应答 &#x2F;* GET和POST的区别： 1.GET是从服务器上获取数据，POST是向服务器传送数据 2.GET方式通过URL提交数据，数据在URL中可以看到；POST方式是将数据放置在HTML HEADER内提交 3.GET方式提交的数据最多只能有1024字节，而POST则没有此限制 4.使用GET的时候，参数会显示出来，而POST不会，因此如果需要提交的数据是非敏感数据，那么可以使用GET方式；如果用户输入的数据包含敏感数据，那么还是推荐使用POST 简单来说，GET请求是将参数直接写在访问路径上，特点是操作方便、简单，不过容易被外界看到，所以安全性不高；POST请求的操作相对复杂，需要将参数和地址分开，不过安全性高，参数放在body里面，不易被捕获，而且可以发送更多的数据 *&#x2F; &#x2F;&#x2F;同步意味着线程阻塞，在主线程中使用此方法会响应任何用户事件，以同步的方式从网络请求数据，一旦发送同步请求，应用程序将停止用户交互，直至服务器返回数据完成，才可以进行下一步操作。在同步请求过程中，应用程序的主线程不响应其他事件，直到同步请求结束 &#x2F;&#x2F;异步请求不会阻塞主线程，而会建立一个新的线程来操作，用户发出异步请求后，依然可以进行其他操作，应用程序可以继续运行，也就是说，异步请求不会阻塞主线程对其他事件的响应，所以用户体验会优于同步请求；在iOS开发中，异步请求会使用URLSession的委托协议URLSessionDelegate，在请求的不同阶段回调不同的委托对象方法 &#x2F;&#x2F;使用URLSession进行网络请求，URLSession类支持三种类型的任务：请求数据、下载和上传 label &#x3D; UILabel(frame: CGRect(x: 0, y: 0, width: 320, height: 568)) label.text &#x3D; &quot;Loading..&quot; label.font &#x3D; UIFont(name: &quot;Arial&quot;, size: 14) label.backgroundColor &#x3D; UIColor.orange label.numberOfLines &#x3D; 0 label.lineBreakMode &#x3D; NSLineBreakMode.byWordWrapping self.view.addSubview(label) &#x2F;&#x2F;创建了一个URL网址对象 let urlString: String &#x3D; &quot;https:&#x2F;&#x2F;www.coolketang.com&quot; let url: URL! &#x3D; URL(string: urlString) let request: URLRequest &#x3D; URLRequest(url: url) &#x2F;&#x2F;根据URL网址初始化一个网络请求URLRequest对象 let session &#x3D; URLSession.shared &#x2F;&#x2F;获得URLSession单例对象 &#x2F;&#x2F;通过session单例对象的方法创建一个任务，根据指定的URL请求远程内容，并在完成后调用尾部的闭包处理程序 let dataTask &#x3D; session.dataTask(with: request, completionHandler: &#123;(data, response, error) -&gt; Void in if let error &#x3D; error &#123; print(error.localizedDescription) &#x2F;&#x2F;输出错误日志 &#125; else &#123; &#x2F;&#x2F;处理请求成功的情况 &#x2F;&#x2F;由于需要更改界面元素，因此通过DispatchQueue.main.async语句返回主线程并以异步的方式更新label对象的文字内容 DispatchQueue.main.async &#123; let str &#x3D; NSString(data: data!, encoding: String.Encoding.utf8.rawValue) self.label.text &#x3D; str as String? &#125; &#x2F;&#x2F;print(response) &#125; &#125;) dataTask.resume() &#x2F;&#x2F;开始执行请求任务 &#125;&#125;","categories":[{"name":"代码仓库","slug":"代码仓库","permalink":"http://example.com/categories/%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93/"}],"tags":[{"name":"iOS-功能demo","slug":"iOS-功能demo","permalink":"http://example.com/tags/iOS-%E5%8A%9F%E8%83%BDdemo/"}]},{"title":"使用URLSession下载图片并显示进度","slug":"代码仓库/iOS-功能demo/使用URLSession下载图片并显示进度","date":"2021-03-25T16:00:00.000Z","updated":"2021-05-13T02:41:27.508Z","comments":true,"path":"2021/03/26/代码仓库/iOS-功能demo/使用URLSession下载图片并显示进度/","link":"","permalink":"http://example.com/2021/03/26/%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93/iOS-%E5%8A%9F%E8%83%BDdemo/%E4%BD%BF%E7%94%A8URLSession%E4%B8%8B%E8%BD%BD%E5%9B%BE%E7%89%87%E5%B9%B6%E6%98%BE%E7%A4%BA%E8%BF%9B%E5%BA%A6/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990import UIKit&#x2F;&#x2F;借助URLSessionDownloadDelegate中的代理方法实现下载进度的实时检测class ViewController: UIViewController, URLSessionDownloadDelegate &#123; &#x2F;&#x2F;添加三个控件，用来显示图片下载的进度 var backgroundView: UIView! var foregroundView: UIView! var progressLabel: UILabel! &#x2F;&#x2F;添加第二个代理方法，该代理方法用来监听图片下载完成并存储在指定磁盘位置的事件 func urlSession(_ session: URLSession, downloadTask: URLSessionDownloadTask, didFinishDownloadingTo location: URL) &#123; do &#123; &#x2F;&#x2F;当图片完成下载后，首先获得图像的临时存储路径 let originalPath &#x3D; location.path print(&quot;Original location: \\(originalPath)&quot;) &#x2F;&#x2F;创建位于沙箱Documents目录下的一个图片路径，下载后的临时图片将从临时目录移动到该位置 let targetPath: String &#x3D; NSHomeDirectory() + &quot;&#x2F;Documents&#x2F;background.png&quot; &#x2F;&#x2F;将临时图片移动到指定的位置 let fileManager: FileManager &#x3D; FileManager.default if !fileManager.fileExists(atPath: targetPath) &#123; try fileManager.moveItem(atPath: originalPath, toPath: targetPath) print(&quot;new location: \\(targetPath)&quot;) &#125; &#125; catch &#123; print(&quot;FileManager error.&quot;) &#125; &#125; override func viewDidLoad() &#123; super.viewDidLoad() &#x2F;&#x2F; Do any additional setup after loading the view. &#x2F;&#x2F;使用URLSession下载图片并显示进度：除了请求远程数据外，URLSession还具有下载和上传功能 backgroundView &#x3D; UIView(frame:CGRect(x: 16, y: 106, width: 288, height: 44)) backgroundView.backgroundColor &#x3D; UIColor.lightGray foregroundView &#x3D; UIView(frame:CGRect(x: 20, y: 110, width: 0, height: 36)) foregroundView.backgroundColor &#x3D; UIColor.green progressLabel &#x3D; UILabel(frame:CGRect(x: 20, y: 160, width: 280, height: 36)) progressLabel.textAlignment &#x3D; NSTextAlignment.center self.view.addSubview(backgroundView) self.view.addSubview(foregroundView) self.view.addSubview(progressLabel) &#x2F;&#x2F;初始化了一个URLRequest网络请求对象，表示需要下载的一张图片素材的路径 let url &#x3D; URL(string: &quot;https:&#x2F;&#x2F;coolketang.com&#x2F;images&#x2F;img_bg_1.jpg&quot;)! let request: URLRequest &#x3D; URLRequest(url: url) let urlSession &#x3D; self.buildSession() as Foundation.URLSession &#x2F;&#x2F;urlSession对象是由视图控制器类的buildSession方法实现的 let task &#x3D; urlSession.downloadTask(with: request) task.resume() &#x2F;&#x2F;开始下载任务的执行 &#125; func buildSession() -&gt; Foundation.URLSession &#123; var session: URLSession? &#x3D; nil let config &#x3D; URLSessionConfiguration.default session &#x3D; URLSession(configuration: config, delegate: self, delegateQueue: nil) &#x2F;&#x2F;设置其代理delegate为当前的视图控制器对象，由视图控制器对象实现代理中用来监听图片下载进度的方法 return session! &#125; &#x2F;&#x2F;添加用来监听图片下载进度的方法 func urlSession(_ session: URLSession, downloadTask: URLSessionDownloadTask, didWriteData bytesWritten: Int64, totalBytesWritten: Int64, totalBytesExpectedToWrite: Int64) &#123; let rate: CGFloat &#x3D; CGFloat(totalBytesWritten)&#x2F;CGFloat(totalBytesExpectedToWrite) &#x2F;&#x2F;获得图像已经下载的字节占总字节的比例，totalBytesWritten表示已经下载的字节数，totalBytesExpectedToWrite表示需要下载的总字节数，两者之间的比例就是当前图片下载进度的百分比值 DispatchQueue.main.async(execute: &#123; () in self.foregroundView.frame.size.width &#x3D; rate * 280 &#x2F;&#x2F;根据下载进度的百分比调整foregroundView进度条的宽度，随着下载百分比的增加，foregroundView进度条的宽度也随之增加，这样就实现了模拟图像下载进度的动画效果 if rate &#x3D;&#x3D; 1.0 &#123; self.progressLabel.text &#x3D; &quot;Finished 😝&quot; &#125; &#125;) &#125; &#125;","categories":[{"name":"代码仓库","slug":"代码仓库","permalink":"http://example.com/categories/%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93/"}],"tags":[{"name":"iOS-功能demo","slug":"iOS-功能demo","permalink":"http://example.com/tags/iOS-%E5%8A%9F%E8%83%BDdemo/"}]},{"title":"使用UIWebView加载网页","slug":"代码仓库/iOS-功能demo/使用UIWebView加载网页","date":"2021-03-24T16:00:00.000Z","updated":"2021-05-14T01:05:18.525Z","comments":true,"path":"2021/03/25/代码仓库/iOS-功能demo/使用UIWebView加载网页/","link":"","permalink":"http://example.com/2021/03/25/%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93/iOS-%E5%8A%9F%E8%83%BDdemo/%E4%BD%BF%E7%94%A8UIWebView%E5%8A%A0%E8%BD%BD%E7%BD%91%E9%A1%B5/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142import UIKit&#x2F;&#x2F;UIWebView目前被替换为WKWebView&#x2F;&#x2F;添加协议，检测UIWebView加载网页的状态class ViewController: UIViewController, UIWebViewDelegate &#123; override func viewDidLoad() &#123; super.viewDidLoad() &#x2F;&#x2F; Do any additional setup after loading the view. &#x2F;&#x2F;使用UIWebView加载网页 let bounds &#x3D; UIScreen.main.bounds let frame &#x3D; CGRect(x: 0, y: 0, width: bounds.width, height: bounds.height) let webView &#x3D; UIWebView(frame: frame) webView.delegate &#x3D; self &#x2F;&#x2F;设置webView对象的代理为当前的视图控制器类，由该视图控制器类提供方法，以实现对webView对象的检测 webView.backgroundColor &#x3D; UIColor.black let url &#x3D; URL(string: &quot;https:&#x2F;&#x2F;liao-hexo.github.io&#x2F;archives&#x2F;&quot;)! &#x2F;&#x2F;网址需要采用HTTPS协议 let urlRequest &#x3D; NSURLRequest(url: url) &#x2F;&#x2F;将URL网址对象转换为一个NSURLRequest请求 webView.loadRequest(urlRequest as URLRequest) &#x2F;&#x2F;由webView对象加载这个网页请求 self.view.addSubview(webView) &#125; &#x2F;&#x2F;实现了UIWebViewDelegate协议中的webViewDidStartLoad方法，该方法将在webView开始加载网页时调用 func webViewDidStartLoad(_ webView: UIWebView) &#123; &#x2F;&#x2F;通过UIApplication对象在顶部的状态栏显示用于描述网络状态的旋转风火轮的图标 UIApplication.shared.isNetworkActivityIndicatorVisible &#x3D; true &#125; func webViewDidFinishLoad(_ webView: UIWebView) &#123; UIApplication.shared.isNetworkActivityIndicatorVisible &#x3D; false &#125;&#125;","categories":[{"name":"代码仓库","slug":"代码仓库","permalink":"http://example.com/categories/%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93/"}],"tags":[{"name":"iOS-功能demo","slug":"iOS-功能demo","permalink":"http://example.com/tags/iOS-%E5%8A%9F%E8%83%BDdemo/"}]},{"title":"使用UIWebView加载HTML字符串和GIF动画","slug":"代码仓库/iOS-功能demo/使用UIWebView加载HTML字符串和GIF动画","date":"2021-03-23T16:00:00.000Z","updated":"2021-05-14T01:27:46.862Z","comments":true,"path":"2021/03/24/代码仓库/iOS-功能demo/使用UIWebView加载HTML字符串和GIF动画/","link":"","permalink":"http://example.com/2021/03/24/%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93/iOS-%E5%8A%9F%E8%83%BDdemo/%E4%BD%BF%E7%94%A8UIWebView%E5%8A%A0%E8%BD%BDHTML%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8CGIF%E5%8A%A8%E7%94%BB/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import UIKitclass ViewController: UIViewController &#123; var webView: UIWebView! override func viewDidLoad() &#123; super.viewDidLoad() &#x2F;&#x2F; Do any additional setup after loading the view. &#x2F;&#x2F;使用UIWebView加载HTML字符串和GIF动画 let bounds &#x3D; UIScreen.main.bounds let frame &#x3D; CGRect(x: 0, y: 40, width: bounds.width, height: bounds.height) webView &#x3D; UIWebView(frame: frame) webView.backgroundColor &#x3D; UIColor.clear self.view.addSubview(webView) let loadHTML &#x3D; UIButton(frame: CGRect(x: 40, y: 400, width: 240, height: 44)) loadHTML.setTitle(&quot;加载HTML网页&quot;, for:.normal) loadHTML.backgroundColor &#x3D; UIColor.brown &#x2F;&#x2F;添加点击事件，调用loadHTML方法 loadHTML.addTarget(self, action: #selector(ViewController.loadHTML), for: .touchUpInside) let loadGIF &#x3D; UIButton(frame: CGRect(x: 40, y: 470, width: 240, height: 44)) loadGIF.setTitle(&quot;加载GIF动画&quot;, for: .normal) loadGIF.backgroundColor &#x3D; UIColor.brown &#x2F;&#x2F;添加点击事件，调用loadGIF方法 loadGIF.addTarget(self, action: #selector(ViewController.loadGIF), for: .touchUpInside) self.view.addSubview(loadHTML) self.view.addSubview(loadGIF) &#125; @objc func loadHTML() &#123; let team &#x3D; &quot;&lt;div style &#x3D; &#39;color:#ff0000; font-size:20px;&#39;&gt; 团队名称：酷课堂 &lt;&#x2F;div&gt;&quot; let tel &#x3D; &quot;&lt;div&gt; 电话：&lt;span style &#x3D; &#39;color:#ff0000&#39;&gt; 15011122222 &lt;&#x2F;span&gt;&lt;&#x2F;div&gt;&quot; let url &#x3D; &quot;&lt;div&gt;&lt;b&gt; 网址：http:&#x2F;&#x2F;www.coolketang.com&lt;&#x2F;b&gt;&lt;&#x2F;div&gt;&quot; let html &#x3D; team + tel + url &#x2F;&#x2F;将三个div标签拼接成一个字符串，供webView对象加载使用 webView.dataDetectorTypes &#x3D; [UIDataDetectorTypes.link, UIDataDetectorTypes.phoneNumber] &#x2F;&#x2F;dataDetectorTypes属性被用来设置webView可以将网页中的哪些元素设置为可交互的对象 webView.loadHTMLString(html, baseURL: nil) &#x2F;&#x2F;将拼接好的HTML字符串加载到webView对象中 &#125; @objc func loadGIF() &#123; let resourceURL &#x3D; Bundle.main.resourceURL &#x2F;&#x2F;获得应用程序的根目录，因为GIF动画被保存在根目录的位置 webView.loadHTMLString(&quot;&lt;img src&#x3D;&#39;WildWorld.gif&#39;&gt;&quot;, baseURL: resourceURL) &#125; &#125;","categories":[{"name":"代码仓库","slug":"代码仓库","permalink":"http://example.com/categories/%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93/"}],"tags":[{"name":"iOS-功能demo","slug":"iOS-功能demo","permalink":"http://example.com/tags/iOS-%E5%8A%9F%E8%83%BDdemo/"}]},{"title":"使用UIWebView加载本地网页","slug":"代码仓库/iOS-功能demo/使用UIWebView加载本地网页","date":"2021-03-22T16:00:00.000Z","updated":"2021-05-17T00:56:53.953Z","comments":true,"path":"2021/03/23/代码仓库/iOS-功能demo/使用UIWebView加载本地网页/","link":"","permalink":"http://example.com/2021/03/23/%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93/iOS-%E5%8A%9F%E8%83%BDdemo/%E4%BD%BF%E7%94%A8UIWebView%E5%8A%A0%E8%BD%BD%E6%9C%AC%E5%9C%B0%E7%BD%91%E9%A1%B5/","excerpt":"","text":"123456789101112131415161718192021&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv&#x3D;&quot;Content-Type&quot; content&#x3D;&quot;text&#x2F;html; charset&#x3D;UTF-8&quot;&gt; &lt;title&gt;用户注册页面&lt;&#x2F;title&gt; &lt;script&gt; function submitForm()&#123; alert(&quot;提交表单。&quot;); &#125; &lt;&#x2F;script&gt;&lt;&#x2F;head&gt;&lt;body&gt; &lt;form id&#x3D;&quot;registerForm&quot; action&#x3D;&quot;form_action.php&quot; onsubmit&#x3D;&quot;submitForm()&quot;&gt; 用户名：&lt;input type&#x3D;&quot;text&quot; id&#x3D;&quot;userName&quot; name&#x3D;&quot;userName&quot;&#x2F;&gt;&lt;br&#x2F;&gt; 密 码：&lt;input type&#x3D;&quot;password&quot; id&#x3D;&quot;password&quot; name&#x3D;&quot;password&quot;&#x2F;&gt;&lt;br&#x2F;&gt; &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;提交&quot;&#x2F;&gt; &lt;&#x2F;form&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import UIKitclass ViewController: UIViewController &#123; var webView: UIWebView! override func viewDidLoad() &#123; super.viewDidLoad() &#x2F;&#x2F; Do any additional setup after loading the view. &#x2F;&#x2F;使用UIWebView加载本地网页 &#x2F;&#x2F;首先创建一个HTML页面，该网页包含一个用于用户注册的表单，表单包含用户名、密码两个文本框，允许用户输入自己的个人信息，然后点击表单底部的“提交”按钮，完成用户的注册操作，并向服务器提交表单，当表单被提交时，将执行名为submitForm的JavaScript方法 let bounds &#x3D; UIScreen.main.bounds let frame &#x3D; CGRect(x: 0, y: 40, width: bounds.width, height: bounds.height) webView &#x3D; UIWebView(frame: frame) webView.backgroundColor &#x3D; UIColor.clear self.view.addSubview(webView) let path &#x3D; Bundle.main.path(forResource: &quot;Register&quot;, ofType: &quot;html&quot;) &#x2F;&#x2F;从应用程序束中获得Register.html文件所在路径 let url &#x3D; URL(string: path!) &#x2F;&#x2F;将路径转换为URL对象 webView.loadRequest(NSURLRequest(url: url!) as URLRequest) &#x2F;&#x2F;通过webView对象的loadRequest方法加载指定路径的HTML页面 let getInfo &#x3D; UIButton(frame: CGRect(x: 40, y: 400, width: 240, height: 44)) getInfo.setTitle(&quot;获得页面信息&quot;, for: .normal) getInfo.backgroundColor &#x3D; UIColor.brown getInfo.addTarget(self, action: #selector(ViewController.getInfo), for: .touchUpInside) let submitForm &#x3D; UIButton(frame: CGRect(x: 40, y: 470, width: 240, height: 44)) submitForm.setTitle(&quot;设置并提交表单&quot;, for: .normal) submitForm.backgroundColor &#x3D; UIColor.brown submitForm.addTarget(self, action: #selector(ViewController.submitForm), for: .touchUpInside) self.view.addSubview(getInfo) self.view.addSubview(submitForm) &#125; &#x2F;&#x2F;当用户点击第一个按钮时，将获得并在日志区输出webView对象的网址和网页的标题信息 @objc func getInfo() &#123; &#x2F;&#x2F;通过stringByEvaluatingJavaScript方法使webView对象可以调用网页中的JavaScript方法 &#x2F;&#x2F;UIWebView工具之所以在iOS项目开发中如此重要，就是因为它拥有stringByEvaluatingJavaScript方法，从而使UIWebView和HTML页面的沟通变得简单起来 let url &#x3D; webView.stringByEvaluatingJavaScript(from: &quot;document.location.href&quot;) &#x2F;&#x2F;通过document.location.href获得当前网页的网址 let title &#x3D; webView.stringByEvaluatingJavaScript(from: &quot;document.title&quot;) &#x2F;&#x2F;获得当前网页的标题文字 let info &#x3D; url! + &quot;\\n&quot; + title! print(info) &#125; @objc func submitForm() &#123; let firstJs &#x3D; &quot;document.getElementById(&#39;userName&#39;).value &#x3D; &#39;Jerry&#39;&quot; &#x2F;&#x2F;通过document对象的getElementById方法获得网页中id值为userName的文本框，并将该文本框的值设置为Jerry let secondJs &#x3D; &quot;submitForm()&quot; &#x2F;&#x2F;表示网页中名为submitForm的JavaScript方法 webView.stringByEvaluatingJavaScript(from: firstJs) webView.stringByEvaluatingJavaScript(from: secondJs) &#125; &#125;","categories":[{"name":"代码仓库","slug":"代码仓库","permalink":"http://example.com/categories/%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93/"}],"tags":[{"name":"iOS-功能demo","slug":"iOS-功能demo","permalink":"http://example.com/tags/iOS-%E5%8A%9F%E8%83%BDdemo/"}]},{"title":"使用JavaScript回调原生程序","slug":"代码仓库/iOS-功能demo/使用JavaScript回调原生程序","date":"2021-03-21T16:00:00.000Z","updated":"2021-05-17T01:46:39.321Z","comments":true,"path":"2021/03/22/代码仓库/iOS-功能demo/使用JavaScript回调原生程序/","link":"","permalink":"http://example.com/2021/03/22/%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93/iOS-%E5%8A%9F%E8%83%BDdemo/%E4%BD%BF%E7%94%A8JavaScript%E5%9B%9E%E8%B0%83%E5%8E%9F%E7%94%9F%E7%A8%8B%E5%BA%8F/","excerpt":"","text":"123456789101112131415161718&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv&#x3D;&quot;Content-Type&quot; content&#x3D;&quot;text&#x2F;html; charset&#x3D;UTF-8&quot;&gt; &lt;title&gt;用户注册页面&lt;&#x2F;title&gt; &lt;script&gt; function getDeviceInfo()&#123; document.location &#x3D; &quot;callios:getDeviceInfo&quot; &#x2F;&#x2F;通过设置document对象的location属性的值使浏览器进行跳转 &#x2F;&#x2F;注意，此处跳转的网址不是一个普通的网络地址，而是以冒号&quot;:&quot;进行分隔的自定义格式的字符串。在此和webView对象约定，如果webView对象发现其网页跳转的路径不是HTTP协议，而是我们自定义的callios协议，就不进行页面的跳转，而是执行一些自定义操作，从而获得当前设备的信息 &#125; &lt;&#x2F;script&gt;&lt;&#x2F;head&gt;&lt;body&gt; &lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;获得设备信息&quot; onClick&#x3D;&quot;getDeviceInfo()&quot; style&#x3D;&quot;width:305px;height:50px;font-size:20px;&quot;&#x2F;&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import UIKit&#x2F;&#x2F;使用该协议中的方法对网页跳转的请求进行监听class ViewController: UIViewController, UIWebViewDelegate &#123; var webView: UIWebView! override func viewDidLoad() &#123; super.viewDidLoad() &#x2F;&#x2F; Do any additional setup after loading the view. &#x2F;&#x2F;使用JavaScript回调原生程序 &#x2F;&#x2F;使用UIWebView对象，通过stringByEvaluatingJavaScript方法来调用HTML中的JavaScript语言，那么JavaScript是否可以回调原生程序呢？ &#x2F;&#x2F;我们可以通过UIWebView的重定向请求功能来实现JavaScript的回调 &#x2F;&#x2F;创建一个HTML文件 let bounds &#x3D; UIScreen.main.bounds let frame &#x3D; CGRect(x: 0, y: 40, width: bounds.width, height: bounds.height) webView &#x3D; UIWebView(frame: frame) webView.delegate &#x3D; self webView.backgroundColor &#x3D; UIColor.clear self.view.addSubview(webView) &#x2F;&#x2F;加载被导入项目中的HTML文件 let path &#x3D; Bundle.main.path(forResource: &quot;GetDeviceInfo&quot;, ofType: &quot;html&quot;) let url &#x3D; URL(string: path!) webView.loadRequest(NSURLRequest(url: url!) as URLRequest) &#125; &#x2F;&#x2F;实现UIWebViewDelegate协议中的shouldStartLoadWith:request:方法，该方法会监听所有webView对象中的网页跳转的请求，然后通过对请求的URL路径进行检测，从而判断是否通过该请求 func webView(_ webView: UIWebView, shouldStartLoadWith request: URLRequest, navigationType: UIWebView.NavigationType) -&gt; Bool &#123; let url &#x3D; request.url?.absoluteString &#x2F;&#x2F;获得网页打算跳转到的网址 let components &#x3D; url?.components(separatedBy: &quot;:&quot;) &#x2F;&#x2F;使用冒号对网址字符串进行分隔，从而获得分隔后的数组对象 let firstElement &#x3D; components?[0] &#x2F;&#x2F;获得数组中的第一个字符串对象，即网络协议 if (components?.count)! &gt; 1 &amp;&amp; firstElement! &#x3D;&#x3D; &quot;callios&quot; &#123; let model &#x3D; UIDevice.current.model &#x2F;&#x2F;获得当前设备的型号 let systemName &#x3D; UIDevice.current.systemName &#x2F;&#x2F;操作系统名称 let systemVersion &#x3D; UIDevice.current.systemVersion &#x2F;&#x2F;操作系统的版本号 let message &#x3D; &quot;设备类型:&quot;+model+&quot;\\\\n系统类型:&quot;+systemName+&quot;\\\\n系统版本:&quot;+systemVersion webView.stringByEvaluatingJavaScript(from: &quot;alert(&#39;&quot; + message + &quot;&#39;)&quot;) &#x2F;&#x2F;通过webView.stringByEvaluatingJavaScript反过来调用JavaScript的alert方法，将当前设备的信息返回网页，并在网页中使用alert方法弹出窗口，在网页中显示传递过来的设备信息 return false &#125; return true &#125; &#125;","categories":[{"name":"代码仓库","slug":"代码仓库","permalink":"http://example.com/categories/%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93/"}],"tags":[{"name":"iOS-功能demo","slug":"iOS-功能demo","permalink":"http://example.com/tags/iOS-%E5%8A%9F%E8%83%BDdemo/"}]},{"title":"创建一个简单的笔记本","slug":"代码仓库/iOS-功能demo/创建一个简单的笔记本","date":"2021-03-20T16:00:00.000Z","updated":"2021-05-17T07:14:50.817Z","comments":true,"path":"2021/03/21/代码仓库/iOS-功能demo/创建一个简单的笔记本/","link":"","permalink":"http://example.com/2021/03/21/%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93/iOS-%E5%8A%9F%E8%83%BDdemo/%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E7%AC%94%E8%AE%B0%E6%9C%AC/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788&lt;!-- 设置网页的CSS样式 --&gt;&lt;style&gt; &#x2F;*避免在iOS系统较低版本时，用户点击webView会出现的短暂闪烁现象*&#x2F;* &#123; outline: 0px solid transparent; -webkit-tap-highlight-color: rgba(0,0,0,0); -webkit-touch-callout: none;&#125;body &#123; background-image: url(bg.png); margin: 0 auto; &#x2F;* 外间距 *&#x2F; max-width: 900px; color: clear; &#x2F;* 文字颜色: #000000 *&#x2F;&#125; .content &#123; &#x2F;* 设置了可编辑div标签的外观样式 *&#x2F; margin: 0px 0; min-height: 430px; overflow-x: hidden; &#x2F;* 让webView不显示横向滚动条 *&#x2F;&#125; div &#123; font-size: 16px; line-height: 18px; margin: 5px 0;&#125; img &#123; max-width: 900px; width: 100%;&#125; &lt;&#x2F;style&gt;&lt;script&gt; &#x2F;&#x2F;添加插入笔记图片的方法，往可编辑div中插入来自Swift的图片&#x2F;&#x2F;通过imagePath获得从swift中传递进来的图片的路径function insertImage(imagePath) &#123; var selection &#x3D; window.getSelection ? window.getSelection() : document.selection; &#x2F;&#x2F;获得网页中的选区对象，将通过该对象获得光标所在的位置，因为图片有可能不是插入div标签最后的位置，而是插入由用户自定义的光标所在的位置 var range &#x3D; selection.createRange ? selection.createRange() : selection.getRangeAt(0); &#x2F;&#x2F;该对象将用来在光标处插入图片 var div &#x3D; document.createElement(&quot;div&quot;); &#x2F;&#x2F;创建一个新的div标签，它将作为图片的容器 div.style.position &#x3D; &quot;relative&quot;; &#x2F;&#x2F;设置div标签的位置属性为relative相对模式，使div标签的位置由它的前一兄弟对象决定 &#x2F;&#x2F;创建了一个img图像标签，用来从swift传递过来的图片路径中加载图片 &#x2F;&#x2F;src：表示图片的路径，onerror属性表示如果img标签无法正常加载swift传递过来的图片路径，就显示加载错误提示图片defaultErrorPic.png var insertingImage &#x3D; &quot;&lt;img src &#x3D; &#39;&quot;+imagePath+&quot;&#39; onerror &#x3D; \\&quot;this.src &#x3D; &#39;defaultErrorPic.png&#39;\\&quot;&#x2F;&gt;&quot; &#x2F;&#x2F;创建了另一个img图像标签，用来显示悬浮在图片上方并位于右上角的删除图片 &#x2F;&#x2F;position : absolute表示图像的位置属性为绝对定位，不会受其兄弟节点位置的影响 &#x2F;&#x2F;onclick &#x3D; &#39;removeImage(this)&#39;即当用户点击删除图标时，执行该方法以删除该图标和位于图标下方的图片 var deleteIcon &#x3D; &quot;&lt;img src &#x3D; &#39;deleteImage.png&#39; style &#x3D; &#39;width : 30px; height : 30px; margin-top : 9px; position : absolute; z-index : 10; right : 5px&#39; contenteditable &#x3D; &#39;false&#39; onclick &#x3D; &#39;removeImage(this)&#39;&#x2F;&gt;&quot; div.innerHTML &#x3D; deleteIcon+insertingImage; &#x2F;&#x2F;这样就可以在新建的div标签中插入一张图片和删除一个图标了 range.insertNode(div); &#x2F;&#x2F;将div控件添加到当前光标的位置 &#x2F;&#x2F;新的div控件被插入后，光标仍然位于原来的位置，所以通过执行selection对象的modify方法，将光标向右移动一个单词的距离，这样就可以在插入图片之后，将光标移至图片的后方 selection.modify(&quot;move&quot;, &quot;right&quot;, &quot;word&quot;)&#125;&#x2F;&#x2F;删除图片&#x2F;&#x2F;obj表示被点击的图片，也就是删除图标&#x2F;&#x2F;第二个参数表示点击事件，可以通过该参数获得点击位置等信息function removeImage(obj,e) &#123; obj.parentNode.parentNode.removeChild(obj.parentNode); &#x2F;&#x2F;通过第一个parentNode属性获得删除图标的父对象，即新建的那个div控件，再通过第二个parentNode属性获得最外围的、id为content的可编辑的div控件，由该控件通过执行其removeChild方法移除删除图标的父节点 document.getElementById(&quot;content&quot;).blur(); &#x2F;&#x2F;删除图片后执行了可编辑div的blur操作，因此自动退出编辑模式，iOS系统的键盘也会自动消失&#125;&#x2F;&#x2F;获得笔记内容function getNote() &#123; return document.getElementById(&quot;content&quot;).innerHTML; &#x2F;&#x2F;首先通过document.getElementById获得id为content的可编辑的div控件，然后获得该控件的innerHTML属性，即该控件下的所有子标签(包含文字和图像等)，最后通过return方法返回获得的内容，返回的内容将被传递给swift&#125;&lt;&#x2F;script&gt; &lt;!-- 创建一个可编辑的div，该div标签充当笔记内容的容器，笔记中的所有文字和图像内容都被放置在该div标签内 --&gt;&lt;div class &#x3D; &quot;content&quot; contenteditable &#x3D; &quot;true&quot; id &#x3D; &quot;content&quot;&gt;&lt;&#x2F;div&gt;&lt;!-- 通过设置contenteditable&#x3D;&quot;true&quot;，将该div设置为可编辑的容器 --&gt;&lt;!-- 通过div标签的id属性，可以通过document的getElementById方法查找到该div控件，从而保存该控件内的所有文字和图像内容，以及再次读取保存的内容至div标签中 --&gt;&lt;!-- class属性设置div标签的外观样式，具体的样式设置在CSS样式表中进行定义 --&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import UIKitclass ViewController: UIViewController &#123; var webView: UIWebView! override func viewDidLoad() &#123; super.viewDidLoad() &#x2F;&#x2F; Do any additional setup after loading the view. &#x2F;&#x2F;创建一个简单的笔记本 let bounds &#x3D; UIScreen.main.bounds let frame &#x3D; CGRect(x: 0, y: 60, width: bounds.width, height: bounds.height-60) webView &#x3D; UIWebView(frame: frame) webView.scrollView.showsVerticalScrollIndicator &#x3D; true &#x2F;&#x2F;显示webView的垂直滚动条，当笔记内容较多时，需要使用垂直滚动条帮助用户浏览笔记 self.view.addSubview(webView) &#x2F;&#x2F;加载项目中的NoteBook.html网页 let path &#x3D; Bundle.main.path(forResource: &quot;NoteBook&quot;, ofType: &quot;html&quot;) let url &#x3D; URL(string: path!) webView.loadRequest(NSURLRequest(url: url!) as URLRequest) let inserImage &#x3D; UIButton(frame: CGRect(x: 0, y: 20, width: 160, height: 40)) inserImage.setTitle(&quot;插入图片&quot;, for: UIControl.State.init(rawValue: 0)) inserImage.backgroundColor &#x3D; UIColor.purple inserImage.addTarget(self, action: #selector(ViewController.inserImage), for: .touchUpInside) self.view.addSubview(inserImage) let saveNote &#x3D; UIButton(frame: CGRect(x: 160, y: 20, width: 160, height: 40)) saveNote.setTitle(&quot;保存笔记&quot;, for: UIControl.State.init(rawValue: 0)) saveNote.backgroundColor &#x3D; UIColor.brown saveNote.addTarget(self, action: #selector(ViewController.saveNote), for: .touchUpInside) self.view.addSubview(saveNote) &#125; @objc func inserImage() &#123; &#x2F;&#x2F;当用户点击该按钮时，通过执行webView对象的stringByEvaluatingJavaScript方法，从而调用JavaScript语言的insertImage方法，并传递项目根目录中的Coffee.png图片，供insertImage方法使用 webView.stringByEvaluatingJavaScript(from: &quot;insertImage(&#39;Coffee.png&#39;)&quot;) &#x2F;&#x2F;在实际工作中，可能需要从网络上下载图片，或者从相册、相机中加载图片，然后将图片路径传递给JavaScript方法 &#125; @objc func saveNote() &#123; let note &#x3D; webView.stringByEvaluatingJavaScript(from: &quot;getNote()&quot;) print(note ?? &quot;&quot;) &#x2F;&#x2F;在实际工作中，通常需要将笔记的内容保存在本地的SQLite数据库中，或者存储到远程的服务器 &#125; &#125;","categories":[{"name":"代码仓库","slug":"代码仓库","permalink":"http://example.com/categories/%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93/"}],"tags":[{"name":"iOS-功能demo","slug":"iOS-功能demo","permalink":"http://example.com/tags/iOS-%E5%8A%9F%E8%83%BDdemo/"}]},{"title":"创建和解析plist文件","slug":"代码仓库/iOS-功能demo/创建和解析plist文件","date":"2021-03-19T16:00:00.000Z","updated":"2021-05-18T02:57:40.843Z","comments":true,"path":"2021/03/20/代码仓库/iOS-功能demo/创建和解析plist文件/","link":"","permalink":"http://example.com/2021/03/20/%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93/iOS-%E5%8A%9F%E8%83%BDdemo/%E5%88%9B%E5%BB%BA%E5%92%8C%E8%A7%A3%E6%9E%90plist%E6%96%87%E4%BB%B6/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233import UIKitclass ViewController: UIViewController &#123; override func viewDidLoad() &#123; super.viewDidLoad() &#x2F;&#x2F; Do any additional setup after loading the view. &#x2F;&#x2F;一个功能丰富的应用程序，它的数据不仅存储在内存中，而是将更多的数据写入磁盘，进行持久化存储 &#x2F;&#x2F;iOS中的数据持久化方式基本上有4种：plist属性列表、对象归档、SQLite3、Core Data &#x2F;&#x2F;在iOS开发工作中，经常需要使用plist文件存储一些属性或配置信息，plist文件的全名是Property List，即属性列表文件，它是一种用来存储串行化后的对象的文件，由于属性列表文件的扩展名为.plist，因此通常被简称为plist文件 &#x2F;&#x2F;plist文件为属性列表文件，以类似于键值对(key-value)的形式存储项目中的各种数据 &#x2F;&#x2F;创建和解析plist文件 &#x2F;&#x2F;plist文件支持Array数组和Dictionary字典两种集合类型，以及Boolean布尔类型、Data二进制数据类型、Date日期类型、Number数字类型和String字符串类型 &#x2F;&#x2F;plist文件是以XML文件的格式进行存储的，在demoPlist.plist文件名称上右击，然后依次选择Open As、Source Code选项，查看该plist文件的源代码 let plistPath &#x3D; Bundle.main.path(forResource: &quot;demoPlist&quot;, ofType: &quot;plist&quot;) &#x2F;&#x2F;获得demoPlist.plist文件在项目沙箱目录中的路径 let data: NSMutableDictionary &#x3D; NSMutableDictionary.init(contentsOfFile: plistPath!)! &#x2F;&#x2F;加载plist文件，并将plist文件转换为可变字典类型的数据 let message &#x3D; data.description let name &#x3D; data[&quot;Name&quot;] as! String let age &#x3D; data[&quot;Age&quot;] as! Int print(message) print(name) print(age) &#125; &#125;","categories":[{"name":"代码仓库","slug":"代码仓库","permalink":"http://example.com/categories/%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93/"}],"tags":[{"name":"iOS-功能demo","slug":"iOS-功能demo","permalink":"http://example.com/tags/iOS-%E5%8A%9F%E8%83%BDdemo/"}]},{"title":"将信息写入plist文件","slug":"代码仓库/iOS-功能demo/将信息写入plist文件","date":"2021-03-18T16:00:00.000Z","updated":"2021-05-18T03:19:44.855Z","comments":true,"path":"2021/03/19/代码仓库/iOS-功能demo/将信息写入plist文件/","link":"","permalink":"http://example.com/2021/03/19/%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93/iOS-%E5%8A%9F%E8%83%BDdemo/%E5%B0%86%E4%BF%A1%E6%81%AF%E5%86%99%E5%85%A5plist%E6%96%87%E4%BB%B6/","excerpt":"","text":"12345678910111213141516171819202122232425262728import UIKitclass ViewController: UIViewController &#123; override func viewDidLoad() &#123; super.viewDidLoad() &#x2F;&#x2F; Do any additional setup after loading the view. &#x2F;&#x2F;将信息写入plist文件 let dic: NSMutableDictionary &#x3D; NSMutableDictionary() &#x2F;&#x2F;创建了一个NSMutableDictionary可变字典对象 &#x2F;&#x2F;以键值对的形式创建两个对象，并添加到可变字典对象中 dic.setObject(&quot;Bruce&quot;, forKey: &quot;Name&quot; as NSCopying) dic.setObject(22, forKey: &quot;Age&quot; as NSCopying) let plistPath &#x3D; Bundle.main.path(forResource: &quot;demoPlist&quot;, ofType: &quot;plist&quot;) dic.write(toFile: plistPath!, atomically: true) &#x2F;&#x2F;将可变字典对象写入plist文件中 let data: NSMutableDictionary &#x3D; NSMutableDictionary.init(contentsOfFile: plistPath!)! &#x2F;&#x2F;将plist文件加载到内存中，并转换为可变字典对象，从而查看写入后的plist文件的内容 let message &#x3D; data.description print(plistPath!) &#x2F;&#x2F;plist文件在项目中的位置，访达中定位该位置可以看到plist文件 print(message) &#125; &#125;","categories":[{"name":"代码仓库","slug":"代码仓库","permalink":"http://example.com/categories/%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93/"}],"tags":[{"name":"iOS-功能demo","slug":"iOS-功能demo","permalink":"http://example.com/tags/iOS-%E5%8A%9F%E8%83%BDdemo/"}]},{"title":"创建CoreData实体并插入数据","slug":"代码仓库/iOS-功能demo/创建CoreData实体并插入数据","date":"2021-03-17T16:00:00.000Z","updated":"2021-05-19T06:54:35.750Z","comments":true,"path":"2021/03/18/代码仓库/iOS-功能demo/创建CoreData实体并插入数据/","link":"","permalink":"http://example.com/2021/03/18/%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93/iOS-%E5%8A%9F%E8%83%BDdemo/%E5%88%9B%E5%BB%BACoreData%E5%AE%9E%E4%BD%93%E5%B9%B6%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE/","excerpt":"","text":"⭐️注意：项目名称一定不能使用CoreData 创建项目时记得选上Use Core Data选项 选择.xcdatamodeld文件，然后依次点击Editor、Create NSManagedObject subclass Codegen：Manual/None 123456789101112131415161718192021222324252627282930313233import UIKitimport CoreData &#x2F;&#x2F;引入CoreData框架class ViewController: UIViewController &#123; override func viewDidLoad() &#123; super.viewDidLoad() &#x2F;&#x2F; Do any additional setup after loading the view. &#x2F;&#x2F;创建Core Data实体并插入数据 let appDelegate: AppDelegate &#x3D; UIApplication.shared.delegate as! AppDelegate &#x2F;&#x2F;从UIApplication中获得当前项目中的AppDelegate对象 let managedObjectContext &#x3D; appDelegate.persistentContainer.viewContext &#x2F;&#x2F;获得AppDelegate对象的managedObjectContext托管对象的上下文 let newUser &#x3D; NSEntityDescription.insertNewObject(forEntityName: &quot;User&quot;, into: managedObjectContext) as! User &#x2F;&#x2F;通过NSEntityDescription.insertNewObject在托管对象上下文中插入一条User实体对象 newUser.userName &#x3D; &quot;John&quot; newUser.password &#x3D; &quot;123456&quot; &#x2F;&#x2F;执行数据的存储操作 do &#123; try managedObjectContext.save() &#x2F;&#x2F;对newUser对象进行保存操作 print(&quot;成功保存数据。&quot;) &#125; catch &#123; print(&quot;保存数据失败。&quot;) &#125; &#125; &#125;","categories":[{"name":"代码仓库","slug":"代码仓库","permalink":"http://example.com/categories/%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93/"}],"tags":[{"name":"iOS-功能demo","slug":"iOS-功能demo","permalink":"http://example.com/tags/iOS-%E5%8A%9F%E8%83%BDdemo/"}]},{"title":"检索Core_Data中的数据","slug":"代码仓库/iOS-功能demo/检索Core_Data中的数据","date":"2021-03-16T16:00:00.000Z","updated":"2021-05-19T07:34:59.128Z","comments":true,"path":"2021/03/17/代码仓库/iOS-功能demo/检索Core_Data中的数据/","link":"","permalink":"http://example.com/2021/03/17/%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93/iOS-%E5%8A%9F%E8%83%BDdemo/%E6%A3%80%E7%B4%A2Core_Data%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE/","excerpt":"","text":"项目的创建与上一节相同！ 1234567891011121314151617181920212223242526272829303132333435363738394041import UIKitimport CoreData &#x2F;&#x2F;引入CoreData框架class ViewController: UIViewController &#123; override func viewDidLoad() &#123; super.viewDidLoad() &#x2F;&#x2F; Do any additional setup after loading the view. &#x2F;&#x2F;检索Core Data中的数据 let appDelegate: AppDelegate &#x3D; UIApplication.shared.delegate as! AppDelegate let managedObjectContext &#x3D; appDelegate.persistentContainer.viewContext let entity: NSEntityDescription? &#x3D; NSEntityDescription.entity(forEntityName: &quot;User&quot;, in: managedObjectContext) &#x2F;&#x2F;通过NSEntityDescription.entity获得托管对象上下文中的User实体 let request &#x3D; NSFetchRequest&lt;User&gt;(entityName: &quot;User&quot;) &#x2F;&#x2F;创建一个User类型的NSFetchRequest查询请求对象 request.fetchOffset &#x3D; 0 &#x2F;&#x2F;fetchOffset属性用于设置数据查询的偏移位置，例如返回结果有A、B、C、D四个结果，当设置fetchOffset为1时，仅返回B、C、D三个结果 request.fetchLimit &#x3D; 10 &#x2F;&#x2F;获取从偏移值为0的位置起的10条数据，如果总的数据量少于10条，就返回全部的数据 request.entity &#x3D; entity &#x2F;&#x2F;设置request对象的entity为User类型的实体，即查询持久化存储中类型为User的符合查询条件的实体 &#x2F;&#x2F;创建一个Predicate断言，以查询userName为John的User类型的实体，如果不设置断言，就会查询所有类型的为User的实体 let predicate &#x3D; NSPredicate(format: &quot;userName&#x3D; &#39;John&#39; &quot;, &quot;&quot;) request.predicate &#x3D; predicate do&#123; let results:[AnyObject]? &#x3D; try managedObjectContext.fetch(request) &#x2F;&#x2F;调用fetch方法，根据指定的断言查询符合条件的User类型的实体，并将查询的结果存储在一个名为results的AnyObject类型的数组中 for user:User in results as! [User]&#123; print(&quot;userName &#x3D; \\(user.userName!)&quot;) print(&quot;password &#x3D; \\(user.password!)&quot;) &#125; &#125; catch&#123; print(&quot;获取数据失败。&quot;) &#125; &#125; &#125;","categories":[{"name":"代码仓库","slug":"代码仓库","permalink":"http://example.com/categories/%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93/"}],"tags":[{"name":"iOS-功能demo","slug":"iOS-功能demo","permalink":"http://example.com/tags/iOS-%E5%8A%9F%E8%83%BDdemo/"}]},{"title":"修改Core_Data中的数据","slug":"代码仓库/iOS-功能demo/修改Core_Data中的数据","date":"2021-03-15T16:00:00.000Z","updated":"2021-05-19T07:50:06.814Z","comments":true,"path":"2021/03/16/代码仓库/iOS-功能demo/修改Core_Data中的数据/","link":"","permalink":"http://example.com/2021/03/16/%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93/iOS-%E5%8A%9F%E8%83%BDdemo/%E4%BF%AE%E6%94%B9Core_Data%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import UIKitimport CoreData &#x2F;&#x2F;引入CoreData框架class ViewController: UIViewController &#123; override func viewDidLoad() &#123; super.viewDidLoad() &#x2F;&#x2F; Do any additional setup after loading the view. &#x2F;&#x2F;修改Core Data中的数据 let appDelegate: AppDelegate &#x3D; UIApplication.shared.delegate as! AppDelegate let managedObjectContext &#x3D; appDelegate.persistentContainer.viewContext let entity: NSEntityDescription? &#x3D; NSEntityDescription.entity(forEntityName: &quot;User&quot;, in: managedObjectContext) &#x2F;&#x2F;通过NSEntityDescription.entity获得托管对象上下文中的User实体 let request &#x3D; NSFetchRequest&lt;User&gt;(entityName: &quot;User&quot;) &#x2F;&#x2F;创建一个User类型的NSFetchRequest查询请求对象 request.fetchOffset &#x3D; 0 &#x2F;&#x2F;fetchOffset属性用于设置数据查询的偏移位置，例如返回结果有A、B、C、D四个结果，当设置fetchOffset为1时，仅返回B、C、D三个结果 request.fetchLimit &#x3D; 10 &#x2F;&#x2F;获取从偏移值为0的位置起的10条数据，如果总的数据量少于10条，就返回全部的数据 request.entity &#x3D; entity &#x2F;&#x2F;设置request对象的entity为User类型的实体，即查询持久化存储中类型为User的符合查询条件的实体 &#x2F;&#x2F;创建一个Predicate断言，以查询userName为John的User类型的实体，如果不设置断言，就会查询所有类型的为User的实体 let predicate &#x3D; NSPredicate(format: &quot;userName&#x3D; &#39;John&#39; &quot;, &quot;&quot;) request.predicate &#x3D; predicate do&#123; let results:[AnyObject]? &#x3D; try managedObjectContext.fetch(request) &#x2F;&#x2F;调用fetch方法，根据指定的断言查询符合条件的User类型的实体，并将查询的结果存储在一个名为results的AnyObject类型的数组中 &#x2F;&#x2F;遍历查询到的results数组，并将数组中的User对象的userName修改为Peter for user:User in results as! [User]&#123; user.userName &#x3D; &quot;Peter&quot; &#125; try managedObjectContext.save() &#x2F;&#x2F;被修改后的User对象仍然处于内存中，尚未被持久化，通过调用save()方法保存到序列化文件中 request.predicate &#x3D; nil &#x2F;&#x2F;重置断言，以查找所有的user实体 let newResults:[AnyObject]? &#x3D; try managedObjectContext.fetch(request) for user:User in newResults as! [User]&#123; print(&quot;userName: \\(user.userName!)&quot;) print(&quot;password: \\(user.password!)&quot;) &#125; &#125; catch&#123; print(&quot;获取数据失败。&quot;) &#125; &#125; &#125;","categories":[{"name":"代码仓库","slug":"代码仓库","permalink":"http://example.com/categories/%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93/"}],"tags":[{"name":"iOS-功能demo","slug":"iOS-功能demo","permalink":"http://example.com/tags/iOS-%E5%8A%9F%E8%83%BDdemo/"}]},{"title":"删除Core_Data中的数据","slug":"代码仓库/iOS-功能demo/删除Core_Data中的数据","date":"2021-03-14T16:00:00.000Z","updated":"2021-05-19T08:00:15.370Z","comments":true,"path":"2021/03/15/代码仓库/iOS-功能demo/删除Core_Data中的数据/","link":"","permalink":"http://example.com/2021/03/15/%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93/iOS-%E5%8A%9F%E8%83%BDdemo/%E5%88%A0%E9%99%A4Core_Data%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import UIKitimport CoreData &#x2F;&#x2F;引入CoreData框架class ViewController: UIViewController &#123; override func viewDidLoad() &#123; super.viewDidLoad() &#x2F;&#x2F; Do any additional setup after loading the view. &#x2F;&#x2F;删除Core Data中的数据 let appDelegate: AppDelegate &#x3D; UIApplication.shared.delegate as! AppDelegate let managedObjectContext &#x3D; appDelegate.persistentContainer.viewContext let entity: NSEntityDescription? &#x3D; NSEntityDescription.entity(forEntityName: &quot;User&quot;, in: managedObjectContext) &#x2F;&#x2F;通过NSEntityDescription.entity获得托管对象上下文中的User实体 let request &#x3D; NSFetchRequest&lt;User&gt;(entityName: &quot;User&quot;) &#x2F;&#x2F;创建一个User类型的NSFetchRequest查询请求对象 request.fetchOffset &#x3D; 0 &#x2F;&#x2F;fetchOffset属性用于设置数据查询的偏移位置，例如返回结果有A、B、C、D四个结果，当设置fetchOffset为1时，仅返回B、C、D三个结果 request.fetchLimit &#x3D; 10 &#x2F;&#x2F;获取从偏移值为0的位置起的10条数据，如果总的数据量少于10条，就返回全部的数据 request.entity &#x3D; entity &#x2F;&#x2F;设置request对象的entity为User类型的实体，即查询持久化存储中类型为User的符合查询条件的实体 let predicate &#x3D; NSPredicate(format: &quot;userName&#x3D; &#39;John&#39; &quot;, &quot;&quot;) request.predicate &#x3D; nil &#x2F;&#x2F;查询上下文中所有的User实体数据 do&#123; let results:[AnyObject]? &#x3D; try managedObjectContext.fetch(request) &#x2F;&#x2F;调用fetch方法，根据指定的断言查询符合条件的User类型的实体，并将查询的结果存储在一个名为results的AnyObject类型的数组中 &#x2F;&#x2F;将数组中的User实体对象删除 for user:User in results as! [User]&#123; managedObjectContext.delete(user) &#125; try managedObjectContext.save() &#x2F;&#x2F;被修改后的User对象仍然处于内存中，尚未被持久化，通过调用save()方法保存到序列化文件中 request.predicate &#x3D; nil &#x2F;&#x2F;重置断言，以查找所有的user实体 let newResults:[AnyObject]? &#x3D; try managedObjectContext.fetch(request) for user:User in newResults as! [User]&#123; print(&quot;userName: \\(user.userName!)&quot;) print(&quot;password: \\(user.password!)&quot;) &#125; &#125; catch&#123; print(&quot;获取数据失败。&quot;) &#125; &#125; &#125;","categories":[{"name":"代码仓库","slug":"代码仓库","permalink":"http://example.com/categories/%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93/"}],"tags":[{"name":"iOS-功能demo","slug":"iOS-功能demo","permalink":"http://example.com/tags/iOS-%E5%8A%9F%E8%83%BDdemo/"}]},{"title":"项目1.加法计算器","slug":"iOS开发-项目/UI/项目1.加法计算器","date":"2020-11-29T16:00:00.000Z","updated":"2021-03-24T13:26:07.000Z","comments":true,"path":"2020/11/30/iOS开发-项目/UI/项目1.加法计算器/","link":"","permalink":"http://example.com/2020/11/30/iOS%E5%BC%80%E5%8F%91-%E9%A1%B9%E7%9B%AE/UI/%E9%A1%B9%E7%9B%AE1.%E5%8A%A0%E6%B3%95%E8%AE%A1%E7%AE%97%E5%99%A8/","excerpt":"","text":"iOS开发步骤：1.搭建软件界面（UI）2.发送网络请求（多线程/网络）3.网络数据解析（json/xml）4.在界面上显示数据 软件开发定律：万物皆对象 UIKit框架中的一些控件：1.UIImageView：图片对象2.UILabel：文本标签（显示一串固定的文字）3.UIButton：按钮（监听用户的点击事件，在用户点击后作出响应）4.UITextField：文本输入框（可以弹出键盘，让用户输入文本内容） UIView和UIViewController：1）UIView：屏幕上能看得见摸得着的东西就是UIView(视图、控件、组件)，UILabel、UIButton、UITextField都继承自UIView；每一个UIView都是一个容器，能容纳其他UIView2）UIViewController：UIView的创建、显示和销毁；负责监听UIView内部的事件；UIView跟用户的交互（处理UIView内部每一行的点击）；其实每当显示一个新界面时，首先会创建一个新的UIViewController对象，然后创建一个对应的全屏UIView，UIViewController负责管理这个UIView3）UIViewController内部有一个UIView属性，就是它负责管理UIView对象：@property(nonatomic,retain)UIView *view;4）UIView只负责对数据的展示、采集用户的输入、监听用户的事件等；其他的操作比如：每个UIView的创建、销毁、用户触发某个事件后的事件处理程序等这些都交给UIViewController来处理 项目1.加法计算器 1）先把界面搭建出来 2）选中文本框时让弹出的键盘为数字键盘【Keyboard Type：Number Pad】，如果运行时键盘弹不出来，按command+k 3）在ViewController.m文件类扩展中开始写代码【可以自己写，也可以直接拖拽(control键将按钮添加到类扩展中)】 12345678910111213141516//类扩展@interface ViewController ()//IBAction生成方法，跟void一样，只是它可以建立连线- (IBAction)calculate;//计算方法的声明//IBOutlet生成属性@property (weak, nonatomic) IBOutlet UITextField *text1; //第一个文本框@property (weak, nonatomic) IBOutlet UITextField *text2; //第二个文本框@property (weak, nonatomic) IBOutlet UILabel *result; //最后计算显示的结果@end 4）在方法的实现中写计算的代码 1234567891011121314151617181920212223242526272829303132333435363738@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view.&#125;//计算方法的实现- (IBAction)calculate &#123; //1.获取用户的输入(因为用户输入的是整型数字，text是NSString类型的，所以后面要用intValue)// 1）第一种方法：// NSString *num1=self.text1.text;// NSString *num2=self.text2.text;// int n1=[num1 intValue];// int n2=num2.intValue;// 2）第二种方法： int n1=self.text1.text.intValue; int n2=self.text2.text.intValue; //2.计算和 int result=n1+n2; //3.把结果显示到结果result【把数字转化为字符串：stringWithFormat】 self.result.text=[NSString stringWithFormat:@&quot;%d&quot;,result]; //小技巧：把键盘叫回去的两种方法 //1.谁叫出的键盘，谁就是第一响应者，让第一响应者辞职，就可以把键盘叫回去 //[self.text1 resignFirstResponder]; //[self.text2 resignFirstResponder]; //2.让控制器所管理的view停止编辑，也可以把键盘叫回去 [self.view endEditing:YES];&#125;@end 结果演示：","categories":[{"name":"iOS开发-项目","slug":"iOS开发-项目","permalink":"http://example.com/categories/iOS%E5%BC%80%E5%8F%91-%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"UI","slug":"UI","permalink":"http://example.com/tags/UI/"}]},{"title":"多线程概念","slug":"iOS开发-项目/多线程实战/多线程概念","date":"2020-11-29T16:00:00.000Z","updated":"2021-03-24T13:24:44.000Z","comments":true,"path":"2020/11/30/iOS开发-项目/多线程实战/多线程概念/","link":"","permalink":"http://example.com/2020/11/30/iOS%E5%BC%80%E5%8F%91-%E9%A1%B9%E7%9B%AE/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%9E%E6%88%98/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A6%82%E5%BF%B5/","excerpt":"","text":"循环的速度非常快操作内存的栈空间，速度非常快操作内存的堆空间，速度有点慢循环非常消耗cpu资源I/O操作，速度非常慢 同步：我们之前写程序的时候都是从上到下，从左到右，代码执行顺序；一个人执行多个任务，也是依次执行，一个人同一时间只能执行一个任务 异步：多个人可以同时执行多个任务 进程：指在系统中正在运行的一个应用程序，每个进程之间是独立的，每个进程均运行在其专用的且受保护的内存空间内 线程：一个进程有多个线程组成（一个进程至少要有一个线程），线程是进程的基本执行单元，一个进程的所有任务都在线程中执行 多线程：一个进程中可以开启多个线程，多个线程可以“同时”执行不同的任务，多线程可以解决程序阻塞的问题，多线程可以提高程序的执行效率 多线程执行原理：（单核CPU）同一时间，cpu只能处理一个线程，只有一个线程在执行；多线程同时执行是CPU快速的在多个线程之间的切换，CPU调度线程的时间足够快，就造成了多线程的“同时”执行；如果线程数非常多，CPU会在n个线程之间切换，消耗大量的CPU资源，每个线程被调度的次数会降低，线程的执行效率降低 多线程的优点：能适当提高程序的执行效率，能适当提高资源的利用率(CPU、内存)，线程上的任务执行完成后，线程会自动销毁 多线程的缺点：开启线程需要占用一定的内存空间(默认情况下，每一个线程都占512KB)，如果开启大量的线程，会占用大量的内存空间，降低程序的性能；线程越多，CPU在调用线程上的开销就越大；程序设计更加复杂，比如线程间的通信、多线程的数据共享 主线程：一个程序运行后，默认会开启一个线程，称为主线程或UI线程，主线程一般用来刷新UI界面，处理UI事件（比如点击、滚动、拖拽），主线程使用注意：别将耗时的操作放到主线程中，耗时操作会卡住主线程，严重影响UI的流畅度，给用户一种卡的坏体验 iOS中多线程的技术方案： pthread：一套通用的多线程API，适用于Unix/Linux/Windows等系统，跨平台/可移植，使用难度大，用C语言，由程序员管理线程生命周期，几乎不用 NSThread：使用更加面向对象，简单易用，可直接操作线程对象，用OC语言，由程序员管理线程生命周期，偶尔使用 GCD：旨在替代NSThread等线程技术，充分利用设备的多核，用C语言，自动管理，经常使用 NSOperation：基于GCD（底层是GCD），比GCD多了一些更简单实用的功能，使用更加面向对象，用OC语言，自动管理，经常使用","categories":[{"name":"iOS开发-项目","slug":"iOS开发-项目","permalink":"http://example.com/categories/iOS%E5%BC%80%E5%8F%91-%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"多线程实战","slug":"多线程实战","permalink":"http://example.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%9E%E6%88%98/"}]},{"title":"项目2.三种方法进行按钮控制","slug":"iOS开发-项目/UI/项目2.三种方法进行按钮控制","date":"2020-11-28T16:00:00.000Z","updated":"2021-03-24T13:26:17.000Z","comments":true,"path":"2020/11/29/iOS开发-项目/UI/项目2.三种方法进行按钮控制/","link":"","permalink":"http://example.com/2020/11/29/iOS%E5%BC%80%E5%8F%91-%E9%A1%B9%E7%9B%AE/UI/%E9%A1%B9%E7%9B%AE2.%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95%E8%BF%9B%E8%A1%8C%E6%8C%89%E9%92%AE%E6%8E%A7%E5%88%B6/","excerpt":"","text":"UIButton：按钮 一般情况下，点击某个控件后，会做出相应反应的都是按钮；按钮既能显示文字，又能显示图片，还能随时调整内部图片和文字的位置 按钮有三种状态：1）Default状态2）Highlighted；高亮状态鼠标点击（手指还未松开）会显示另一种状态3）Disabled失效状态，不可用状态，代表按钮不可以被点击 Type选择System类型后高亮状态会显示为灰色，提醒用户鼠标已经点击；如果不想被提示，可以选择Custom 按钮控制的三种方法：1）frame：CGRect，方法里面既可以改变位置，也可以改变大小（表示的是控件左上角的坐标）2）center：CGPoint，只能改变位置（表示的是控件中心点的坐标），bounds：CGRect，只能改变大小（bounds虽然也是CGRect类型，但是x,y的值始终是0）3）transform（是一个结构体）：可以改变位置，大小，旋转，清空所有改变的属性 frame放大与center+bounds放大的一个小区别：前者是左上角不变放大，后者是中心点不变放大 frame(center+bounds，transform)的封装：创建方法的时候注意选UIButton，sender，注意设置不同的tag 效果展示： 项目代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288//// ViewController.m// 三种方法进行按钮控制// 只有第一种frame封装方法中加入了动画效果，其余两种方法中未加入// Created by 廖家龙 on 2020/4/19.// Copyright © 2020 liuyuecao. All rights reserved.//#import &quot;ViewController.h&quot;@interface ViewController ()//第一种方法基础版：frame的基本使用//- (IBAction)up;//向上的方法//- (IBAction)down;//向下的方法//- (IBAction)left;//向左的方法//- (IBAction)right;//向右的方法//@property (weak, nonatomic) IBOutlet UIButton *image;//图片属性//- (IBAction)big;//放大的方法//- (IBAction)small;//缩小的方法//第一种方法进阶版：frame的封装@property (weak, nonatomic) IBOutlet UIButton *image;- (IBAction)move:(UIButton *)sender;//移动方法- (IBAction)smallandBig:(UIButton *)sender;//放大缩小//第二种方法：center+bounds的封装使用- (IBAction)centerMove:(UIButton *)sender;//移动方法- (IBAction)boundsSandB:(UIButton *)sender;//放大缩小//第三种方法：transform的封装使用- (IBAction)transformMove:(UIButton *)sender;//移动方法- (IBAction)transformSandB:(UIButton *)sender;//放大缩小- (IBAction)transformXuanZhuan;//顺时针旋转方法- (IBAction)transformXuanZhuan2;//逆时针旋转方法- (IBAction)transformQingKong;//清空方法@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view.&#125;//第一种方法基础版：frame的基本使用//- (IBAction)up &#123;// 思路：获取图片按钮的y坐标的值，让y的值递减，然后再把新的值赋值给图片按钮的y// 1.获取图片按钮原始的frame值（这个值包含了按钮的位置和大小）// CGRect originFrame=self.image.frame;// 2.设置y值-10// originFrame.origin.y -= 10;// 3.把新的frame值赋值给图片按钮// self.image.frame=originFrame;//注意：self.image.frame.origin.y -= 10；是不行的，当一个OC对象里面有一个属性，这个属性是一个结构体，你希望修改这个结构体里面的值的时候，不能直接修改//&#125;//- (IBAction)down &#123;// CGRect originFrame=self.image.frame;// originFrame.origin.y += 10;// self.image.frame=originFrame;//&#125;//- (IBAction)left &#123;// CGRect originFrame=self.image.frame;// originFrame.origin.x -= 10;// self.image.frame=originFrame;//&#125;//- (IBAction)right &#123;// CGRect originFrame=self.image.frame;// originFrame.origin.x += 10;// self.image.frame=originFrame;//&#125;//- (IBAction)small &#123;// CGRect originFrame=self.image.frame;// 第一种写法：// originFrame.size.height -= 10;// originFrame.size.width -= 10;// 第二种写法：// originFrame.size=CGSizeMake(originFrame.size.width - 10,originFrame.size.height - 10);// self.image.frame=originFrame;//&#125;//- (IBAction)big &#123;// CGRect originFrame=self.image.frame;// originFrame.size.height += 10;// originFrame.size.width += 10;// self.image.frame=originFrame;//&#125;//第一种方法进阶版：frame的封装//点击上下左右执行move方法- (IBAction)move:(UIButton *)sender &#123; //为每个按钮设置不同的tag值，然后这个方法中就可以根据sender.tag来判断用户当前点击的是哪个按钮 //1.获取图片按钮原始的frame值（这个值包含了按钮的位置和大小） CGRect originFrame=self.image.frame; //2.修改frame switch (sender.tag) &#123; case 10://上 originFrame.origin.y -=10; break; case 20://下 originFrame.origin.y +=10; break; case 30://左 originFrame.origin.x -=10; break; case 40://右 originFrame.origin.x +=10; break; &#125; //如果感觉位置移动和放大缩小的时候很生硬，可以增加一个动画效果//第一种动画效果方式：头尾式 //开启一个动画 [UIView beginAnimations:nil context:nil]; //设置动画执行时间 [UIView setAnimationDuration:0.5]; //3.把新的frame值赋值给图片按钮 self.image.frame=originFrame; //提交动画 [UIView commitAnimations];&#125;//点击加减执行该方法- (IBAction)smallandBig:(UIButton *)sender &#123; //1.获取图片按钮原始的frame值（这个值包含了按钮的位置和大小） CGRect originFrame=self.image.frame; //2.修改frame switch (sender.tag) &#123; case 200://放大 originFrame.size.height +=10; originFrame.size.width +=10; break; case 300://缩小 originFrame.size.height -=10; originFrame.size.width -=10; break; &#125; //第二种动画效果方式：Block式 //3.把新的frame值赋值给图片按钮 [UIView animateWithDuration:0.5 animations:^&#123; self.image.frame=originFrame; &#125;];&#125;//第二种方法：center+bounds的封装使用//先执行center方法修改图片的位置- (IBAction)centerMove:(UIButton *)sender &#123; //获取图片按钮原始的center值（这个值只包含了按钮的位置） CGPoint centerPoint=self.image.center; //修改center switch (sender.tag) &#123; case 50://上 centerPoint.y -=10; break; case 60://下 centerPoint.y +=10; break; case 70://左 centerPoint.x -=10; break; case 80://右 centerPoint.x +=10; break; &#125; //把新的center值赋值给图片按钮 self.image.center=centerPoint;&#125;//再执行bounds方法修改图片的大小- (IBAction)boundsSandB:(UIButton *)sender &#123; //获取图片按钮原始的bounds值（这个值只包含了按钮的大小） CGRect originBounds=self.image.bounds; //修改bounds的值 if(sender.tag==400)&#123; originBounds.size.height+=10; originBounds.size.width+=10; &#125; if(sender.tag==500)&#123; originBounds.size.height-=10; originBounds.size.width-=10; &#125; //把新的bounds值赋值给图片按钮 self.image.bounds=originBounds;&#125;//第三种方法：transform的封装使用//上下左右平移- (IBAction)transformMove:(UIButton *)sender &#123; //下面这句话的意思是告诉控件，平移到距离原始位置-10的距离 //self.image.transform=CGAffineTransformMakeTranslation(0, -10);//向上平移，只能平移一次 //基于一个现有的值进行平移 switch (sender.tag) &#123; case 90: //向上平移 self.image.transform=CGAffineTransformTranslate(self.image.transform, 0, -10); break; case 100: //向下平移 self.image.transform=CGAffineTransformTranslate(self.image.transform, 0, +10); break; case 110: //向左平移 self.image.transform=CGAffineTransformTranslate(self.image.transform, -10, 0); break; case 120: //向右平移 self.image.transform=CGAffineTransformTranslate(self.image.transform, +10, 0); break; &#125;&#125;//放大缩小- (IBAction)transformSandB:(UIButton *)sender &#123; //只能缩小一次 //self.image.transform=CGAffineTransformMakeScale(0.5, 0.5); if(sender.tag==600)&#123; //放大 self.image.transform=CGAffineTransformScale(self.image.transform, 1.5, 1.5); &#125; if(sender.tag==700)&#123; //缩小 self.image.transform=CGAffineTransformScale(self.image.transform, 0.5, 0.5); &#125;&#125;//逆时针旋转- (IBAction)transformXuanZhuan2 &#123; //逆时针旋转一次 //self.image.transform=CGAffineTransformMakeRotation(-M_PI_4); //逆时针旋转45度（这是旋转的弧度不是角度），可以一直旋转 self.image.transform=CGAffineTransformRotate(self.image.transform, -M_PI_4); &#125;//顺时针旋转- (IBAction)transformXuanZhuan &#123; //顺时针旋转45度，可以一直旋转 self.image.transform=CGAffineTransformRotate(self.image.transform, M_PI_4);&#125;//一键清空- (IBAction)transformQingKong &#123; self.image.transform=CGAffineTransformIdentity;&#125;@end","categories":[{"name":"iOS开发-项目","slug":"iOS开发-项目","permalink":"http://example.com/categories/iOS%E5%BC%80%E5%8F%91-%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"UI","slug":"UI","permalink":"http://example.com/tags/UI/"}]},{"title":"pthread和__bridge","slug":"iOS开发-项目/多线程实战/pthread和__bridge","date":"2020-11-28T16:00:00.000Z","updated":"2021-03-24T13:24:55.000Z","comments":true,"path":"2020/11/29/iOS开发-项目/多线程实战/pthread和__bridge/","link":"","permalink":"http://example.com/2020/11/29/iOS%E5%BC%80%E5%8F%91-%E9%A1%B9%E7%9B%AE/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%9E%E6%88%98/pthread%E5%92%8C__bridge/","excerpt":"","text":"无参数： 1234567891011121314151617181920212223242526272829303132333435363738#import &quot;ViewController.h&quot;#import&lt;pthread/pthread.h&gt;@interface ViewController ()@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view. //第一个参数：线程编号的地址 //第二个参数：线程的属性 //第三个参数：线程要执行的函数 //第四个参数：要执行的函数的参数 //这个函数的返回值是int，0是成功，非0是失败 pthread_t pthread; //线程编号 int result=pthread_create(&amp;pthread, NULL, demo, NULL); NSLog(@&quot;%@&quot;,[NSThread currentThread]); if(result == 0)&#123; NSLog(@&quot;成功&quot;); &#125;else&#123; NSLog(@&quot;失败&quot;); &#125;&#125;void * demo(void *param)&#123; NSLog(@&quot;hello %@&quot;,[NSThread currentThread]); return NULL;&#125;@end 有参数： 12345678910111213141516171819202122232425262728293031323334#import &quot;ViewController.h&quot;#import&lt;pthread/pthread.h&gt;@interface ViewController ()@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view. //这个函数的返回值是int，0是成功，非0是失败 pthread_t pthread; //线程编号 NSString *name=@&quot;ls&quot;; int result=pthread_create(&amp;pthread, NULL, demo, (__bridge void *)(name));//__bridge桥接，把OC中的对象传递给C语言需要桥接，反过来也一样 NSLog(@&quot;%@&quot;,[NSThread currentThread]); if(result == 0)&#123; NSLog(@&quot;成功&quot;); &#125;else&#123; NSLog(@&quot;失败&quot;); &#125;&#125;void * demo(void *param)&#123; NSLog(@&quot;hello %@&quot;,[NSThread currentThread]); return NULL;&#125;@end","categories":[{"name":"iOS开发-项目","slug":"iOS开发-项目","permalink":"http://example.com/categories/iOS%E5%BC%80%E5%8F%91-%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"多线程实战","slug":"多线程实战","permalink":"http://example.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%9E%E6%88%98/"}]},{"title":"项目3.通过代码创建控件","slug":"iOS开发-项目/UI/项目3.通过代码创建控件","date":"2020-11-27T16:00:00.000Z","updated":"2021-03-24T13:26:30.000Z","comments":true,"path":"2020/11/28/iOS开发-项目/UI/项目3.通过代码创建控件/","link":"","permalink":"http://example.com/2020/11/28/iOS%E5%BC%80%E5%8F%91-%E9%A1%B9%E7%9B%AE/UI/%E9%A1%B9%E7%9B%AE3.%E9%80%9A%E8%BF%87%E4%BB%A3%E7%A0%81%E5%88%9B%E5%BB%BA%E6%8E%A7%E4%BB%B6/","excerpt":"","text":"Xcode模拟器路径：/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs 如果发现通过代码无法修改控件的位置或者尺寸时，应该去掉storyboard里面的autolayout功能，顾名思义，autolayout是用来自动布局的，用来束缚控件的位置和尺寸，去掉这个功能，控件的位置和尺寸就不再有一些固定的束缚 结果演示： 项目代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273//// ViewController.m// 手写代码创建控件//// Created by 廖家龙 on 2020/4/19.// Copyright © 2020 liuyuecao. All rights reserved.//#import &quot;ViewController.h&quot;@interface ViewController ()@end@implementation ViewController//当要显示一个界面的时候，首先创建这个界面对应的控制器，控制器创建好以后，接着创建控制器所管理的那个view，当这个view加载完毕以后就开始执行下面的方法了//所以只要viewDidLoad方法被执行了，就表示控制器所管理的view创建好了- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view. //动态创建自己的按钮 //1.创建按钮（UIButton） //1) UIButton *button=[[UIButton alloc]init]; //2) 创建系统默认的按钮，也可以创建Custom的按钮 UIButton *button=[UIButton buttonWithType:UIButtonTypeSystem]; //2.设置按钮上显示的文字 //默认状态下显示的文字 [button setTitle:@&quot;第一张图片&quot; forState:UIControlStateNormal]; //高亮状态下显示的文字 [button setTitle:@&quot;第二张图片&quot; forState:UIControlStateHighlighted]; //3.设置不同状态下的文字颜色 //默认状态下设置为红色 [button setTitleColor:[UIColor redColor] forState:UIControlStateNormal]; //高亮状态下设置为蓝色 [button setTitleColor:[UIColor blueColor] forState:UIControlStateHighlighted]; //4.设置按钮的背景图片 //加载图片：一个UIImage对象代表一张图片，一般通过imageNamed:方法就可以通过文件名加载项目中的图片 UIImage *imgNormal=[UIImage imageNamed:@&quot;图片1.png&quot;]; UIImage *imgHighlighted=[UIImage imageNamed:@&quot;图片2.png&quot;]; //设置默认状态下的背景图片 [button setBackgroundImage:imgNormal forState:UIControlStateNormal]; //设置高亮状态下的背景图片 [button setBackgroundImage:imgHighlighted forState:UIControlStateHighlighted]; //5.设置按钮的frame（x=50，y=100，这个按钮的宽度为110，高度为120） button.frame=CGRectMake(50, 100, 110, 120); //通过代码为按钮注册一个单击事件 [button addTarget:self action:@selector(buttonClick) forControlEvents:UIControlEventTouchUpInside]; //6.把动态创建的按钮加到控制器所管理的那个view中 [self.view addSubview:button]; &#125;- (void)buttonClick&#123; NSLog(@&quot;按钮被点击了。&quot;);&#125;@end","categories":[{"name":"iOS开发-项目","slug":"iOS开发-项目","permalink":"http://example.com/categories/iOS%E5%BC%80%E5%8F%91-%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"UI","slug":"UI","permalink":"http://example.com/tags/UI/"}]},{"title":"NSThread","slug":"iOS开发-项目/多线程实战/NSThread","date":"2020-11-27T16:00:00.000Z","updated":"2021-03-24T13:25:06.000Z","comments":true,"path":"2020/11/28/iOS开发-项目/多线程实战/NSThread/","link":"","permalink":"http://example.com/2020/11/28/iOS%E5%BC%80%E5%8F%91-%E9%A1%B9%E7%9B%AE/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%9E%E6%88%98/NSThread/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637#import &quot;ViewController.h&quot;@interface ViewController ()@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view. //方式1 //NSThread *thread=[[NSThread alloc] initWithTarget:self selector:@selector(demo) object:nil]; //[thread start]; //方式2 //[NSThread detachNewThreadSelector:@selector(demo) toTarget:self withObject:nil]; //方式3 //[self performSelectorInBackground:@selector(demo) withObject:nil]; //带参数 NSThread *thread=[[NSThread alloc] initWithTarget:self selector:@selector(demo:) object:@&quot;小明&quot;]; [thread start];&#125;- (void)demo:(NSString *)name&#123; NSLog(@&quot;hello %@&quot;,name);&#125;//- (void)demo&#123;// NSLog(@&quot;hello %@&quot;,[NSThread currentThread]);//&#125;@end","categories":[{"name":"iOS开发-项目","slug":"iOS开发-项目","permalink":"http://example.com/categories/iOS%E5%BC%80%E5%8F%91-%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"多线程实战","slug":"多线程实战","permalink":"http://example.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%9E%E6%88%98/"}]},{"title":"项目4.QQ登陆界面","slug":"iOS开发-项目/UI/项目4.QQ登陆界面","date":"2020-11-26T16:00:00.000Z","updated":"2021-03-24T13:26:42.000Z","comments":true,"path":"2020/11/27/iOS开发-项目/UI/项目4.QQ登陆界面/","link":"","permalink":"http://example.com/2020/11/27/iOS%E5%BC%80%E5%8F%91-%E9%A1%B9%E7%9B%AE/UI/%E9%A1%B9%E7%9B%AE4.QQ%E7%99%BB%E9%99%86%E7%95%8C%E9%9D%A2/","excerpt":"","text":"项目要求： 实现细节： Placeholder属性：文本框中会有文字提示，用户输入文字时会自动消失 文本框只能输入数字：Keyboard Type—Number Pad 密码文本框的文字必须是暗文显示（掩码显示）：勾上Secure Text Entry 文本框一直显示清除按钮：Clear Button—Is always visible 结果演示： 项目代码： 1234567891011121314151617181920212223242526272829303132333435363738394041//// ViewController.m// QQ登陆界面//// Created by 廖家龙 on 2020/4/20.// Copyright © 2020 liuyuecao. All rights reserved.//#import &quot;ViewController.h&quot;@interface ViewController ()- (IBAction)login;//登陆方法@property (weak, nonatomic) IBOutlet UITextField *textQQ;//QQ属性@property (weak, nonatomic) IBOutlet UITextField *textpassword;//密码属性@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view.&#125;//登陆方法的实现- (IBAction)login &#123; //拿到QQ和密码 NSString *qq=self.textQQ.text; NSString *pwd=self.textpassword.text; //将QQ和密码输出 NSLog(@&quot;QQ:%@,密码:%@&quot;,qq,pwd); //收回键盘 [self.view endEditing:YES];&#125;@end","categories":[{"name":"iOS开发-项目","slug":"iOS开发-项目","permalink":"http://example.com/categories/iOS%E5%BC%80%E5%8F%91-%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"UI","slug":"UI","permalink":"http://example.com/tags/UI/"}]},{"title":"控件的属性和方法","slug":"iOS开发-项目/UI/控件的属性和方法","date":"2020-11-25T16:00:00.000Z","updated":"2021-03-24T13:26:52.000Z","comments":true,"path":"2020/11/26/iOS开发-项目/UI/控件的属性和方法/","link":"","permalink":"http://example.com/2020/11/26/iOS%E5%BC%80%E5%8F%91-%E9%A1%B9%E7%9B%AE/UI/%E6%8E%A7%E4%BB%B6%E7%9A%84%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95/","excerpt":"","text":"控件的属性： frame center bounds transform subviews：获取当前控制器所管理的view下的所有子控件 123for(UIView *view in self.view.subviews)&#123; view.backgroundColor=[UIColor redColor];&#125; superview：获取自己的父控件对象self.text1.superview.backgroundColor=[UIColor yellowColor]; viewWithTag：控件的ID标识，父控件可以通过tag来找到对应的控件 12UITextField *txt=(UITextField *)[self.view viewWithTag:100];txt.text=@&quot;我的tag值是100&quot;; 控件的方法： addSubview添加一个子控件view 12//把动态创建的按钮加到控制器所管理的那个view中[self.view addSubview:button]; removeFromSuperview：从父控件中移除所有的子控件 123while(self.view.subviews.firstObject)&#123; [self.view.subviews.firstObject removeFromSuperview];&#125;","categories":[{"name":"iOS开发-项目","slug":"iOS开发-项目","permalink":"http://example.com/categories/iOS%E5%BC%80%E5%8F%91-%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"UI","slug":"UI","permalink":"http://example.com/tags/UI/"}]},{"title":"项目5.图片浏览器(plist文件)","slug":"iOS开发-项目/UI/项目5.图片浏览器(plist文件)","date":"2020-11-24T16:00:00.000Z","updated":"2021-03-24T13:27:03.000Z","comments":true,"path":"2020/11/25/iOS开发-项目/UI/项目5.图片浏览器(plist文件)/","link":"","permalink":"http://example.com/2020/11/25/iOS%E5%BC%80%E5%8F%91-%E9%A1%B9%E7%9B%AE/UI/%E9%A1%B9%E7%9B%AE5.%E5%9B%BE%E7%89%87%E6%B5%8F%E8%A7%88%E5%99%A8(plist%E6%96%87%E4%BB%B6)/","excerpt":"","text":"创建plist文件：New File-iOS-Resource-Property List plist文件：注意是从Item 0开始的，数组下面包含字典，字典下面要注意类型是String还是Number 项目演示： 项目代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105//// ViewController.m// 图片浏览器//// Created by 廖家龙 on 2020/4/21.// Copyright © 2020 liuyuecao. All rights reserved.//#import &quot;ViewController.h&quot;@interface ViewController ()//声明picture属性为了重写它的getter方法，懒加载数据@property(nonatomic,strong)NSArray *picture;//自己写一个索引，来控制当前显示的是第几张图片，这个属性一开始没有赋值就是0@property(nonatomic,assign) int index;@property (weak, nonatomic) IBOutlet UILabel *suoyin;@property (weak, nonatomic) IBOutlet UIImageView *tupian;@property (weak, nonatomic) IBOutlet UILabel *biaoti;- (IBAction)last;//点击上一张箭头- (IBAction)next;//点击下一张箭头//设置&quot;上一张&quot;“下一张”按钮是否可以点击@property (weak, nonatomic) IBOutlet UIButton *lastButton;@property (weak, nonatomic) IBOutlet UIButton *nextButton;@end@implementation ViewController//重写picture属性的getter方法（懒加载数据）- (NSArray *)picture&#123; if(_picture==nil)&#123; //写代码加载picture.plist文件中的数据到_picture //1.获取picture.plist文件的路径赋值给path变量，[NSBundle mainBundle]表示获取这个app安装到手机时的根目录，然后在app安装的根目录下搜索picture.plist文件的路径 NSString *path=[[NSBundle mainBundle] pathForResource:@&quot;picture.plist&quot; ofType:nil]; //2.读取文件 NSArray *array=[NSArray arrayWithContentsOfFile:path]; _picture=array; &#125; return _picture;&#125;//控制器的view加载完毕以后执行的方法- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view. self.index=-1; //这行代码的作用：控制器view加载完毕之后，执行‘下一张图片’的方法，index=0，再执行setData方法来设置控件的数据，将picture字典中的数据加载进来 [self next]; //手动写plist代码，如果要永久的保存数据，就要创建plist文件// NSDictionary *dict1=@&#123;@&quot;name&quot; : @&quot;张三&quot;, @&quot;age&quot; : @18, @&quot;height&quot; : @180&#125;;// NSDictionary *dict2=@&#123;@&quot;name&quot; : @&quot;李四&quot;, @&quot;age&quot; : @19, @&quot;height&quot; : @190&#125;;// NSDictionary *dict3=@&#123;@&quot;name&quot; : @&quot;王五&quot;, @&quot;age&quot; : @17, @&quot;height&quot; : @178&#125;;// NSArray *students=@[dict1,dict2,dict3];// NSLog(@&quot;%@&quot;,students);//打印出数据&#125;//上一张图片- (IBAction)last &#123; self.index--;//让索引-- [self setData];//设置控件数据&#125;//下一张图片- (IBAction)next &#123; self.index++;//让索引++ [self setData];//设置控件数据&#125;- (void)setData&#123; //1.从数组中获取当前这张图片的数据 NSDictionary *dict=self.picture[self.index]; //2.把获取到的数据设置给界面上的控件 //设置索引 self.suoyin.text=[NSString stringWithFormat:@&quot;%d/%ld&quot;,self.index+1,self.picture.count]; //通过image属性来设置图片框里面的图片 self.tupian.image=[UIImage imageNamed:dict[@&quot;图片名称&quot;]]; //设置这张图片的标题 self.biaoti.text=dict[@&quot;图片标题&quot;]; //3.设置&quot;上一张&quot;“下一张”按钮是否可以点击 self.lastButton.enabled=(self.index != 0); self.nextButton.enabled=(self.index != (self.picture.count-1));&#125;@end","categories":[{"name":"iOS开发-项目","slug":"iOS开发-项目","permalink":"http://example.com/categories/iOS%E5%BC%80%E5%8F%91-%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"UI","slug":"UI","permalink":"http://example.com/tags/UI/"}]},{"title":"项目6.会说话的汤姆猫","slug":"iOS开发-项目/UI/项目6.会说话的汤姆猫","date":"2020-11-23T16:00:00.000Z","updated":"2021-03-24T13:27:13.000Z","comments":true,"path":"2020/11/24/iOS开发-项目/UI/项目6.会说话的汤姆猫/","link":"","permalink":"http://example.com/2020/11/24/iOS%E5%BC%80%E5%8F%91-%E9%A1%B9%E7%9B%AE/UI/%E9%A1%B9%E7%9B%AE6.%E4%BC%9A%E8%AF%B4%E8%AF%9D%E7%9A%84%E6%B1%A4%E5%A7%86%E7%8C%AB/","excerpt":"","text":"UIImageView帧动画相关属性和方法： 1）需要播放的序列帧图片数组（里面都是UIImage对象，会按顺序显示里面的图片）@property (nullable, nonatomic, copy) NSArray&lt;UIImage *&gt; *animationImages; 2）帧动画的持续时间@property (nonatomic) NSTimeInterval animationDuration; 3）帧动画的执行次数（默认是无限循环）@property (nonatomic) NSInteger animationRepeatCount; 4）开始执行帧动画- (void)startAnimating; 5）停止执行帧动画- (void)stopAnimating; 6）是否正在执行帧动画- (BOOL)isAnimating; 第一种加载图片的方式，使用清空图片集合的方法后，内存依旧没有被释放，原因？ 使用第一种方式加载图片，加载起来的图片即便没有强类型指针引用也不会销毁，会被缓存；使用第二种加载图片的方式，只要没有强类型指针引用就会被销毁了： 项目演示： 项目代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184//// ViewController.m// 会说话的汤姆猫//// Created by 廖家龙 on 2020/4/21.// Copyright © 2020 liuyuecao. All rights reserved.//#import &quot;ViewController.h&quot;@interface ViewController ()@property (weak, nonatomic) IBOutlet UIImageView *imageViewCat;- (IBAction)angrytail;//1.踩尾巴- (IBAction)blink;//2.眨眼睛- (IBAction)cymbal;//3.击打乐器- (IBAction)drinkmilk;//4.喝牛奶- (IBAction)eat;//5.吃- (IBAction)fart;//6.放屁- (IBAction)footleft;//7.左脚- (IBAction)footright;//8.右脚- (IBAction)happy;//9.很高兴- (IBAction)happysimple;//10.一点高兴- (IBAction)knock;//11.敲头- (IBAction)listen;//12.听- (IBAction)pie;//13.扔馅饼- (IBAction)scratch;//14.刮屏幕- (IBAction)sneeze;//15.打喷嚏- (IBAction)stomach;//16.胃疼- (IBAction)talk;//17.说话- (IBAction)yawn;//18.打哈欠@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view.&#125;//1.踩尾巴的动画- (IBAction)angrytail &#123; [self startAnimating:26 picName:@&quot;cat_angry&quot;];&#125;//2.眨眼睛的动画- (IBAction)blink &#123; [self startAnimating:3 picName:@&quot;cat_blink&quot;];&#125;//3.击打乐器的动画- (IBAction)cymbal &#123; [self startAnimating:13 picName:@&quot;cat_cymbal&quot;];&#125;//4.喝牛奶的动画- (IBAction)drinkmilk &#123; [self startAnimating:81 picName:@&quot;cat_drink&quot;];&#125;//5.吃的动画- (IBAction)eat &#123; [self startAnimating:40 picName:@&quot;cat_eat&quot;];&#125;//6.放屁的动画- (IBAction)fart &#123; [self startAnimating:28 picName:@&quot;cat_fart&quot;];&#125;//7.左脚的动画- (IBAction)footleft &#123; [self startAnimating:30 picName:@&quot;cat_foot_left&quot;];&#125;//8.右脚的动画- (IBAction)footright &#123; [self startAnimating:30 picName:@&quot;cat_foot_right&quot;];&#125;//9.很高兴的动画- (IBAction)happy &#123; [self startAnimating:29 picName:@&quot;cat_happy&quot;];&#125;//10.一点高兴的动画- (IBAction)happysimple &#123; [self startAnimating:25 picName:@&quot;cat_happy_simple&quot;];&#125;//11.敲头的动画- (IBAction)knock &#123; [self startAnimating:81 picName:@&quot;cat_knockout&quot;];&#125;//12.听的动画- (IBAction)listen &#123; [self startAnimating:12 picName:@&quot;cat_listen&quot;];&#125;//13.扔馅饼的动画- (IBAction)pie &#123; [self startAnimating:23 picName:@&quot;pie&quot;];&#125;//14.刮屏幕的动画- (IBAction)scratch &#123; [self startAnimating:56 picName:@&quot;cat_scratch&quot;];&#125;//15.打喷嚏的动画- (IBAction)sneeze &#123; [self startAnimating:14 picName:@&quot;cat_sneeze&quot;];&#125;//16.胃疼的动画- (IBAction)stomach &#123; [self startAnimating:34 picName:@&quot;cat_stomach&quot;];&#125;//17.说话的动画- (IBAction)talk &#123; [self startAnimating:16 picName:@&quot;cat_talk&quot;];&#125;//18.打哈欠的动画- (IBAction)yawn &#123; [self startAnimating:31 picName:@&quot;cat_zeh&quot;];&#125;//执行动画的方法- (void)startAnimating:(int)count picName:(NSString *)picName&#123; //如果当前图片框正在执行动画，那么直接return，什么都不做(不开启一个新动画) if(self.imageViewCat.isAnimating)&#123; return; &#125; //1.动态加载图片到一个NSArray中 NSMutableArray *arrayM=[NSMutableArray array]; for(int i=0;i&lt;count;i++)&#123; //拼接图片名称 NSString *imgName=[NSString stringWithFormat:@&quot;%@%0004d.jpg&quot;,picName,i]; //第一种加载图片的方式： //根据imageNamed图片名称加载图片，加载好的图片会一直保存写在内存中，不会释放，这样下次如果再使用同样的图片的时候就不需要再重新加载了，因为内存里面已经有了；缺点就是如果加载了大量的图片，那么这些图片会一直保留在内存中，导致应用程序占用内存过大(这就叫缓存) // UIImage *imgCat=[UIImage imageNamed:imgName]; //第二种加载图片的方式 //1.获取图片的完整路径 NSString *path=[[NSBundle mainBundle] pathForResource:imgName ofType:nil]; //2.这里的参数不能再传递图片名称了，这里需要传递一个图片的完整路径 UIImage *imgCat=[UIImage imageWithContentsOfFile:path]; //把图片加载到数组中 [arrayM addObject:imgCat]; &#125; //2.设置UIImageView（图片框）的animationImages属性，这个属性中包含的就是所有那些要执行动画的图片 self.imageViewCat.animationImages=arrayM; //3.设置动画持续时间 self.imageViewCat.animationDuration=self.imageViewCat.animationImages.count*0.1; //4.设置动画重复的次数 self.imageViewCat.animationRepeatCount=1; //5.开启动画 [self.imageViewCat startAnimating]; //清空图片集合（用第二种加载图片的方式执行完动画后内存被释放）: //这样写的问题是，当动画启动以后，动画还没开始执行，就已经让图片集合清空了 //self.imageViewCat.animationImages=nil; //方法：设置图片框在调用setAnimationImages:nil方法的时候延迟执行 [self.imageViewCat performSelector:@selector(setAnimationImages:) withObject:nil afterDelay:self.imageViewCat.animationImages.count*0.1]; &#125;@end","categories":[{"name":"iOS开发-项目","slug":"iOS开发-项目","permalink":"http://example.com/categories/iOS%E5%BC%80%E5%8F%91-%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"UI","slug":"UI","permalink":"http://example.com/tags/UI/"}]},{"title":"UIButton和UIImageView的区别","slug":"iOS开发-项目/UI/UIButton和UIImageView的区别","date":"2020-11-22T16:00:00.000Z","updated":"2021-03-24T13:27:23.000Z","comments":true,"path":"2020/11/23/iOS开发-项目/UI/UIButton和UIImageView的区别/","link":"","permalink":"http://example.com/2020/11/23/iOS%E5%BC%80%E5%8F%91-%E9%A1%B9%E7%9B%AE/UI/UIButton%E5%92%8CUIImageView%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"相同点：都能显示图片 不同点： UIButton默认情况下就能监听点击事件，而UIImageView默认情况下不能【UIButton先继承自UIControl，UIControl继承自UIView；UIImageView直接继承自UIView；所以UIButton默认情况下能监听点击事件】 UIButton可以在不同状态下显示不同的图片 UIButton既能显示文字，又能显示图片（能显示两张图片，backgroundImage和Image） 如何选择：UIImageView：仅仅需要显示图片，点击图片后不需要做任何事情UIButton：需要显示图片，点击图片后需要做一些特定的操作 文档注释：","categories":[{"name":"iOS开发-项目","slug":"iOS开发-项目","permalink":"http://example.com/categories/iOS%E5%BC%80%E5%8F%91-%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"UI","slug":"UI","permalink":"http://example.com/tags/UI/"}]},{"title":"应用管理(字典转模型、xib、MVC)：","slug":"iOS开发-项目/UI/应用管理(字典转模型、xib、MVC)：","date":"2020-11-21T16:00:00.000Z","updated":"2021-03-24T13:27:32.000Z","comments":true,"path":"2020/11/22/iOS开发-项目/UI/应用管理(字典转模型、xib、MVC)：/","link":"","permalink":"http://example.com/2020/11/22/iOS%E5%BC%80%E5%8F%91-%E9%A1%B9%E7%9B%AE/UI/%E5%BA%94%E7%94%A8%E7%AE%A1%E7%90%86(%E5%AD%97%E5%85%B8%E8%BD%AC%E6%A8%A1%E5%9E%8B%E3%80%81xib%E3%80%81MVC)%EF%BC%9A/","excerpt":"","text":"字典转模型（把字典中的数据使用模型来保存，新建一个类，根据字典中键值对的个数来编写这个类中的属性，用这个类的对象的属性来保存字典中每个键对应的值）：1）字典缺陷：写代码的时候字典的键没有智能提示，但是模型的属性可以有智能提示；“键”是字符串，如果写错了，编译器在编译的时候不报错，运行时可能出错，出错了很难找错；使用“模型”可以更方便的使用面向对象的三大特征进行扩展2）“模型”就是自定义的类，通过为“类”增加各种属性来保存数据 id与instancetype：1）使用id作为方法返回值，在接收方法的返回值的时候可以使用任何类型来接收，编译都不报错，但是运行可能出错2）instancetype在类型表示上与id意思一样，都表示任何对象类型3）instancetype只能用做返回值类型，不能向id一样声明变量，用作参数等4）使用instancetype，编译器会检测instancetype的真实类型，如果类型不匹配，编译时就报错了（instancetype出现在哪个类中就表示对应的类） 每次字典转模型的时候都要声明实现一个对象方法和类方法，这是规范： 12345678910111213141516171819//// App.h// 8.应用管理//// Created by 廖家龙 on 2020/4/24.// Copyright © 2020 liuyuecao. All rights reserved.//#import &lt;Foundation/Foundation.h&gt;**@interface** App : NSObject**@property**(**nonatomic**,**copy**)NSString *name;**@property**(**nonatomic**,**copy**)NSString *icon;- (**instancetype**)initWithDict:(NSDictionary *)dict;+ (**instancetype**)appWithDict:(NSDictionary *)dict;**@end** 123456789101112131415161718192021222324//// App.m// 8.应用管理//// Created by 廖家龙 on 2020/4/24.// Copyright © 2020 liuyuecao. All rights reserved.//#import “App.h”**@implementation** App- (**instancetype**)initWithDict:(NSDictionary *)dict&#123; **if**(**self**=[**super** init])&#123; **self**.name=dict[@“name”]; **self**.icon=dict[@“icon”]; &#125; **return** **self**;&#125;+ (**instancetype**)appWithDict:(NSDictionary *)dict&#123; **return** [[**self** alloc] initWithDict:dict];&#125;**@end** 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155//// ViewController.m// 8.应用管理//// Created by 廖家龙 on 2020/4/24.// Copyright © 2020 liuyuecao. All rights reserved.//#import “ViewController.h”#import “App.h”**@interface** ViewController ()//用来保存所有应用的数据**@property**(**nonatomic**,**strong**)NSArray *apps;**@end****@implementation** ViewController//重写apps属性的getter方法，进行懒加载数据- (NSArray *)apps&#123; **if**(_apps==**nil**)&#123; //加载数据 //1.获取app.plist文件在手机上的路径 NSString *path=[[NSBundle mainBundle] pathForResource:@“app.plist” ofType:**nil**]; //2.根据路径加载数据 NSArray *arrayDict=[NSArray arrayWithContentsOfFile:path]; //3.创建一个可变数组用来保存一个一个的模型对象 NSMutableArray *arrayModels=[NSMutableArray array];//一个空的可变数组 //4.循环字典数组，把每个字典对象转换成一个模型对象 **for**(NSDictionary *dict **in** arrayDict)&#123; //创建一个模型 //App *model=[[App alloc] initWithDict:dict];//调用对象方法 App *model=[App appWithDict:dict];//调用类方法 //把模型加到arrayModels中 [arrayModels addObject:model]; &#125; _apps=arrayModels; &#125; **return** _apps;&#125;- (**void**)viewDidLoad &#123; [**super** viewDidLoad]; // Do any additional setup after loading the view. //假设每行的应用的个数 **int** columns=3; //获取控制器所管理的view的宽度 CGFloat viewWidth=**self**.view.frame.size.width; //每个应用的高和宽 CGFloat appW=75; CGFloat appH=90; CGFloat marginTop=100;//第一行距离顶部的距离 CGFloat marginX=(viewWidth-columns*appW)/(columns+1); CGFloat marginY=marginX;//假设每行之间的间距与marginX相等 **for**(**int** I=0;i&lt;**self**.apps.count;i++)&#123; //获取当前这个应用的数据字典 App *appModel=**self**.apps[I]; //1.创建每个应用（UIView） UIView *appView=[[UIView alloc]init]; //2.设置appView的属性 //设置appView的背景色 //appView.backgroundColor=[UIColor blueColor]; //设置appView的frame属性 //计算每个单元格所在列的索引 **int** colIdx=I%columns; //计算每个单元格的行索引 **int** rowIdx=I/columns; CGFloat appx=marginX+colIdx*(appW+marginX); CGFloat appY=marginTop+rowIdx*(appH+marginY); appView.frame=CGRectMake(appx, appY, appW, appH); //3.将appView加到self.view（控制器所管理的那个view） [**self**.view addSubview:appView]; //4.向UIView中增加子控件 //4.1.增加一个图片框 UIImageView *imgViewIcon=[[UIImageView alloc]init]; //设置背景色 //imgViewIcon.backgroundColor=[UIColor yellowColor]; //设置frame CGFloat iconW=45; CGFloat iconH=45; CGFloat iconX=(appView.frame.size.width-iconW)*0.5; CGFloat iconY=0; imgViewIcon.frame=CGRectMake(iconX, iconY, iconW, iconH); //把图片框添加到appView中 [appView addSubview:imgViewIcon]; //设置图片框的数据 imgViewIcon.image=[UIImage imageNamed:appModel.icon]; //4.2.增加一个Label标签 //创建Label UILabel *lblName=[[UILabel alloc] init]; //设置背景色 //lblName.backgroundColor=[UIColor redColor]; //设置frame CGFloat nameW=appView.frame.size.width; CGFloat nameH=20; CGFloat nameY=iconH; CGFloat nameX=0; lblName.frame=CGRectMake(nameX, nameY, nameW, nameH); //添加到appView中 [appView addSubview:lblName]; //设置Label的数据（标题） lblName.text=appModel.name; //设置Label的文字的字体大小 lblName.font=[UIFont systemFontOfSize:12]; //设置文字居中对齐 lblName.textAlignment=NSTextAlignmentCenter; //4.3.增加一个按钮（UIButton） UIButton *btnDownload=[[UIButton alloc] init]; //设置背景色 //btnDownload.backgroundColor=[UIColor greenColor]; //设置frame CGFloat btnW=iconW; CGFloat btnH=20; CGFloat btnX=iconX; CGFloat btnY=nameY+nameH; btnDownload.frame=CGRectMake(btnX, btnY, btnW, btnH); //添加到appView中 [appView addSubview:btnDownload]; //设置按钮的数据 //设置按钮上的文字 [btnDownload setTitle:@“下载” forState:UIControlStateNormal]; [btnDownload setTitle:@“已安装” forState:UIControlStateDisabled]; //设置按钮的背景图 [btnDownload setBackgroundImage:[UIImage imageNamed:@“绿色1.jpg”] forState:UIControlStateNormal]; [btnDownload setBackgroundImage:[UIImage imageNamed:@“绿色2.jpg”] forState:UIControlStateHighlighted]; //设置按钮的文字的大小 btnDownload.titleLabel.font=[UIFont systemFontOfSize:14]; //为按钮注册一个单击事件 //[btnDownload addTarget:self action:@selector(btnDownloadClick) forControlEvents:UIControlEventTouchUpInside]; &#125;&#125;//- (void)btnDownloadClick&#123;// NSLog(@“….”);//&#125;**@end** ～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～进行完字典转模型，未进行xib封装的代码⬆️ xib：1）用来描述软件界面的文件2）如果没有xib，所有的界面都需要通过代码来手动创建；有了xib以后，可以在xib中进行可视化开发，然后加载xib文件的时候，系统自动生成对应的代码来创建界面3）与xib类似的还有storyboard文件 xib与storyboard的区别：1）xib是轻量级的，一般只用来描述一个界面中的某部分内容（用来描述局部UI界面）2）storyboard是重量级的，一般用来描述软件的多个界面，以及不同界面之间的跳转关系 //shift+option+command+左（折叠所有的代码）//shift+option+command+右（展开所有的代码） Xib文件的加载过程：1）根据路径，搜索对应的xib文件（nib文件）2）加载xib文件的时候，会按顺序加载xib文件中的每个控件3）对于每个控件，创建的时候都会查找对应的Class属性中配置的是哪个类，那么就创建对应的类的对象4）创建好某个控件以后，按照在xib中配置的属性的值，依次为对象的属性赋值5）创建该控件下的子控件，并设置属性值，然后把该控件加到父控件中6）最后返回一个数组，这个数组中包含创建的根元素对象 ～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～进行完xib封装以后的代码（完整）⬇️ 12345678910111213141516171819//// APPView.h// 8.应用管理//// Created by 廖家龙 on 2020/4/25.// Copyright © 2020 liuyuecao. All rights reserved.//#import &lt;UIKit/UIKit.h&gt;**@class** App;**@interface** APPView : UIView**@property**(**nonatomic**,**strong**)App *model;//为自定义view封装一个类方法，这个类方法的作用就是创建一个view对象+ (**instancetype**)appView;**@end** 123456789101112131415161718192021222324252627282930313233343536373839404142//// APPView.m// 8.应用管理//// Created by 廖家龙 on 2020/4/25.// Copyright © 2020 liuyuecao. All rights reserved.//#import “APPView.h”#import “App.h”**@interface** APPView()**@property** (**weak**, **nonatomic**) **IBOutlet** UIImageView *imgViewIcon;**@property** (**weak**, **nonatomic**) **IBOutlet** UILabel *lblName;**@property** (**weak**, **nonatomic**) **IBOutlet** UIButton *btnDownload;**@end****@implementation** APPView//重写model属性的setter方法- (**void**)setModel:(App *)model&#123; //解析模型数据，把模型数据赋值给UIView中的各个子控件 **self**.imgViewIcon.image=[UIImage imageNamed:model.icon]; **self**.lblName.text=model.name; //赋值 _model=model;&#125;+ (**instancetype**)appView&#123; //1.通过xib创建每个应用（UIView） //通过动态加载xib文件创建里面的view //1.1.找到应用的根目录 NSBundle *rootBundle=[NSBundle mainBundle]; //NSLog(@“%@“,[mainBundle bundlePath]); //1.2.在应用程序根目录下去搜索对应的xib(nib)文件 **return** [[rootBundle loadNibNamed:@“APPView” owner:**nil** options:**nil**] lastObject];&#125;**@end** 12345678910111213141516171819//// App.h// 8.应用管理//// Created by 廖家龙 on 2020/4/24.// Copyright © 2020 liuyuecao. All rights reserved.//#import &lt;Foundation/Foundation.h&gt;**@interface** App : NSObject**@property**(**nonatomic**,**copy**)NSString *name;**@property**(**nonatomic**,**copy**)NSString *icon;- (**instancetype**)initWithDict:(NSDictionary *)dict;+ (**instancetype**)appWithDict:(NSDictionary *)dict;**@end** 123456789101112131415161718192021222324//// App.m// 8.应用管理//// Created by 廖家龙 on 2020/4/24.// Copyright © 2020 liuyuecao. All rights reserved.//#import “App.h”**@implementation** App- (**instancetype**)initWithDict:(NSDictionary *)dict&#123; **if**(**self**=[**super** init])&#123; **self**.name=dict[@“name”]; **self**.icon=dict[@“icon”]; &#125; **return** **self**;&#125;+ (**instancetype**)appWithDict:(NSDictionary *)dict&#123; **return** [[**self** alloc] initWithDict:dict];&#125;**@end** 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889//// ViewController.m// 8.应用管理//// Created by 廖家龙 on 2020/4/24.// Copyright © 2020 liuyuecao. All rights reserved.//#import “ViewController.h”#import “App.h”#import “APPView.h”**@interface** ViewController ()//用来保存所有应用的数据**@property**(**nonatomic**,**strong**)NSArray *apps;**@end****@implementation** ViewController//重写apps属性的getter方法，进行懒加载数据- (NSArray *)apps&#123; **if**(_apps==**nil**)&#123; //加载数据 //1.获取app.plist文件在手机上的路径 NSString *path=[[NSBundle mainBundle] pathForResource:@“app.plist” ofType:**nil**]; //2.根据路径加载数据 NSArray *arrayDict=[NSArray arrayWithContentsOfFile:path]; //3.创建一个可变数组用来保存一个一个的模型对象 NSMutableArray *arrayModels=[NSMutableArray array];//一个空的可变数组 //4.循环字典数组，把每个字典对象转换成一个模型对象 **for**(NSDictionary *dict **in** arrayDict)&#123; //创建一个模型 //App *model=[[App alloc] initWithDict:dict];//调用对象方法 App *model=[App appWithDict:dict];//调用类方法 //把模型加到arrayModels中 [arrayModels addObject:model]; &#125; _apps=arrayModels; &#125; **return** _apps;&#125;- (**void**)viewDidLoad &#123; [**super** viewDidLoad]; // Do any additional setup after loading the view. //假设每行的应用的个数 **int** columns=3; //获取控制器所管理的view的宽度 CGFloat viewWidth=**self**.view.frame.size.width; //每个应用的高和宽 CGFloat appW=75; CGFloat appH=90; CGFloat marginTop=100;//第一行距离顶部的距离 CGFloat marginX=(viewWidth-columns*appW)/(columns+1); CGFloat marginY=marginX;//假设每行之间的间距与marginX相等 **for**(**int** I=0;i&lt;**self**.apps.count;i++)&#123; //获取当前这个应用的数据字典 App *appModel=**self**.apps[I]; //创建view APPView *appView=[APPView appView]; //2.设置appView的属性 //设置appView的frame属性 //计算每个单元格所在列的索引 **int** colIdx=I%columns; //计算每个单元格的行索引 **int** rowIdx=I/columns; CGFloat appx=marginX+colIdx*(appW+marginX); CGFloat appY=marginTop+rowIdx*(appH+marginY); appView.frame=CGRectMake(appx, appY, appW, appH); //3.将appView加到self.view（控制器所管理的那个view） [**self**.view addSubview:appView]; //4.设置appView中的子控件的数据 //把模型数据设置给自定义view的model属性，然后重写model属性的setter方法，在setter方法中解析模型对象中的属性，并把属性值设置给自定义view的各个子控件 appView.model=appModel; &#125;&#125;**@end** ～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～增加下载按钮的单击事件⬇️ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101//// APPView.m// 8.应用管理//// Created by 廖家龙 on 2020/4/25.// Copyright © 2020 liuyuecao. All rights reserved.//#import “APPView.h”#import “App.h”**@interface** APPView()**@property** (**weak**, **nonatomic**) **IBOutlet** UIImageView *imgViewIcon;**@property** (**weak**, **nonatomic**) **IBOutlet** UILabel *lblName;**@property** (**weak**, **nonatomic**) **IBOutlet** UIButton *btnDownload;- (**IBAction**)btnDownloadClick:(UIButton *)sender;**@end****@implementation** APPView//重写model属性的setter方法- (**void**)setModel:(App *)model&#123; //解析模型数据，把模型数据赋值给UIView中的各个子控件 **self**.imgViewIcon.image=[UIImage imageNamed:model.icon]; **self**.lblName.text=model.name; //赋值 _model=model;&#125;+ (**instancetype**)appView&#123; //1.通过xib创建每个应用（UIView） //通过动态加载xib文件创建里面的view //1.1.找到应用的根目录 NSBundle *rootBundle=[NSBundle mainBundle]; //NSLog(@“%@“,[mainBundle bundlePath]); //1.2.在应用程序根目录下去搜索对应的xib(nib)文件 **return** [[rootBundle loadNibNamed:@“APPView” owner:**nil** options:**nil**] lastObject];&#125;//下载按钮的单击事件- (**IBAction**)btnDownloadClick:(UIButton *)sender &#123; //1.禁用当前被点击的按钮 sender.enabled=**NO**; //2.弹出一个消息提醒框（这个消息提醒框其实就是一个UILabel） UILabel *lblMsg=[[UILabel alloc] init]; //2.1.设置lblMsg的显示文字 lblMsg.text=@“正在下载。。。”; //2.2.设置lblMsg的背景色 lblMsg.backgroundColor=[UIColor blackColor]; //2.3.设置lblMsg的frame CGFloat viewW=**self**.superview.frame.size.width; CGFloat viewH=**self**.superview.frame.size.height; CGFloat msgW=200; CGFloat msgH=30; CGFloat msgX=(viewW-msgW)/2; CGFloat msgY=(viewH-msgH)*0.5; lblMsg.frame=CGRectMake(msgX, msgY, msgW, msgH); //2.4.设置label的文字颜色 lblMsg.textColor=[UIColor redColor]; //2.5.设置label居中显示 lblMsg.textAlignment=NSTextAlignmentCenter; //2.6.设置文字粗体 lblMsg.font=[UIFont boldSystemFontOfSize:17]; //2.7.设置label的透明度 lblMsg.alpha=0.0;//一开始把透明度设置为0，然后通过动画的方式慢慢的改变透明度 //2.8.设置label为“圆角” lblMsg.layer.cornerRadius=10;//设置四个角的半径 lblMsg.layer.masksToBounds=**YES**;//把多余的部分给剪掉 //2.9.通过动画的方式来显示Label //开启一个动画，这个动画要执行1.5秒钟 [UIView animateWithDuration:1.5 animations:^&#123; //将透明度变成0.6 lblMsg.alpha=0.6; &#125; completion:^(**BOOL** finished) &#123; //当上面的动画执行完毕以后执行这个代码 **if**(finished)&#123; //隔一段时间后再启动另外一个动画 //这个动画的执行时间是1.5秒钟，但是这个动画会在1.0秒之后再开始执行 // [UIView animateWithDuration:1.5 delay:1.0 options:UIViewAnimationOptionCurveLinear animations:^&#123; lblMsg.alpha=0; &#125; completion:^(**BOOL** finished) &#123; **if**(finished)&#123; //当Label的透明度变成0以后，再把这个Label从view中移除 [lblMsg removeFromSuperview]; &#125; &#125;]; &#125; &#125;]; //3.把lblMsg加到控制器所管理的那个view上 [**self**.superview addSubview:lblMsg];&#125;**@end**","categories":[{"name":"iOS开发-项目","slug":"iOS开发-项目","permalink":"http://example.com/categories/iOS%E5%BC%80%E5%8F%91-%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"UI","slug":"UI","permalink":"http://example.com/tags/UI/"}]},{"title":"超级猜图：","slug":"iOS开发-项目/UI/超级猜图：","date":"2020-11-20T16:00:00.000Z","updated":"2021-03-24T13:27:42.000Z","comments":true,"path":"2020/11/21/iOS开发-项目/UI/超级猜图：/","link":"","permalink":"http://example.com/2020/11/21/iOS%E5%BC%80%E5%8F%91-%E9%A1%B9%E7%9B%AE/UI/%E8%B6%85%E7%BA%A7%E7%8C%9C%E5%9B%BE%EF%BC%9A/","excerpt":"","text":"1） 12345678910//改变状态栏的文字颜色为白色(默认是黑色)- (UIStatusBarStyle)preferredStatusBarStyle&#123; **return** UIStatusBarStyleLightContent;&#125;//隐藏状态栏- (**BOOL**)prefersStatusBarHidden&#123; **return** **YES**;&#125; 2）User Interaction Enabled设置是否允许按钮和用户交互，把勾去掉后用户点击按钮无效果（金币按钮） 3）实现图片的相框效果先添加按钮的白色背景图片，再把图片添加进按钮，设置内边距都为5 4）把按钮的Highlighted Adjusts Image的勾去掉：可以和用户交互，但是点击按钮无反应（图片按钮） 5）实现大图/小图功能 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475//记录头像按钮原始的frame**@property**(**nonatomic**,**assign**) CGRect iconFrame;//用来引用那个阴影按钮的属性**@property**(**weak**,**nonatomic**) UIButton *cover;//显示大图- (**IBAction**)bigImage:(**id**)sender&#123; //记录一下头像按钮的原始frame **self**.iconFrame=**self**.btnIcon.frame; //1.创建大小与self.view一样的按钮，把这个按钮作为一个阴影 UIButton *btnCover=[[UIButton alloc] init]; //设置按钮大小 btnCover.frame=**self**.view.bounds; //设置按钮背景色 btnCover.backgroundColor=[UIColor blackColor]; //设置按钮透明度 btnCover.alpha=0.0; //把按钮加到self.view中 [**self**.view addSubview:btnCover]; //为阴影按钮注册一个单击事件 [btnCover addTarget:**self** action:**@selector**(smallImage) forControlEvents:UIControlEventTouchUpInside]; //2.把图片设置到阴影的上面 //把self.view中的所有子控件中，只把self.btnIcon显示到最上层 [**self**.view bringSubviewToFront:**self**.btnIcon]; //通过self.cover来引用btnCover **self**.cover=btnCover; //3.通过动画的方式把图片变大 CGFloat iconW=**self**.view.frame.size.width; CGFloat iconH=iconW; CGFloat iconX=0; CGFloat iconY=(**self**.view.frame.size.height-iconH)*0.5; [UIView animateWithDuration:0.7 animations:^&#123; //设置按钮透明度 btnCover.alpha=0.6; //设置图片的新frame **self**.btnIcon.frame=CGRectMake(iconX,iconY,iconW,iconH); &#125;];&#125;//阴影的单击事件- (**void**)smallImage&#123; [UIView animateWithDuration:0.7 animations:^&#123; //1.设置btnIcon(头像)按钮的frame还原 **self**.btnIcon.frame=**self**.iconFrame; //2.让阴影按钮的透明度变成0 **self**.cover.alpha=0.0; &#125;completion:^(**BOOL** finished)&#123; **if**(finished)&#123; //移除阴影按钮 [**self**.cover removeFromSuperview]; //当头像图片变成小图以后，再把self.cover设置成nil **self**.cover=**nil**; &#125; &#125;];&#125; //头像按钮的单击事件- (**IBAction**)btnIconClick:(**id**)sender&#123; **if**(**self**.cover==**nil**)&#123; //显示大图 [**self** bigImage:**nil**]; &#125;**else**&#123; [**self** smallImage]; &#125;&#125; 6）动态创建“答案按钮”","categories":[{"name":"iOS开发-项目","slug":"iOS开发-项目","permalink":"http://example.com/categories/iOS%E5%BC%80%E5%8F%91-%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"UI","slug":"UI","permalink":"http://example.com/tags/UI/"}]},{"title":"基础知识","slug":"硬件基础/《汇编语言(第4版)》/基础知识","date":"2020-10-30T16:00:00.000Z","updated":"2021-03-24T13:29:51.000Z","comments":true,"path":"2020/10/31/硬件基础/《汇编语言(第4版)》/基础知识/","link":"","permalink":"http://example.com/2020/10/31/%E7%A1%AC%E4%BB%B6%E5%9F%BA%E7%A1%80/%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80(%E7%AC%AC4%E7%89%88)%E3%80%8B/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","excerpt":"","text":"——————————————————1.1.机器语言1.2.汇编语言的产生1.3.汇编语言的组成1.4.存储器1.5.指令和数据1.6.存储单元1.7.CPU对存储器的读写1.8.地址总线1.9.数据总线1.10.控制总线1.11.内存地址空间(概述)1.12.主板1.13.接口卡1.14.各类存储器芯片1.15.内存地址空间—————————————————— 汇编语言是直接在硬件之上工作的编程语言，首先要了解硬件系统的结构，才能有效的应用汇编语言对其编程 机器语言是机器指令的集合，机器指令展开来讲就是一台机器可以正确执行的命令，电子计算机的机器指令是一列二进制数字，计算机将之转变为一列高低电平，以使计算机的电子器件受到驱动，进行运算 CPU是一种微处理器，每一种微处理器，由于硬件设计和内部结构的不同，就需要不同的电平脉冲来控制，使他工作，所以每一种微处理器都有自己的机器指令集，也就是机器语言———————— 汇编语言的主体是汇编指令 汇编指令和机器指令的差别在于指令的表示方法上，汇编指令是机器指令便于记忆的书写格式，汇编指令是机器指令的助记符 寄存器，简单的讲是CPU中可以存储数据的器件，一个CPU中有多个寄存器，AX是其中一个寄存器的代号，BX是另一个寄存器的代号———————— 汇编语言由以下三类组成：1）汇编指令（机器码的助记符，有对应的机器码）2）伪指令（没有对应的机器码，由编译器执行，计算机并不执行）3）其他符号如+-*/（由编译器识别，没有对应的机器码） 汇编语言的核心是汇编指令，它决定了汇编语言的特性———————— CPU是计算机的核心部件，它控制着整个计算机的运作并进行运算，要想让一个CPU工作，就必须向它提供指令和数据，指令和数据在存储器中存放，也就是平时所说的内存 在一台PC机中内存的作用仅次于CPU，离开了内存，性能再好的CPU也无法工作，磁盘不同于内存，磁盘上的数据或程序如果不读到内存中，就无法被CPU使用———————— 指令和数据是应用上的概念，在内存或磁盘上，指令和数据没有任何区别，都是二进制信息———————— 存储器被划分为若干个存储单元，每个存储单元从0开始顺序编号【电子计算机的最小信息单位是bit（比特），也就是一个二进制位，8个bit组成一个Byte（字节），微型机存储器的存储单位可以存储一个Byte】————————— CPU要想进行数据的读写，必须和外部器件（芯片）进行三类信息的交互：1）地址信息：存储单元的地址2）控制信息：器件的选择，读或写命令3）数据信息：读或写的数据 每一个CPU芯片都有许多管脚，这些管脚和总线相连，也可以说，这些管脚引出总线，一个CPU可以引出三种总线的宽度标志着这个CPU的不同方面的性能：地址总线的宽度决定了CPU的寻址能力数据总线的宽度决定了CPU与其他器件进行数据传送时的一次数据传送量控制总线的宽度决定了CPU对系统中其他器件的控制能力 电子计算机能处理、传输的信息都是电信号，电信号当然要用导线传送，在计算机中专门有连接CPU和其他芯片的导线，通常称为总线物理上：一根根导线的集合逻辑上划分为：1）地址总线：CPU是通过地址总线来指定存储单元的，地址总线上能传送多少个不同的信息，CPU就可以对多少个存储单元进行寻址 一个CPU有N根地址总线，则可以说这个CPU的地址总线的宽度为N，这样的CPU最多可以寻找2的N次方个内存单元 2）数据总线：CPU与内存或其他器件之间的数据传送是通过数据总线来进行的，数据总线的宽度决定了CPU和外界的数据传送速度 8088CPU的数据总线宽度为8，8086CPU的数据总线宽度为16 3）控制总线：CPU对外部器件的控制是通过控制总线来进行的，在这里控制总线是个总称，控制总线是一些不同控制线的集合，有多少根控制总线，就意味着CPU提供了对外部器件的多少种控制，所以，控制总线的宽度决定了CPU对外部器件的控制能力 要让一个计算机或微处理器工作，应向它输入能够驱动它进行工作的电平信号（机器码）—————————— 一个CPU的地址线宽度为10，那么可以寻址1024个内存单元，这1024个可寻到的内存单元就构成了这个CPU的内存地址空间—————————— 在每一台PC机中，都有一个主板，主板上有核心器件和一些主要器件，这些器件通过总线（地址总线、数据总线、控制总线）相连，这些器件有CPU、存储器、外围芯片组、扩展插槽等，扩展插槽上一般插有RAM内存条和各类接口卡—————————— 计算机系统中，所有可用程序控制其互作的设备，必须受到CPU的控制，CPU对外部设备不能直接控制，如显示器、音箱、打印机等，直接控制这些设备进行工作的是插在扩展插槽上的接口卡，扩展插槽通过总线和CPU相连，所以接口卡也通过总线同CPU相连—————————— 各类存储器芯片：1）从读写属性上看分为两类：随机存储器（RAM）和只读存储器（ROM），随机存储器可读可写，但必须带电存储，关机后存储的内容丢失；只读存储器只能读取不能写入，关机后其中的内容不丢失2）从功能和连接上分类： 这些存储器在物理上是独立的器件： 但是它们在以下两点上相同：1）都和CPU的总线相连2）CPU对它们进行读或写的时候都通过控制线发出内存读写命令 不同的计算机系统的内存地址空间分配情况是不同的 内存地址空间的大小受CPU地址总线宽度的限制 对CPU来讲，系统中的所有存储器中的存储单元都处于一个统一的逻辑存储器中，它的容量受CPU寻址能力的限制，这个逻辑存储器即是我们所说的内存地址空间","categories":[{"name":"硬件基础","slug":"硬件基础","permalink":"http://example.com/categories/%E7%A1%AC%E4%BB%B6%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"《汇编语言(第4版)》","slug":"《汇编语言-第4版-》","permalink":"http://example.com/tags/%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E7%AC%AC4%E7%89%88-%E3%80%8B/"}]},{"title":"数据库基本术语","slug":"数据库系统原理/《MySQL必知必会》/数据库基本术语","date":"2020-10-30T16:00:00.000Z","updated":"2021-03-24T13:38:59.000Z","comments":true,"path":"2020/10/31/数据库系统原理/《MySQL必知必会》/数据库基本术语/","link":"","permalink":"http://example.com/2020/10/31/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E6%9C%AF%E8%AF%AD/","excerpt":"","text":"数据库：保存有组织的数据的容器（通常是一个文件或一组文件） 表：某种特定类型数据的结构化清单，数据库中的每个表都有一个名字，用来标识自己，此名字是唯一的，这表示数据库中没有其他表具有相同的名字【虽然在相同数据库中不能两次使用相同的表名，但在不同数据库中却可以使用相同的表名】 模式：关于数据库和表的布局及特性的信息 列：表中的一个字段，所有表都是由一个或多个列组成的 数据类型：所容许的数据的类型，每个表列都有相应的数据类型，它限制（或容许）该列中存储的数据 行：表中的一个记录 主键：一列（或一组列），其值能够唯一区分表中每个行 表中的任何列都可以作为主键，只要他满足以下条件：1）任意两行都不具有相同的主键值2）每个行都必须具有一个主键值（主键列不允许NULL值） ps aux | grep mysql /usr/local/mysql/bin/mysql -u root -p 关键字：作为MySQL语言组成部分的一个保留字，绝不要用关键字命名一个表或列 SQL语句不区分大小写！！","categories":[{"name":"数据库系统原理","slug":"数据库系统原理","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"《MySQL必知必会》","slug":"《MySQL必知必会》","permalink":"http://example.com/tags/%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B/"}]},{"title":"操作系统概述","slug":"操作系统原理/操作系统原理/操作系统概述","date":"2020-10-30T16:00:00.000Z","updated":"2021-03-24T13:32:04.000Z","comments":true,"path":"2020/10/31/操作系统原理/操作系统原理/操作系统概述/","link":"","permalink":"http://example.com/2020/10/31/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/","excerpt":"","text":"————————————— 1-1：操作系统功能和定义 1-2：操作系统发展历史 1-3：典型操作系统类型 —————————————操作系统功能和定义： 基本功能：1）提供操作界面2）控制程序运行3）管理系统资源4）配置系统参数5）监控系统状态6）工具软件集合 操作系统的功能：1）进程管理（CPU管理） a.进程控制：创建，暂停，唤醒，撤销 b.进程调度：调度策略，优先级 c.进程通信：进程间通信2）内存管理 a.内存分配 b.内存共享 c.内存保护 d.虚拟内存3）设备管理 a.设备的分配和调度 b.设备无关性作 c.设备传输控制 d.设备驱动4）文件管理 a.存储空间管理 b.文件的操作 c.目录的操作 d.文件和目录的存取权限管理 操作系统的定义：操作系统是一个大型系统程序，提供用户接口，方便用户控制计算机；负责为应用程序分配和调度软硬件资源，并控制与协调应用程序并发活动，帮助用户存取和保护信息 ————————————————操作系统发展历史： 用户需求提升和硬件技术进步是操作系统发展的两大动力 速度、容量、稳定性、可靠性都得到了逐步提高 第一台数字电子计算机ENIAC 1）手工操作（没有操作系统）电子管时代【1946～1955】结构特点： 硬件：电子管、接线面板（按钮、开关） 程序：二进制程序，打孔：纸带和卡片使用特点：程序准备、启动、结束要手工处理，繁琐耗时缺点：效率低，CPU有效运行时间极低；用户独占、缺少交互 2）单道批处理系统工作过程：1）管理员事先将多个作业输入到磁盘形成队列2）操作系统依次自动处理队列中的每个作业（装入-运行-撤出），程序的装入和撤出自动完成，效率高3）运行完毕，通知用户取结果工作特点：1）批量：作业队列2）自动：识别作业，装入和撤出3）单道：依次、串行背景：1）晶体管时代【1955～1965】2）1955年，IBM推出了第一台晶体管计算机：典型机型7094 结论：外设与CPU交替空闲和忙碌，CPU和外设利用效率低 3）多道批处理系统1）定义：在内存中存放多道程序，当某道程序因为某种原因（例执行I/O操作时）不能继续运行而放弃CPU时，操作系统便调度另一程序投入运行。这样可以使CPU尽量忙碌，提高系统效率2）提高系统CPU利用率3）提高系统吞吐量4）特点：多道，内存同时存放多道程序；并行（宏观上）；串行（微观上）5）缺点：作业处理时间长；交互能力差；运行过程不稳定 4）分时操作系统背景：1）事务性任务的涌现：交互性高，响应快速2）要求支持多任务/多用户3）多终端计算机 分时技术：概念：1）主机以很短的“时间片”为单位，把CPU轮流分配给每个终端使用，直到全部作业被运行完2）由于时间片很短，在终端数量不多的情况下，每个终端都能很快重新获得CPU，使得每个终端都能得到及时响应（等待周期=时间片*终端数量）分时系统的特点：1）多路调制性：多用户联机使用同一台计算机2）独占性：用户感觉独占计算机3）交互性：及时响应用户的请求 —————————————————————典型操作系统类型：","categories":[{"name":"操作系统原理","slug":"操作系统原理","permalink":"http://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"操作系统原理","slug":"操作系统原理","permalink":"http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"}]},{"title":"寄存器(CPU工作原理)","slug":"硬件基础/《汇编语言(第4版)》/寄存器(CPU工作原理)","date":"2020-10-29T16:00:00.000Z","updated":"2021-03-24T13:30:05.000Z","comments":true,"path":"2020/10/30/硬件基础/《汇编语言(第4版)》/寄存器(CPU工作原理)/","link":"","permalink":"http://example.com/2020/10/30/%E7%A1%AC%E4%BB%B6%E5%9F%BA%E7%A1%80/%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80(%E7%AC%AC4%E7%89%88)%E3%80%8B/%E5%AF%84%E5%AD%98%E5%99%A8(CPU%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86)/","excerpt":"","text":"—————————————————2.1.通用寄存器2.2.字在寄存器中的存储2.3.几条汇编指令2.4.物理地址2.5.16位结构的CPU2.6.8086CPU给出物理地址的方法2.7.“段地址*16+偏移地址=物理地址”的本质含义2.8.段的概念2.9.段寄存器2.10.CS和IP2.11.修改CS、IP的指令2.12.代码段————————————————— 一个典型的CPU由运算器、控制器、寄存器(CPU工作原理)等器件组成，这些器件靠内部总线相连 内部总线实现CPU内部各个器件之间的联系，外部总线实现CPU和主板上其他器件的联系 在CPU中：1）运算器进行信息处理2）寄存器进行信息存储3）控制器控制各种器件进行工作4）内部总线连接各种器件，在他们之间进行数据的传送 对于一个汇编程序员来说，CPU中的主要部件是寄存器，寄存器是CPU中程序员可以用指令读写的部件，程序员通过改变各种寄存器中的内容来实现对CPU的控制 8086CPU有14个寄存器，它们的名称为：AX，BX，CX，DX，SI，DI，SP，BP，CS，IP，SS，DS，ES，PSW 8086CPU所有的寄存器都是16位的，可以存放两个字节，AX、BX、CX、DX通常用来存放一般性数据被称为通用寄存器 一个16位寄存器可以存储一个16位的数据，所能存储的数据的最大值为2^16-1 8086上一代CPU中的寄存器都是8位的，为保证兼容性，这四个通用寄存器都可以分为两个独立的8位寄存器使用AX可以分为AH和ALBX可以分为BH和BLCX可以分为CH和CLDX可以分为DH和DL————————— 出于对兼容性的考虑，8086CPU可以一次性处理以下两种尺寸的数据：1）字节：记为byte，一个字节由8个bit组成，可以存在8位寄存器中2）字：记为word，一个字由两个字节组成，这两个字节分别称为这个字的高位字节和低位字节 为了区分不同的进制，在十六进制表示的数据的后面加H，在二进制表示的数据的后面加B————————— 在写一条汇编指令或一个寄存器的名称时不区分大小写：————————— CPU访问内存单元时，要给出内存单元的地址，所有的内存单元构成的存储空间是一个一维的线性空间，每一个内存单元在这个空间中都有唯一的地址，我们将这个唯一的地址称为物理地址 CPU通过地址总线送入存储器的，必须是一个内存单元的物理地址。在CPU向地址总线上发出物理地址之前，必须要在内部先形成这个物理地址，不同的CPU可以有不同的形成物理地址的方式————————— 概括来讲，16位结构描述了一个CPU具有下面几方面的结构特性：1）运算器一次最多可以处理16位的数据2）寄存器的最大宽度为16位3）寄存器和运算器之间的通路为16位————————— 8086CPU给出物理地址的方法： 8086CPU有20位地址总线，又是16位结构，采用一种在内部用两个16位地址合成的方法来形成一个20位的物理地址 当8086CPU要读写内存时：1）CPU中的相关部件提供两个16位的地址，一个称为段地址，另一个称为偏移地址2）段地址和偏移地址通过内部总线送入一个称为地址加法器的部件3）地址加法器将两个16位地址合成为一个20位的物理地址4）地址加法器通过内部总线将20位物理地址送入输入输出控制电路5）输入输出控制电路将20位物理地址送上地址总线6）20位物理地址被地址总线传送到存储器 —————————— “段地址16+偏移地址=物理地址”的本质含义是：CPU在访问内存时，用一个基础地址（段地址16）和一个相对于基础地址的偏移地址相加，给出内存单元的物理地址—————————— 在编程时可以根据需要，将若干地址连续的内存单元看作一个段，用段地址16定位段的起始地址（基础地址），用偏移地址定位段中的内存单元1）段地址16必然是16的倍数，所以一个段的起始地址也一定是16的倍数2）偏移地址为16位，16位地址的寻址能力为64KB，所以一个段的长度最大为64KB—————————— 段地址在8086CPU的段寄存器中存放，8086CPU有4个段寄存器：CS，DS，SS，ES—————————— CS和IP是8086CPU中两个最关键的寄存器，它们指示了CPU当前要读取指令的地址，CS为代码段寄存器，IP为指令指针寄存器 在8086PC机中，任意时刻，设CS中的内容为M，IP中的内容为N，8086CPU将从内存M*16+N单元开始，读取一条指令并执行 8086CPU读取、执行一条指令的过程： 1）从CS：IP指向的内存单元读取指令，读取的指令进入指令缓冲器2）IP=IP+所读取指令的长度，从而指向下一条指令3）执行指令，转到步骤1），重复这个过程 CPU将CS：IP指向的内存单元中的内容看作指令————————— 程序员可以通过改变CS、IP中的内容来控制CPU执行目标指令 8086CPU大部分寄存器的值，都可以用mov指令来改变，mov指令被称为传送指令，但是mov指令不能用于设置CS、IP的值；能够改变CS、IP的内容的指令被统称为转移指令（jmp指令） 若想仅修改IP的内容，可用形如“jmp 某一合法寄存器”的指令完成： ——————————","categories":[{"name":"硬件基础","slug":"硬件基础","permalink":"http://example.com/categories/%E7%A1%AC%E4%BB%B6%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"《汇编语言(第4版)》","slug":"《汇编语言-第4版-》","permalink":"http://example.com/tags/%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E7%AC%AC4%E7%89%88-%E3%80%8B/"}]},{"title":"SHOW语句HELP SHOW","slug":"数据库系统原理/《MySQL必知必会》/SHOW语句HELP SHOW","date":"2020-10-29T16:00:00.000Z","updated":"2021-03-24T13:39:13.000Z","comments":true,"path":"2020/10/30/数据库系统原理/《MySQL必知必会》/SHOW语句HELP SHOW/","link":"","permalink":"http://example.com/2020/10/30/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B/SHOW%E8%AF%AD%E5%8F%A5HELP%20SHOW/","excerpt":"","text":"SHOW语句【HELP SHOW;】： 可使用的数据库名： USE选择数据库（必须先使用USE打开数据库，才能读取其中的数据） SHOW TABLES；返回当前选择的数据库内可用表的列表 SHOW COLUMNS FROM…….【DESCRIBE…..】（从某个表中查找）","categories":[{"name":"数据库系统原理","slug":"数据库系统原理","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"《MySQL必知必会》","slug":"《MySQL必知必会》","permalink":"http://example.com/tags/%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B/"}]},{"title":"操作系统逻辑结构","slug":"操作系统原理/操作系统原理/操作系统逻辑结构","date":"2020-10-29T16:00:00.000Z","updated":"2021-03-24T13:32:16.000Z","comments":true,"path":"2020/10/30/操作系统原理/操作系统原理/操作系统逻辑结构/","link":"","permalink":"http://example.com/2020/10/30/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84/","excerpt":"","text":"———————————— 2-1：操作系统的逻辑结构 2-2：CPU的态 2-3：中断机制 ———————————— 操作系统的逻辑结构： 逻辑结构：OS的设计和实现思路逻辑结构的种类：1）整体式结构2）层次式结构3）微内核结构（客户/服务器结构，Client/Server） 整体式结构：以模块为基本单位构建 特点：1）模块设计、编码和调试独立2）模块调用自由3）模块通信多以全局变量形式完成缺点：信息传递随意，维护和更新困难 层次结构： 分层原则：1）硬件相关—最底层2）外部特性—最外层3）中间层—调用次序或消息传递次序4）共性的服务—较低层5）活跃功能—较低层优点：1）结构清晰，避免循环调用2）整体问题局部化，系统的正确性容易保证3）有利于操作系统的维护、扩充、移植 微内核结构： ——————————————— CPU的态： 支持操作系统的最基本的硬件结构：CPU、内存、中断、时钟 CPU态：CPU的工作状态，对资源和指令使用权限的描述 态的分类：1）核态：能够访问所有资源和执行所有指令；管理程序/OS内核2）用户态（目态）：仅能访问部分资源，其他资源受限；用户程序3）管态：介于核态和用户态之间 用户态向核态转换：1）用户请求OS提供服务2）发生中断3）用户进程产生错误（内部中断）4）用户态企图执行特权指令 核态向用户态转换的情形：一般是执行中断返回（IRET） 硬件按“态”来区分CPU的状态OS按“进程”来区分CPU的状态 存储器：存储程序和数据的部件分类：1）按存储器（半导体存储器）读写工作方式：RAM、ROM2）按存储元的材料：半导体存储器（常作主存）；磁存储器（磁带、磁盘）；光存储器（光盘）3）按与CPU的联系：主存（直接和CPU交换信息），辅存（不能直接和CPU交换信息） —————————————— 中断机制： 中断定义：1）指CPU对突发的外部事件的反应过程或机制2）CPU收到外部信号（中断信号）后，停止当前工作，转去处理该外部事件，处理完毕后回到原来工作的中断处（断点）继续原来的工作引入中断的目的：1）实现并发活动2）实现实时处理3）故障自动处理 中断源：引起系统中断的事件 中断类型：1）强迫性中断：程序没有预期：I/O、外部中断自愿中断：程序有预期的：执行访管指令2）外中断（中断）：由CPU外部事件引起：I/O、外部事情内中断（俘获）：由CPU内部事件引起：访管中断、程序中断 外中断：1）不可屏蔽中断：中断的原因很紧要，CPU必须响应2）可屏蔽中断：中断原因不很紧要，CPU可以不响应 断点：程序中断的地方，将要执行的下一指令的地址 现场：程序正确运行所依赖的信息集合（相关寄存器）现场的两个处理过程：1）现场的保护：进入中断服务程序之前，要先把现场保存在栈里2）现场的恢复 中断响应过程：1）识别中断源2）保护断点和现场3）装入中断服务程序的入口地址（CS：IP）4）进入中断服务程序5）恢复现场和断点6）中断返回：IRET 中断响应的实质：1）交换指令执行地址2）交换CPU的态 中断响应的工作：1）现场保护和恢复2）参数传递（通信）","categories":[{"name":"操作系统原理","slug":"操作系统原理","permalink":"http://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"操作系统原理","slug":"操作系统原理","permalink":"http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"}]},{"title":"实验1、查看CPU和内存，用机器指令和汇编指令编程","slug":"硬件基础/《汇编语言(第4版)》/实验1、查看CPU和内存，用机器指令和汇编指令编程","date":"2020-10-28T16:00:00.000Z","updated":"2021-03-24T13:30:17.000Z","comments":true,"path":"2020/10/29/硬件基础/《汇编语言(第4版)》/实验1、查看CPU和内存，用机器指令和汇编指令编程/","link":"","permalink":"http://example.com/2020/10/29/%E7%A1%AC%E4%BB%B6%E5%9F%BA%E7%A1%80/%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80(%E7%AC%AC4%E7%89%88)%E3%80%8B/%E5%AE%9E%E9%AA%8C1%E3%80%81%E6%9F%A5%E7%9C%8BCPU%E5%92%8C%E5%86%85%E5%AD%98%EF%BC%8C%E7%94%A8%E6%9C%BA%E5%99%A8%E6%8C%87%E4%BB%A4%E5%92%8C%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4%E7%BC%96%E7%A8%8B/","excerpt":"","text":"Debug是DOS、Windows都提供的实模式（8086方式）程序的调试工具，使用它可以查看CPU各种寄存器的内容、内存的情况和在机器码级跟踪程序的运行 Debug功能：1）R：查看、改变CPU寄存器的内容2）D：查看内存中的内容3）E：改写内存中的内容4）U：将内存中的机器指令翻译成汇编指令5）T：执行一条机器指令6）A：以汇编指令的格式在内存中写入一条机器指令 1）使用R命令查看、修改CPU中各个寄存器的内容： 2）用Debug的D命令查看内存中的内容 a.中间是从指定地址开始的128个内存单元的内容，用十六进制的格式输出，每行的输出从16的整数倍的地址开始，最多输出16个单元的内容b.左边是每行的起始地址c.右边是每个内存单元中的数据对应的可显示的ASCII码字符 直接使用D命令，将列出Debug预设的地址处的内容在使用“d 段地址：偏移地址”之后，接着使用D命令，可列出后续的内容也可以指定D命令的查看范围：“d 段地址：起始偏移地址 结尾偏移地址”只想查看内存单元10000H中的内容： 3）用Debug的E命令改写内存中的内容 也可以采用提问的方式一个一个的改写内存中的内容： 可以用E命令向内存中写入字符、字符串 4）用E命令向内存中写入机器码，用U命令查看内存中机器码的含义，用T命令执行内存中的机器码 向内存中写入机器码： 查看写入的或内存中原有的机器码所对应的汇编指令： U命令的显示输出分为3部分：每一条机器指令的地址、机器指令、机器指令所对应的汇编指令 T命令可以执行一条或多条指令，简单的使用T命令，可以执行CS：IP指向的指令 若要用T命令控制CPU执行我们写到1000:0的指令，必须先让CS：IP指向1000:0 5）用Debug的A命令以汇编指令的形式在内存中写入机器指令 简单的使用A命令，可以从一个预设的地址开始输入指令","categories":[{"name":"硬件基础","slug":"硬件基础","permalink":"http://example.com/categories/%E7%A1%AC%E4%BB%B6%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"《汇编语言(第4版)》","slug":"《汇编语言-第4版-》","permalink":"http://example.com/tags/%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E7%AC%AC4%E7%89%88-%E3%80%8B/"}]},{"title":"检索数据SELECT语句","slug":"数据库系统原理/《MySQL必知必会》/检索数据SELECT语句","date":"2020-10-28T16:00:00.000Z","updated":"2021-03-24T13:39:27.000Z","comments":true,"path":"2020/10/29/数据库系统原理/《MySQL必知必会》/检索数据SELECT语句/","link":"","permalink":"http://example.com/2020/10/29/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B/%E6%A3%80%E7%B4%A2%E6%95%B0%E6%8D%AESELECT%E8%AF%AD%E5%8F%A5/","excerpt":"","text":"检索数据【SELECT语句】： 检索单个列： 从db表中检索一个名为Host的列：从db表中检索多个列：从db表中检索所有列： 检索不同的行？？ 限制结果：LIMIT 1；【指示MySQL返回不多于1行】LIMIT 1，2；【第一个数为开始位置，第二个数为要检索的行数】1）所以，带一个值的LIMIT总是从第一行开始，给出的数为返回的行数。带两个值的LIMIT可以指定从行号为第一个值的位置开始2）检索出来的第一行为行0而不是行1，因此，LIMIT 1，1将检索出第二行而不是第一行3）LIMIT中指定要检索的行数为检索的最大行数，如果没有足够的行（例如，给出LIMIT 10，5，但只有13行），MySQL将只返回它能返回的那么多行 使用完全限定的表名：","categories":[{"name":"数据库系统原理","slug":"数据库系统原理","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"《MySQL必知必会》","slug":"《MySQL必知必会》","permalink":"http://example.com/tags/%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B/"}]},{"title":"进程管理","slug":"操作系统原理/操作系统原理/进程管理","date":"2020-10-28T16:00:00.000Z","updated":"2021-03-24T13:32:27.000Z","comments":true,"path":"2020/10/29/操作系统原理/操作系统原理/进程管理/","link":"","permalink":"http://example.com/2020/10/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/","excerpt":"","text":"——————————————— 3-1：进程概念 3-1-1.进程基本概念 3-1-2.进程状态 3-1-3.进程控制块 3-2：进程控制概念 3-3：线程 3-3-1.线程概念 3-3-2.线程典型应用场景 3-4：临界区和锁 3-4-1.临界资源与临界区 3-4-2.锁机制 3-5：同步和P-V操作 3-5-1.同步和互斥的概念 3-5-2.P-V操作概念 3-5-3.P-V操作解决互斥问题 3-5-4.P-V操作解决同步问题 3-5-5.经典同步问题 3-6：进程通信 3-6-1.匿名管道通信 3-6-2.Linux信号通信———————————————","categories":[{"name":"操作系统原理","slug":"操作系统原理","permalink":"http://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"操作系统原理","slug":"操作系统原理","permalink":"http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"}]},{"title":"寄存器(内存访问)","slug":"硬件基础/《汇编语言(第4版)》/寄存器(内存访问)","date":"2020-10-27T16:00:00.000Z","updated":"2021-03-24T13:30:28.000Z","comments":true,"path":"2020/10/28/硬件基础/《汇编语言(第4版)》/寄存器(内存访问)/","link":"","permalink":"http://example.com/2020/10/28/%E7%A1%AC%E4%BB%B6%E5%9F%BA%E7%A1%80/%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80(%E7%AC%AC4%E7%89%88)%E3%80%8B/%E5%AF%84%E5%AD%98%E5%99%A8(%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE)/","excerpt":"","text":"寄存器(内存访问)： ——————————————————3.1.内存中字的存储3.2.DS和[address]3.3.字的传送3.4.mov、add、sub指令3.5.数据段3.6.栈3.7.CPU提供的栈机制3.8.栈顶超界的问题3.9.push、pop指令3.10.栈段—————————————————— CPU中，用16位寄存器来存储一个字，高8位存放高位字节，低八位存放低位字节。在内存中存储时，由于内存单元是字节单位（一个单元存放一个字节），则一个字要用两个地址连续的内存单元来存放，这个字的低位字节存放在低地址单元中，高位字节存放在高地址单元中 将起始地址为N的字单元简称为N地址字单元 任何两个地址连续的内存单元，N号单元和N+1号单元，可以将它们看成两个内存单元，也可看成一个地址为N的字单元中的高位字节单元和低位字节单元—————————— CPU要读写一个内存单元的时候，必须先给出这个内存单元的地址，在8086PC中，内存地址由段地址和偏移地址组成，8086CPU中有一个DS寄存器，通常用来存放要访问数据的段地址 可以使用mov指令将一个内存单元中的内容送入一个寄存器中：mov 寄存器名，内存单元地址 “[…]”表示一个内存单元，“[…]”中的0表示内存单元的偏移地址，指令执行时，8086CPU自动取ds中的数据为内存单元的段地址 8086CPU不支持将数据直接送入段寄存器的操作，ds是一个段寄存器，所以mov ds,1000H这条指令是非法的—————————— 8086CPU是16位结构，有16根数据线，所以可以一次性传送16位的数据，也就是说可以一次性传送一个字，只要在mov指令中给出16位的寄存器就可以进行16位数据的传送了 —————————— mov 寄存器，段寄存器mov 内存单元，段寄存器mov 段寄存器，内存单元 mov、add、sub是具有两个操作对象的指令，jmp是具有一个操作对象的指令—————————— 我们可以将一组长度为N（N&lt;=64KB）、地址连续、起始地址为16的倍数的内存单元当作专门存储数据的内存空间，从而定义了一个数据段 —————————— 栈是一种具有特殊的访问方式的存储空间，最后进入这个空间的数据，最先出去，栈的这种操作规则被称为：LIFO（Last In First Out，后进先出）—————————— 8086CPU提供相关的指令来以栈的方式访问内存空间，这意味着，在基于8086CPU编程的时候，可以将一段内存当作栈来使用：PUSH（入栈）和POP（出栈），8086CPU的入栈和出栈操作都是以字为单位进行的 CS、IP中存放着当前指令的段地址和偏移地址8086CPU中，有两个寄存器，段寄存器SS和寄存器SP，栈顶的段地址存放在SS中，偏移地址存放在SP中，任意时刻，SS：SP指向栈顶元素，push指令和pop指令执行时，CPU从SS和SP中得到栈顶的地址 —————————————— 当栈满的时候再使用push指令入栈，或栈空的时候再使用pop指令出栈，都将发生栈顶越界问题 —————————————— push和pop指令是可以在寄存器和内存之间传送数据的 栈空间也是内存空间的一部分，它只是一段可以以一种特殊的方式进行访问的内存空间 注意：push、pop等栈操作指令，修改的只是SP，也就是说，栈顶的变化范围最大为0～FFFFH 提供SS、SP指示栈顶，改变SP后写内存的入栈指令，读内存后改变SP的出栈指令，这就是8086CPU提供的栈操作机制————————————————— 在编程时，可以根据需要，将一组内存单元定义为一个段，我们可以将长度为N（N&lt;=64KB）的一组地址连续、起始地址为16的倍数的内存单元，当作栈空间来用，从而定义了一个栈段","categories":[{"name":"硬件基础","slug":"硬件基础","permalink":"http://example.com/categories/%E7%A1%AC%E4%BB%B6%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"《汇编语言(第4版)》","slug":"《汇编语言-第4版-》","permalink":"http://example.com/tags/%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E7%AC%AC4%E7%89%88-%E3%80%8B/"}]},{"title":"排序检索数据","slug":"数据库系统原理/《MySQL必知必会》/排序检索数据","date":"2020-10-27T16:00:00.000Z","updated":"2021-03-24T13:39:39.000Z","comments":true,"path":"2020/10/28/数据库系统原理/《MySQL必知必会》/排序检索数据/","link":"","permalink":"http://example.com/2020/10/28/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B/%E6%8E%92%E5%BA%8F%E6%A3%80%E7%B4%A2%E6%95%B0%E6%8D%AE/","excerpt":"","text":"排序检索数据 子句：SQL语句由子句构成，有些子句是必须的，而有的是可选的。一个子句通常由一个关键字和所提供的数据组成。 1）指示MySQL对列以字母顺序排序SELECT 列名FROM 表名ORDER BY 列名; 2）先按价格，再按名称排序：SELECT prodid,prodprice,prod_nameFROM productsORDER BY prodprice,prodname; 3）按价格以降序排序SELECT prodid,prodprice,prod_nameFROM productsORDER BY prod_price DESC; 4）先按价格以降序排序，再对产品名排序SELECT prodid,prodprice,prod_nameFROM productsORDER BY prodprice DESC,prodname;DESC关键字只应用到直接位于其前面的列名，在上例中，只对prodprice列指定DESC，对prodname列不指定。因此，prodprice列以降序排序，而prodname列（在每个价格内）仍然按标准的升序排序 5）prod_price DESC保证行是按照由最昂贵到最便宜检索的，而LIMIT 1告诉MySQL仅返回一行SELECT prod_priceFROM productsORDER BY prod_price DESCLIMIT 1;","categories":[{"name":"数据库系统原理","slug":"数据库系统原理","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"《MySQL必知必会》","slug":"《MySQL必知必会》","permalink":"http://example.com/tags/%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B/"}]},{"title":"进程概念","slug":"操作系统原理/操作系统原理/进程概念","date":"2020-10-27T16:00:00.000Z","updated":"2021-03-24T13:32:38.000Z","comments":true,"path":"2020/10/28/操作系统原理/操作系统原理/进程概念/","link":"","permalink":"http://example.com/2020/10/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E8%BF%9B%E7%A8%8B%E6%A6%82%E5%BF%B5/","excerpt":"","text":"进程概念： 描述和管理程序的“运行过程”—进程 进程定义：进程是程序在某个数据集合上的一次运行活动 数据集合：软/硬件环境，多个进程共存/共享的环境 进程的特征：1）动态性：进程是程序的一次执行过程，动态产生/消亡2）并发性：进程同其他进程一起向前推进3）异步性：进程按各自速度向前推进4）独立性：进程是系统分配资源和调度CPU的单位 进程与程序的区别：1）动态与静态：进程是动态的，程序的一次执行过程；程序是静态的，一组指令的有序集合2）暂存与长存：进程是暂存的，在内存驻留；程序是长存的，在介质上长期保存3）程序和进程的对应：一个程序可能有多个进程 进程的类型：1）按使用资源的权限系统进程：指系统内核相关的进程用户进程：运行于用户态的进程2）按对CPU的依赖性偏CPU进程：计算型进程偏I/O进程：侧重于I/O的进程 进程的状态：1）运行状态（Running）：进程已经占有CPU，在CPU上运行2）就绪状态（Ready）：具备运行条件但由于无CPU，暂时不能运行3）阻塞状态（Block）【等待（Wait）状态】：因为等待某项服务完成或信号不能运行的状态，如等待系统调用、I/O操作、合作进程信号 进程状态的变迁：进程的状态可以依据一定的条件相互转化 Linux进程的状态： 进程控制块（Process Control Block，PCB）1）描述进程状态、资源、和与相关进程关系的数据结构2）PCB是进程的标志3）创建进程时创建PCB；进程撤销后PCB同时撤销 进程的切换：进程的上下文：Context，进程运行环境，CPU环境进程切换过程：1）换入进程的上下文进入CPU（从栈上来）2）换出进程的上下文离开CPU（到栈上去）","categories":[{"name":"操作系统原理","slug":"操作系统原理","permalink":"http://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"操作系统原理","slug":"操作系统原理","permalink":"http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"}]},{"title":"实验2、用机器指令和汇编指令编程","slug":"硬件基础/《汇编语言(第4版)》/实验2、用机器指令和汇编指令编程","date":"2020-10-26T16:00:00.000Z","updated":"2021-03-24T13:30:38.000Z","comments":true,"path":"2020/10/27/硬件基础/《汇编语言(第4版)》/实验2、用机器指令和汇编指令编程/","link":"","permalink":"http://example.com/2020/10/27/%E7%A1%AC%E4%BB%B6%E5%9F%BA%E7%A1%80/%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80(%E7%AC%AC4%E7%89%88)%E3%80%8B/%E5%AE%9E%E9%AA%8C2%E3%80%81%E7%94%A8%E6%9C%BA%E5%99%A8%E6%8C%87%E4%BB%A4%E5%92%8C%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4%E7%BC%96%E7%A8%8B/","excerpt":"","text":"1）D命令也提供了一种符合CPU机理的格式：“d 段寄存器：偏移地址”，以段寄存器中的数据为段地址SA，列出从SA：偏移地址开始的内存区间中的数据 查看从ds:0开始的内存区间中的内容： 查看当前代码段和栈段中的内容： 2）在E、A、U命令中使用段寄存器 3）在Debug中，用A命令写一段程序 在用T命令执行mov ss,ax的时候，它的下一条指令mov sp,10也紧接着执行了不单是mov ss,ax，对于如mov ss,bx mov ss,[0] pop ss等指令都会发生这种情况，这些指令的共性是都是修改栈段寄存器SS的指令 Debug的T命令在执行修改寄存器SS的指令时，下一条指令也紧接着被执行","categories":[{"name":"硬件基础","slug":"硬件基础","permalink":"http://example.com/categories/%E7%A1%AC%E4%BB%B6%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"《汇编语言(第4版)》","slug":"《汇编语言-第4版-》","permalink":"http://example.com/tags/%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E7%AC%AC4%E7%89%88-%E3%80%8B/"}]},{"title":"过滤数据","slug":"数据库系统原理/《MySQL必知必会》/过滤数据","date":"2020-10-26T16:00:00.000Z","updated":"2021-03-24T13:39:51.000Z","comments":true,"path":"2020/10/27/数据库系统原理/《MySQL必知必会》/过滤数据/","link":"","permalink":"http://example.com/2020/10/27/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B/%E8%BF%87%E6%BB%A4%E6%95%B0%E6%8D%AE/","excerpt":"","text":"过滤数据 1）只返回prod_price值为2.50的行SELECT prodname,prodpriceFROM productsWHERE prod_price=2.50; 2） 3）MySQL在执行匹配时默认不区分大小写，所以fuses与Fuses匹配SELECT prodname,prodpriceFROM productsWHERE prod_name=‘fuses’;【注意单引号】 4）SELECT prodname,prodpriceFROM productsWHERE prod_price&lt;10; 5)列出不是由供应商1003制造的所有产品SELECT vendid,prodnameFROM productsWHERE vend_id&lt;&gt;1003; 6）检索价格在5美元和10美元之间的所有产品SELECT prodname,prodpriceFROM productsWHERE prod_price BETWEEN 5 AND 10; 7）NULL：无值，它与字段包含0、空字符串或仅仅包含空格不同这条语句返回没有价格（空prod_price字段，不是价格为0）的所有产品SELECT prod_nameFROM productsWHERE prod_price IS NULL;","categories":[{"name":"数据库系统原理","slug":"数据库系统原理","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"《MySQL必知必会》","slug":"《MySQL必知必会》","permalink":"http://example.com/tags/%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B/"}]},{"title":"进程控制概念","slug":"操作系统原理/操作系统原理/进程控制概念","date":"2020-10-26T16:00:00.000Z","updated":"2021-03-24T13:32:49.000Z","comments":true,"path":"2020/10/27/操作系统原理/操作系统原理/进程控制概念/","link":"","permalink":"http://example.com/2020/10/27/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E6%A6%82%E5%BF%B5/","excerpt":"","text":"概念：在进程生存全期间，对其全部行为的控制 四个典型的控制行为：1）创建进程2）阻塞进程3）撤销进程4）唤醒进程 进程创建：创建一个具有指定标识（ID）的进程（进程标识、优先级、进程起始地址、CPU初始状态、资源清单） 进程撤销：撤销一个指定的进程；收回进程所占有的资源，撤销该进程的PCB 进程撤销的时机/事件：1）正常结束2）异常结束3）外界干预 参数：被撤销的进程名（ID） 进程阻塞：停止进程的执行，变为阻塞 参数：阻塞原因，不同原因构建有不同的阻塞队列 进程阻塞的实现：1）停止运行2）将PCB“运行态”改“阻塞态”3）插入相应原因的阻塞队列4）转调度程序 进程唤醒：唤醒处于阻塞队列当中的某个进程 引起唤醒的时机/事件：1）系统服务由不满足到满足2）I/O完成3）新数据到达4）进程提出新请求（服务） 参数：被唤醒进程的标识 进程控制原语：由若干指令构成的具有特定功能的函数，具有原子性，其操作不可分割 进程控制原语：1）创建原语2）撤销原语3）阻塞原语4）唤醒原语","categories":[{"name":"操作系统原理","slug":"操作系统原理","permalink":"http://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"操作系统原理","slug":"操作系统原理","permalink":"http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"}]},{"title":"第一个程序","slug":"硬件基础/《汇编语言(第4版)》/第一个程序","date":"2020-10-25T16:00:00.000Z","updated":"2021-03-24T13:30:49.000Z","comments":true,"path":"2020/10/26/硬件基础/《汇编语言(第4版)》/第一个程序/","link":"","permalink":"http://example.com/2020/10/26/%E7%A1%AC%E4%BB%B6%E5%9F%BA%E7%A1%80/%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80(%E7%AC%AC4%E7%89%88)%E3%80%8B/%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8F/","excerpt":"","text":"———————————————————4.1.一个源程序从写出到执行的过程4.2.源程序4.3.编辑源程序4.4.编译4.5.连接4.6：1.exe的执行4.7.谁将可执行文件中的程序装载进入内存并使它运行？4.8.程序执行过程的跟踪——————————————————— 1）编写汇编源程序：使用文本编辑器，用汇编语言编写汇编源程序，这一步工作的结果是产生了一个存储源程序的文本文件2）对源程序进行编译连接：使用汇编语言编译程序对源程序文件中的源程序进行编译，产生目标文件；再用连接程序对目标文件进行连接，生成可在操作系统中直接运行的可执行文件 可执行文件包含两部分内容：程序（从源程序中的汇编指令翻译过来的机器码）和数据（源程序中定义的数据）、相关的描述信息（比如程序有多大、要占用多少内存空间） 这一步工作的结果，产生了一个可在操作系统中运行的可执行文件 3）执行可执行文件中的程序，在操作系统中，执行可执行文件中的程序，操作系统依照可执行文件中的描述信息，将可执行文件中的机器码和数据加载入内存，并进行相关的初始化（比如设置CS：IP指向第一条要执行的指令），然后由CPU执行程序——————————————— 1）伪指令：在汇编语言源程序中，包含两种指令，一种是汇编指令，一种是伪指令。汇编指令是有对应的机器码的指令，可以被编译为机器指令，最终为CPU所执行。而伪指令没有对应的机器指令，最终不被CPU所执行，伪指令是由编译器来执行的指令，编译器根据伪指令来进行相关的编译工作 segment和ends是一对成对使用的伪指令，功能是定义一个段end是一个汇编程序的结束标记，标记整个程序的结束assume假设某一段寄存器和程序中的某一个用segment…ends定义的段相关联2）源程序中的“程序” 3）标号：一个标号指代了一个地址，比如codesg在segment的前面，作为一个段的名称，这个段的名称最终将被编译、连接程序处理为一个段的段地址4）程序的结构5）程序返回：一个程序结束后，将CPU的控制权交还给使它得以运行的程序，称这个过程为程序返回 6）语法错误和逻辑错误程序在编译时被编译器发现的错误是语法错误在源程序编译后，在运行时发生的错误是逻辑错误，语法错误容易发现，也容易解决，而逻辑错误通常不容易被发现—————————————— 编辑源程序： 可以用任意的文本编辑器来编辑源程序，只要最终将其存储为纯文本文件即可 ——————————————— 编译：在编译过程中，我们提供了一个输入，即源程序文件，最多可以得到3个输出：目标文件（.obj）、列表文件（.lst）、交叉引用文件（.crf），这3个输出文件中，目标文件是我们最终要得到的结果，而另外两个只是中间结果 ——————————————— 连接：连接的作用： 最终生成3个文件：———————————————— 1.exe的执行：———————————————— 在DOS中直接执行1.exe时，是正在运行的command，将1.exe中的程序加载入内存，command设置CPU的CS：IP指向程序的第一条指令（即程序的入口），从而使程序得以运行，程序运行结束后，返回到command中，CPU继续运行command ———————————————— 程序执行过程的跟踪（Debug）： 为了观察程序的运行过程，可以使用Debug，Debug可以将程序加载入内存，设置CS：IP指向程序的入口，但Debug并不放弃对CPU的控制 CX中存放的是程序的长度，1.exe中程序的机器码共有15个字节 DS的值为075A，则PSP的地址为075A：0，程序的地址为076A：0（即075A+10:0） 源程序中的指令是mov ax,0123H，在Debug中记为mov ax,0123，这是因为Debug默认所有数据都用十六进制表示 可以用U命令看一下其他指令： T命令单步执行程序中的每一条指令： 到了int 21，我们要用P命令执行：","categories":[{"name":"硬件基础","slug":"硬件基础","permalink":"http://example.com/categories/%E7%A1%AC%E4%BB%B6%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"《汇编语言(第4版)》","slug":"《汇编语言-第4版-》","permalink":"http://example.com/tags/%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E7%AC%AC4%E7%89%88-%E3%80%8B/"}]},{"title":"数据过滤","slug":"数据库系统原理/《MySQL必知必会》/数据过滤","date":"2020-10-25T16:00:00.000Z","updated":"2021-03-24T13:40:03.000Z","comments":true,"path":"2020/10/26/数据库系统原理/《MySQL必知必会》/数据过滤/","link":"","permalink":"http://example.com/2020/10/26/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B/%E6%95%B0%E6%8D%AE%E8%BF%87%E6%BB%A4/","excerpt":"","text":"数据过滤 操作符：用来联结或改变WHERE子句中的子句的关键字，也称为逻辑操作符 1）AND:用在WHERE子句中的关键字，用来指示检索满足所有给定条件的行SELECT prodid,prodname,prod_priceFROM productsWHERE vendid=1003 AND prodprice&lt;=10; 2)OR：用来表示检索匹配任一给定条件的行SELECT prodname,prodpriceFROM productsWHERE vendid=1002 OR vendid=1003; 3）SELECT prodname,prodpriceFROM productsWHERE vendid=1002 OR vendid=1003 AND prod_price&gt;=10; SELECT prodname,prodpriceFROM productsWHERE (vendid=1002 OR vendid=1003) AND prod_price&gt;=10; 4)IN WHERE子句中用来指定要匹配值的清单的关键字，功能与OR相当SELECT prodname,prodpriceFROM productsWHERE vend_id IN(1002,1003)ORDER BY prod_name; 5）NOT WHERE子句中用来否定后跟条件的关键字SELECT prodname,prodpriceFROM productsWHERE vend_id NOT IN(1002,1003)ORDER BY prod_name;","categories":[{"name":"数据库系统原理","slug":"数据库系统原理","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"《MySQL必知必会》","slug":"《MySQL必知必会》","permalink":"http://example.com/tags/%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B/"}]},{"title":"线程（Thread）","slug":"操作系统原理/操作系统原理/线程（Thread）","date":"2020-10-25T16:00:00.000Z","updated":"2021-03-24T13:33:16.000Z","comments":true,"path":"2020/10/26/操作系统原理/操作系统原理/线程（Thread）/","link":"","permalink":"http://example.com/2020/10/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%BA%BF%E7%A8%8B%EF%BC%88Thread%EF%BC%89/","excerpt":"","text":"线程（Thread）： 1）线程是可由CPU直接运行的实体2）一个进程可以创建多个线程3）多个线程共享CPU可以实现并发运行 单线程程序：整个进程只有一个线程，Windows程序缺省只有一个线程（主线程，main线程） 多线程程序：整个进程至少有2个线程，主线程和至少一个用户线程 线程技术典型适用场景：1）程序的多个功能需要并发运行2）提高窗口程序的交互性3）改善程序结构4）多核CPU上的应用，充分发挥多核性能 使用线程的麻烦：1）程序难以调试2）并发过程难以控制3）线程安全问题","categories":[{"name":"操作系统原理","slug":"操作系统原理","permalink":"http://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"操作系统原理","slug":"操作系统原理","permalink":"http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"}]},{"title":"BX和loop指令","slug":"硬件基础/《汇编语言(第4版)》/[BX]和loop指令","date":"2020-10-24T16:00:00.000Z","updated":"2021-03-24T13:30:59.000Z","comments":true,"path":"2020/10/25/硬件基础/《汇编语言(第4版)》/[BX]和loop指令/","link":"","permalink":"http://example.com/2020/10/25/%E7%A1%AC%E4%BB%B6%E5%9F%BA%E7%A1%80/%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80(%E7%AC%AC4%E7%89%88)%E3%80%8B/[BX]%E5%92%8Cloop%E6%8C%87%E4%BB%A4/","excerpt":"","text":"——————————————————————————5.1.[BX]5.2.Loop指令5.3.在Debug中跟踪用loop指令实现的循环程序5.4.Debug和汇编编译器masm对指令的不同处理5.5.loop和[bx]的联合应用5.6.段前缀5.7.一段安全的空间5.8.段前缀的使用—————————————————————————— 要完整的描述一个内存单元，需要两种信息：内存单元的地址、内存单元的长度（类型） 用[0]表示一个内存单元时，0表示单元的偏移地址，段地址默认在ds中，单元的长度（类型）可以由具体指令中的其他操作对象（比如说寄存器）指出 [bx]同样也表示一个内存单元，它的偏移地址在bx中 loop：循环 用一个描述性的符号“（）”来表示一个寄存器或一个内存单元中的内容，（）中的内存单元的地址为物理地址 （）中的元素可以有3种类型：寄存器名、段寄存器名、内存单元的物理地址（一个20位数据） 约定符号idata表示常量—————————————————— ——————————————— loop指令的格式是：loop 标号CPU执行loop指令的时候，要进行两步操作：(cx)=(cx)-1、判断cx中的值，不为零则转至标号处执行程序，如果为零则向下执行【通常，我们用loop指令来实现循环功能，cx中存放循环次数】 assume cs:codecode segment mov ax,2 mov cx,11s: add ax,ax loop s mov ax,4c00h int 21h code endsend 1）在cx中存放循环次数2）loop指令中的标号所标识地址要在前面3）要循环执行的程序段，要写在标号和loop指令的中间—————————————— 在Debug中跟踪用loop指令实现的循环程序： 1）标号s前的指令我们已经确定在逻辑上完全正确，不想再一步一步跟踪了（g IP，直接跳转到IP值处） 2）循环也不想再一步一步跟踪了（遇到loop，直接p） ——————————————————— Debug和汇编编译器masm对指令的不同处理：","categories":[{"name":"硬件基础","slug":"硬件基础","permalink":"http://example.com/categories/%E7%A1%AC%E4%BB%B6%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"《汇编语言(第4版)》","slug":"《汇编语言-第4版-》","permalink":"http://example.com/tags/%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E7%AC%AC4%E7%89%88-%E3%80%8B/"}]},{"title":"用通配符进行过滤","slug":"数据库系统原理/《MySQL必知必会》/用通配符进行过滤","date":"2020-10-24T16:00:00.000Z","updated":"2021-03-24T13:40:16.000Z","comments":true,"path":"2020/10/25/数据库系统原理/《MySQL必知必会》/用通配符进行过滤/","link":"","permalink":"http://example.com/2020/10/25/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B/%E7%94%A8%E9%80%9A%E9%85%8D%E7%AC%A6%E8%BF%9B%E8%A1%8C%E8%BF%87%E6%BB%A4/","excerpt":"","text":"用通配符进行过滤 通配符：用来匹配值的一部分的特殊字符搜索模式：由字面值、通配符或两者组合构成的搜索条件 1）%表示任何字符出现的任意次数，下列找出所有以词jet起头的产品，%告诉MySQL接受jet之后的任意字符，不管它有多少字符SELECT prodid,prodnameFROM productsWHERE prod_name LIKE ‘jet%’; 2）搜索模式’%anvil%’表示匹配任何位置包含文本anvil的值，而不论它之前或之后出现什么字符SELECT prodid,prodnameFROM productsWHERE prod_name LIKE ‘%anvil%’; 3）下划线只匹配单个字符而不是多个字符SELECT prodid,prodnameFROM productsWHERE prodname LIKE ‘ ton anvil’; SELECT prodid,prodnameFROM productsWHERE prod_name LIKE ‘% ton anvil’;与%能匹配0个字符不一样，_总是匹配一个字符，不能多也不能少","categories":[{"name":"数据库系统原理","slug":"数据库系统原理","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"《MySQL必知必会》","slug":"《MySQL必知必会》","permalink":"http://example.com/tags/%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B/"}]},{"title":"临界区和锁","slug":"操作系统原理/操作系统原理/临界区和锁","date":"2020-10-24T16:00:00.000Z","updated":"2021-03-24T13:33:28.000Z","comments":true,"path":"2020/10/25/操作系统原理/操作系统原理/临界区和锁/","link":"","permalink":"http://example.com/2020/10/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E4%B8%B4%E7%95%8C%E5%8C%BA%E5%92%8C%E9%94%81/","excerpt":"","text":"临界区和锁： 临界资源：一次只允许一个进程独占访问（使用）的资源（共享变量i）临界区：进程中访问临界资源的程序段 临界区和临界资源的访问特点：1）具有排他性2）并发进程不能同时进入临界区 设计临界区访问机制的四个原则：1）忙则等待：当临界区忙时，其他进程必须在临界区外等待2）空闲让进：当无进程处于临界区时，任何有权进程可进入临界区3）有限等待：进程进入临界区的请求应在有限时间内得到满足4）让权等待：等待进程放弃CPU（让其他进程有机会得到CPU） 锁机制：1）基本原理：设置一个“标志”S，表明临界资源可用还是不可用2）上锁操作：进入临界区之前检查标志是否可用，若为不可用状态，进程在临界区外等待；若为可用状态，访问临界资源，且将标志修改为不可用3）开锁操作：退开临界区时将标志修改为可用状态","categories":[{"name":"操作系统原理","slug":"操作系统原理","permalink":"http://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"操作系统原理","slug":"操作系统原理","permalink":"http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"}]},{"title":"用正则表达式进行搜索","slug":"数据库系统原理/《MySQL必知必会》/用正则表达式进行搜索","date":"2020-10-23T16:00:00.000Z","updated":"2021-03-24T13:40:30.000Z","comments":true,"path":"2020/10/24/数据库系统原理/《MySQL必知必会》/用正则表达式进行搜索/","link":"","permalink":"http://example.com/2020/10/24/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B/%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BF%9B%E8%A1%8C%E6%90%9C%E7%B4%A2/","excerpt":"","text":"用正则表达式进行搜索 正则表达式是用来匹配文本的特殊的串（字符集合），正则表达式的作用是匹配文本，将一个模式（正则表达式）与一个文本串进行比较 1）检索列prod_name包含文本1000的所有行SELECT prod_nameFROM productsWHERE prod_name REGEXP ‘1000’ORDER BY prod_name; 2）SELECT prod_nameFROM productsWHERE prod_name REGEXP ‘.000’ORDER BY prod_name; 3）|为正则表达式的OR操作符，它表示匹配其中之一，使用|从功能上类似于在SELECT语句中使用OR语句，多个OR条件可并入单个正则表达式SELECT prod_nameFROM productsWHERE prod_name REGEXP ‘1000|2000’ORDER BY prod_name; 4）[123]定义一组字符，它的意思是匹配1或者2或者3，因此，1 ton 和2 ton都匹配且返回（没有 3 ton）,[123] Ton为[1|2|3] Ton的缩写SELECT prod_nameFROM productsWHERE prod_name REGEXP ‘[123] Ton’ORDER BY prod_name; MySQL假定你的意思是‘1’或‘2’或‘3 ton’，除非你把字符｜括在一个集合中，否则它将应用于整个串SELECT prod_nameFROM productsWHERE prod_name REGEXP ‘1|2|3 Ton’ORDER BY prod_name; [^123]匹配除这些字符外的任何东西 5）SELECT prod_nameFROM productsWHERE prod_name REGEXP ‘[1-5] Ton’ORDER BY prod_name; 6）.匹配任意字符，因此每个行都被检索出来SELECT vend_nameFROM vendorsWHERE vend_name REGEXP ‘.’ORDER BY vend_name; 为了匹配特殊字符，必须用\\为前导。\\-表示查找-，\\.表示查找.SELECT vend_nameFROM vendorsWHERE vend_name REGEXP ‘\\.’ORDER BY vend_name; 7) 8)SELECT prod_nameFROM productsWHERE prod_name REGEXP ‘\\([0-9] sticks?\\)’ORDER BY prod_name; SELECT prod_nameFROM productsWHERE prod_name REGEXP ‘:digit:{4}’ORDER BY prod_name; 9)SELECT prod_nameFROM productsWHERE prod_name REGEXP ‘^[0-9\\.]’ORDER BY prod_name;","categories":[{"name":"数据库系统原理","slug":"数据库系统原理","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"《MySQL必知必会》","slug":"《MySQL必知必会》","permalink":"http://example.com/tags/%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B/"}]},{"title":"同步和P-V操作","slug":"操作系统原理/操作系统原理/同步和P-V操作","date":"2020-10-23T16:00:00.000Z","updated":"2021-03-24T13:33:39.000Z","comments":true,"path":"2020/10/24/操作系统原理/操作系统原理/同步和P-V操作/","link":"","permalink":"http://example.com/2020/10/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E5%90%8C%E6%AD%A5%E5%92%8CP-V%E6%93%8D%E4%BD%9C/","excerpt":"","text":"同步和P-V操作： 进程的互斥关系：多个进程由于共享了独占性资源，必须协调各进程对资源的存取顺序，确保没有任何两个或以上的进程同时进行存取操作互斥和资源共享相关资源：临界资源存取操作区域：临界区 进程的同步关系：若干合作进程为了完成一个共同的任务，需要相互协调运行步伐，一个进程开始某个操作之前必须要求另一个进程已经完成某个操作，否则前面的进程只能等待【另一解释：合作进程中某些操作之间需要满足某种先后关系或某个操作能否进行需要满足某个前提条件，否则只能等待】 互斥关系属于特殊的同步关系 信号灯是一种卓有成效的进程同步机制 信号灯用于进程同步的基本思想：进程在运行过程受信号灯状态控制，并能改变信号灯状态【信号灯的状态可以阻塞或唤醒进程；信号灯的状态可以被进程改变】 信号灯的两个操作：1）P操作（函数或过程，P(S,q)）2）V操作（函数或过程，V(S,q)）————————————— P-V操作解决互斥问题：实质是实现对临界区的互斥访问，允许最多一个进程处于临界区 应用过程（S的初值设置要合理）：1）进入临界区之前先执行P操作（可能阻塞当前进程）2）离开临界区之后再执行V操作（可能唤醒某个进程）————————————— P-V操作解决同步问题： ——————————— 经典同步问题： 生产者和消费者问题","categories":[{"name":"操作系统原理","slug":"操作系统原理","permalink":"http://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"操作系统原理","slug":"操作系统原理","permalink":"http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"}]},{"title":"创建计算字段","slug":"数据库系统原理/《MySQL必知必会》/创建计算字段","date":"2020-10-22T16:00:00.000Z","updated":"2021-03-24T13:40:42.000Z","comments":true,"path":"2020/10/23/数据库系统原理/《MySQL必知必会》/创建计算字段/","link":"","permalink":"http://example.com/2020/10/23/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B/%E5%88%9B%E5%BB%BA%E8%AE%A1%E7%AE%97%E5%AD%97%E6%AE%B5/","excerpt":"","text":"创建计算字段 计算字段并不实际存在于数据库表中，计算字段是运行时在SELECT语句内创建的 字段：基本上与列的意思相同，经常互换使用，不过数据库列一般称为列，而术语字段通常用在计算字段的连接上 只有数据库知道SELECT语句中哪些列是实际的表列，哪些列是计算字段。从客户机（如应用程序）的角度来看，计算字段的数据是以与其他列的数据相同的方式返回的 拼接：将值联结到一起构成单个值 1）SELECT Concat(vendname，‘ （’，vendcountry，‘）’）FROM vendorsORDER BY vend_name; RTrim()函数去掉值右边的所有空格，通过使用RTrim()，各个列都进行了整理SELECT Concat(RTrim(vendname)，‘ （’，RTrim(vendcountry)，‘）’）FROM vendorsORDER BY vend_name; 2）别名是一个字段或值的替换名，别名用AS关键字赋予SELECT Concat(RTrim(vendname)，‘ （’，RTrim(vendcountry)，‘）’）AS vend_titleFROM vendorsORDER BY vend_name; 3)检索订单号20005中的所有物品SELECT prodid,quantity,itempriceFROM orderitemsWHERE order_num=20005; item_price列包含订单中每项物品的单价，如下汇总物品的价格（单价乘以订购数量）SELECT prod_id, quantity, item_price, quantity*itemprice AS expandedpriceFROM orderitemsWHERE order_num=20005;","categories":[{"name":"数据库系统原理","slug":"数据库系统原理","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"《MySQL必知必会》","slug":"《MySQL必知必会》","permalink":"http://example.com/tags/%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B/"}]},{"title":"进程通信","slug":"操作系统原理/操作系统原理/进程通信","date":"2020-10-22T16:00:00.000Z","updated":"2021-03-24T13:33:51.000Z","comments":true,"path":"2020/10/23/操作系统原理/操作系统原理/进程通信/","link":"","permalink":"http://example.com/2020/10/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/","excerpt":"","text":"进程通信： Windows匿名管道通信： 管道（pipe）：进程间的一种通信机制，一个进程（A）可以通过管道把数据传输给另外一个进程（B），前者向管道输入数据，后者从管道读取数据 Linux信号通信： 信号：1）信号是Linux进程间一种重要的通信机制2）信号是向进程发送的一个通知，通知某个事件已发生3）收到信号的进程可以立即执行指定的操作4）信号的发出可以是进程，也可以是系统（含硬件） 信号的产生：1）键盘输入特殊组合键产生信号（Ctrl+C）2）执行终端命令产生信号（kill系列命令）3）程序中调用函数产生信号：kill(),abort()4）硬件异常或内核产生相应信号：内存访问错","categories":[{"name":"操作系统原理","slug":"操作系统原理","permalink":"http://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"操作系统原理","slug":"操作系统原理","permalink":"http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"}]},{"title":"使用数据处理函数","slug":"数据库系统原理/《MySQL必知必会》/使用数据处理函数","date":"2020-10-21T16:00:00.000Z","updated":"2021-03-24T13:40:53.000Z","comments":true,"path":"2020/10/22/数据库系统原理/《MySQL必知必会》/使用数据处理函数/","link":"","permalink":"http://example.com/2020/10/22/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B/%E4%BD%BF%E7%94%A8%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0/","excerpt":"","text":"使用数据处理函数 1）文本处理函数Upper()SELECT vendname,Upper(vendname) AS vendnameupcaseFROM vendorsORDER BY vend_name; 2)日期和时间处理函数 SELECT custid,ordernumFROM ordersWHERE order_date=‘2005-09-01’;SELECT custid,ordernumFROM ordersWHERE Date(order_date)=‘2005-09-01’; 检索出2005年9月下的所有订单法1:SELECT custid,ordernumFROM ordersWHERE Date(order_date) BETWEEN ‘2005-09-01’ AND ‘2005-09-30’; 法2:SELECT custid,ordernumFROM ordersWHERE Year(orderdate)=2005 AND Month(orderdate)=9; 3)数值处理函数","categories":[{"name":"数据库系统原理","slug":"数据库系统原理","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"《MySQL必知必会》","slug":"《MySQL必知必会》","permalink":"http://example.com/tags/%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B/"}]},{"title":"死锁","slug":"操作系统原理/操作系统原理/死锁","date":"2020-10-21T16:00:00.000Z","updated":"2021-03-24T13:34:01.000Z","comments":true,"path":"2020/10/22/操作系统原理/操作系统原理/死锁/","link":"","permalink":"http://example.com/2020/10/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%AD%BB%E9%94%81/","excerpt":"","text":"死锁： ————————————— 4-1：死锁概念 4-2：死锁起因 4-3：死锁预防策略 ————————————— 死锁：两个或多个进程无限期的等待永远不会发生的条件的一种系统状态（结果每个进程都永远阻塞） 另一个定义：在两个或多个进程中，每个进程都持有某种资源，但又继续申请其他进程已持有的某种资源。此时每个进程都拥有其运行所需的一部分资源，但是又都不够，从而每个进程都不能向前推进，陷于阻塞状态，这种状态称死锁—————————————— 死锁的起因：1）系统资源有限：资源数目不足，进程对资源的竞争而产生死锁2）并发进程的推进顺序不当：进程请求资源和释放资源的顺序不当，导致死锁3）不正确的P-V操作导致死锁 A，B尽管并发争用i，j，且发生了阻塞，但是没有死锁不正确的推进顺序发生死锁：不正确的P-V操作也可能会带来死锁：生产者和消费者问题 死锁的一些结论：1）参与死锁的进程至少是两个，两个或以上进程才会出现死锁2）参与死锁的进程至少有两个已经占有资源3）参与死锁的所有进程都在等待资源4）参与死锁的进程是当前系统中所有进程的子集5）死锁会浪费大量系统资源，甚至导致系统崩溃—————————————— 死锁的必要条件：1）互斥条件：进程互斥使用资源，，资源具有独占性2）不剥夺条件：进程在访问完资源前不能被其他进程强行剥夺3）部分分配条件：进程边运行边申请资源，临时需要临时分配（区别于全部分配）4）环路条件：多个进程构成环路，环中每个进程已占用的资源被前一进程申请，而自己所申请资源又被环中后一进程占用着 解决死锁的策略： 1）预防死锁：通过设置某些限制条件，破坏死锁四个必要条件中的一个或多个，来防止死锁 较易实现，早期广泛使用，缺点：由于限制太严格，导致资源利用率和吞吐量降低 2）避免死锁：不事先采取限制去破坏产生死锁的条件，而是在资源分配过程中，用某种方法去评估若分配资源是否会让系统进入死锁状态，若是，则拒绝此次分配资源，从而避免死锁的发生（银行家算法） 只需要较弱的限制条件，可获得较高的资源利用率和系统吞吐量，缺点：实现较难 3）检测和恢复死锁：允许死锁发生，但可通过检测机制及时检测出死锁状态，并精确确定与死锁有关的进程和资源，然后采取适当措施，将系统中已发生的死锁清除，将进程从死锁状态解脱出来 缺点：1）检测方法复杂，实现难度大2）恢复方法靠人工，撤销一些进程，回收资源再分配 Windows，Linux采用的死锁解决方案：鸵鸟策略","categories":[{"name":"操作系统原理","slug":"操作系统原理","permalink":"http://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"操作系统原理","slug":"操作系统原理","permalink":"http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"}]},{"title":"汇总数据","slug":"数据库系统原理/《MySQL必知必会》/汇总数据","date":"2020-10-20T16:00:00.000Z","updated":"2021-03-24T13:41:05.000Z","comments":true,"path":"2020/10/21/数据库系统原理/《MySQL必知必会》/汇总数据/","link":"","permalink":"http://example.com/2020/10/21/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B/%E6%B1%87%E6%80%BB%E6%95%B0%E6%8D%AE/","excerpt":"","text":"汇总数据 聚集函数：运行在行组上，计算和返回单个值的函数 1）AVG()函数：AVG()通过对表中行数计算并计算特定列值之和，求得该列的平均值。AVG()可用来返回所有列的平均值，也可以用来返回特定列或行的平均值 返回products表中所有产品的平均价格SELECT AVG(prodprice) AS avgpriceFROM products; 返回特定供应商所提供产品的平均价格SELECT AVG(prodprice) AS avgpriceFROM productsWHERE vend_id =1003; 2)COUNT()函数 返回customers表中客户的总数：SELECT COUNT(*) AS num_custFROM customers; 只对具有电子邮件地址的客户计数SELECT COUNT(custemail) AS numcustFROM customers; 3)MAX()函数：要求指定列名SELECT MAX(prodprice) AS maxpriceFROM products; 4)MIN()函数：要求指定列名SELECT MIN(prodprice) AS minpriceFROM products; 5)SUM()函数：用来返回指定列值的和（总计） 检索所订购物品的总数（所有quantity值之和）SELECT SUM(quantity) AS items_orderedFROM orderitemsWHERE order_num=20005; 合计每项物品的items_pricequantity，得到总的订单金额SELECT SUM(itempricequantity) AS totalpriceFROM orderitemsWHERE order_num=20005; 6)聚集不同值 7）组合聚集函数SELECT COUNT(*) AS num_items, MIN(prodprice) AS pricemin, MAX(prodprice) AS pricemax, AVG(prodprice) AS priceavgFROM products;","categories":[{"name":"数据库系统原理","slug":"数据库系统原理","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"《MySQL必知必会》","slug":"《MySQL必知必会》","permalink":"http://example.com/tags/%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B/"}]},{"title":"进程调度","slug":"操作系统原理/操作系统原理/进程调度","date":"2020-10-20T16:00:00.000Z","updated":"2021-03-24T13:34:12.000Z","comments":true,"path":"2020/10/21/操作系统原理/操作系统原理/进程调度/","link":"","permalink":"http://example.com/2020/10/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/","excerpt":"","text":"进程调度： ———————————— 5-1：进程调度概念 5-2：典型调度算法 ———————————— 在合适的时候以一定的策略选择一个就绪进程运行 进程调度的目标：1）响应速度尽可能快2）进程处理的时间尽可能短3）系统吞吐量尽可能大4）资源利用率尽可能高5）对所有进程要公平6）避免饥饿7）避免死锁 进程调度两个量化的衡量指标：1）周转时间/平均周转时间 2）带权周转时间/平均带权周转时间 ——————————————— 典型调度算法：1）先来先服务调度2）短作业优先调度算法3）响应比高者优先调度算法4）优先数调度算法5）循环轮转调度法 可变时间片轮转调度法 多重时间片循环调度法","categories":[{"name":"操作系统原理","slug":"操作系统原理","permalink":"http://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"操作系统原理","slug":"操作系统原理","permalink":"http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"}]},{"title":"分组数据","slug":"数据库系统原理/《MySQL必知必会》/分组数据","date":"2020-10-19T16:00:00.000Z","updated":"2021-03-24T13:41:27.000Z","comments":true,"path":"2020/10/20/数据库系统原理/《MySQL必知必会》/分组数据/","link":"","permalink":"http://example.com/2020/10/20/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B/%E5%88%86%E7%BB%84%E6%95%B0%E6%8D%AE/","excerpt":"","text":"分组数据 分组允许把数据分为多个逻辑组，以便能对每个组进行聚集计算 1）SELECT vendid,COUNT(*) AS numprodsFROM productsGROUP BY vend_id; 2)WHERE过滤行，HAVING过滤分组SELECT cust_id,COUNT() AS ordersFROM ordersGROUP BY cust_idHAVING COUNT() &gt;=2; 这里WHERE子句不起作用，因为过滤是基于分组聚集值而不是特定行值的 3）列出具有2个（含）以上、价格为10（含）以上的产品的供应商SELECT vendid,COUNT() AS numprodsFROM productsWHERE prod_price &gt;=10GROUP BY vend_idHAVING COUNT() &gt;=2; SELECT vendid,COUNT() AS numprodsFROM productsGROUP BY vend_idHAVING COUNT() &gt;=2; 4）检索总计订单价格大于等于50的订单号和总计订单价格SELECT ordernum,SUM(quantityitemprice) AS ordertotalFROM orderitemsGROUP BY order_numHAVING SUM(quantityitem_price) &gt;= 50; 按总计订单价格排序输出：SELECT ordernum,SUM(quantityitemprice) AS ordertotalFROM orderitemsGROUP BY order_numHAVING SUM(quantityitem_price) &gt;= 50ORDER BY ordertotal; 5）","categories":[{"name":"数据库系统原理","slug":"数据库系统原理","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"《MySQL必知必会》","slug":"《MySQL必知必会》","permalink":"http://example.com/tags/%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B/"}]},{"title":"存储管理","slug":"操作系统原理/操作系统原理/存储管理","date":"2020-10-19T16:00:00.000Z","updated":"2021-03-24T13:34:23.000Z","comments":true,"path":"2020/10/20/操作系统原理/操作系统原理/存储管理/","link":"","permalink":"http://example.com/2020/10/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/","excerpt":"","text":"存储管理： ——————————————— 6-1：内存管理功能 6-2：物理内存管理 6-2-1.分区内存管理 6-2-2.分区放置策略 6-2-3.内存覆盖技术 6-2-4.内存交换技术 6-2-5.内存碎片 6-3：虚拟内存管理 6-3-1.页式虚拟内存管理概念 6-3-2.页表和页式地址映射 6-3-3.快表技术和页面共享技术 6-3-4.缺页中断 6-3-5.页面淘汰策略 6-3-6.缺页因素与页式系统缺点 6-3-7.段式和段页式虚拟存储 ———————————————","categories":[{"name":"操作系统原理","slug":"操作系统原理","permalink":"http://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"操作系统原理","slug":"操作系统原理","permalink":"http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"}]},{"title":"使用子查询","slug":"数据库系统原理/《MySQL必知必会》/使用子查询","date":"2020-10-18T16:00:00.000Z","updated":"2021-03-24T13:41:40.000Z","comments":true,"path":"2020/10/19/数据库系统原理/《MySQL必知必会》/使用子查询/","link":"","permalink":"http://example.com/2020/10/19/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B/%E4%BD%BF%E7%94%A8%E5%AD%90%E6%9F%A5%E8%AF%A2/","excerpt":"","text":"使用子查询 查询：任何SQL语句都是查询，但此术语一般指SELECT语句 1）列出订购物品TNT2的所有客户： 法1:SELECT order_numFROM orderitemsWHERE prod_id=’TNT2’; SELECT cust_idFROM ordersWHERE order_num IN(20005,20007); SELECT custname,custcontactFROM customersWHERE cust_id IN(10001,10004); 法2:(在SELECT语句中，子查询总是从内向外处理)SELECT custname,custcontactFROM customersWHERE custid IN(SELECT custid FROM orders WHERE ordernum IN(SELECT ordernum FROM orderitems WHERE prod_id=’TNT2’)); 法3:SELECT custname,custcontactFROM customers,orders,orderitemsWHERE customers.custid=orders.custid AND orderitems..ordernum=orders.ordernum AND prod_id=’TNT2’; 2)显示customers表中每个客户的订单总数SELECT custname,custstate, (SELECT COUNT(*) FROM orders WHERE orders.custid=customers.custid) AS ordersFROM customersORDER BY cust_name; 相关子查询：涉及外部查询的子查询","categories":[{"name":"数据库系统原理","slug":"数据库系统原理","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"《MySQL必知必会》","slug":"《MySQL必知必会》","permalink":"http://example.com/tags/%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B/"}]},{"title":"内存管理功能","slug":"操作系统原理/操作系统原理/内存管理功能","date":"2020-10-18T16:00:00.000Z","updated":"2021-03-24T13:34:35.000Z","comments":true,"path":"2020/10/19/操作系统原理/操作系统原理/内存管理功能/","link":"","permalink":"http://example.com/2020/10/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%8A%9F%E8%83%BD/","excerpt":"","text":"内存管理功能： 存储器功能需求：1）容量足够大2）速度足够快3）信息永久保存4）多道程序并行 多道程序并行带来的问题：1）共享：代码和数据共享，节省内存2）保护：不允许内存中的程序相互间非法访问 存储管理的功能： 1）地址映射(地址重定位/地址重映射)：把程序中的地址（虚拟地址/虚地址/逻辑地址）变换成内存的真实地址（实地址/物理地址）的过程 方式：a.固定地址映射：编程或编译时确定逻辑地址和物理地址映射关系（特点：程序加载时必须放在指定的内存区域，容易产生地址冲突，运行失败） b.静态地址映射：程序装入时由操作系统完成逻辑地址到物理地址的映射 特点：1.程序运行之前确定映射关系2.程序装入后不能移动，如果移动必须放回原来位置3.程序占用连续的内存空间 c.动态地址映射 2）虚拟存储解决的问题：1）程序过大或过多时，内存不够，不能运行2）多个程序并发时地址冲突，不能运行 3）内存分配：为程序运行分配足够的内存空间需要解决的问题：1）放置策略：程序调入内存时将其放置在哪个/哪些内存区2）调入策略：何时把要运行的代码和要访问的数据调入内存3）淘汰策略：内存空间不够时，迁出/淘汰哪些代码或数据以腾出内存空间 4）存储保护：保证在内存中的多道程序只能在给定的存储区域内活动并互不干扰【防止访问越界，防止访问越权】","categories":[{"name":"操作系统原理","slug":"操作系统原理","permalink":"http://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"操作系统原理","slug":"操作系统原理","permalink":"http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"}]},{"title":"联结表、内部联结或等值联结","slug":"数据库系统原理/《MySQL必知必会》/联结表、内部联结或等值联结","date":"2020-10-17T16:00:00.000Z","updated":"2021-03-24T13:41:52.000Z","comments":true,"path":"2020/10/18/数据库系统原理/《MySQL必知必会》/联结表、内部联结或等值联结/","link":"","permalink":"http://example.com/2020/10/18/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B/%E8%81%94%E7%BB%93%E8%A1%A8%E3%80%81%E5%86%85%E9%83%A8%E8%81%94%E7%BB%93%E6%88%96%E7%AD%89%E5%80%BC%E8%81%94%E7%BB%93/","excerpt":"","text":"联结表【内部联结或等值联结】 联结是一种机制，用来在一条SELECT语句中关联表，使用特殊的语法，可以联结多个表返回一组输出，联结在运行时关联表中正确的行 1）SELECT vendname,prodname,prod_priceFROM vendors,productsWHERE vendors.vendid=products.vendidORDER BY vendname,prodname; 笛卡尔积：由没有联结条件的表关系返回的结果为笛卡尔积，检索出的行的数目将是第一个表中的行数乘以第二个表中的行数SELECT vendname,prodname,prod_priceFROM vendors,productsORDER BY vendname,prodname; 2）SELECT vendname,prodname,prod_priceFROM vendors INNER JOIN productsON vendors.vendid=products.vendid; 3)SELECT prodname,vendname,prod_price,quantityFROM orderitems,products,vendorsWHERE products.vendid=vendors.vendid AND orderitems.prodid=products.prodid AND order_num=20005;","categories":[{"name":"数据库系统原理","slug":"数据库系统原理","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"《MySQL必知必会》","slug":"《MySQL必知必会》","permalink":"http://example.com/tags/%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B/"}]},{"title":"物理内存管理","slug":"操作系统原理/操作系统原理/物理内存管理","date":"2020-10-17T16:00:00.000Z","updated":"2021-03-24T13:34:46.000Z","comments":true,"path":"2020/10/18/操作系统原理/操作系统原理/物理内存管理/","link":"","permalink":"http://example.com/2020/10/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/","excerpt":"","text":"物理内存管理： ————————————————— 分区内存管理： 分区存储管理方式： 1）单一区存储管理(不分区存储管理)：用户区不分区，完全被一个程序占用（DOS） 优点：简单，不需要复杂硬件支持，适于单用户单任务OS 缺点：程序运行占用整个内存，即使小程序也是如此，内存浪费，利用率低 2）分区存储管理：把用户区内存划分为若干大小不等的分区，供不同程序使用，适合单用户单任务系统 a.固定分区：把内存固定的划分为若干个大小不等的分区供各个程序使用，每个分区的大小和位置都固定，系统运行期间不再重新划分 分区表：记录分区的位置、大小和使用标志固定分区的使用特点：1）在程序装入前，内存已被分区，不再改变2）每个分区大小不同，适应不同大小的程序3）系统要维护分区表 b.动态分区：在程序装入时创建分区，使分区的大小刚好与程序的大小相等 特点：分区动态建立————————————————— 分区放置策略： 分区的分配： 放置策略（空闲区表排序原则）：1）首次适应算法：按空闲区位置（首址）递增排序2）按空闲区位置（首址）递减排序3）最佳适应算法：按空闲区大小的递增排序4）最坏适应算法：按空闲区大小的递减排序 分区的回收：回收程序释放分区（释放区），登记到空闲区表中，以便再分配——————————————— 内存覆盖技术： 覆盖的缺点：1）编程复杂：程序员划分程序模块并确定覆盖关系2）程序执行时间长：从外存装入内存耗时———————————————— 内存交换技术： ———————————————— 内存碎片： 碎片问题： 动态分区的缺点：容易产生内存碎片（内存反复分配和分割）【其中最佳适应法最容易产生碎片，最坏适应法最不容易产生碎片】","categories":[{"name":"操作系统原理","slug":"操作系统原理","permalink":"http://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"操作系统原理","slug":"操作系统原理","permalink":"http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"}]},{"title":"创建高级联结、自联结、自然联结、外部联结","slug":"数据库系统原理/《MySQL必知必会》/创建高级联结、自联结、自然联结、外部联结","date":"2020-10-16T16:00:00.000Z","updated":"2021-03-24T13:42:04.000Z","comments":true,"path":"2020/10/17/数据库系统原理/《MySQL必知必会》/创建高级联结、自联结、自然联结、外部联结/","link":"","permalink":"http://example.com/2020/10/17/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B/%E5%88%9B%E5%BB%BA%E9%AB%98%E7%BA%A7%E8%81%94%E7%BB%93%E3%80%81%E8%87%AA%E8%81%94%E7%BB%93%E3%80%81%E8%87%AA%E7%84%B6%E8%81%94%E7%BB%93%E3%80%81%E5%A4%96%E9%83%A8%E8%81%94%E7%BB%93/","excerpt":"","text":"创建高级联结【自联结、自然联结、外部联结】 别名除了用于列名和计算字段外，SQL还允许给表名起别名，这样做有两个主要理由：1）缩短SQL语句2）允许在单条SELECT语句中多次使用相同的表 1）表别名不仅能用于WHERE子句，它还可以用于SELECT的列表、ORDER BY子句以及语句的其他部分，表别名只在查询执行中使用，与列别名不一样，表别名不返回到客户机SELECT custname,custcontactFROM customers AS c,orders AS o,orderitems AS oiWHERE c.custid=o.custid AND oi.ordernum=o.ordernum AND prod_id=’TNT2’; 2）自联结首先找到生产ID为DTNTR的物品的供应商，然后找出这个供应商生产的其他物品SELECT prodid,prodnameFROM productsWHERE vendid =(SELECT vendid FROM products WHERE prod_id=‘DTNTR’); SELECT p1.prodid,p1.prodnameFROM products AS p1,products AS p2WHERE p1.vendid=p2.vendid AND p2.prod_id=‘DTNTR’; 3)无论何时对表进行联结，应该至少有一个列出现在不止一个表中（被联结的列），标准的联结返回所有数据，甚至相同的列多次出现。自然联结排除多次出现，使每个列只返回一次 4）联结包含了那些在相关表中没有关联行的行，这种类型的联结称为外部联结 检索所有客户及其订单（内部联结）SELECT customers.custid,orders.ordernumFROM customers INNER JOIN orders ON customers.custid=orders.custid; 为了检索所有客户，包括那些没有订单的客户（外部联结）：SELECT customers.custid,orders.ordernumFROM customers LEFT OUTER JOIN orders ON customers.custid=orders.custid; 5)检索所有客户及每个客户所下的订单数SELECT customers.cust_name, customers.cust_id, COUNT(orders.ordernum) AS numordFROM customers INNER JOIN orders ON customers.custid=orders.custidGROUP BY customers.cust_id; 6)SELECT customers.cust_name, customers.cust_id, COUNT(orders.ordernum) AS numordFROM customers LEFT OUTER JOIN orders ON customers.custid=orders.custidGROUP BY customers.cust_id;","categories":[{"name":"数据库系统原理","slug":"数据库系统原理","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"《MySQL必知必会》","slug":"《MySQL必知必会》","permalink":"http://example.com/tags/%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B/"}]},{"title":"虚拟内存管理","slug":"操作系统原理/操作系统原理/虚拟内存管理","date":"2020-10-16T16:00:00.000Z","updated":"2021-03-24T13:34:57.000Z","comments":true,"path":"2020/10/17/操作系统原理/操作系统原理/虚拟内存管理/","link":"","permalink":"http://example.com/2020/10/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/","excerpt":"","text":"虚拟内存管理： ———————————————— 页式虚拟内存管理概念： 虚拟内存管理的目标：1）使得大的程序能在较小的内存中运行2）使得多个程序能在较小的内存中运行（能容纳下）3）使得多个程序并发运行时地址不冲突4）使得内存利用效率高：无碎片，共享方便 虚拟内存管理的实现思路：在程序运行时，只把当前必要的很小一部分代码和数据装入内存中，其余代码和数据需要时再装入，不再运行的代码和数据及时从内存删除，实际内存很容易就能满足上述的内存需求 程序运行的局部性：程序在一个有限的时间段内访问的代码和数据往往集中在有限的地址范围内，把程序一部分装入内存在较大概率上也足够让其运行一小段时间 典型虚拟内存管理方式：1）页式虚拟存储管理2）段式虚拟存储管理3）段页式虚拟存储管理 页式虚拟存储管理：进程装入和使用内存的原则：————————————————— 页表和页式地址映射： 页式系统中的地址： 虚拟地址(VA)可以分解成页号P和页内偏移W1）页号P=VA/页的大小2）页内偏移W=VA%页的大小 页面映射表：记录页与页框之间的对应关系，也叫页表页号：登记程序地址的页号页框号：登记页所在的物理页号页面其他特性：登记含存取权限在内的其他特性 页式地址映射：虚拟地址（页式地址）—&gt; 物理地址 过程：1）从VA分离页号P和页内偏移W2）查页表：以P为索引查页框号P‘3）计算物理地址MA：MA=P’ * 页大小 + W ————————————— 快表技术和页面共享技术； 快表机制（Cache）： 快表的概念：1）慢表：页表放在内存中2）快表：页表放在Cache中 快表的特点：1）容量小，访问快，成本高2）快表是慢表的部分内容的复制3）地址映射时优先访问快表【若在快表中找到所需数据，则称为“命中”；没有命中时，需要访问慢表，同时更新快表】4）合理的页面调度策略能使快表具有较高命中率 快表机制下地址映射过程： 页面的共享原理：1）在不同进程的页表中填上相同的页框号，多个进程能访问相同的内存空间，从而实现页面共享2）共享页面在内存只有一份真实存储，节省内存 ———————————————— 缺页中断： 分级存储体系：Cache+内存+辅存 页表扩充：带中断位的页表 扩充有中断位和辅存地址的页表：中断位I：标识该页是否在内存【1:不在内存；0:在内存】辅存地址：该页在辅存上的位置 扩充有访问位和修改位的页表：访问位：标识该页最近是否被访问【0:最近没有被访问；1:最近已被访问】修改位：标识该页的数据是否已被修改【0:该页未被修改；1:该页已被修改】 缺页中断定义：在地址映射过程中，当所要访问的目的页不在内存时，则系统产生异常中断 缺页中断处理程序：中断处理程序把所缺的页从页表指出的辅存地址调入内存的某个页框中，并更新页表中该页对应的页框号以及修改中断位I为0 访存指令的执行过程(含缺页中断处理)： 缺页（中断）率f=缺页次数/访问页面总次数命中率=1-f —————————————— 页面淘汰策略： 淘汰策略：选择淘汰哪一页的规则称淘汰策略 页面抖动：页面在内存和辅存间频繁交换的现象，“抖动”会导致系统效率下降 好的淘汰策略具有较低的缺页率（高命中率），页面抖动较少 常用的淘汰算法：1）最佳算法（OPT算法）2）先进先出淘汰算法（FIFO算法）3）最久未使用淘汰算法（LRU算法）4）最不经常使用（LFU）算法 最佳算法（OPT算法，Optimal）：淘汰以后不再需要或最远的将来才会用到的页面【理论上最佳，实践中该算法无法实现】 先进先出淘汰算法（FIFO算法）：淘汰在内存中停留时间最长的页面 优点：实现简单，页面按进入内存的时间排序，淘汰队头页面 缺点：进程只有按顺序访问地址空间时页面命中率才最理想 异常现象：对于一些特定的访问序列，随分配的页框增多，缺页率反而增加 最久未使用淘汰算法（LRU，Least Recently Used）：淘汰最长时间未被使用的页面 最不经常使用（LFU，Least Frequently Used）算法：选择到当前时间为止被访问次数最少的页面，每页设置访问计数器，每当页面被访问时，该页面的访问计数器加1，发生缺页中断时，淘汰计数值最小的页面，并将所有计数清零 ——————————————————— 缺页因素与页式系统缺点： 缺页的因素：1）淘汰算法2）分配给进程的页框数：页框越少，越容易缺页3）页面的大小选择：【页面太大：浪费内存，极限是分区存储；页面太小：页面增多，页表长度增加，浪费内存，换页频繁，系统效率低】【页面的常见大小：2的整数次幂，1KB，2KB，4KB】【页面越小，容易缺页】4）程序的编制方法：局部性越好，越不容易缺；跳转或分支越多越容易缺页 页式系统的不足：1）页面划分无逻辑含义2）页的共享不灵活3）页内碎片 ———————————————————— 段式和段页式虚拟存储： 段式存储管理： 进程分段：把进程按逻辑意义划分为多个段，每段有段名，长度不定，进程由多段组成 段式内存管理系统的内存分配：以段为单位装入，每段分配连续的内存；但是段和段不要求相邻 段式系统的虚拟地址：段式虚拟地址VA包括段号S和段内偏移W【VA：（S，W）】 段式地址的映射机制： 段式地址映射过程：1）由逻辑地址VA分离出（S，W）2）查询段表：检索段号S，查询该段基地址B和长度L3）物理地址MA=B+W 段的共享：1）共享段在内存中只有一份存储2）共享段被多个进程映射到各自段表3）需要共享的模块都可以设置为单独的段 段式系统的缺点：1）段需要连续的存储空间2）段的最大尺寸受到内存大小的限制3）在辅存中管理可变尺寸的段比较困难 段式系统 VS 页式系统：1）地址空间的区别：页式系统是一维地址空间，段式系统是二维地址空间2）段与页的区别：段长可变，页面大小固定段的划分有意义，页面无意义段方便共享，页面不方便共享段用户可见，页面用户不可见段偏移有溢出，页面偏移无溢出 段页式存储管理：在段式存储管理中结合页式存储管理技术，在段中划分页面 段页式地址的映射机构：同时采用段表和页表实现地址映射系统为每个进程建立一个段表系统为每个段建立一个页表段表给出每段的页表基地址及页表长度（段长）页表给出每页对应的页框","categories":[{"name":"操作系统原理","slug":"操作系统原理","permalink":"http://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"操作系统原理","slug":"操作系统原理","permalink":"http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"}]},{"title":"组合查询","slug":"数据库系统原理/《MySQL必知必会》/组合查询","date":"2020-10-15T16:00:00.000Z","updated":"2021-03-24T13:42:16.000Z","comments":true,"path":"2020/10/16/数据库系统原理/《MySQL必知必会》/组合查询/","link":"","permalink":"http://example.com/2020/10/16/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B/%E7%BB%84%E5%90%88%E6%9F%A5%E8%AF%A2/","excerpt":"","text":"组合查询 MySQL也允许执行多个查询（多条SELECT语句），并将结果作为单个查询结果集返回，这些组合查询通常称为并或复合查询 1）假如需要价格小于等于5的所有物品的一个列表，而且还想包括供应商1001和1002生产的所有物品（不考虑价格） 法1:SELECT vendid,prodid,prod_priceFROM productsWHERE prod_price&lt;=5; SELECT vendid,prodid,prod_priceFROM productsWHERE vend_id IN(1001,1002); 法2:SELECT vendid,prodid,prod_priceFROM productsWHERE prod_price&lt;=5;UNIONSELECT vendid,prodid,prod_priceFROM productsWHERE vend_id IN(1001,1002); UNION从查询结果集中自动去除了重复的行，这是UNION的默认行为，但是如果需要，可以改变它，事实上，如果想返回所有匹配行，可使用UNION ALL而不是UNIONSELECT vendid,prodid,prod_priceFROM productsWHERE prod_price&lt;=5;UNION ALLSELECT vendid,prodid,prod_priceFROM productsWHERE vend_id IN(1001,1002); 2）SELECT语句的输出用ORDER BY子句排序。在用UNION组合查询时，只能使用一条ORDER BY子句，它必须出现在最后一条SELECT语句之后。对于结果集，不存在用一种方式排序一部分，而又用另一种方式排序另一部分的情况。因此不允许使用多条ORDER BY子句SELECT vendid,prodid,prod_priceFROM productsWHERE prod_price&lt;=5;UNIONSELECT vendid,prodid,prod_priceFROM productsWHERE vend_id IN(1001,1002)ORDER BY vendid,prodprice;","categories":[{"name":"数据库系统原理","slug":"数据库系统原理","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"《MySQL必知必会》","slug":"《MySQL必知必会》","permalink":"http://example.com/tags/%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B/"}]},{"title":"设备管理","slug":"操作系统原理/操作系统原理/设备管理","date":"2020-10-15T16:00:00.000Z","updated":"2021-03-24T13:35:08.000Z","comments":true,"path":"2020/10/16/操作系统原理/操作系统原理/设备管理/","link":"","permalink":"http://example.com/2020/10/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/","excerpt":"","text":"设备管理： ———————————————— 7-1.设备管理概念 7-2.Spooling系统 ————————————————","categories":[{"name":"操作系统原理","slug":"操作系统原理","permalink":"http://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"操作系统原理","slug":"操作系统原理","permalink":"http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"}]},{"title":"全文本搜索","slug":"数据库系统原理/《MySQL必知必会》/全文本搜索","date":"2020-10-14T16:00:00.000Z","updated":"2021-03-24T13:42:28.000Z","comments":true,"path":"2020/10/15/数据库系统原理/《MySQL必知必会》/全文本搜索/","link":"","permalink":"http://example.com/2020/10/15/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B/%E5%85%A8%E6%96%87%E6%9C%AC%E6%90%9C%E7%B4%A2/","excerpt":"","text":"全文本搜索 1）CREATE TABLE语句接受FULLTEXT子句，它给出被索引列的一个逗号分隔的列表 2）在索引之后，使用两个函数Match()和Against()执行全文本搜索，其中Match()指定被搜索的列，Against()指定要使用的搜索表达式；传递给Match()的值必须与FULLTEXT()定义中的相同，如果指定多个列，则必须列出它们（而且次序正确）SELECT note_textFROM productnotesWHERE Match(note_text) Against(‘rabbit’); 3）这条SELECT语句同样检索出两行，但次序不同（虽然并不总是出现这种情况）SELECT note_textFROM productnotesWHERE note_text LIKE ‘%rabbit%’; 上述两条SELECT语句都不包含ORDER BY子句，后者以不特别有用的顺序返回数据。前者返回以文本匹配的良好程度排序的数据。两个行都包含词rabbit，但包含词rabbit作为第3个词的行的等级比作为第20个词的行高 4）演示排序如何工作SELECT note_text， Match(note_text) Against(‘rabbit’) AS rankFROM productnotes 如果指定多个搜索项，则包含多数匹配词的那些行将具有比包含较少词（或仅有一个匹配）的那些行高的等级值 5)查询扩展用来设法放宽所返回的全文本搜索结果的范围SELECT note_textFROM productnotesWHERE Match(note_text) Against(‘anvils’); 表中的行越多（这些行中的文本就越多，使用查询扩展返回的结果越好）SELECT note_textFROM productnotesWHERE Match(note_text) Against(‘anvils’ WITH QUERY EXPANSION); 6）布尔文本搜索，以布尔方式，可以提供关于如下内容的细节：SELECT note_textFROM productnotesWHERE Match(note_text) Against(‘heavy’ IN BOOLEAN MODE); 匹配包含heavy但不包含任意以rope开始的词的行：SELECT note_textFROM productnotesWHERE Match(note_text) Against(‘heavy -rope*’ IN BOOLEAN MODE);","categories":[{"name":"数据库系统原理","slug":"数据库系统原理","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"《MySQL必知必会》","slug":"《MySQL必知必会》","permalink":"http://example.com/tags/%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B/"}]},{"title":"设备管理概念","slug":"操作系统原理/操作系统原理/设备管理概念","date":"2020-10-14T16:00:00.000Z","updated":"2021-03-24T13:35:19.000Z","comments":true,"path":"2020/10/15/操作系统原理/操作系统原理/设备管理概念/","link":"","permalink":"http://example.com/2020/10/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/","excerpt":"","text":"设备管理概念： 1）按交互对象分类：人机交互设备：显示设备、键盘、鼠标、打印机与CPU等交互的设备：磁盘、磁带、传感器、控制器计算机间的通信设备：网卡、调制解调器 2）按交互方向分类：输入设备：键盘、扫描仪输出设备：显示设备、打印机双向设备输入/输出：硬盘、软盘、网卡 3）按外设特征分类：使用特征：存储、输入/输出数据传输率：低速（如键盘）、中速（如打印机）、高速（如网卡、磁盘）信息组织特征：字符设备（如打印机）、块设备（如磁盘）、网络设备 鼠标： 键盘： 喷墨打印机： 硬盘： 设备管理的主要功能： 1）设备分配：设备分配功能是设备管理的基本任务，设备分配程序按照一定的策略，为申请设备的进程分配设备，记录设备的使用情况 2）设备映射：设备管理模块将逻辑设备映射到物理设备的功能，从应用软件的角度看，逻辑设备是一类物理设备的抽象；从设备管理程序的角度看，物理设备是逻辑设备的实例 设备独立性：物理设备对用户透明，用户使用统一规范的方式使用设备；用户编程时使用设备逻辑名，由系统实现逻辑设备到物理设备的转换 3）设备驱动：对物理设备进行控制，实现I/O操作：IN/OUT接收应用的服务请求（例如读/写命令），转换为具体的I/O指令，控制设备完成相关操作向用户提供统一接口：read/write/open，把外设作为特别文件处理 设备驱动程序的特点：1）设备驱动程序与硬件密切相关2）每类设备都要配置特定的驱动程序3）驱动程序一般由设备厂商根据操作系统要求编写4）操作系统仅对与设备驱动的接口提出要求","categories":[{"name":"操作系统原理","slug":"操作系统原理","permalink":"http://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"操作系统原理","slug":"操作系统原理","permalink":"http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"}]},{"title":"插入数据","slug":"数据库系统原理/《MySQL必知必会》/插入数据","date":"2020-10-13T16:00:00.000Z","updated":"2021-03-24T13:42:39.000Z","comments":true,"path":"2020/10/14/数据库系统原理/《MySQL必知必会》/插入数据/","link":"","permalink":"http://example.com/2020/10/14/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B/%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE/","excerpt":"","text":"插入数据 INSERT是用来插入（或添加）行到数据库表的【INSERT语句一般不会产生输出】插入可以用几种方式使用： 1）插入完整的行INSERT INTO CustomersVALUES(NULL, ‘Pep E.LaPew’, ‘100 Main Street’, ‘Los Angeles’, ‘CA’, ‘90046’, ‘USA’, NULL, NULL); INSERT INTO Customers(cust_name, cust_address, cust_city, cust_state, cust_zip, cust_country, cust_contact, cust_email)VALUES(‘Pep E.LaPew’, ‘100 Main Street’, ‘Los Angeles’, ‘CA’, ‘90046’, ‘USA’, NULL, NULL); 2)插入多个行INSERT INTO Customers(cust_name, cust_address, cust_city, cust_state, cust_zip, cust_country)VALUES(‘Pep E.LaPew’, ‘100 Main Street’, ‘Los Angeles’, ‘CA’, ‘90046’, ‘USA’);INSERT INTO Customers(cust_name, cust_address, cust_city, cust_state, cust_zip, cust_country)VALUES(‘M.Martian’, ’42 Galaxy Way’, ’New York’, ‘NY’, ’11213’, ‘USA’); 只要每条INSERT语句中的列名（和次序）相同，可以如下组合各语句：INSERT INTO Customers(cust_name, cust_address, cust_city, cust_state, cust_zip, cust_country)VALUES( ‘Pep E.LaPew’, ‘100 Main Street’, ‘Los Angeles’, ‘CA’, ‘90046’, ‘USA’ )， ( ‘M.Martian’, ’42 Galaxy Way’, ’New York’, ‘NY’, ’11213’, ‘USA’ ); 3）插入检索出的数据INSERT INTO Customers(cust_id, cust_contact, cust_email, cust_name, cust_address, cust_city, cust_state, cust_zip, cust_country)SELECT cust_id, cust_contact, cust_email, cust_name, cust_address, cust_city, cust_state, cust_zip, cust_countryFROM custnew; INSERT SELECT中SELECT语句可包含WHERE子句以过滤插入的数据","categories":[{"name":"数据库系统原理","slug":"数据库系统原理","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"《MySQL必知必会》","slug":"《MySQL必知必会》","permalink":"http://example.com/tags/%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B/"}]},{"title":"Spooling系统","slug":"操作系统原理/操作系统原理/Spooling系统","date":"2020-10-13T16:00:00.000Z","updated":"2021-03-24T13:35:30.000Z","comments":true,"path":"2020/10/14/操作系统原理/操作系统原理/Spooling系统/","link":"","permalink":"http://example.com/2020/10/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/Spooling%E7%B3%BB%E7%BB%9F/","excerpt":"","text":"Spooling系统： 设备分配方法： 1）独占型设备的分配：独占型设备包括所有的字符型设备，任意时间段内最多只能被一个进程占用；使用时，进程首先向系统申请，可能进入阻塞状态【当设备可用时，唤醒一个等待进程；使用完毕以后，进程必须释放设备】 进程使用独占设备的过程：申请、使用、释放【从进程申请成功，直到释放用完之前，独占设备】1）进程申请设备2）系统分配设备3）进程发送使用命令4）系统将转到设备驱动模块完成一次I/O传输5）进程释放设备6）系统回收设备 2）共享型设备的分配：共享型设备包括所有块型设备【I/O传输单位：块；宏观上一个共享型设备可以被多个进程同时占用；微观上多个设备交替使用同一设备；进程使用这类设备时，无需申请或释放设备，也不存在某个进程占用设备的问题】 进程使用共享型设备不需要申请，当然也就不存在占用或释放设备的问题 但是I/O期间只能有一个进程使用设备，因此进程使用共享型设备之前，有一个隐含的申请命令；使用完毕以后，有一个隐含的释放命令，以实现一次基本I/O传输期间的排他性，保证操作的正常进行 使用共享型设备的过程中，进程完全有可能进入阻塞等待状态 3）虚拟分配：当进程需要与独占设备交换信息时，就采用虚拟技术将与该独占设备所对应的虚拟设备（部分辅存）分配给它 虚拟技术：在一类物理设备上模拟另一类物理设备的技术，借助辅存部分区域模拟独占设备，将独占设备转化为共享设备 虚拟设备：用来模拟独占设备的部分辅存称为虚拟设备，虚拟独占设备 输入井：模拟输入设备的辅存区域（磁盘上）输出井：模拟输出设备的辅存区域（磁盘上） 内存中开辟的存储区域：输入缓冲区【暂存输入数据，以后再传送到输入井】、输出缓冲区【暂存输出数据，以后再传送到输出设备】 SPOOLing系统是虚拟技术和虚拟分配的实现（Simultaneaus Periphernal Operations OnLine，外部设备同时联机操作，假脱机输入/输出操作） 当用户进程需要数据时，直接从输入井读入所需数据（提前读）用户进程将输出数据先传送到输出井，当输出设备空闲时，再将输出井的数据送到输出设备上（延后写） 输入监控进程模拟脱机输入的卫星机，将用户要求的数据从输入设备通过输入缓冲区再传送输入井，当用户进程需要数据时，直接从输入井读入所需数据 输出监控进程模拟脱机输出的卫星机，用户进程将输出数据从内存先传送到输出井，当输出设备空闲时，再将输出井的数据送到输出设备上 SPOOLing系统原理：1）任务执行前：预先将程序和数据输入到输入井中2）任务运行时：使用数据时，从输入井中取出3）任务运行时：输出数据时，把数据写入输出井4）任务运行完：外设空闲时输出全部数据和信息 “提高”了I/O速度，将独占设备改造为“共享”设备，实现了虚拟设备功能","categories":[{"name":"操作系统原理","slug":"操作系统原理","permalink":"http://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"操作系统原理","slug":"操作系统原理","permalink":"http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"}]},{"title":"更新和删除数据","slug":"数据库系统原理/《MySQL必知必会》/更新和删除数据","date":"2020-10-12T16:00:00.000Z","updated":"2021-03-24T13:42:51.000Z","comments":true,"path":"2020/10/13/数据库系统原理/《MySQL必知必会》/更新和删除数据/","link":"","permalink":"http://example.com/2020/10/13/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B/%E6%9B%B4%E6%96%B0%E5%92%8C%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE/","excerpt":"","text":"更新和删除数据 1）为了更新（修改）表中的数据，可使用UPDATE语句，可采用两种方式使用UPDATE：更新表中特定行；更新表中所有行； UPDATE语句的组成：1）要更新的表2）列名和它们的新值3）确定要更新行的过滤条件 UPDATE customersSET cust_email=‘ &#x65;&#x6c;&#x6d;&#x65;&#114;&#x40;&#x66;&#x75;&#x64;&#100;&#46;&#x63;&#111;&#x6d; ’WHERE cust_id=10005; UPDATE customersSET cust_name=’The Fudds’, cust_email=‘ &#x65;&#x6c;&#x6d;&#101;&#x72;&#x40;&#102;&#x75;&#100;&#x64;&#46;&#x63;&#x6f;&#109; ’WHERE cust_id=10005; 为了删除某个列的值，可设置它为NULL（假定表定义允许NULL值）UPDATE customersSET cust_email=NULLWHERE cust_id=10005; 2）为了从一个表中删除（去掉）数据，可使用DELETE语句从表中删除特定的行从表中删除所有行 DELETE FROM customersWHERE cust_id =10006;","categories":[{"name":"数据库系统原理","slug":"数据库系统原理","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"《MySQL必知必会》","slug":"《MySQL必知必会》","permalink":"http://example.com/tags/%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B/"}]},{"title":"文件系统","slug":"操作系统原理/操作系统原理/文件系统","date":"2020-10-12T16:00:00.000Z","updated":"2021-03-24T13:35:41.000Z","comments":true,"path":"2020/10/13/操作系统原理/操作系统原理/文件系统/","link":"","permalink":"http://example.com/2020/10/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/","excerpt":"","text":"文件系统： ———————————————— 8-1.文件系统概念8-2.文件物理结构8-3.FAT文件系统8-4.文件存储和目录 ————————————————","categories":[{"name":"操作系统原理","slug":"操作系统原理","permalink":"http://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"操作系统原理","slug":"操作系统原理","permalink":"http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"}]},{"title":"创建和操纵表","slug":"数据库系统原理/《MySQL必知必会》/创建和操纵表","date":"2020-10-11T16:00:00.000Z","updated":"2021-03-24T13:43:03.000Z","comments":true,"path":"2020/10/12/数据库系统原理/《MySQL必知必会》/创建和操纵表/","link":"","permalink":"http://example.com/2020/10/12/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B/%E5%88%9B%E5%BB%BA%E5%92%8C%E6%93%8D%E7%BA%B5%E8%A1%A8/","excerpt":"","text":"创建和操纵表 一般有两种创建表的方法：1）使用具有交互式创建和管理表的工具2）表也可以直接用MySQL语句操纵 值得注意的是，在使用交互式工具时，实际上使用的是MySQL语句，但是这些语句不是用户编写的，界面工具会自动生成并执行相应的MySQL语句（更改现有表时也是这样） 为利用CREATE TABLE创建表，必须给出下列信息：1）新表的名字，在关键字CREATE TABLE之后给出2）表列的名字和定义，用逗号分隔 1）表的主键可以在创建表时用PRIMARY KEY关键字指定，为创建由多个列组成的主键，应该以逗号分隔的列表给出各列名；主键为其值唯一标识表中每个行的列，主键中只能使用不允许NULL值的列，允许NULL值的列不能作为唯一标识CREATE TABLE customers( custid int NOT NULL AUTOINCREMENT, cust_name char(50) NOT NULL, cust_address char(50) NULL, cust_city char(50) NULL, cust_state char(5) NULL, cust_zip char(10) NULL, cust_country char(50) NULL, cust_contact char(50) NULL, cust_email char(255) NULL, PRIMARY KEY (cust_id))ENGINE-InnoDB; AUTOINCREMENT告诉MySQL，本列每当增加一行时自动增量。每次执行一个INSERT操作时，MySQL自动对该列增量（从而才有这个关键字AUTOINCREMENT），给该列赋予下一个可用的值。这样给每个行分配一个唯一的custid，从而可以用作主键值；每个表只允许一个AUTOINCREMENT列，而且它必须被索引（如通过使它成为主键） 2）如果在插入行时没有给出值，MySQL允许指定此时使用的默认值。默认值用CREATE TABLE语句的列定义中的DEFAULT关键字指定CREATE TABLE orderitems( order_num int NOT NULL, order_item int NOT NULL, prod_id char(10) NOT NULL, quantity int NOT NULL DEFAULT 1, item_price decimal(8,2) NOT NULL, PRIMARY KEY(ordernum,orderitem))ENGINE-InnoDB; 3)更新表为了使用ALTER TABLE更改表结构，必须给出下面的信息：1）在ALTER TABLE之后给出要更改的表名（该表必须存在，否则将出错）2）所做更改的列表 ALTER TABLE vendorsADD vend_phone CHAR(20); 删除刚刚添加的列：ALTER TABLE VendorsDROP COLUMN vend_phone; 4)删除表：删除整个表而不是其内容，删除表没有确认，也不能撤销，执行这条语句将永久删除该表 DROP TABLE customers2; 5)重命名表 RENAME TABLE customers2 TO customers, backup_vendors TO vendors;","categories":[{"name":"数据库系统原理","slug":"数据库系统原理","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"《MySQL必知必会》","slug":"《MySQL必知必会》","permalink":"http://example.com/tags/%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B/"}]},{"title":"文件系统概念","slug":"操作系统原理/操作系统原理/文件系统概念","date":"2020-10-11T16:00:00.000Z","updated":"2021-03-24T13:35:52.000Z","comments":true,"path":"2020/10/12/操作系统原理/操作系统原理/文件系统概念/","link":"","permalink":"http://example.com/2020/10/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/","excerpt":"","text":"文件系统概念： 文件是计算机信息存取的一种重要组织形式 文件由若干信息项有序构成，信息项可以是字节，可以是结构化数据用户通过读写指针来存取文件的信息项文件具有文件名，用户通过文件名存取文件 文件的分类： 按照文件的用途分：1）系统文件：包括操作系统的可执行程序和数据文件，这种文件不对用户开放，仅供系统使用2）库文件：系统为用户提供的各种标准函数库和实用程序等，用户只能使用这些文件，而无权对其进行修改3）用户文件：用户创建的文件，如用户可执行程序，源程序，数据文件等，这种文件的使用和修改权均属于用户 按照文件的操作权限分：1）只读文件：只允许进行读操作2）读写文件：允许进行读写操作3）不保护文件：不作任何操作限制 按照文件的性质分：1）普通文件：指一般的用户文件/系统文件2）目录文件：记录目录里面的文件列表信息（文件名，文件存放地址，文件属性）3）设备文件：把设备作为文件管理和使用 文件属性：指定文件的类型、操作特性和存取保护等一组信息，文件属性存放在文件所在目录的目录文件中 MS-DOS系统中，文件属性占目录项的一个字节【00000001：只读属性；00000010：隐藏属性】 文件系统定义：负责管理文件的机构称为文件系统 功能：负责文件的创立、撤销、读写、修改、复制和存取控制等，并管理存放文件的存储设备 文件系统的目标是让用户以文件名来存取文件 文件的结构： 文件的逻辑结构：【现代操作系统中文件都是流式文件，由应用程序解释和处理文件】 文件的存取方法：1）顺序存取2）随机存取","categories":[{"name":"操作系统原理","slug":"操作系统原理","permalink":"http://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"操作系统原理","slug":"操作系统原理","permalink":"http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"}]},{"title":"使用视图","slug":"数据库系统原理/《MySQL必知必会》/使用视图","date":"2020-10-10T16:00:00.000Z","updated":"2021-03-24T13:43:14.000Z","comments":true,"path":"2020/10/11/数据库系统原理/《MySQL必知必会》/使用视图/","link":"","permalink":"http://example.com/2020/10/11/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B/%E4%BD%BF%E7%94%A8%E8%A7%86%E5%9B%BE/","excerpt":"","text":"使用视图 视图是虚拟的表，与包含数据的表不一样，视图只包含使用时动态检索数据的查询 SELECT custname,custcontactFROM customers,orders,orderitemsWHERE customers.custid=orders.custid AND orderitems.ordernum=orders.ordernum AND prod_id=’TNT2’; 现在，假如可以把整个查询包装成一个名为productcustomers的虚拟表，则可以如下轻松地检索出相同的数据：SELECT custname,custcontactFROM productcustomersWHERE prod_id=’TNT2’; 1）CREATE VIEW productcustomers ASSELECT custname,custcontact,prod_idFROM customers,orders,orderitemsWHERE customers.custid=orders.custid AND orderitems.ordernum=orders.ordernum; 为检索订购了产品TNT2的客户：SELECT custname,custcontactFROM productcustomersWHERE prod_id=’TNT2’; 可以看出，视图极大的简化了复杂SQL语句的使用，利用视图，可一次性编写基础的SQL，然后根据需要多次使用 2）SELECT Concat(RTrim(vendname)，‘ （’，RTrim(vendcountry)，‘）’）AS vend_titleFROM vendorsORDER BY vend_name; CREATE VIEW vendorlocations ASSELECT Concat(RTrim(vendname)，‘ （’，RTrim(vendcountry)，‘）’）AS vend_titleFROM vendorsORDER BY vend_name; SELECT *FROM vendorlocations; 3)CREATE VIEW customeremaillist ASSELECT custid,custname,cust_emailFROM customersWHERE cust_email IS NOT NULL; SELECT *FROM customeremaillist; 4)SELECT prod_id, quantity, item_price, quantity*itemprice AS expandedpriceFROM orderitemsWHERE order_num=20005; CREATE VIEW orderitemsexpanded ASSELECT prod_id, quantity, item_price, quantity*itemprice AS expandedpriceFROM orderitems; SELECT *FROM orderitemsexpandedWHERE order_num=20005;","categories":[{"name":"数据库系统原理","slug":"数据库系统原理","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"《MySQL必知必会》","slug":"《MySQL必知必会》","permalink":"http://example.com/tags/%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B/"}]},{"title":"文件物理结构","slug":"操作系统原理/操作系统原理/文件物理结构","date":"2020-10-10T16:00:00.000Z","updated":"2021-03-24T13:36:02.000Z","comments":true,"path":"2020/10/11/操作系统原理/操作系统原理/文件物理结构/","link":"","permalink":"http://example.com/2020/10/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%96%87%E4%BB%B6%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84/","excerpt":"","text":"文件物理结构： 类型： 1）连续文件 连续文件的特点：文件建立时给出文件最大长度并登记文件起始位置 优点：1）简单2）支持顺序存取和随机存取3）顺序存取速度快：所需磁盘寻道次数和寻道时间最少 缺点：1）文件不易动态增长：预留空间过大造成浪费，过小又不合适，需要重新分配和移动2）不利于文件插入和删除3）外部碎片问题 2）索引结构：文件存放在不连续的存储块中，建立索引表记录文件逻辑块和物理存储块的对应关系 索引表单独放在存储块中 索引文件的特点：1）文件=索引区+数据区2）先访问索引，再访问数据3）支持顺序存取和随机存取4）支持文件动态增长、插入、删除 3）串联文件 特点：1）适用于顺序存取，随机存取较为困难2）提高了磁盘空间利用率，不存在外部碎片问题3）有利于文件动态扩充、插入和删除 缺点：1）存取速度慢，不适用于随机存取2）可靠性问题：若next指针出错，则文件访问失败3）next指针占用一定的空间 串联文件的应用：FAT文件系统","categories":[{"name":"操作系统原理","slug":"操作系统原理","permalink":"http://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"操作系统原理","slug":"操作系统原理","permalink":"http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"}]},{"title":"使用存储过程","slug":"数据库系统原理/《MySQL必知必会》/使用存储过程","date":"2020-10-09T16:00:00.000Z","updated":"2021-03-24T13:43:26.000Z","comments":true,"path":"2020/10/10/数据库系统原理/《MySQL必知必会》/使用存储过程/","link":"","permalink":"http://example.com/2020/10/10/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B/%E4%BD%BF%E7%94%A8%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/","excerpt":"","text":"使用存储过程 存储过程简单来说，就是为以后的使用而保存的一条或多条MySQL语句的集合。可将其视为批文件，虽然它们的作用不仅限于批处理 1）执行存储过程：MySQL称存储过程的执行为调用，因此MySQL执行存储过程的语句为CALL，CALL接受存储过程的名字以及需要传递给它的任意参数CALL productpricing(@pricelow, @pricehigh, @priceaverage); 2）创建存储过程CREATE PROCEDURE productpricing()BEGIN SELECT Avg(prod_price) AS priceaverage FROM products;END;3)使用存储过程：CALL productpricing(); 4）删除存储过程：DROP PROCEDURE productpricing; 变量：内存中一个特定的位置，用来临时存储数据变量名：所有MySQL变量都必须以@开始 5)每个参数必须具有指定的类型，这里使用十进制值，关键字OUT指出相应的参数用来从存储过程传出一个值（返回给调用者）；MySQL支持IN（传递给存储过程）、OUT（从存储过程传出）和INOUT（对存储过程传入和传出）类型的参数CREATE PROCEDURE productpricing( OUT pl DECIMAL(8,2), OUT ph DECIMAL(8,2), OUT pa DECIMAL(8,2))BEGIN SELECT Min(prod_price) INTO pl FROM products; SELECT Max(prod_price) INTO ph FROM products; SELECT Avg(prod_price) INTO pa FROM products;END; CALL productpricing(@pricelow, @pricehigh, @priceaverage);为了获得3个值，可使用：SELECT @pricehigh,@pricelow, @priceaverage; 6)CREATE PROCEDURE ordertotal( IN onumber INT, OUT ototal DECIMAL(8,2))BEGIN SELECT Sum(item_price*quantity) FROM orderitems; WHERE order_num=onumber INTO ototal;END; CALL ordertotal(20005,@total); SELECT @total;","categories":[{"name":"数据库系统原理","slug":"数据库系统原理","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"《MySQL必知必会》","slug":"《MySQL必知必会》","permalink":"http://example.com/tags/%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B/"}]},{"title":"FAT文件系统","slug":"操作系统原理/操作系统原理/FAT文件系统","date":"2020-10-09T16:00:00.000Z","updated":"2021-03-24T13:36:13.000Z","comments":true,"path":"2020/10/10/操作系统原理/操作系统原理/FAT文件系统/","link":"","permalink":"http://example.com/2020/10/10/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/FAT%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/","excerpt":"","text":"FAT文件系统： FAT：File Allocation Table FAT文件系统：FAT12、FAT16、FAT32 文件分配表（FAT）： 文件分配表的缺点：1）读文件时，先读FAT，影响使用效率2）FAT要占用存储空间，存储容量越大，存储块越多，FAT元素越多，且元素位宽越长，占用更多额外存储空间 扇区：磁盘上最小可寻址存储单元（512字节） 簇（cluster）=存储块，设备的最小存取单元，固定数量的扇区 360KB磁盘：簇=2个扇区（1024字节）10MB硬盘：簇=8个扇区（4096字节）2GB硬盘：簇=64个扇区（32KB） FAT16文件系统指的是N=16： FAT16文件系统：以簇为单位管理磁盘，簇是扇区的倍数，是2的次幂，最大64扇区【扇区512B，簇32KB（64个扇区）】","categories":[{"name":"操作系统原理","slug":"操作系统原理","permalink":"http://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"操作系统原理","slug":"操作系统原理","permalink":"http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"}]},{"title":"使用游标","slug":"数据库系统原理/《MySQL必知必会》/使用游标","date":"2020-10-08T16:00:00.000Z","updated":"2021-03-24T13:43:37.000Z","comments":true,"path":"2020/10/09/数据库系统原理/《MySQL必知必会》/使用游标/","link":"","permalink":"http://example.com/2020/10/09/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B/%E4%BD%BF%E7%94%A8%E6%B8%B8%E6%A0%87/","excerpt":"","text":"使用游标 有时，需要在检索出来的行中前进或后退一行或多行。这就是使用游标的原因。游标是一个存储在MySQL服务器上的数据库查询，它不是一条SELECT语句，而是被该语句检索出来的结果集。在存储了游标之后，应用程序可以根据需要滚动或浏览其中的数据；游标主要用于交互式应用，其中用户需要滚动屏幕上的数据，并对数据进行浏览或做出更改 不像多数DBMS，MySQL游标只能用于存储过程（和函数） 1）创建游标【存储过程处理完成后，游标就消失（因为它局限于存储过程）】游标用DECLARE语句创建，DECLARE命名游标，并定义相应的SELECT语句，根据需要带WHERE和其他子句CREATE PROCEDURE processorders()BEGIN DECLARE ordernumbers CURSOR FOR SELECT order_num FROM orders;END; 2）打开和关闭游标OPEN ordernumbers; CLOSE ordernumbers; 在一个游标关闭后，如果没有重新打开，则不能使用它。但是，使用声明过的游标不需要再次声明，用OPEN语句打开它就可以了，如果你不明确关闭游标，MySQL将会在到达END语句时自动关闭它 这个存储过程声明、打开和关闭一个游标，但对检索出来的数据什么也没做CREATE PROCEDURE processorders()BEGIN DECLARE ordernumbers CURSOR FOR SELECT order_num FROM orders; OPEN ordernumbers; CLOSE ordernumbers; END; 3）使用游标数据：在一个游标被打开后，可以使用FETCH语句分别访问它的每一行。FETCH指定检索什么数据（所需的列），检索出来的数据存储在什么地方。它还向前移动游标中的内部行指针，使下一条FETCH语句检索下一行（不重复读取同一行） 从游标中检索单个行（第一行）：CREATE PROCEDURE processorders()BEGIN DECLARE o INT; DECLARE ordernumbers CURSOR FOR SELECT order_num FROM orders; OPEN ordernumbers; FETCH ordernumbers INTO o; CLOSE ordernumbers; END; 循环检索数据，从第一行到最后一行：【如果一切正常，你可以在循环内放入任意需要的处理（在FETCH语句之后，循环结束之前）】CREATE PROCEDURE processorders()BEGIN DECLARE done BOOLEAN DEFAULT 0; DECLARE o INT; DECLARE ordernumbers CURSOR FOR SELECT order_num FROM orders; DECLARE CONTINUE HANDLER FOR SQLSTATE ’02000’ SET done=1; OPEN ordernumbers; REPEAT FETCH ordernumbers INTO o; UNTIL done END REPEAT; CLOSE ordernumbers; END; CREATE PROCEDURE processorders()BEGIN DECLARE done BOOLEAN DEFAULT 0; DECLARE o INT; DECLARE t DECIMAL(8,2); DECLARE ordernumbers CURSOR FOR SELECT order_num FROM orders; DECLARE CONTINUE HANDLER FOR SQLSTATE ’02000’ SET done=1; CREATE TABLE IF NOT EXISTS ordertotals (order_num INT,total DECIMAL(8,2)); OPEN ordernumbers; REPEAT FETCH ordernumbers INTO o; CALL ordertotal(o,l,t); INSERT INTO ordertotals(order_num,total) VALUES(o,t); UNTIL done END REPEAT; CLOSE ordernumbers; END; SELECT *FROM ordertotals;","categories":[{"name":"数据库系统原理","slug":"数据库系统原理","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"《MySQL必知必会》","slug":"《MySQL必知必会》","permalink":"http://example.com/tags/%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B/"}]},{"title":"文件存储和目录","slug":"操作系统原理/操作系统原理/文件存储和目录","date":"2020-10-08T16:00:00.000Z","updated":"2021-03-24T13:36:24.000Z","comments":true,"path":"2020/10/09/操作系统原理/操作系统原理/文件存储和目录/","link":"","permalink":"http://example.com/2020/10/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E5%92%8C%E7%9B%AE%E5%BD%95/","excerpt":"","text":"文件存储和目录： 存储空间管理功能：记录磁盘使用情况，管理和分配、回收存储空间 记录磁盘空闲块的方法： 1）空闲文件目录 空闲文件：把连续空闲区看成一个特殊文件，由多个连续空闲块组成 空闲文件目录：1）所有空闲文件代表存储设备全部空闲空间2）为空闲文件建立的专门目录：空闲文件目录3）每个表项对应一个空闲文件，包括第一个空闲块号，空闲块个数等信息 2）空闲块链 把所有空闲块链接在一起 当申请者需要空闲块时，链头开始搜索所需空闲块 当回收空闲块时，把释放的空闲块逐个加在链尾 3）位示图：从内存中划出若干个字节，每个bit表示一个存储块空闲或占用状态 文件目录管理： 文件目录：1）文件名址录，记录文件名和存放地址的目录表2）具有将文件名转换为外存物理位置的功能3）文件属性也记录在目录中 目录文件：文件目录以文件形式存于外存，这个文件叫目录文件 目录结构：单级目录、二级目录、多级目录（树型目录） 文件全名和路径： Linux文件目录： 文件的保护：对文件的访问系统首先要检查访问权限 文件和目录操作： 典型的文件系统：FAT16、FAT32、NTFS、EXT2、EXT3、EXT4","categories":[{"name":"操作系统原理","slug":"操作系统原理","permalink":"http://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"操作系统原理","slug":"操作系统原理","permalink":"http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"}]},{"title":"使用触发器","slug":"数据库系统原理/《MySQL必知必会》/使用触发器","date":"2020-10-07T16:00:00.000Z","updated":"2021-03-24T13:43:48.000Z","comments":true,"path":"2020/10/08/数据库系统原理/《MySQL必知必会》/使用触发器/","link":"","permalink":"http://example.com/2020/10/08/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B/%E4%BD%BF%E7%94%A8%E8%A7%A6%E5%8F%91%E5%99%A8/","excerpt":"","text":"使用触发器 触发器是MySQL响应以下任意语句而自动执行的一条MySQL语句（或位于BEGIN和END语句之间的一组语句）： DELETE; INSERT; UPDATE;其他MySQL语句不支持触发器 在创建触发器时，需要给出4条信息：1）唯一的触发器名2）触发器关联的表3）触发器应该响应的活动（DELETE、INSERT、UPDATE）4）触发器何时执行（处理之前或之后） 1）创建触发器CREATE TRIGGER newproduct AFTER INSERT ON productsFOR EACH ROW SELECT ‘Product added’; 只有表才支持触发器，视图不支持（临时表也不支持）；触发器按每个表每个事件每次的定义，每个表每个事件每次只允许一个触发器，因此每个表最多支持6个触发器（每条INSERT、UPDATE、DELETE的之前和之后）。单一触发器不能与多个事件或多个表关联，所以，如果你需要一个对INSERT和UPDATE操作执行的触发器，则应该定义两个触发器。 2）删除触发器DROP TRIGGER newproduct;触发器不能更新或覆盖，为了修改一个触发器，必须先删除它，然后再重新创建 3）使用触发器（1）INSERT触发器CREATE TRIGGER neworder AFTER INSERT ON ordersFOR EACH ROW SELECT NEW.order_num; (2)DELETE触发器 【原书缺页？？？？】","categories":[{"name":"数据库系统原理","slug":"数据库系统原理","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"《MySQL必知必会》","slug":"《MySQL必知必会》","permalink":"http://example.com/tags/%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B/"}]},{"title":"管理事务处理","slug":"数据库系统原理/《MySQL必知必会》/管理事务处理","date":"2020-10-06T16:00:00.000Z","updated":"2021-03-24T13:44:00.000Z","comments":true,"path":"2020/10/07/数据库系统原理/《MySQL必知必会》/管理事务处理/","link":"","permalink":"http://example.com/2020/10/07/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B/%E7%AE%A1%E7%90%86%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/","excerpt":"","text":"管理事务处理 事务处理可以用来维护数据库的完整性，它保证成批的MySQL操作要么完全执行，要么完全不执行 事务处理是一种机制，用来管理必须成批执行的MySQL操作，以保证数据库不包含不完整的操作结果，利用事务处理，可以保证一组操作不会中途停止，它们或者作为整体执行，或者完全不执行（除非明确指示），如果没有发生错误，整组语句提交给（写到）数据库表。如果发生错误，则进行回退（撤销）以恢复数据库到某个已知且安全的状态 事务：指一组SQL语句回退：指撤销指定SQL语句的过程提交：指将未存储的SQL语句结果写入数据库表保留点：指事务处理中设置的临时占位符，你可以对它发布回退（与回退整个事务处理不同） 1）START TRANSACTION标识事务的开始 2）MySQL的ROLLBACK命令用来回退（撤销）MySQL语句：SELECT * FROM ordertotals;START TRANSACTION;DELETE FROM ordertotals;SELECT * FROM ordertotals;ROLLBACK;SELECT * FROM ordertotals; 3)一般的MySQL语句都是直接针对数据库表执行和编写的，这就是所谓的隐含提交，即提交（写或保存）操作是自动进行的；但是，在事务处理块中，提交不会隐含的进行。为进行明确的提交，使用COMMIT语句START TRANSACTION;DELETE FROM orderitems WHERE order_num=20010;DELETE FROM orders WHERE order_num=20010;COMMIT; 使用保留点：这些占位符称为保留点 创建占位符：SAVEPOINT deletel; 每个保留点都取标识它的唯一名字，以便在回退时，MySQL知道要回退到何处。为了回退到本例给出的保留点，可如下进行：ROLLBACK TO deletel;","categories":[{"name":"数据库系统原理","slug":"数据库系统原理","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"《MySQL必知必会》","slug":"《MySQL必知必会》","permalink":"http://example.com/tags/%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B/"}]},{"title":"全球化和本地化","slug":"数据库系统原理/《MySQL必知必会》/全球化和本地化","date":"2020-10-05T16:00:00.000Z","updated":"2021-03-24T13:44:13.000Z","comments":true,"path":"2020/10/06/数据库系统原理/《MySQL必知必会》/全球化和本地化/","link":"","permalink":"http://example.com/2020/10/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B/%E5%85%A8%E7%90%83%E5%8C%96%E5%92%8C%E6%9C%AC%E5%9C%B0%E5%8C%96/","excerpt":"","text":"","categories":[{"name":"数据库系统原理","slug":"数据库系统原理","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"《MySQL必知必会》","slug":"《MySQL必知必会》","permalink":"http://example.com/tags/%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B/"}]},{"title":"安全管理","slug":"数据库系统原理/《MySQL必知必会》/安全管理","date":"2020-10-04T16:00:00.000Z","updated":"2021-03-24T13:44:25.000Z","comments":true,"path":"2020/10/05/数据库系统原理/《MySQL必知必会》/安全管理/","link":"","permalink":"http://example.com/2020/10/05/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B/%E5%AE%89%E5%85%A8%E7%AE%A1%E7%90%86/","excerpt":"","text":"","categories":[{"name":"数据库系统原理","slug":"数据库系统原理","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"《MySQL必知必会》","slug":"《MySQL必知必会》","permalink":"http://example.com/tags/%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B/"}]},{"title":"数据库维护","slug":"数据库系统原理/《MySQL必知必会》/数据库维护","date":"2020-10-03T16:00:00.000Z","updated":"2021-03-24T13:44:35.000Z","comments":true,"path":"2020/10/04/数据库系统原理/《MySQL必知必会》/数据库维护/","link":"","permalink":"http://example.com/2020/10/04/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BB%B4%E6%8A%A4/","excerpt":"","text":"","categories":[{"name":"数据库系统原理","slug":"数据库系统原理","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"《MySQL必知必会》","slug":"《MySQL必知必会》","permalink":"http://example.com/tags/%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B/"}]},{"title":"改善性能","slug":"数据库系统原理/《MySQL必知必会》/改善性能","date":"2020-10-02T16:00:00.000Z","updated":"2021-03-24T13:44:46.000Z","comments":true,"path":"2020/10/03/数据库系统原理/《MySQL必知必会》/改善性能/","link":"","permalink":"http://example.com/2020/10/03/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B/%E6%94%B9%E5%96%84%E6%80%A7%E8%83%BD/","excerpt":"","text":"","categories":[{"name":"数据库系统原理","slug":"数据库系统原理","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"《MySQL必知必会》","slug":"《MySQL必知必会》","permalink":"http://example.com/tags/%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B/"}]},{"title":"概念、功能、组成、分类","slug":"计算机网络原理/计算机网络原理/概念、功能、组成、分类","date":"2020-08-30T16:00:00.000Z","updated":"2021-03-24T13:47:10.000Z","comments":true,"path":"2020/08/31/计算机网络原理/计算机网络原理/概念、功能、组成、分类/","link":"","permalink":"http://example.com/2020/08/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E6%A6%82%E5%BF%B5%E3%80%81%E5%8A%9F%E8%83%BD%E3%80%81%E7%BB%84%E6%88%90%E3%80%81%E5%88%86%E7%B1%BB/","excerpt":"","text":"概念、功能、组成、分类： 计算机网络：是一个将分散的、具有独立功能的计算机系统，通过通信设备与线路连接起来，由功能完善的软件实现资源共享和信息传递的系统 计算机网络是互连的【互联互通、通信链路】、自治的【无主从关系】计算机集合 计算机网络的功能：1）数据通信（连通性）2）资源共享（硬件、软件、数据）3）分布式处理：多台计算机各自承担同一工作任务的不同部分（Hadoop平台）4）提高可靠性5）负载均衡（各计算机之间更亲密） 计算机网络的组成：1）按组成部分分类：硬件、软件、协议2）按工作方式分类：边缘部分（用户直接使用：C/S方式、P2P方式）、核心部分（为边缘部分服务）3）按功能组成分类：通信子网（实现数据通信）、资源子网（实现资源共享/数据处理） 计算机网络的分类：1）按分布范围分：广域网（WAN、使用交换技术）、城域网（MAN）、局域网（LAN、使用广播技术）、个人区域网（PAN）2）按使用者分：公用网、专用网3）按交换技术分：电路交换、报文交换、分组交换4）按拓扑结构分：总线型、星型、环型、网状型（常用于广域网）5）按传输技术分：广播式网络（共享公共通信信道）、点对点网络（使用分组存储转发和路由选择机制）","categories":[{"name":"计算机网络原理","slug":"计算机网络原理","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"计算机网络原理","slug":"计算机网络原理","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"}]},{"title":"标准化","slug":"计算机网络原理/计算机网络原理/标准化","date":"2020-08-29T16:00:00.000Z","updated":"2021-03-24T13:47:25.000Z","comments":true,"path":"2020/08/30/计算机网络原理/计算机网络原理/标准化/","link":"","permalink":"http://example.com/2020/08/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E6%A0%87%E5%87%86%E5%8C%96/","excerpt":"","text":"标准化： 要实现不同厂商的硬、软件之间相互连通，必须遵守统一的标准 标准的分类：1）法定标准（由权威机构制定的正式的、合法的标准：OSI）2）事实标准（某些公司的产品在竞争中占据了主流，时间长了，这些产品中的协议和技术就成了标准：TCP/IP） RFC（Request For Comments）：因特网标准的形式 RFC要上升为因特网正式标准的四个阶段：1）因特网草案：这个阶段还不是RFC文档2）建议标准：从这个阶段开始成为RFC文档3）因特网标准 标准化工作的相关组织：1）国际标准化组织ISO：OSI参考模型、HDLC协议2）国际电信联盟ITU：制定通信规则3）国际电气电子工程师协会IEEE：学术机构、IEEE802系列标准、5G4）Internet工程任务组IETF：负责因特网相关标准的制定","categories":[{"name":"计算机网络原理","slug":"计算机网络原理","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"计算机网络原理","slug":"计算机网络原理","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"}]},{"title":"速率、带宽、吞吐量","slug":"计算机网络原理/计算机网络原理/速率、带宽、吞吐量","date":"2020-08-28T16:00:00.000Z","updated":"2021-03-24T13:47:37.000Z","comments":true,"path":"2020/08/29/计算机网络原理/计算机网络原理/速率、带宽、吞吐量/","link":"","permalink":"http://example.com/2020/08/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E9%80%9F%E7%8E%87%E3%80%81%E5%B8%A6%E5%AE%BD%E3%80%81%E5%90%9E%E5%90%90%E9%87%8F/","excerpt":"","text":"速率、带宽、吞吐量： 速率：即数据率、数据传输率、比特率，连接在计算机网络上的主机在数字信道上传送数据位数的速率（b/s、kb/s、Mb/s、Gb/s、Tb/s） 带宽：原本指某个信号具有的频带宽度，即最高频率与最低频率之差，单位是赫兹（Hz）；计算机网络中，带宽用来表示网络的通信线路传送数据的能力，通常是指单位时间内从网络中的某一点到另一点所能通过的最高数据率（b/s、kb/s、Mb/s、Gb/s、Tb/s），网络设备所支持的最高速度 吞吐量：表示在单位时间内通过某个网络（或信道、接口）的数据量（b/s、kb/s、Mb/s、Gb/s、Tb/s），吞吐量受网络的带宽或网络的额定速率的限制","categories":[{"name":"计算机网络原理","slug":"计算机网络原理","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"计算机网络原理","slug":"计算机网络原理","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"}]},{"title":"时延、时延带宽积、往返时间RTT、利用率","slug":"计算机网络原理/计算机网络原理/时延、时延带宽积、往返时间RTT、利用率","date":"2020-08-27T16:00:00.000Z","updated":"2021-03-24T13:47:49.000Z","comments":true,"path":"2020/08/28/计算机网络原理/计算机网络原理/时延、时延带宽积、往返时间RTT、利用率/","link":"","permalink":"http://example.com/2020/08/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E6%97%B6%E5%BB%B6%E3%80%81%E6%97%B6%E5%BB%B6%E5%B8%A6%E5%AE%BD%E7%A7%AF%E3%80%81%E5%BE%80%E8%BF%94%E6%97%B6%E9%97%B4RTT%E3%80%81%E5%88%A9%E7%94%A8%E7%8E%87/","excerpt":"","text":"时延、时延带宽积、往返时间RTT、利用率 时延：指数据（报文/分组/比特流）从网络（或链路）的一端传送到另一端所需的时间，也叫延迟或迟延，单位是s 1）发送时延（传输时延）：从发送分组的第一个比特算起，到该分组的最后一个比特发送完毕所需的时间【计算公式：数据长度/信道带宽（发送速率）】2）传播时延：取决于电磁波传播速度和链路长度【公式：信道长度/电磁波在信道上的传播速率】3）排队时延：等待输出/入链路可用4）处理时延：检错、找出口 高速链路只是提高了信道带宽，减小了发送时延，但是传播时延和传播速率是不变的 时延带宽积（bit）：传播时延（s）*带宽（b/s），又称为以比特为单位的链路长度，即“某段链路现在有多少比特” 往返时延RTT：从发送方发送数据开始，到发送方收到接收方的确认（接收方收到数据后立即发送确认），总共经过的时延；RTT越大，在收到确认之前，可以发送的数据越多 RTT包括：往返传播时延=传播时延*2、末端处理时间【不包括发送时延】 利用率：信道利用率【有数据通过时间/有+无数据通过时间】、网络利用率（信道利用率加权平均值）","categories":[{"name":"计算机网络原理","slug":"计算机网络原理","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"计算机网络原理","slug":"计算机网络原理","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"}]},{"title":"分层结构、协议、接口、服务","slug":"计算机网络原理/计算机网络原理/分层结构、协议、接口、服务","date":"2020-08-26T16:00:00.000Z","updated":"2021-03-24T13:48:00.000Z","comments":true,"path":"2020/08/27/计算机网络原理/计算机网络原理/分层结构、协议、接口、服务/","link":"","permalink":"http://example.com/2020/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E5%88%86%E5%B1%82%E7%BB%93%E6%9E%84%E3%80%81%E5%8D%8F%E8%AE%AE%E3%80%81%E6%8E%A5%E5%8F%A3%E3%80%81%E6%9C%8D%E5%8A%A1/","excerpt":"","text":"分层结构、协议、接口、服务： 发送文件前要完成的工作：1）发起通信的计算机必须将数据通信的通路进行激活2）要告诉网络如何识别目的主机3）发起通信的计算机要查明目的主机是否开机，并且与网络连接正常4）发起通信的计算机要弄清楚，对方计算机中文件管理程序是否已经做好准备工作5）确保差错和意外可以解决 分层的基本原则：1）各层之间相互独立，每层只实现一种相对独立的功能2）每层之间界面自然清晰，易于理解，相互交流尽可能少3）结构上可分割开，每层都采用最合适的技术来实现4）保持下层对上层的独立性，上层单向使用下层提供的服务5）整个分层结构应该能促进标准化工作 1）网络体系结构是从功能上描述计算机网络结构2）计算机网络体系结构简称网络体系结构，是分层结构3）每层遵循某个/些网络协议以完成本层功能4）计算机网络体系结构是计算机网络的各层及其协议的集合5）第n层在向n+1层提供服务时，此服务不仅包含第n层本身的功能，还包含由下层服务提供的功能6）仅仅在相邻层间有接口，且所提供服务的具体实现细节对上一层完全屏蔽7）体系结构是抽象的，而实现是指能运行的一些软件和硬件","categories":[{"name":"计算机网络原理","slug":"计算机网络原理","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"计算机网络原理","slug":"计算机网络原理","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"}]},{"title":"7层OSI参考模型","slug":"计算机网络原理/计算机网络原理/7层OSI参考模型","date":"2020-08-25T16:00:00.000Z","updated":"2021-03-24T13:48:11.000Z","comments":true,"path":"2020/08/26/计算机网络原理/计算机网络原理/7层OSI参考模型/","link":"","permalink":"http://example.com/2020/08/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/7%E5%B1%82OSI%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B/","excerpt":"","text":"7层OSI参考模型： 为了支持异构网络系统的互联互通，国际标准化组织ISO于1984年提出开放系统互连（OSI）参考模型 应用层：用户与网络的界面，所有能和用户交互产生网络流量的程序【文件传输(FTP)、电子邮件(SMTP)、万维网(HTTP)】 表示层：用于处理在两个通信系统中交换信息的表示方式（语法和语义）【功能：数据格式变换、数据加密解密、数据压缩和恢复】【主要协议：JPEG、ASCII】 会话层：向表示层实体/用户进程提供建立连接并在连接上有序的传输数据，这是会话，也是建立同步(SYN)【功能：建立、管理、终止会话；使用校验点可使会话在通信失效时从校验点/同步点继续恢复通信，实现数据同步，适用于传输大文件】【主要协议：ADSP、ASP】 传输层：负责主机中两个进程的通信，即端到端的通信，传输单位是报文段或用户数据段【功能：可靠传输、不可靠传输；差错控制；流量控制；复用分用(复用：多个应用层进程可同时使用下面运输层的服务；分用：运输层把收到的信息分别交付给上面应用层中相应的进程)】【主要协议：TCP、UDP】 网络层：主要任务是把分组从源端传到目的端，为分组交换网上的不同主机提供通信服务，网络层传输单位是数据报【功能：路由选择、最佳路径；流量控制；差错控制；拥塞控制(若所有结点都来不及接受分组，而要丢弃大量分组的话，网络就处于拥塞状态。因此要采取一定措施，缓解这种拥塞)】【主要协议：IP、IPX、ICMP、IGMP、ARP、RARP、OSPF】 数据链路层：主要任务是把网络层传下来的数据报组装成帧，数据链路层/链路层的传输单位是帧【功能：成帧(定义帧的开始和结束)；差错控制(帧错+位错)；流量控制；访问(接入)控制(控制对信道的访问)】【主要协议：SDLC、HDLC、PPP、STP】 物理层：主要任务是在物理媒体上实现比特流的透明传输，物理层传输单位是比特(透明传输：指不管所传数据是什么样的比特组合，都应当能够在链路上传送)【功能：定义接口特性；定义传输模式(单工、半双工、双工)；定义传输速率；比特同步；比特编码】【主要协议：Rj45、802.3】","categories":[{"name":"计算机网络原理","slug":"计算机网络原理","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"计算机网络原理","slug":"计算机网络原理","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"}]},{"title":"4层TCP/IP参考模型","slug":"计算机网络原理/计算机网络原理/4层TCP:IP参考模型","date":"2020-08-24T16:00:00.000Z","updated":"2021-03-24T13:48:24.000Z","comments":true,"path":"2020/08/25/计算机网络原理/计算机网络原理/4层TCP:IP参考模型/","link":"","permalink":"http://example.com/2020/08/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/4%E5%B1%82TCP:IP%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B/","excerpt":"","text":"4层TCP/IP参考模型： OSI参考模型与TCP/IP参考模型： 相同点：1）都分层2）基于独立的协议栈的概念3）可以实现异构网络互联 不同点：","categories":[{"name":"计算机网络原理","slug":"计算机网络原理","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"计算机网络原理","slug":"计算机网络原理","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"}]},{"title":"5层参考模型","slug":"计算机网络原理/计算机网络原理/5层参考模型","date":"2020-08-23T16:00:00.000Z","updated":"2021-03-24T13:48:36.000Z","comments":true,"path":"2020/08/24/计算机网络原理/计算机网络原理/5层参考模型/","link":"","permalink":"http://example.com/2020/08/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/5%E5%B1%82%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B/","excerpt":"","text":"5层参考模型： 5层参考模型的数据封装与解封装：","categories":[{"name":"计算机网络原理","slug":"计算机网络原理","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"计算机网络原理","slug":"计算机网络原理","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"}]},{"title":"物理层基本概念","slug":"计算机网络原理/计算机网络原理/物理层基本概念","date":"2020-08-22T16:00:00.000Z","updated":"2021-03-24T13:48:48.000Z","comments":true,"path":"2020/08/23/计算机网络原理/计算机网络原理/物理层基本概念/","link":"","permalink":"http://example.com/2020/08/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E7%89%A9%E7%90%86%E5%B1%82%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/","excerpt":"","text":"物理层基本概念： 物理层解决如何在连接各种计算机的传输媒体上传输数据比特流，而不是指具体的传输媒体 物理层主要任务：确定与传输媒体接口有关的一些特性(定义标准)1）机械特性：定义物理连接的特性，规定物理连接时所采用的规格、接口形状、引线数目、引脚数量和排列情况2）电气特性：规定传输二进制位时，线路上信号的电压范围、阻抗匹配、传输速率和距离限制等3）功能特性：指明某条线上出现的某一电平表示何种意义，接口部件的信号线的用途4）规程特性：（过程特性）定义各条物理线路的工作规程和时序关系","categories":[{"name":"计算机网络原理","slug":"计算机网络原理","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"计算机网络原理","slug":"计算机网络原理","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"}]},{"title":"数据通信基础知识","slug":"计算机网络原理/计算机网络原理/数据通信基础知识","date":"2020-08-21T16:00:00.000Z","updated":"2021-03-24T13:49:00.000Z","comments":true,"path":"2020/08/22/计算机网络原理/计算机网络原理/数据通信基础知识/","link":"","permalink":"http://example.com/2020/08/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","excerpt":"","text":"数据通信基础知识： 典型的数据通信模型： 通信的目的是传送消息 数据：传送信息的实体，通常是有意义的符号序列 信号：数据的电气/电磁的表现，是数据在传输过程中的存在形式【数字信号：代表消息的参数取值是离散的；模拟信号：代表消息的参数取值是连续的】 信源：产生和发送数据的源头 信宿：接收数据的终点 信道：信号的传输媒介，一般用来表示向某一个方向传送信息的介质，因此一条通信线路往往包含一条发送信道和一条接收信道【按传输信号分：模拟信道(传送模拟信号)、数字信道(传送数字信号)；按传输介质分：无线信道、有线信道】 三种通信方式：1）单工通信：只有一个方向的通信而没有反方向的交互，仅需要一条信道2）半双工通信：通信的双方都可以发送或接收信息，但任何一方都不能同时发送和接收，需要两条信道3）全双工通信：通信双方可以同时发送和接收信息，也需要两条信道 两种数据传输方式：1）串形传输：速度慢，费用低，适合远距离2）并行传输：速度快，费用高，适合近距离，用于计算机内部数据传输","categories":[{"name":"计算机网络原理","slug":"计算机网络原理","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"计算机网络原理","slug":"计算机网络原理","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"}]},{"title":"码元、波特、速率、带宽","slug":"计算机网络原理/计算机网络原理/码元、波特、速率、带宽","date":"2020-08-20T16:00:00.000Z","updated":"2021-03-24T13:49:11.000Z","comments":true,"path":"2020/08/21/计算机网络原理/计算机网络原理/码元、波特、速率、带宽/","link":"","permalink":"http://example.com/2020/08/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E7%A0%81%E5%85%83%E3%80%81%E6%B3%A2%E7%89%B9%E3%80%81%E9%80%9F%E7%8E%87%E3%80%81%E5%B8%A6%E5%AE%BD/","excerpt":"","text":"码元、波特、速率、带宽： 码元是指用一个固定时长的信号波形（数字脉冲），代表不同离散数值的基本波形，是数字通信中数字信号的计量单位，这个时长内的信号称为k进制码元，而该时长称为码元宽度，当码元的离散状态有M个时（M大于2），此时码元为M进制码元；一码元可以携带多个比特的信息量，例如在使用二进制编码时，只有两种不同的码元，一种代表0状态，另一种代表1状态 速率也叫数据率，是指数据的传输速率（注意区分传播速率），表示单位时间内传输的数据量，可以用码元传输速率和信息传输速率表示 码元传输速率：别名码元速率、波形速率、调制速率、符号速率等，它表示单位时间内数字通信系统所传输的码元个数（也可称为脉冲个数或信号变化的次数），单位是波特（Baud），1波特表示数字通信系统每秒传输一个码元，这里的码元可以是多进制的，也可以是二进制的，但码元速率与进制数无关【1s传输多少个码元】 信息传输速率：别名信息速率、比特率等，表示单位时间内数字通信系统传输的二进制码元个数（即比特数），单位是比特/秒（b/s）【1s传输多少个比特】 关系：若一个码元携带n bit的信息量，则M Baud的码元传输速率所对应的信息传输速率为M*n bit/s 带宽：表示在单位时间内从网络中的某一点到另一点所能通过的“最高数据率”，常用来表示网络的通信线路所能传输数据的能力，单位是b/s","categories":[{"name":"计算机网络原理","slug":"计算机网络原理","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"计算机网络原理","slug":"计算机网络原理","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"}]},{"title":"奈式准则和香农定理","slug":"计算机网络原理/计算机网络原理/奈式准则和香农定理","date":"2020-08-19T16:00:00.000Z","updated":"2021-03-24T13:54:09.000Z","comments":true,"path":"2020/08/20/计算机网络原理/计算机网络原理/奈式准则和香农定理/","link":"","permalink":"http://example.com/2020/08/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E5%A5%88%E5%BC%8F%E5%87%86%E5%88%99%E5%92%8C%E9%A6%99%E5%86%9C%E5%AE%9A%E7%90%86/","excerpt":"","text":"奈式准则和香农定理： 失真： 失真的一种现象：码间串扰（接收端收到的信号波形失去了码元之间清晰界限的现象） 奈式准则（奈奎斯特定理）：在理想低通（无噪声，带宽受限）条件下，为了避免码间串扰，极限码元传输速率为2W Baud，W是信道带宽，单位是Hz【只有在这两个公式这带宽才用Hz】 理想低通信道下的极限数据传输率=2Wlog2V（b/s） 1）在任何信道中，码元传输的速率是有上限的，若传输速率超过此上限，就会出现严重的码间串扰问题，使接收端对码元的完全正确识别成为不可能2）信道的频带越宽（即能通过的信号高频分量越多），就可以用更高的速率进行码元的有效传输3）奈式准则给出了码元传输速率的限制，但并没有对信息传输速率给出限制4）由于码元的传输速率受奈式准则的制约，所以要提高数据的传输速率，就必须设法使每个码元能携带更多个比特的信息量，这就需要采用多元制的调制方法 香农定理： 噪声存在于所有的电子设备和通信信道中，由于噪声随机产生，它的瞬时值有时会很大，因此噪声会使接收端对码元的判决产生错误。但是噪声的影响是相对的，若信号较强，那么噪声影响相对较小。因此信噪比就很重要 信噪比=信号的平均功率/噪声的平均功率，常记为S/N，并用分贝（dB）作为度量单位，即：信噪比（dB）=10log10(S/N)【注意题目中有没有dB这个单位】 香农定理：在带宽受限且有噪声的信道中，为了不产生误差，信息的数据传输速率有上限值 信道的极限数据传输速率=Wlog2(1+S/N)(b/s) 1）信道的带宽或信道中的信噪比越大，则信息的极限传输速率就越高2）对一定的传输带宽和一定的信噪比，信息传输速率的上限就确定了3）只要信息的传输速率低于信道的极限传输速率，就一定能找到某种方法来实现无差错的传输4）香农定理得出的为极限信息传输速率，实际信道能达到的传输速率要比它低不少5）从香农定理可以看出，若信道带宽W或信噪比S/N没有上限（不可能），那么信道的极限信息传输速率也就没有上限 取最小值：","categories":[{"name":"计算机网络原理","slug":"计算机网络原理","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"计算机网络原理","slug":"计算机网络原理","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"}]},{"title":"编码与调制","slug":"计算机网络原理/计算机网络原理/编码与调制","date":"2020-08-18T16:00:00.000Z","updated":"2021-03-24T13:54:21.000Z","comments":true,"path":"2020/08/19/计算机网络原理/计算机网络原理/编码与调制/","link":"","permalink":"http://example.com/2020/08/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E7%BC%96%E7%A0%81%E4%B8%8E%E8%B0%83%E5%88%B6/","excerpt":"","text":"编码与调制： 信道：信号的传输媒介，一般用来表示向某一个方向传送信息的介质，因此一条通信线路往往包含一条发送信道和一条接收信道【按传输信号分：模拟信道(传送模拟信号)、数字信道(传送数字信号)；按传输介质分：无线信道、有线信道】 信道上传送的信号：1）基带信号：将数字信号1和0直接用两种不同的电压表示，再送到数字信道上去传输（基带传输）【来自信源的信号，像计算机输出的代表各种文字或图像文件的数据信号都属于基带信号，基带信号就是发出的直接表达了要传输的信息的信号，比如我们说话的声波就是基带信号】2）宽带信号：将基带信号进行调制后形成的频分复用模拟信号，再传送到模拟信道上去传输（宽带传输）【把基带信号经过载波调制后，把信号的频率范围搬移到较高的频段以便在信道中传输（即仅在一段频率范围内能够通过信道】 在传输距离较近时，计算机网络采用基带传输方式（近距离衰减小，从而信号内容不易发生变化）在传输距离较远时，计算机网络采用宽带传输方式（远距离衰减大，即使信号变化大也能最后过滤出来基带信号） 编码与调制： 数字数据编码为数字信号： 数字数据调制为模拟信号：数字数据调制技术在发送端将数字信号转换为模拟信号，而在接收端将模拟信号还原为数字信号，分别对应于调制解调器的调制和解调过程 模拟数据编码为数字信号： 模拟数据调制为模拟信号：","categories":[{"name":"计算机网络原理","slug":"计算机网络原理","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"计算机网络原理","slug":"计算机网络原理","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"}]},{"title":"物理层传输介质","slug":"计算机网络原理/计算机网络原理/物理层传输介质","date":"2020-08-17T16:00:00.000Z","updated":"2021-03-24T13:54:32.000Z","comments":true,"path":"2020/08/18/计算机网络原理/计算机网络原理/物理层传输介质/","link":"","permalink":"http://example.com/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E7%89%A9%E7%90%86%E5%B1%82%E4%BC%A0%E8%BE%93%E4%BB%8B%E8%B4%A8/","excerpt":"","text":"物理层传输介质： 传输介质也称传输媒体/传输媒介，它就是数据传输系统中在发送设备和接收设备之间的物理通路 传输媒体并不是物理层，传输媒体在物理层的下面，因为物理层是体系结构的第一层，因此有时称传输媒体为0层。在传输媒体中传输的是信号但传输媒体并不知道所传输的信号代表什么意思，但物理层规定了电气特性，因此能够识别所传送的比特流 传输介质：1）导向性传输介质：电磁波被导向沿着固体媒介(铜线/光纤)传播2）非导向性传输介质：自由空间，介质可以是空气、真空、海水等 导向性传输介质: 1）双绞线2）同轴电缆3）光纤特点：传输损耗小，中继距离长，对远距离传输特别经济；抗雷电和电磁干扰性能好；无串音干扰，保密性好，也不易被窃听或截取数据；体积小，重量轻 非导向性传输介质：","categories":[{"name":"计算机网络原理","slug":"计算机网络原理","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"计算机网络原理","slug":"计算机网络原理","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"}]},{"title":"物理层设备","slug":"计算机网络原理/计算机网络原理/物理层设备","date":"2020-08-16T16:00:00.000Z","updated":"2021-03-24T13:54:43.000Z","comments":true,"path":"2020/08/17/计算机网络原理/计算机网络原理/物理层设备/","link":"","permalink":"http://example.com/2020/08/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E7%89%A9%E7%90%86%E5%B1%82%E8%AE%BE%E5%A4%87/","excerpt":"","text":"物理层设备： ———————————————— 中继器： 诞生原因：由于存在损耗，在线路上传输的信号功率会逐渐衰减，衰减到一定程度时将造成信号失真，因此会导致接收错误 中继器的功能：对信号进行再生和还原，对衰减的信号进行放大，保持与原数据相同，以增加信号传输的距离，延长网络的长度【再生数字信号】 中继器的两端：1）两端的网络部分是网段，而不是子网，适用于完全相同的两类网络的互连，且两个网段速率要相同2）中继器只将任何电缆段上的数据发送到另一段电缆上，它仅作用于信号的电气部分，并不管数据中是否有错误数据或不适于网段的数据3）两端可连相同媒体，也可连不同媒体4）中继器两端的网段一定要是同一个协议（中继器不会存储转发） 5-4-3规则：网络标准中都对信号的延迟范围作了具体的规定，因而中继器只能在规定的范围内进行，否则会网络故障 ————————————————— 集线器（多口中继器）：","categories":[{"name":"计算机网络原理","slug":"计算机网络原理","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"计算机网络原理","slug":"计算机网络原理","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"}]},{"title":"数据链路层基本概念","slug":"计算机网络原理/计算机网络原理/数据链路层基本概念","date":"2020-08-15T16:00:00.000Z","updated":"2021-03-24T13:54:54.000Z","comments":true,"path":"2020/08/16/计算机网络原理/计算机网络原理/数据链路层基本概念/","link":"","permalink":"http://example.com/2020/08/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/","excerpt":"","text":"数据链路层基本概念： 结点：主机、路由器 链路：网络中两个结点之间的物理通道，链路的传输介质主要有双绞线、光纤和微波，分为有线链路、无线链路 数据链路：网络中两个结点之间的逻辑通道，把实现控制数据传输协议的硬件和软件加到链路上就构成了数据链路 帧：链路层的协议数据单元，封装网络层数据报 数据链路层负责通过一条链路从一个结点向另一个物理链路直接相连的相邻结点传送数据报 数据链路层功能概述：数据链路层在物理层提供服务的基础上向网络层提供服务，其最基本的服务是将源自网络层来的数据可靠的传输到相邻节点的目标机网络层。其主要作用是加强物理层传输原始比特流的功能，将物理层提供的可能出错的物理连接改造成为逻辑上无差错的数据链路，使之对网络层表现为一条无差错的链路 1）为网络层提供服务：无确认无连接服务【通信质量好，有线传输链路】、有确认无连接服务、有确认面向连接服务【有连接一定有确认】【通信质量差的无线传输链路】2）链路管理，即连接的建立、维持、释放（用于面向连接的服务）3）组帧4）流量控制5）差错控制（帧错/位错）","categories":[{"name":"计算机网络原理","slug":"计算机网络原理","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"计算机网络原理","slug":"计算机网络原理","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"}]},{"title":"封装成帧和透明传输","slug":"计算机网络原理/计算机网络原理/封装成帧和透明传输","date":"2020-08-14T16:00:00.000Z","updated":"2021-03-24T13:55:05.000Z","comments":true,"path":"2020/08/15/计算机网络原理/计算机网络原理/封装成帧和透明传输/","link":"","permalink":"http://example.com/2020/08/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E5%B0%81%E8%A3%85%E6%88%90%E5%B8%A7%E5%92%8C%E9%80%8F%E6%98%8E%E4%BC%A0%E8%BE%93/","excerpt":"","text":"封装成帧和透明传输： 封装成帧就是在一段数据的前后部分添加首部和尾部，这样就构成了一个帧。接收端在收到物理层上交的比特流后，就能根据首部和尾部的标记，从收到的比特流中识别帧的开始和结束 首部和尾部包含许多的控制信息，他们的一个重要作用：帧定界（确定帧的界限） 帧同步：接收方应当能从接收到的二进制比特流中区分出帧的起始和终止 组帧的四种方法：字符计数法、字符（节）填充法、零比特填充法、违规编码法 透明传输是指不管所传数据是什么样的比特组合，都应当能够在链路上传送。因此，链路层就“看不见”有什么妨碍数据传输的东西 当所传数据中的比特组合恰巧与某一个控制信息完全一样时，就必须采取适当的措施，使收方不会将这样的数据误认为是某种控制信息。这样才能保证数据链路层的传输是透明的 字符计数法： 字符填充法： 零比特填充法： 违规编码法：","categories":[{"name":"计算机网络原理","slug":"计算机网络原理","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"计算机网络原理","slug":"计算机网络原理","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"}]},{"title":"差错控制","slug":"计算机网络原理/计算机网络原理/差错控制","date":"2020-08-13T16:00:00.000Z","updated":"2021-03-24T13:55:15.000Z","comments":true,"path":"2020/08/14/计算机网络原理/计算机网络原理/差错控制/","link":"","permalink":"http://example.com/2020/08/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E5%B7%AE%E9%94%99%E6%8E%A7%E5%88%B6/","excerpt":"","text":"差错控制： 概括来说，传输中的差错都是由于噪声引起的 1）全局性：由于线路本身电气特性所产生的随机噪声(热噪声)，是信道固有的，随机存在的【解决办法：提高信噪比来减少或避免干扰(对传感器下手)】2）局部性：外界特定的短暂原因所造成的冲击噪声，是产生差错的主要原因【解决办法：通常利用编码技术来解决】 检错编码：纠错编码：","categories":[{"name":"计算机网络原理","slug":"计算机网络原理","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"计算机网络原理","slug":"计算机网络原理","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"}]},{"title":"流量控制与可靠传输机制","slug":"计算机网络原理/计算机网络原理/流量控制与可靠传输机制","date":"2020-08-12T16:00:00.000Z","updated":"2021-03-24T13:55:27.000Z","comments":true,"path":"2020/08/13/计算机网络原理/计算机网络原理/流量控制与可靠传输机制/","link":"","permalink":"http://example.com/2020/08/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E4%B8%8E%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E6%9C%BA%E5%88%B6/","excerpt":"","text":"流量控制与可靠传输机制： 数据链路层的流量控制：较高的发送速度和较低的接收能力的不匹配，会造成传输出错，因此流量控制也是数据链路层的一项重要工作 数据链路层的流量控制是点对点的，而传输层的流量控制是端到端的 数据链路层流量控制的手段：接收方收不下就不回复确认传输层流量控制的手段：接收端给发送端一个窗口公告 流量控制的方法：1）停止-等待协议：每发送完一个帧就停止发送，等待对方的确认，在收到确认后再发送下一个帧2）滑动窗口协议：后退N帧协议(GBN)、选择重传协议(SR) 停止-等待协议：发送窗口大小=1，接收窗口大小=1后退N帧协议(GBN)：发送窗口大小&gt;1，接收窗口大小=1选择重传协议(SR)：发送窗口大小&gt;1，接收窗口大小&gt;1 可靠传输、流量控制、滑动窗口： ———————————— 停止等待协议： 为什么要有停止等待协议：除了比特出差错，底层信道还会出现丢包问题，为了实现流量控制【丢包：物理线路故障、设备故障、病毒攻击、路由信息错误等原因，会导致数据包的丢失】 研究停止等待协议的前提：1）虽然现在常用全双工通信方式，但为了讨论问题方便，仅考虑一方发送数据（发送方），一方接收数据（接收方）2）因为是在讨论可靠传输的原理，所以并不考虑数据是在哪一个层次上传送的 停止等待协议的几种应用情况：1）无差错情况2）有差错情况 停止等待协议的性能分析：简单、信道利用率太低 信道利用率：发送方在一个发送周期内，有效的发送数据所需要的时间占整个发送周期的比率 信道利用率=(L/C)/TL：T内发送L比特数据C：发送方数据传输率T；发送周期，从开始发送数据，到收到第一个确认帧为止 信道吞吐率：信道利用率*发送方的发送速率 停止等待协议的弊端： 流水线技术：必须增加序号范围、发送方需要缓存多个分组 ————————————— 后退N帧协议(GBN)： 后退N帧协议中的滑动窗口： GBN发送方必须响应的三件事：1）上层的调用：上层要发送数据时，发送方先检查发送窗口是否已满，如果未满，则产生一个帧并将其发送；如果窗口已满，发送方只需将数据返回给上层，暗示上层窗口已满。上层等一会再发送（实际实现中，发送方可以缓存这些数据，窗口不满时再发送帧）2）收到了一个ACK：GBN协议中，对n号帧的确认采用累计确认的方式，标明接收方已经收到n号帧和它之前的全部帧3）超时事件：协议的名字为后退N帧/回退N帧，来源于出现丢失和时延过长帧时发送方的行为。就像在停等协议中一样，定时器将再次用于恢复数据帧或确认帧的丢失，如果出现超时，发送方重传所有已发送但未被确认的帧 GBN接收方要做的事：1）如果正确收到n号帧，并且按序，那么接收方为n帧发送一个ACK，并将该帧中的数据部分交付给上层2）其余情况都丢弃帧，并为最近按序接收的帧重新发送ACK，接收方无需缓存任何失序帧，只需要维护一个信息：expectedseqnum（下一个按序接收的帧序号）【接收方只按序接收帧，不按序无情丢弃】【确认序列号最大的，按序到达的帧】滑动窗口长度：若采用n个比特对帧编号，那么发送窗口的尺寸WT应满足：1&lt;=WT&lt;=2^n-1，因为发送窗口尺寸过大，就会使得接收方无法区别新帧和旧帧 GBN协议性能分析：1）因连续发送数据帧而提高了信道利用率2）在重传时必须把原来已经正确传送的数据帧重传，使得传送效率降低 ————————————— 选择重传协议(SR)： 解决GBN的弊端：可不可以只重传出错的帧？设置单个确认，同时加大接收窗口，设置接收缓存，缓存乱序到达的帧 选择重传协议中的滑动窗口： SR发送方必须要响应的三件事：1）上层的调用：从上层收到数据后，SR发送方检查下一个可用于该帧的序号，如果序号位于发送窗口内，则发送数据帧，否则就像GBN一样，要么将数据缓存，要么返回给上层之后再传输2）收到了一个ACK：如果收到ACK，假如该帧序号在窗口内，则SR发送方将那个被确认的帧标记为已接收。如果该帧序号是窗口的下界（最左边第一个窗口对应的序号），则窗口向前移动到具有最小序号的未确认帧处，如果窗口移动了并且有序号在窗口内的未发送帧，则发送这些帧3）超时事件：每个帧都有自己的定时器，一个超时事件发生后只重传一个帧【只重传出错帧】 SR接收方要做的事：窗口内的帧来者不拒滑动窗口的长度：发送窗口最好等于接收窗口（大了会溢出，小了没意义）【WTmax=WRmax=2^(n-1)】","categories":[{"name":"计算机网络原理","slug":"计算机网络原理","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"计算机网络原理","slug":"计算机网络原理","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"}]},{"title":"信道划分介质访问控制","slug":"计算机网络原理/计算机网络原理/信道划分介质访问控制","date":"2020-08-11T16:00:00.000Z","updated":"2021-03-24T13:55:38.000Z","comments":true,"path":"2020/08/12/计算机网络原理/计算机网络原理/信道划分介质访问控制/","link":"","permalink":"http://example.com/2020/08/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E4%BF%A1%E9%81%93%E5%88%92%E5%88%86%E4%BB%8B%E8%B4%A8%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/","excerpt":"","text":"信道划分介质访问控制： 传输数据使用的两种链路：1）点对点链路：两个相邻节点通过一个链路相连，没有第三者。【应用：PPP协议，常用于广域网】2）广播式链路：所有主机共享通信介质【应用：早期的总线以太网、无线局域网。常用于局域网】【典型拓扑结构：总线型、星型(逻辑总线型)】 介质访问控制：采取一定的措施，使得两对节点之间的通信不会发生相互干扰的现象信道划分介质访问控制：将使用介质的每个设备与来自同一信道上的其他设备的通信隔离开，把时域和频域资源合理的分配给网络上的设备 1）频分多路复用FDM 2）时分多路复用TDM 3）改进的时分复用—统计时分复用STDM 4）波分多路复用WDM：波分多路复用就是光的频分多路复用，在一根光纤中传输多种不同波长（频率）的光信号，由于波长（频率）不同，所以各路光信号互不干扰，最后再用波长分解复用器将各路波长分解出来 5）码分多路复用CDM：","categories":[{"name":"计算机网络原理","slug":"计算机网络原理","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"计算机网络原理","slug":"计算机网络原理","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"}]},{"title":"ALOHA协议","slug":"计算机网络原理/计算机网络原理/ALOHA协议","date":"2020-08-10T16:00:00.000Z","updated":"2021-03-24T13:55:51.000Z","comments":true,"path":"2020/08/11/计算机网络原理/计算机网络原理/ALOHA协议/","link":"","permalink":"http://example.com/2020/08/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/ALOHA%E5%8D%8F%E8%AE%AE/","excerpt":"","text":"ALOHA协议： 1）纯ALOHA协议：不监听信道，不按时间槽发送，随机重发【想发就发】 2）时隙ALOHA协议：把时间分成若干个相同的时间片，所有用户在时间片开始时刻同步接入网络信道，若发生冲突，则必须等到下一个时间片开始时刻再发送【控制想发就发的随意性】 纯ALOHA协议比时隙ALOHA吞吐量更低，效率更低纯ALOHA想发就发，时隙ALOHA只有在时间片段开始时才能发","categories":[{"name":"计算机网络原理","slug":"计算机网络原理","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"计算机网络原理","slug":"计算机网络原理","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"}]},{"title":"CSMA协议","slug":"计算机网络原理/计算机网络原理/CSMA协议","date":"2020-08-09T16:00:00.000Z","updated":"2021-03-24T13:56:02.000Z","comments":true,"path":"2020/08/10/计算机网络原理/计算机网络原理/CSMA协议/","link":"","permalink":"http://example.com/2020/08/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/CSMA%E5%8D%8F%E8%AE%AE/","excerpt":"","text":"CSMA协议： 载波监听多路访问协议CSMA CS：载波监听，每一个站在发送数据之前要检测一下总线上是否有其他计算机在发送数据【当几个站同时在总线上发送数据时，总线上的信号电压摆动值将会增大(互相叠加)，当一个站检测到的信号电压摆动值超过一定门限值时，就认为总线上至少有两个站同时在发送数据，表明产生了碰撞，即发生了冲突】 MA：多点接入，表示许多计算机以多点接入的方式连接在一根总线上 协议思想：发送帧之前，监听信道 监听结果：1）信道空闲：发送完整帧【1-坚持CSMA、非坚持CSMA、p-坚持CSMA】2）信道忙：推迟发送 1-坚持CSMA： 非坚持CSMA： p-坚持CSMA： 有没有什么办法可以减少资源浪费，一冲突就能发现呢？？","categories":[{"name":"计算机网络原理","slug":"计算机网络原理","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"计算机网络原理","slug":"计算机网络原理","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"}]},{"title":"CSMA-CD协议","slug":"计算机网络原理/计算机网络原理/CSMA-CD协议","date":"2020-08-08T16:00:00.000Z","updated":"2021-03-24T13:56:12.000Z","comments":true,"path":"2020/08/09/计算机网络原理/计算机网络原理/CSMA-CD协议/","link":"","permalink":"http://example.com/2020/08/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/CSMA-CD%E5%8D%8F%E8%AE%AE/","excerpt":"","text":"CSMA-CD协议： 载波监听多点接入/碰撞检测CSMA/CD CS：载波监听，每一个站在发送数据之前以及发送数据时都要检测一下总线上是否有其他计算机在发送数据 MA：多点接入，表示许多计算机以多点接入的方式连接在一根总线上（总线型网络） CD：碰撞检测（冲突检测），“边发送边监听”，适配器边发送数据边检测信道上信号电压的变化情况，以便判断自己在发送数据时其他站是否也在发送数据（半双工网络） 先听后发为什么还会冲突：因为电磁波在总线上总是以有限的速率传播的 传播时延对载波监听的影响： 如何确定碰撞后的重传时机： 最小帧长问题：A站发了一个很短的帧，但发生了碰撞，不过帧在发送完毕后才检测到发生碰撞，没法停止发送，因为已经发完了。。。","categories":[{"name":"计算机网络原理","slug":"计算机网络原理","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"计算机网络原理","slug":"计算机网络原理","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"}]},{"title":"CSMA-CA协议","slug":"计算机网络原理/计算机网络原理/CSMA-CA协议","date":"2020-08-07T16:00:00.000Z","updated":"2021-03-24T13:56:23.000Z","comments":true,"path":"2020/08/08/计算机网络原理/计算机网络原理/CSMA-CA协议/","link":"","permalink":"http://example.com/2020/08/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/CSMA-CA%E5%8D%8F%E8%AE%AE/","excerpt":"","text":"CSMA-CA协议： 载波监听多点接入/碰撞避免CSMA/CA 为什么有了CSMA-CD后还要有CSMA-CA：CSMA-CA多用于无线局域网，无线局域网无法做到360度全面检测碰撞、隐蔽站(当A和C都检测不到信号，认为信道空闲时，同时像终端B发送数据帧，就会导致冲突) CSMA-CA协议工作原理： CSMA-CD与CSMA-CA：","categories":[{"name":"计算机网络原理","slug":"计算机网络原理","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"计算机网络原理","slug":"计算机网络原理","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"}]},{"title":"轮询访问介质访问控制","slug":"计算机网络原理/计算机网络原理/轮询访问介质访问控制","date":"2020-08-06T16:00:00.000Z","updated":"2021-03-24T13:56:35.000Z","comments":true,"path":"2020/08/07/计算机网络原理/计算机网络原理/轮询访问介质访问控制/","link":"","permalink":"http://example.com/2020/08/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%BD%AE%E8%AF%A2%E8%AE%BF%E9%97%AE%E4%BB%8B%E8%B4%A8%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/","excerpt":"","text":"轮询访问介质访问控制： 介质访问控制：1）信道划分介质访问控制协议：基于多路复用技术划分资源；网络负载重的时候共享信道效率高，且公平；网络负载轻的时候共享信道效率低2）随机访问MAC协议：用户根据意愿随机发送信息，发送信息时可独占信道带宽；网络负载重时产生冲突开销；网络负载轻时共享信道效率高，单个结点可利用信道全部带宽3）轮询访问MAC协议：既要不产生冲突，又要发送时占全部带宽 轮询协议：主结点轮流邀请从属结点发送数据【问题：轮询开销、等待延迟、单点故障】 令牌传递协议：","categories":[{"name":"计算机网络原理","slug":"计算机网络原理","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"计算机网络原理","slug":"计算机网络原理","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"}]},{"title":"局域网基本概念和体系结构","slug":"计算机网络原理/计算机网络原理/局域网基本概念和体系结构","date":"2020-08-05T16:00:00.000Z","updated":"2021-03-24T13:56:45.000Z","comments":true,"path":"2020/08/06/计算机网络原理/计算机网络原理/局域网基本概念和体系结构/","link":"","permalink":"http://example.com/2020/08/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E5%B1%80%E5%9F%9F%E7%BD%91%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/","excerpt":"","text":"局域网基本概念和体系结构： 局域网：简称LAN，是指在某一区域内由多台计算机互联成的计算机组，使用广播信道 特点：1）覆盖的地理范围较小，只在一个相对独立的局部范围内联，如一座或集中的建筑群内2）使用专门铺设的传输介质（双绞线、同轴电缆）进行联网，数据传输速率高（10Mb/s～10Gb/s）3）通信延迟时间短，误码率低，可靠性较高4）各站为平等关系，共享传输信道5）多采用分布式控制和广播式通信，能进行广播和组播 决定局域网的主要要素为：网络拓扑、传输介质、介质访问控制方法 局域网拓扑结构： 局域网传输介质：1）有线局域网：双绞线、同轴电缆、光纤2）无线局域网：电磁波 局域网介质访问控制方法：1）CSMA-CD：常用于总线型局域网，也用于树型网络2）令牌总线：常用于总线型局域网，也用于树型网络；它是把总线型或树型网络中的各个工作站按一定的顺序如按接口地址大小排列形成一个逻辑环，只有令牌持有者才能控制总线，才有发送信息的权力3）令牌环：用于环形局域网，如令牌环网 局域网的分类： IEEE 802标准：1）IEEE 802.3:以太网2）IEEE 802.5:令牌环网3）IEEE 802.8:光纤4）IEEE 802.11:无线局域网 MAC子层和LLC子层：","categories":[{"name":"计算机网络原理","slug":"计算机网络原理","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"计算机网络原理","slug":"计算机网络原理","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"}]},{"title":"以太网","slug":"计算机网络原理/计算机网络原理/以太网","date":"2020-08-04T16:00:00.000Z","updated":"2021-03-24T13:56:55.000Z","comments":true,"path":"2020/08/05/计算机网络原理/计算机网络原理/以太网/","link":"","permalink":"http://example.com/2020/08/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E4%BB%A5%E5%A4%AA%E7%BD%91/","excerpt":"","text":"以太网： 以太网(Ethernet)指的是由Xerox公司创建并由Xerox、Intel和DEC公司联合开发的基带总线局域网规范，是当今现有局域网采用的最通用的通信协议标准。以太网使用CSMA/CD技术 以太网在局域网各种技术中占统治性地位：1）造价低廉(以太网网卡不到一百块)2）是应用最广泛的局域网技术3）比令牌环网、ATM网便宜，简单4）满足网络速率要求：10Mb/s～10Gb/s 以太网两个标准：1）DIX Ethernet V2:第一个局域网产品（以太网）规约2）IEEE 802.3:IEEE 802委员会802.3工作组制定的第一个IEEE的以太网标准（帧格式有一点改动） 以太网提供无连接、不可靠的服务：1）无连接：发送方和接收方之间无“握手过程”2）不可靠：不对发送方的数据帧编号，接收方不向发送方进行确认，差错帧直接丢弃，差错纠正由高层负责 以太网只实现无差错接收，不实现可靠传输 以太网传输介质与拓扑结构的发展： 10BASE-T以太网：10BASE-T是传送基带信号的双绞线以太网，T表示采用双绞线，现10BASE-T采用的是无屏蔽双绞线（UTP），传输速率是10Mb/s1）物理上采用星型拓扑，逻辑上总线型，每段双绞线最长为100m2）采用曼彻斯特编码3）采用CSMA/CD介质访问控制 适配器与MAC地址： 以太网MAC帧： 高速以太网：","categories":[{"name":"计算机网络原理","slug":"计算机网络原理","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"计算机网络原理","slug":"计算机网络原理","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"}]},{"title":"无线局域网","slug":"计算机网络原理/计算机网络原理/无线局域网","date":"2020-08-03T16:00:00.000Z","updated":"2021-03-24T13:57:05.000Z","comments":true,"path":"2020/08/04/计算机网络原理/计算机网络原理/无线局域网/","link":"","permalink":"http://example.com/2020/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E6%97%A0%E7%BA%BF%E5%B1%80%E5%9F%9F%E7%BD%91/","excerpt":"","text":"无线局域网： IEEE 802.11是无线局域网通用的标准，它是由IEEE所定义的无线网络通信的标准 无线局域网的分类：1）有固定基础设施无线局域网2）无固定基础设施无线局域网的自组织网络","categories":[{"name":"计算机网络原理","slug":"计算机网络原理","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"计算机网络原理","slug":"计算机网络原理","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"}]},{"title":"PPP协议和HDLC协议","slug":"计算机网络原理/计算机网络原理/PPP协议和HDLC协议","date":"2020-08-02T16:00:00.000Z","updated":"2021-03-24T13:57:15.000Z","comments":true,"path":"2020/08/03/计算机网络原理/计算机网络原理/PPP协议和HDLC协议/","link":"","permalink":"http://example.com/2020/08/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/PPP%E5%8D%8F%E8%AE%AE%E5%92%8CHDLC%E5%8D%8F%E8%AE%AE/","excerpt":"","text":"PPP协议和HDLC协议： 广域网：WAN，通常跨接很大的物理范围，所覆盖的范围从几十公里到几千公里，它能连接多个城市或国家，或横跨几个洲并能提供远距离通信，形成国际性的远程网络 广域网的通信子网主要使用分组交换技术，广域网的通信子网可以利用公用分组交换网、卫星通信网和无线分组交换网，它将分布在不同地区的局域网或计算机系统互连起来，达到资源共享的目的，如因特网（Internet）是世界范围内最大的广域网 ———————————— 点对点协议PPP是目前使用最广泛的数据链路层协议，用户使用拨号电话接入因特网时一般都使用PPP协议 PPP协议只支持全双工链路 PPP协议应满足的要求：1）简单：对于链路层的帧，无需纠错，无需序号，无需流量控制2）封装成帧：帧定界符3）透明传输：与帧定界符一样比特组合的数据应该如何处理：异步线路用字节填充，同步线路用比特填充4）多种网络层协议：封装的IP数据报可以采用多种协议5）多种类型链路：串行/并行，同步/异步，电/光6）差错检测：错就丢弃7）检测连接状态：链路是否正常工作8）最大传送单元：数据部分最大长度MTU9）网络层地址协商：知道通信双方的网络层地址10）数据压缩协商 PPP协议无需满足的要求：1）纠错2）流量控制3）序号4）支持多点线路 PPP协议的三个组成部分：1）一个将IP数据报封装到串行链路（同步串行/异步串行）的方法2）链路控制协议LCP：建立并维护数据链路连接（身份验证）3）网络控制协议NCP：PPP可支持多种网络层协议，每个不同的网络层协议都要一个相应的NCP来配置，为网络层协议建立和配置逻辑连接 PPP协议的状态图： PPP协议的帧格式： ——————————— HDLC协议：高级数据链路控制，是一个在同步网上传输数据、面向比特的数据链路层协议，它是由国际标准化组织ISO根据IBM公司的SDLC协议扩展开发而成的 数据报文可透明传输，用于实现透明传输的“0比特插入法”易于硬件实现 采用全双工通信 所有帧采用CRC检验，对信息帧进行顺序编号，可防止漏收或重份，传输可靠性高 HDLC的站： HDLC的帧格式： PPP协议和HDLC协议：","categories":[{"name":"计算机网络原理","slug":"计算机网络原理","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"计算机网络原理","slug":"计算机网络原理","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"}]},{"title":"链路层设备","slug":"计算机网络原理/计算机网络原理/链路层设备","date":"2020-08-01T16:00:00.000Z","updated":"2021-03-24T13:57:25.000Z","comments":true,"path":"2020/08/02/计算机网络原理/计算机网络原理/链路层设备/","link":"","permalink":"http://example.com/2020/08/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E9%93%BE%E8%B7%AF%E5%B1%82%E8%AE%BE%E5%A4%87/","excerpt":"","text":"链路层设备： 以太网物理上采用星型拓扑，逻辑上总线型，每段双绞线最长为100m 物理层扩展以太网： 链路层扩展以太网（网桥、交换机）： 1）网桥 网桥分类：1）透明网桥2）源路由网桥：在发送帧时，把详细的最佳路由信息（路由最少/时间最短）放在帧的首部中【方法：源站以广播方式向欲通信的目的站发送一个发现帧，选择其中最佳的路由线路】 2）多接口网桥—以太网交换机 以太网交换机的两种交换方式：1）直通式交换机：查完目的地址(6B)就立刻转发；延迟小，可靠性低，无法支持具有不同速率的端口的交换2）存储转发式交换机：将帧放入高速缓存，并检查是否正确，正确则转发，错误则丢弃；延迟大，可靠性高，可以支持具有不同速率的端口的交换 冲突域和广播域：","categories":[{"name":"计算机网络原理","slug":"计算机网络原理","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"计算机网络原理","slug":"计算机网络原理","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"}]},{"title":"网络层功能概述","slug":"计算机网络原理/计算机网络原理/网络层功能概述","date":"2020-07-31T16:00:00.000Z","updated":"2021-03-24T13:57:47.000Z","comments":true,"path":"2020/08/01/计算机网络原理/计算机网络原理/网络层功能概述/","link":"","permalink":"http://example.com/2020/08/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E7%BD%91%E7%BB%9C%E5%B1%82%E5%8A%9F%E8%83%BD%E6%A6%82%E8%BF%B0/","excerpt":"","text":"网络层功能概述： 网络层主要任务是把分组从源端传到目的端，为分组交换网上的不同主机提供通信服务 网络层传输单位是数据报 功能：1）路由选择与分组转发(最佳路径)2）异构网络互联3）拥塞控制：若所有结点都来不及接受分组，而要丢弃大量分组的话，网络就处于拥塞状态，因此要采取一定措施，缓解这种拥塞【开环控制(静)、闭环控制(动)】","categories":[{"name":"计算机网络原理","slug":"计算机网络原理","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"计算机网络原理","slug":"计算机网络原理","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"}]},{"title":"电路交换、报文交换、分组交换","slug":"计算机网络原理/计算机网络原理/电路交换、报文交换、分组交换","date":"2020-07-30T16:00:00.000Z","updated":"2021-03-24T13:58:09.000Z","comments":true,"path":"2020/07/31/计算机网络原理/计算机网络原理/电路交换、报文交换、分组交换/","link":"","permalink":"http://example.com/2020/07/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E7%94%B5%E8%B7%AF%E4%BA%A4%E6%8D%A2%E3%80%81%E6%8A%A5%E6%96%87%E4%BA%A4%E6%8D%A2%E3%80%81%E5%88%86%E7%BB%84%E4%BA%A4%E6%8D%A2/","excerpt":"","text":"电路交换、报文交换、分组交换： 如何使数据通过网络核心(路由器)从源主机到目的主机？——数据交换 为什么要数据交换： 数据交换方式：1）电路交换2）报文交换3）分组交换：数据报方式、虚电路方式 ————————————— 电路交换：电话网络(多路复用) 电路交换的阶段：1）建立连接（呼叫/电路建立）2）通信3）释放连接（拆除电路） 特点：独占资源 优点：通信时延小、有序传输、没有冲突、实时性强 缺点：建立连接时间长、线路独占，使用效率低、灵活性差、无差错控制能力 ————————————— 报文交换： 报文：源应用发送的信息整体 优点：1）无需建立连接2）存储转发，动态分配线路3）线路可靠性较高4）线路利用率较高5）多目标服务 缺点：1）有存储转发时延2）报文大小不定，需要网络节点有较大缓存空间 ————————————— 分组交换： 分组：把大的数据块分割成小的数据块 优点：1）无需建立连接2）存储转发，动态分配线路3）线路可靠性较高4）线路利用率较高5）相对于报文交换，存储管理更容易 缺点：1）有存储转发时延2）需要传输额外的信息量3）乱序到目的主机时，要对分组排序重组 ———————————————— 数据报方式为网络层提供无连接服务【无连接服务：不事先为分组的传输确定传输路径，每个分组独立确定传输路径，不同分组传输路径可能不同】【每个分组携带源和目的地址】【路由器根据分组的目的地址转发分组：基于路由协议/算法构建转发表；检索转发表；每个分组独立选路】 虚电路方式为网络层提供连接服务【连接服务：首先为分组的传输确定传输路径(建立连接)，然后沿该路径(连接)传输系列分组，系列分组传输路径相同，传输结束后拆除连接】 虚电路将数据报方式和电路交换方式结合，以发挥两者优点 虚电路：一条源主机到目的主机类似于电路的路径（逻辑连接），路径上所有的结点都要维持这条虚电路的建立，都维持一张虚电路表，每一项纪录了一个打开的虚电路信息 通信过程：1）建立连接（虚电路建立）：每个分组携带虚电路号，而非目的地址，源主机发送“呼叫请求”分组并收到“呼叫应答”分组后才算建立连接2）数据传输（全双工通信）3）释放连接（虚电路释放）：源主机发送“释放请求”分组以拆除虚电路","categories":[{"name":"计算机网络原理","slug":"计算机网络原理","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"计算机网络原理","slug":"计算机网络原理","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"}]},{"title":"IP数据报格式","slug":"计算机网络原理/计算机网络原理/IP数据报格式","date":"2020-07-29T16:00:00.000Z","updated":"2021-03-24T13:58:23.000Z","comments":true,"path":"2020/07/30/计算机网络原理/计算机网络原理/IP数据报格式/","link":"","permalink":"http://example.com/2020/07/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/IP%E6%95%B0%E6%8D%AE%E6%8A%A5%E6%A0%BC%E5%BC%8F/","excerpt":"","text":"IP数据报格式： TCP/IP协议栈：","categories":[{"name":"计算机网络原理","slug":"计算机网络原理","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"计算机网络原理","slug":"计算机网络原理","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"}]},{"title":"IP数据报分片","slug":"计算机网络原理/计算机网络原理/IP数据报分片","date":"2020-07-28T16:00:00.000Z","updated":"2021-03-24T13:58:37.000Z","comments":true,"path":"2020/07/29/计算机网络原理/计算机网络原理/IP数据报分片/","link":"","permalink":"http://example.com/2020/07/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/IP%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%88%86%E7%89%87/","excerpt":"","text":"","categories":[{"name":"计算机网络原理","slug":"计算机网络原理","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"计算机网络原理","slug":"计算机网络原理","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"}]},{"title":"IPv4地址","slug":"计算机网络原理/计算机网络原理/IPv4地址","date":"2020-07-27T16:00:00.000Z","updated":"2021-03-24T13:58:52.000Z","comments":true,"path":"2020/07/28/计算机网络原理/计算机网络原理/IPv4地址/","link":"","permalink":"http://example.com/2020/07/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/IPv4%E5%9C%B0%E5%9D%80/","excerpt":"","text":"IPv4地址： IP编址的历史阶段：1）分类的IP地址2）子网的划分3）构成超网（无分类编址方法） —————————————————— 分类的IP地址： IP地址：全世界唯一的32位/4字节标识符，标识路由器主机的接口【&lt;网络号&gt;&lt;主机号&gt;】 特殊IP地址： 私有IP地址： —————————————— 路由器对目的地址是私有IP地址的数据报一律不进行转发 网络地址转换NAT：在专用网连接到因特网的路由器上安装NAT软件，安装了NAT软件的路由器叫NAT路由器，它至少有一个有效的外部全球IP地址 ————————————— 子网划分和子网掩码： 分类的IP地址的弱点：1）IP地址空间的利用率有时很低2）两级IP地址不够灵活 子网掩码（相与：相同为1，不同为0）： 使用子网时分组的转发： ——————————————— 无分类编址CIDR： 构成超网：将多个子网聚合成一个较大的子网，叫做构成超网，或路由聚合 方法：将网络前缀缩短 最长前缀匹配：使用CIDR时，查找路由表可能得到几个匹配结果，应选择具有最长网络前缀的路由，前缀越长，地址块越小，路由越具体","categories":[{"name":"计算机网络原理","slug":"计算机网络原理","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"计算机网络原理","slug":"计算机网络原理","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"}]},{"title":"ARP协议","slug":"计算机网络原理/计算机网络原理/ARP协议","date":"2020-07-26T16:00:00.000Z","updated":"2021-03-24T13:59:06.000Z","comments":true,"path":"2020/07/27/计算机网络原理/计算机网络原理/ARP协议/","link":"","permalink":"http://example.com/2020/07/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/ARP%E5%8D%8F%E8%AE%AE/","excerpt":"","text":"ARP协议： 发送数据的过程：1）从主机1—&gt;主机32）从主机1—&gt;主机5 由于在实际网络的链路上传送数据帧时，最终必须使用MAC地址 ARP协议：完成主机或路由器IP地址到MAC地址的映射（解决下一跳走哪的问题） ARP协议使用过程：检查ARP高速缓存，有对应表项则写入MAC帧，没有则用目的MAC地址为FF-FF-FF-FF-FF-FF的帧封装并广播ARP请求分组，同一局域网中所有主机都能收到该请求。目的主机收到请求后就会向源主机单播一个ARP响应分组，源主机收到后将此映射写入ARP缓存（10～20min更新一次） ARP协议的4种典型情况（ARP协议自动进行）：1）主机A发给本网络上的主机B：用ARP找到主机B的硬件地址2）主机A发给另一网络上的主机B：用ARP找到本网络上一个路由器（网关）的硬件地址3）路由器发给本网络的主机A：用ARP找到主机A的硬件地址4）路由器发给另一网络的主机B：用ARP找到本网络上的一个路由器的硬件地址","categories":[{"name":"计算机网络原理","slug":"计算机网络原理","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"计算机网络原理","slug":"计算机网络原理","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"}]},{"title":"DHCP协议","slug":"计算机网络原理/计算机网络原理/DHCP协议","date":"2020-07-25T16:00:00.000Z","updated":"2021-03-24T13:59:22.000Z","comments":true,"path":"2020/07/26/计算机网络原理/计算机网络原理/DHCP协议/","link":"","permalink":"http://example.com/2020/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/DHCP%E5%8D%8F%E8%AE%AE/","excerpt":"","text":"DHCP协议： 主机如何获得IP地址：1）静态配置：IP地址、子网掩码、默认网关2）动态配置： DHCP协议：","categories":[{"name":"计算机网络原理","slug":"计算机网络原理","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"计算机网络原理","slug":"计算机网络原理","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"}]},{"title":"ICMP协议","slug":"计算机网络原理/计算机网络原理/ICMP协议","date":"2020-07-24T16:00:00.000Z","updated":"2021-03-24T13:59:46.000Z","comments":true,"path":"2020/07/25/计算机网络原理/计算机网络原理/ICMP协议/","link":"","permalink":"http://example.com/2020/07/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/ICMP%E5%8D%8F%E8%AE%AE/","excerpt":"","text":"ICMP协议： TCP/IP协议栈：ICMP协议：为了更有效的转发IP数据报和提高交付成功的机会 网际控制报文协议ICMP：ICMP协议支持主机或路由器：差错（或异常）报告、网络探询，发送特定ICMP报文【ICMP差错报文、ICMP询问报文】 ICMP差错报告报文：1）终点不可达：当路由器或主机不能交付数据报时就向源点发送终点不可达报文【无法交付】2）源点抑制：当路由器或主机由于拥塞而丢弃数据报时，就向源点发送源点抑制报文，使源点知道应当把数据报的发送速率放慢【拥塞丢数据】3）时间超过：当路由器收到生存时间TTL=0的数据报时，除丢弃该数据报外，还要向源点发送时间超过报文。当终点在预先规定的时间内不能收到一个数据报的全部数据报片时，就把已收到的数据报片都丢弃，并向源点发送时间超过报文【TTL=0】4）参数问题：当路由器或目的主机收到的数据报的首部中有的字段的值不正确时，就丢弃该数据报，并向源点发送参数问题报文【首部字段有问题】5）改变路由（重定向）：路由器把改变路由报文发送给主机，让主机知道下次应将数据报发送给另外的路由器（可通过更好的路由）【值得更好的路由】 不应发送ICMP差错报文的情况：1）对ICMP差错报告报文不再发送ICMP差错报告报文2）对第一个分片的数据报片的所有后续数据报片都不发送ICMP差错报告报文3）对具有组播地址的数据报都不发送ICMP差错报告报文【广播是一对全部；组播是一对多，有选择性的】4）对具有特殊地址（如127.0.0.0或0.0.0.0）的数据报不发送ICMP差错报告报文 ICMP询问报文：1）回送请求和回答报文：主机或路由器向特定目的主机发出的询问，收到此报文的主机必须给源主机或路由器发送ICMP回送回答报文【测试目的站是否可达以及了解其相关状态】2）时间戳请求和回答报文：请某个主机或路由器回答当前的日期和时间【用来进行时钟同步和测量时间】3）掩码地址请求和回答报文4）路由器询问和通告报文 ICMP的应用：1）PING：测试两个主机之间的连通性，使用了ICMP回送请求和回答报文2）Traceroute：跟踪一个分组从源点到终点的路径，使用了ICMP时间超过差错报告报文","categories":[{"name":"计算机网络原理","slug":"计算机网络原理","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"计算机网络原理","slug":"计算机网络原理","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"}]},{"title":"IPv6","slug":"计算机网络原理/计算机网络原理/IPv6","date":"2020-07-23T16:00:00.000Z","updated":"2021-03-24T14:00:00.000Z","comments":true,"path":"2020/07/24/计算机网络原理/计算机网络原理/IPv6/","link":"","permalink":"http://example.com/2020/07/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/IPv6/","excerpt":"","text":"IPv6： 为什么有IPv6：1）32位IPv4地址空间已分配殆尽，CIDR、NAT治标不治本；IPv6从根本上解决了地址耗尽问题2）改进首部格式3）快速处理/转发数据报4）支持QoS IPv6数据报格式： IPv6和IPv4： IPv6基本地址类型：1）单播：一对一通信，可做源地址+目的地址2）多播：一对多通信，可做目的地址3）任播：一对多中的一个通信，可做目的地址 IPv6向IPv4过渡的策略：","categories":[{"name":"计算机网络原理","slug":"计算机网络原理","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"计算机网络原理","slug":"计算机网络原理","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"}]},{"title":"路由算法与路由协议概述","slug":"计算机网络原理/计算机网络原理/路由算法与路由协议概述","date":"2020-07-22T16:00:00.000Z","updated":"2021-03-24T14:00:14.000Z","comments":true,"path":"2020/07/23/计算机网络原理/计算机网络原理/路由算法与路由协议概述/","link":"","permalink":"http://example.com/2020/07/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%B7%AF%E7%94%B1%E7%AE%97%E6%B3%95%E4%B8%8E%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE%E6%A6%82%E8%BF%B0/","excerpt":"","text":"路由算法与路由协议概述： 路由算法的分类：1）静态路由算法（非自适应路由算法）：管理员手工配置路由信息【简便、可靠，在负荷稳定、拓扑变化不大的网络中运行效果很好，广泛用于高度安全性的军事网络和较小的商业网络】【路由更新慢，不适用大型网络】2）动态路由算法（自适应路由算法）：路由期间彼此交换信息，按照路由算法优化出路由表项【路由更新快，适用大型网络，及时响应链路费用或网络拓扑变化】【算法复杂，增加网络负担】 动态路由算法：1）全局性：链路状态路由算法：OSPF协议，所有路由器掌握完整的网络拓扑和链路费用信息2）分散性：距离向量路由算法：RIP协议，路由器只掌握物理相连的邻居及链路费用 分层次的路由选择协议：","categories":[{"name":"计算机网络原理","slug":"计算机网络原理","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"计算机网络原理","slug":"计算机网络原理","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"}]},{"title":"RIP协议与距离向量算法","slug":"计算机网络原理/计算机网络原理/RIP协议与距离向量算法","date":"2020-07-21T16:00:00.000Z","updated":"2021-03-24T14:00:28.000Z","comments":true,"path":"2020/07/22/计算机网络原理/计算机网络原理/RIP协议与距离向量算法/","link":"","permalink":"http://example.com/2020/07/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/RIP%E5%8D%8F%E8%AE%AE%E4%B8%8E%E8%B7%9D%E7%A6%BB%E5%90%91%E9%87%8F%E7%AE%97%E6%B3%95/","excerpt":"","text":"RIP协议与距离向量算法： RIP是一种分布式的基于距离向量的路由选择协议，是因特网的协议标准，最大优点是简单 RIP协议要求网络中每一个路由器都维护从它自己到其他每一个目的网络的唯一最佳距离记录（即一组距离） 距离：通常为“跳数”，即从源端口到目的端口所经过的路由器个数，经过一个路由器跳数+1。特别的，从一路由器到直接连接的网络距离为1，RIP允许一条路由最多只能包含15个路由器，因此距离为16表示网络不可达 RIP协议只适用于小互联网 RIP协议：1）仅和相邻路由器交换信息2）路由器交换的信息是自己的路由表3）每30s交换一次路由信息，然后路由器根据新信息更新路由表，若超过180s没收到邻居路由器的通告，则判定邻居没了，并更新自己路由表；路由器刚开始工作时，只知道直接连接的网络的距离（距离为1），接着每一个路由器也只和数目非常有限的相邻路由器交换并更新路由信息；经过若干次更新后，所有路由器最终都会知道到达本自治系统任何一个网络的最短距离和下一跳路由器的地址，即“收敛” 距离向量算法： RIP协议的报文格式： RIP的特点：当网络出现故障时，要经过比较长的时间（例如数分钟）才能将此信息传送到所有的路由，“慢收敛”","categories":[{"name":"计算机网络原理","slug":"计算机网络原理","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"计算机网络原理","slug":"计算机网络原理","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"}]},{"title":"OSPF协议与链路状态算法","slug":"计算机网络原理/计算机网络原理/OSPF协议与链路状态算法","date":"2020-07-20T16:00:00.000Z","updated":"2021-03-24T14:00:42.000Z","comments":true,"path":"2020/07/21/计算机网络原理/计算机网络原理/OSPF协议与链路状态算法/","link":"","permalink":"http://example.com/2020/07/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/OSPF%E5%8D%8F%E8%AE%AE%E4%B8%8E%E9%93%BE%E8%B7%AF%E7%8A%B6%E6%80%81%E7%AE%97%E6%B3%95/","excerpt":"","text":"OSPF协议与链路状态算法： 开放最短路径优先OSPF协议：“开放”标明OSPF协议不是受某一家厂商控制，而是公开发表的；“最短路径优先”是因为使用了Dijkstra提出的最短路径算法SPF OSPF最主要的特征就是使用分布式的链路状态协议 链路状态路由算法： OSPF的区域： OSPF分组： OSPF其他特点：1）每隔30min，要刷新一次数据库中的链路状态2）由于一个路由器的链路状态只涉及到与相连路由器的连通状态，因而与整个互联网的规模并无直接关系，因此当互联网规模很大时，OSPF协议要比距离向量协议RIP好很多3）OSPF不存在坏消息传的慢的问题，它的收敛速度很快","categories":[{"name":"计算机网络原理","slug":"计算机网络原理","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"计算机网络原理","slug":"计算机网络原理","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"}]},{"title":"BGP协议","slug":"计算机网络原理/计算机网络原理/BGP协议","date":"2020-07-19T16:00:00.000Z","updated":"2021-03-24T14:00:56.000Z","comments":true,"path":"2020/07/20/计算机网络原理/计算机网络原理/BGP协议/","link":"","permalink":"http://example.com/2020/07/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/BGP%E5%8D%8F%E8%AE%AE/","excerpt":"","text":"BGP协议： 1）和谁交换：与其他AS的邻站BGP发言人交换信息2）交换什么：交换的网络可达性的信息，即要到达某个网络所要经过的一系列AS3）多久交换：发生变化时更新有变化的部分 BGP协议交换信息的过程：BGP所交换的网络可达性的信息就是要到达某个网络所要经过的一系列AS，当BGP发言人互相交换了网络可达性的信息后，各BGP发言人就根据所采用的策略从收到的路由信息中找出到达各AS的较好路由 BGP协议报文格式： BGP协议特点：1）BGP支持CIDR，因此BGP的路由表也就应当包括目的网络前缀、下一跳路由器，以及到达该目的网络所要经过的各个自治系统序列2）在BGP刚刚运行时，BGP的邻站是交换整个的BGP路由表，但以后只需要在发生变化时更新有变化的部分，这样做对节省网络带宽和减少路由器的处理开销都有好处 BGP-4的四种报文： 三种路由协议比较：","categories":[{"name":"计算机网络原理","slug":"计算机网络原理","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"计算机网络原理","slug":"计算机网络原理","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"}]},{"title":"IP组播","slug":"计算机网络原理/计算机网络原理/IP组播","date":"2020-07-18T16:00:00.000Z","updated":"2021-03-24T14:01:11.000Z","comments":true,"path":"2020/07/19/计算机网络原理/计算机网络原理/IP组播/","link":"","permalink":"http://example.com/2020/07/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/IP%E7%BB%84%E6%92%AD/","excerpt":"","text":"IP组播： IP数据报的三种传输方式：1）单播：单播用于发送数据包到单个目的地，且每发送一份单播报文都使用一个单播IP地址作为目的地址，是一种点对点传输方式2）广播：广播是指发送数据包到同一广播域或子网内的所有设备的一种数据传输方式，是一种点对多点传输方式3）组播(多播)：当网络中的某些用户需要特定数据时，组播数据发送者仅发送一次数据，借助组播路由协议为组播数据包建立组播分发树，被传递的数据到达距离用户端尽可能近的节点后才开始复制和分发，是一种点对多点传输方式 IP组播地址： 硬件组播： —————————————————— 网际组管理协议IGMP： IGMP工作的两个阶段：1）某主机要加入组播组时，该主机向组播组的组播地址发送一个IGMP报文，声明自己要成为该组的成员；本地组播路由器收到IGMP报文后，要利用组播路由选择协议把这组成员关系发给因特网上的其他组播路由器2）本地组播路由器周期性探寻本地局域网上的主机，以便知道这些主机是否还是组播组的成员；只要有一个主机对某个组响应，那么组播路由器就认为这个组是活跃的，如果经过几次探寻后没有一个主机响应，组播路由器就认为本网络上没有此组播组的主机，因此就不再把这组的成员关系发给其他的组播路由器 组播路由器知道的成员关系只是所连接的局域网中有无组播组的成员 组播路由选择协议目的是找出以源主机为根节点的组播转发树 构造树可以避免在路由器之间兜圈子 对不同的多播组对应于不同的多播转发树；同一个多播组，对不同的源点也会有不同的多播转发树 组播路由选择协议常使用的三种算法：1）基于链路状态的路由选择2）基于距离-向量的路由选择3）协议无关的组播（稀疏/密集）","categories":[{"name":"计算机网络原理","slug":"计算机网络原理","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"计算机网络原理","slug":"计算机网络原理","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"}]},{"title":"移动IP","slug":"计算机网络原理/计算机网络原理/移动IP","date":"2020-07-17T16:00:00.000Z","updated":"2021-03-24T14:01:25.000Z","comments":true,"path":"2020/07/18/计算机网络原理/计算机网络原理/移动IP/","link":"","permalink":"http://example.com/2020/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E7%A7%BB%E5%8A%A8IP/","excerpt":"","text":"移动IP： 移动IP技术是移动结点（计算机/服务器等）以固定的网络IP地址，实现跨越不同网段的漫游功能，并保证了基于网络IP的网络权限在漫游过程中不发生任何改变 移动结点：具有永久IP地址的移动设备 归属代理（本地代理）：一个移动结点拥有的旧“居所”称为归属网络，在归属网络中代表移动结点执行移动管理功能的实体叫做归属代理 外部代理（外地代理）：在外部网络中帮助移动结点完成移动管理功能的实体称为外部代理 永久地址（归属地址/主地址）：移动站点在归属网络中的原始地址 转交地址（辅地址）：移动站点在外部网络使用的临时地址 移动IP通信过程：","categories":[{"name":"计算机网络原理","slug":"计算机网络原理","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"计算机网络原理","slug":"计算机网络原理","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"}]},{"title":"网络层设备","slug":"计算机网络原理/计算机网络原理/网络层设备","date":"2020-07-16T16:00:00.000Z","updated":"2021-03-24T14:01:39.000Z","comments":true,"path":"2020/07/17/计算机网络原理/计算机网络原理/网络层设备/","link":"","permalink":"http://example.com/2020/07/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E7%BD%91%E7%BB%9C%E5%B1%82%E8%AE%BE%E5%A4%87/","excerpt":"","text":"网络层设备： 路由器：是一种具有多个输入端口和多个输出端口的专用计算机，其任务是转发分组 输入端口对线路上收到的分组的处理：输入端口中的查找和转发功能在路由器的交换功能中是最重要的 输出端口将交换结构传送来的分组发送到线路：若路由器处理分组的速率赶不上分组进入队列的速率，则队列的存储空间最终必定减少到零，这就使后面再进入队列的分组由于没有存储空间而只能被丢弃【路由器中的输入或输出队列产生溢出是造成分组丢失的重要原因】 三层设备的区别：1）集线器：不能互联两个物理层不同的网段2）网桥：可以互联两个物理层和链路层不同的网段3）路由器：可以互联两个不同网络层协议的网段 路由表与路由转发：","categories":[{"name":"计算机网络原理","slug":"计算机网络原理","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"计算机网络原理","slug":"计算机网络原理","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"}]},{"title":"传输层概述","slug":"计算机网络原理/计算机网络原理/传输层概述","date":"2020-07-15T16:00:00.000Z","updated":"2021-03-24T14:01:53.000Z","comments":true,"path":"2020/07/16/计算机网络原理/计算机网络原理/传输层概述/","link":"","permalink":"http://example.com/2020/07/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E4%BC%A0%E8%BE%93%E5%B1%82%E6%A6%82%E8%BF%B0/","excerpt":"","text":"传输层概述： 传输层：只有主机才有的层次，为应用层提供通信服务，使用网络层的服务 传输层的功能：1）传输层提供进程和进程之间的逻辑通信，网络层提供主机之间的逻辑通信2）复用和分用3）传输层对收到的报文进行差错检测4）传输层的两种协议 1）面向连接的传输控制协议TCP：传送数据之前必须建立连接，数据传送结束后要释放连接，不提供广播或多播服务，由于TCP要提供可靠的面向连接的传输服务，因此不可避免增加了许多开销：确认、流量控制、计时器及连接管理等【可靠，面向连接，时延大，适用于大文件】2）无连接的用户数据报协议UDP：传送数据前不需要建立连接，收到UDP报文后也不需要给出任何确认【不可靠，无连接，时延小，适用于小文件】 传输层的寻址与端口： 复用：应用层所有的应用进程都可以通过传输层再传输到网络层分用：传输层从网络层收到数据后交付指明的应用进程 端口是传输层的SAP，标识主机中的应用进程【逻辑端口/软件端口】 端口号只有本地意义，在因特网中不同计算机的相同端口是没有联系的 端口号长度为16bit，能表示65536个不同的端口号在网络中采用发送方和接收方的套接字组合来识别端点，套接字唯一标识了网络中的一个主机和它上面的一个进程 套接字Socket=（主机IP地址，端口号）","categories":[{"name":"计算机网络原理","slug":"计算机网络原理","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"计算机网络原理","slug":"计算机网络原理","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"}]},{"title":"UDP协议","slug":"计算机网络原理/计算机网络原理/UDP协议","date":"2020-07-14T16:00:00.000Z","updated":"2021-03-24T14:02:07.000Z","comments":true,"path":"2020/07/15/计算机网络原理/计算机网络原理/UDP协议/","link":"","permalink":"http://example.com/2020/07/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/UDP%E5%8D%8F%E8%AE%AE/","excerpt":"","text":"UDP协议： 用户数据报协议UDP只在IP数据报服务之上增加了很少功能，即复用分用和差错检测功能 UDP的主要特点：1）UDP是无连接的，减少开销和发送数据之前的时延2）UDP使用最大努力交付，即不保证可靠交付3）UDP是面向报文的，适合一次性传输少量数据的网络应用4）UDP无拥塞控制，适合很多实时应用5）UDP首部开销小，8B，TCP 20B UDP首部格式： UDP校验：","categories":[{"name":"计算机网络原理","slug":"计算机网络原理","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"计算机网络原理","slug":"计算机网络原理","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"}]},{"title":"TCP协议","slug":"计算机网络原理/计算机网络原理/TCP协议","date":"2020-07-13T16:00:00.000Z","updated":"2021-03-24T14:02:23.000Z","comments":true,"path":"2020/07/14/计算机网络原理/计算机网络原理/TCP协议/","link":"","permalink":"http://example.com/2020/07/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/TCP%E5%8D%8F%E8%AE%AE/","excerpt":"","text":"TCP协议： —————————————— TCP协议特点和TCP报文段格式TCP连接管理TCP可靠传输TCP流量控制TCP拥塞控制 —————————————— TCP协议的特点：1）TCP是面向连接（虚连接）的传输层协议2）每一条TCP连接只能有两个端点，每一条TCP连接只能是点对点的3）TCP提供可靠交付的服务，无差错、不丢失、不重复、按序到达【可靠有序，不丢不重】4）TCP提供全双工通信：【发送缓存：准备发送的数据、已发送但尚未收到确认的数据；接收缓存：按序到达但尚未被接受应用程序读取的数据、不按序到达的数据】5）TCP面向字节流：TCP把应用程序交下来的数据看成仅仅是一连串的无结构的字节流【流：流入到进程或从进程流出的字节序列】 TCP报文段首部格式：—————————————————— TCP连接管理： TCP连接传输三个阶段：1）连接建立2）数据传送3）连接释放 TCP连接的建立采用客户服务器方式，主动发起连接建立的应用进程叫做客户，而被动等待连接建立的应用进程叫服务器 TCP的连接建立(三次握手)：假设运行在一台主机（客户）上的一个进程想与另一台主机（服务器）上的一个进程建立一条连接，客户应用进程首先通知客户TCP，它想建立一个与服务器上某个进程之间的连接，客户中的TCP会用以下步骤与服务器中的TCP建立一条TCP连接：【seq：序号，ack：确认号】 SYN洪泛攻击：【解决办法：SYN cookie】 TCP的连接释放(四次挥手)：参与一条TCP连接的两个进程中的任何一个都能终止该连接，连接结束后，主机中的“资源”（缓存和变量）将被释放 ———————————————— TCP可靠传输： 网络层：提供尽最大努力交付，不可靠传输传输层：使用TCP实现可靠传输【如果使用UDP协议，则在应用层实现可靠传输】 可靠：保证接收方进程从缓存区读出的字节流与发送方发出的字节流是完全一样的 TCP实现可靠传输的机制：1）校验：与UDP校验一样，增加伪首部2）序号3）确认：TCP默认使用累计确认4）重传：确认重传不分家，TCP的发送方在规定的时间内没有收到确认就要重传已发送的报文段【超时重传，TCP采用自适应算法，动态改变重传时间RTTs(加权平均往返时间)】 等太久了怎么办？？？ ————————————————— TCP流量控制：让发送方慢点，要让接收方来得及接收 TCP利用滑动窗口机制实现流量控制 在通信过程中，接收方根据自己接收缓存的大小，动态的调整发送方的发送窗口大小，即接收窗口rwnd（接收方设置确认报文段的窗口字段来将rwnd通知给发送方），发送方的发送窗口取接收窗口rwnd和拥塞窗口cwnd的最小值【接收窗口：接收方根据接受缓存设置的值，并告知给发送方，反映接收方容量；拥塞窗口：发送方根据自己估算的网络拥塞程度而设置的窗口值，反映网络当前容量】 这个时候假设B给A发了一个非零的rwnd，但是在路上丢失了，主机A在等着B发送非零窗口，主机B在等着A的确认消息，两者相互等待，造成死锁 解决方法：1）TCP为每一个连接设有一个持续计时器，只要TCP连接的一方收到对方的零窗口通知，就启动持续计时器2）若持续计时器设置的时间到期，就发送一个零窗口探测报文段，接收方收到探测报文段时给出现在的窗口值3）若窗口仍然是0，那么发送方就重新设置持续计时器 ———————————————— TCP拥塞控制：防止过多的数据注入到网络中【全局性】 出现拥塞的条件：对资源需求的总和&gt;可用资源【网络中有许多资源同时呈现供应不足—&gt;网络性能变坏—&gt;网络吞吐量将随输入负荷增大而下降】 拥塞控制四种算法：1）慢开始、拥塞避免2）快重传、快恢复","categories":[{"name":"计算机网络原理","slug":"计算机网络原理","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"计算机网络原理","slug":"计算机网络原理","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"}]},{"title":"网络应用模型","slug":"计算机网络原理/计算机网络原理/网络应用模型","date":"2020-07-12T16:00:00.000Z","updated":"2021-03-24T14:02:37.000Z","comments":true,"path":"2020/07/13/计算机网络原理/计算机网络原理/网络应用模型/","link":"","permalink":"http://example.com/2020/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E6%A8%A1%E5%9E%8B/","excerpt":"","text":"网络应用模型： 应用层对应用程序的通信提供服务 应用层的功能：1）文件传输、访问和管理2）电子邮件3）虚拟终端4）查询服务和远程作业登录 应用层的重要协议：1）FTP、TFTP2）SMTP、POP3、IMAP3）HTTP 网络应用模型：1）客户/服务器模型（Client/Server）2）P2P模型（Peer-to-Peer） ————————— 服务器：提供计算服务的设备【永久提供服务、永久性访问地址/域名】 客户机：请求计算服务的主机1）与服务器通信，使用服务器提供的服务2）间歇性接入网络3）可能使用动态IP地址4）不与其他客户机直接通信 应用：Web、文件传输FTP、远程登录、电子邮件 ————————— P2P模型：1）不存在永远在线的服务器2）每个主机既可以提供服务，也可以请求服务3）任意端系统/节点之间可以直接通讯4）节点间歇性接入网络5）节点可能改变IP地址6）可扩展性好7）网络健壮性强","categories":[{"name":"计算机网络原理","slug":"计算机网络原理","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"计算机网络原理","slug":"计算机网络原理","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"}]},{"title":"域名解析系统DNS","slug":"计算机网络原理/计算机网络原理/域名解析系统DNS","date":"2020-07-11T16:00:00.000Z","updated":"2021-03-24T14:03:04.000Z","comments":true,"path":"2020/07/12/计算机网络原理/计算机网络原理/域名解析系统DNS/","link":"","permalink":"http://example.com/2020/07/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E7%B3%BB%E7%BB%9FDNS/","excerpt":"","text":"域名解析系统DNS： ———————————————————","categories":[{"name":"计算机网络原理","slug":"计算机网络原理","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"计算机网络原理","slug":"计算机网络原理","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"}]},{"title":"文件传输协议FTP","slug":"计算机网络原理/计算机网络原理/文件传输协议FTP","date":"2020-07-10T16:00:00.000Z","updated":"2021-03-24T14:03:25.000Z","comments":true,"path":"2020/07/11/计算机网络原理/计算机网络原理/文件传输协议FTP/","link":"","permalink":"http://example.com/2020/07/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AEFTP/","excerpt":"","text":"文件传输协议FTP： 文件传送协议：1）文件传送协议FTP(File Transfer Protocol)：提供不同种类主机系统（硬、软件体系等都可以不同）之间的文件传输能力【拷贝：上传、下载】2）简单文件传送协议TFTP FTP服务器和用户端：1）FTP是基于客户/服务器（C/S）的协议2）用户通过一个客户机程序连接至在远程计算机上运行的服务器程序3）依照FTP协议提供服务，进行文件传送的计算机就是FTP服务器4）连接FTP服务器，遵循FTP协议与服务器传送文件的电脑就是FTP客户端 FTP工作原理：1）登陆：FTP地址、用户名、密码匿名登陆：2）FTP使用TCP实现可靠传输【FTP服务器进程：一个主进程、n个从属进程】【控制进程和数据传送进程都属于从属进程】 FTP传输模式：1）文本模式：ASCII模式，以文本序列传输数据2）二进制模式：Binary模式，以二进制序列传输数据","categories":[{"name":"计算机网络原理","slug":"计算机网络原理","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"计算机网络原理","slug":"计算机网络原理","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"}]},{"title":"电子邮件","slug":"计算机网络原理/计算机网络原理/电子邮件","date":"2020-07-09T16:00:00.000Z","updated":"2021-03-24T14:03:40.000Z","comments":true,"path":"2020/07/10/计算机网络原理/计算机网络原理/电子邮件/","link":"","permalink":"http://example.com/2020/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6/","excerpt":"","text":"电子邮件： 组成结构： —————————————————— 简单邮件传送协议SMTP【使用TCP连接、端口号为25、C/S】【MIME】：1）SMTP规定了在两个相互通信的SMTP进程之间应如何交换信息2）负责发送邮件的SMTP进程就是SMTP客户，负责接收邮件的进程就是SMTP服务器3）SMTP规定了14条命令（几个字母）和21种应答信息（三位数字代码+简单文字说明） SMTP通信三个阶段： SMTP的缺点：1）SMTP不能传送可执行文件或者其他二进制对象2）SMTP仅限于传送7位ASCII码，不能传送其他非英语国家的文字3）SMTP服务器会拒绝超过一定长度的邮件 ——————————————————— 邮局协议POP3【TCP连接、端口号为110、C/S】:POP3工作方式：下载并保留(在服务器)、下载并删除 ————————————————— 网际报文存取协议IMAP：1）IMAP协议比POP协议复杂，当用户Pc上的IMAP客户程序打开IMAP服务器的邮箱时，用户可以看到邮箱的首部，若用户需要打开某个邮件，该邮件才上传到用户的计算机上2）IMAP可以让用户在不同的地方使用不同的计算机随时上网阅读处理邮件，还允许只读取邮件中的某一个部分（先看正文，有WI-FI的时候再下载附件） ———————————————— 基于万维网的电子邮件（方便）：","categories":[{"name":"计算机网络原理","slug":"计算机网络原理","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"计算机网络原理","slug":"计算机网络原理","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"}]},{"title":"万维网和HTTP协议","slug":"计算机网络原理/计算机网络原理/万维网和HTTP协议","date":"2020-07-08T16:00:00.000Z","updated":"2021-03-24T14:03:55.000Z","comments":true,"path":"2020/07/09/计算机网络原理/计算机网络原理/万维网和HTTP协议/","link":"","permalink":"http://example.com/2020/07/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E4%B8%87%E7%BB%B4%E7%BD%91%E5%92%8CHTTP%E5%8D%8F%E8%AE%AE/","excerpt":"","text":"万维网和HTTP协议： 万维网WWW（World Wide Web）是一个大规模的、联机式的信息储藏所/资料空间，是无数个网络站点和网页的集合用户通过点击超链接（http://www.baidu.com）获取资源，这些资源通过超文本传输协议HTTP传送给使用者 万维网以客户/服务器方式工作，用户使用的浏览器就是万维网客户程序，万维网文档所驻留的主机运行服务器程序 万维网使用超文本标记语言HTML，使得万维网页面设计者可以很方便的从一个界面的链接转到另一个界面，并能够在自己的屏幕上显示出来 ——————————————————— 超文本传输协议HTTP：HTTP协议定义了浏览器（万维网客户进程）怎样向万维网服务器请求万维网文档，以及服务器怎样把文档传送给浏览器 HTTP协议的特点：1）HTTP协议是无状态的【但是在实际工作中，一些万维网站点常常希望能够识别用户（淘宝、Cookie），Cookie是存储在用户主机中的文本文件，记录一段时间内某用户（使用识别码识别，如“123456”）的访问记录、提供个性化服务】2）HTTP采用TCP作为运输层协议，但HTTP协议本身是无连接的（通信双方在交换HTTP报文之前不需要先建立HTTP连接） HTTP的连接方式：1）持久连接(Keep-alive)：非流水线、流水线2）非持久连接(Close) HTTP报文结构：","categories":[{"name":"计算机网络原理","slug":"计算机网络原理","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"计算机网络原理","slug":"计算机网络原理","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"}]},{"title":"数据结构和算法的基本概念","slug":"数据结构和算法/数据结构、算法笔记/数据结构和算法的基本概念","date":"2020-01-30T16:00:00.000Z","updated":"2021-03-23T07:48:17.000Z","comments":true,"path":"2020/01/31/数据结构和算法/数据结构、算法笔记/数据结构和算法的基本概念/","link":"","permalink":"http://example.com/2020/01/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/","excerpt":"","text":"数据：数据是信息的载体，是描述客观事物属性的数、字符及所有能输入到计算机中并被计算机程序识别和处理的符号的集合，数据是计算机程序加工的原料 数据元素和数据项：数据元素是数据的基本单位，通常作为一个整体进行考虑和处理；一个数据元素可由若干数据项组成，数据项是构成数据元素的不可分割的最小单位 结构：各个元素之间的关系 数据结构：是相互之间存在一种或多种特定关系的数据元素的集合数据对象：是具有相同性质的数据元素的集合，是数据的一个子集 数据结构的三要素： 逻辑结构：数据元素之间的逻辑关系是什么【集合、线性结构、树形结构、图状结构(网状结构)】 物理结构(存储结构)：各个数据元素在内存中如何存储，如何用计算机表示数据元素的逻辑关系【顺序存储、链式存储、索引存储、散列存储】 数据的运算：施加在数据上的运算包括运算的定义和实现，运算的定义是针对逻辑结构的，指出运算的功能；运算的实现是针对存储结构的，指出运算的具体操作步骤 线性结构：1）顺序存储：把逻辑上相邻的元素存储在物理位置上也相邻的存储单元中，元素之间的关系由存储单元的邻接关系来体现2）链式存储：逻辑上相邻的元素在物理位置上可以不相邻，借助指示元素存储地址的指针来表示元素之间的逻辑关系3）索引存储：在存储元素信息的同时，还建立附加的索引表，索引表的每项称为索引项，索引项的一般形式是（关键字，地址）4）散列存储：根据元素的关键字直接计算出该元素的存储地址，又称哈希存储 数据类型：一个值的集合和定义在此集合上的一组操作的总称1）原子类型【bool、int】2）结构类型【struct】 抽象数据类型（ADT）：是抽象数据组织及与之相关的操作 程序=数据结构+算法 算法的特性：1）有穷性：一个算法必须总在执行有穷步之后结束，且每一步都可在有穷时间内完成【算法必须是有穷的，而程序可以是无穷的】2）确定性：算法中每条指令必须有确切的含义，对于相同的输入只能得出相同的输出3）可行性：算法中描述的操作都可以通过已经实现的基本运算执行有限次来实现4）输入和输出 好算法的特质：1）正确性：算法应能够正确的解决求解问题2）可读性：算法应具有良好的可读性，以帮助人们理解3）健壮性：输入非法数据时，算法能适当的做出反应或进行处理，而不会产生莫名其妙的输出结果4）高效率与低存储量需求","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构、算法笔记","slug":"数据结构、算法笔记","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"}]},{"title":"算法的时间复杂度和空间复杂度","slug":"数据结构和算法/数据结构、算法笔记/算法的时间复杂度和空间复杂度","date":"2020-01-29T16:00:00.000Z","updated":"2021-03-23T07:48:06.000Z","comments":true,"path":"2020/01/30/数据结构和算法/数据结构、算法笔记/算法的时间复杂度和空间复杂度/","link":"","permalink":"http://example.com/2020/01/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%92%8C%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/","excerpt":"","text":"算法时间复杂度和空间复杂度如何评估算法时间开销：让算法先运行，事后统计运行时间？【存在问题：和机器性能有关；和编程语言有关，越高级的语言执行效率越低；和编译程序产生的机器指令质量有关；有些算法是不能事后再统计的(导弹控制算法)】 算法时间复杂度：事前预估算法时间开销T(n)与问题规模n的关系1）最坏时间复杂度2）平均时间复杂度3）最好时间复杂度 O(1)&lt;O(log2n)&lt;O(n)&lt;O(nlog2n)&lt;O(n^2)&lt;O(n^3)&lt;O(2^n)&lt;O(n!)&lt;O(n^n) 测试算法效率(时钟打点)问题： 源代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465//clock():捕捉从程序开始运行到clock()被调用时所耗费的时间。这个时间单位是clock tick，即“时钟打点”//常数CLK_TCK:机器时钟每秒所走的时钟打点数//让被测函数重复运行充分多次，使得测出的总的时钟打点间隔充分长，最后计算被测函数平均每次运行的时间即可#include&lt;stdio.h&gt;#include&lt;time.h&gt;#include&lt;math.h&gt;#define MAXN 10#define MAXK 1e7//被测函数最大重复调用次数clock_t start,stop;//clock_t是clock()函数返回的变量类型double duration;//记录被测函数运行时间，以秒为单位double f1(int n,double a[],double x)&#123; int i; double p=a[0]; for(i=1;i&lt;=n;i++)&#123; p += (a[i]*pow(x,i)); &#125; return p;&#125;double f2(int n,double a[],double x)&#123; int i; double p=a[0]; for(i=1;i&lt;=n;i++)&#123; p+=(a[i]*pow(x,i)); &#125; return p;&#125;int main()&#123; int i,CLK_TCK; double a[MAXN];//存储多项式的系数 for(i=0;i&lt;MAXN;i++)&#123; a[i]=(double)i; &#125; //不在测试范围内的准备工作写在clock()调用之前 start=clock();//开始计时 for(i=0;i&lt;MAXK;i++)&#123; f1(MAXN-1,a,1.1);//把被测函数加在这里 &#125; stop=clock();//停止计时 duration=((double)(stop-start))/CLK_TCK/MAXK;//计算函数单次运行时间 printf(&quot;ticks1=%f\\n&quot;,(double)(stop-start)); printf(&quot;duration1=%6.2e\\n&quot;,duration); //其他不在测试范围的处理写在后面，例如输出duration的值 start=clock();//开始计时 for(i=0;i&lt;MAXK;i++)&#123; f2(MAXN-1,a,1.1);//把被测函数加在这里 &#125; stop=clock();//停止计时 duration=((double)(stop-start))/CLK_TCK/MAXK;//计算函数单次运行时间 printf(&quot;ticks2=%f\\n&quot;,(double)(stop-start)); printf(&quot;duration2=%6.2e\\n&quot;,duration); return 0;&#125;","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构、算法笔记","slug":"数据结构、算法笔记","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"}]},{"title":"线性表的定义和基本操作","slug":"数据结构和算法/数据结构、算法笔记/线性表的定义和基本操作","date":"2020-01-28T16:00:00.000Z","updated":"2021-03-23T07:47:54.000Z","comments":true,"path":"2020/01/29/数据结构和算法/数据结构、算法笔记/线性表的定义和基本操作/","link":"","permalink":"http://example.com/2020/01/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/","excerpt":"","text":"线性表：是具有相同数据类型的n(n&gt;=0)个数据元素的有限序列，其中n为表长，当n=0时线性表是一个空表【位序从1开始，数组下标从0开始】 线性表的基本操作： InitList(&amp;L)：初始化表，构造一个空的线性表L，分配内存空间 DestroyList(&amp;L)：销毁操作，销毁线性表，并释放线性表L所占用的内存空间 ListInsert(&amp;L,i,e)：插入操作，在表L中的第i个位置上插入指定元素e ListDelete(&amp;L,i,&amp;e)：删除操作，删除表L中第i个位置的元素，并用e返回删除元素的值 LocateElem(L,e)：按值查找操作，在表L中查找具有给定关键字值的元素 GetElem(L,i)：按位查找操作，获取表L中第i个位置的元素的值 Length(L)：求表长，返回线性表L的长度，即L中数据元素的个数 PrintList(L)：输出操作，按前后顺序输出线性表L的所有元素值 Empty(L)：判空操作，若L为空表，则返回true，否则返回false","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构、算法笔记","slug":"数据结构、算法笔记","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"}]},{"title":"顺序表的定义","slug":"数据结构和算法/数据结构、算法笔记/顺序表的定义","date":"2020-01-27T16:00:00.000Z","updated":"2021-03-23T07:47:41.000Z","comments":true,"path":"2020/01/28/数据结构和算法/数据结构、算法笔记/顺序表的定义/","link":"","permalink":"http://example.com/2020/01/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E5%AE%9A%E4%B9%89/","excerpt":"","text":"顺序表：用顺序存储的方式实现线性表，每个结点中只存放数据元素 顺序表的特点： 随机访问，即可以在O(1)时间内找到第i个元素 存储密度高，每个节点只存储数据元素 拓展容量不方便（即便采用动态分配的方式实现，拓展长度的时间复杂度也比较高） 插入、删除操作不方便，需要移动大量元素 顺序表的实现（静态分配）： 12345678910111213141516171819202122232425262728//顺序表的静态分配#include &lt;stdio.h&gt;#define MaxSize 10 //定义最大长度typedef struct&#123; int data[MaxSize]; //用静态的“数组”存放数据元素 int length; //顺序表的当前长度&#125;SqList; //顺序表的类型定义//基本操作：初始化一个顺序表void InitList(SqList *L)&#123; for(int i=0;i&lt;MaxSize;i++)&#123; L-&gt;data[i]=0; //将所有数据元素设置为默认初始值 &#125; L-&gt;length=0; //顺序表初始长度为0&#125;int main()&#123; SqList L; //声明一个顺序表 InitList(&amp;L); //初始化顺序表 //...未完待续，后续操作 return 0;&#125; 顺序表的实现（动态分配）： 123456789101112131415161718192021222324252627282930313233343536373839//顺序表的动态分配#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define InitSize 10 //默认的最大长度typedef struct&#123; int *data; //指示动态分配数组的指针 int MaxSize; //顺序表的最大容量 int length; //顺序表的当前长度&#125;SeqList;void InitList(SeqList *L)&#123; //用malloc函数申请一片连续的存储空间 L-&gt;data=(int *)malloc(InitSize*sizeof(int)); L-&gt;length=0; L-&gt;MaxSize=InitSize;&#125;//增加动态数组的长度void IncreaseSize(SeqList *L,int len)&#123; int *p=L-&gt;data; L-&gt;data=(int *)malloc((L-&gt;MaxSize+len)*sizeof(int)); for(int i=0;i&lt;L-&gt;length;i++)&#123; L-&gt;data[i]=p[i]; //将数据复制到新区域 &#125; L-&gt;MaxSize=L-&gt;MaxSize+len; //顺序表最大长度增加len free(p); //释放原来的内存空间&#125;int main()&#123; SeqList L; //声明一个顺序表 InitList(&amp;L); //初始化顺序表 //往顺序表加入几个元素，加满 IncreaseSize(&amp;L,5); return 0;&#125;","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构、算法笔记","slug":"数据结构、算法笔记","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"}]},{"title":"顺序表的插入和删除","slug":"数据结构和算法/数据结构、算法笔记/顺序表的插入和删除","date":"2020-01-26T16:00:00.000Z","updated":"2021-03-23T07:47:25.000Z","comments":true,"path":"2020/01/27/数据结构和算法/数据结构、算法笔记/顺序表的插入和删除/","link":"","permalink":"http://example.com/2020/01/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4/","excerpt":"","text":"顺序表的插入(最好O(1),最坏O(n),平均O(n)) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//顺序表的插入#include &lt;stdio.h&gt;#include&lt;stdbool.h&gt; //可以使用bool了#define MaxSize 10 //定义最大长度typedef struct&#123; int data[MaxSize]; //用静态的“数组”存放数据元素 int length; //顺序表的当前长度&#125;SqList; //顺序表的类型定义//基本操作：初始化一个顺序表void InitList(SqList *L)&#123; for(int i=0;i&lt;MaxSize;i++)&#123; L-&gt;data[i]=0; //将所有数据元素设置为默认初始值 &#125; L-&gt;length=0; //顺序表初始长度为0&#125;//i的取值：[1,length+1]，因为顺序表是连续排列的bool ListInsert(SqList *L,int i,int e)&#123; if(i&lt;1 || i&gt;L-&gt;length+1)&#123; //判断i的范围是否有效 return false; &#125; if(L-&gt;length &gt;= MaxSize)&#123; //当前存储空间已满，不能插入 return false; &#125; for(int j=L-&gt;length;j&gt;=i;j--)&#123; //将第i个元素及之后的元素后移 L-&gt;data[i]=L-&gt;data[j-1]; &#125; L-&gt;data[i-1]=e; //在位置i处放入e L-&gt;length++; //长度加1 return true;&#125;int main()&#123; SqList L; //声明一个顺序表 InitList(&amp;L); //初始化顺序表 //...此处插入几个元素 bool b=ListInsert(&amp;L, 3, 4); //在位置3处放入4 return 0;&#125; 顺序表的删除(最好O(1),最坏O(n),平均O(n)) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//顺序表的删除#include &lt;stdio.h&gt;#include&lt;stdbool.h&gt; //可以使用bool了#define MaxSize 10 //定义最大长度typedef struct&#123; int data[MaxSize]; //用静态的“数组”存放数据元素 int length; //顺序表的当前长度&#125;SqList; //顺序表的类型定义//基本操作：初始化一个顺序表void InitList(SqList *L)&#123; for(int i=0;i&lt;MaxSize;i++)&#123; L-&gt;data[i]=0; //将所有数据元素设置为默认初始值 &#125; L-&gt;length=0; //顺序表初始长度为0&#125;bool ListDelete(SqList *L,int i,int *e)&#123; if(i&lt;1 || i&gt;L-&gt;length)&#123; //判断i的范围是否有效 return false; &#125; *e=L-&gt;data[i-1]; //将被删除的元素赋值给e for(int j=i;j&lt;L-&gt;length;j++)&#123; //将第i个位置后的元素前移 L-&gt;data[j-1]=L-&gt;data[j]; &#125; L-&gt;length--; //线性表长度减1 return true;&#125;int main()&#123; SqList L; //声明一个顺序表 InitList(&amp;L); //初始化顺序表 //...此处插入几个元素 int e=-1; //用变量e把删除的元素“带回来” if(ListDelete(&amp;L, 3, &amp;e))&#123; printf(&quot;已删除第3个元素，删除元素值为%d\\n&quot;,e); &#125; else&#123; printf(&quot;位序i不合法，删除失败\\n&quot;); &#125; return 0;&#125;","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构、算法笔记","slug":"数据结构、算法笔记","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"}]},{"title":"顺序表的查找","slug":"数据结构和算法/数据结构、算法笔记/顺序表的查找","date":"2020-01-25T16:00:00.000Z","updated":"2021-03-23T07:47:14.000Z","comments":true,"path":"2020/01/26/数据结构和算法/数据结构、算法笔记/顺序表的查找/","link":"","permalink":"http://example.com/2020/01/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE/","excerpt":"","text":"顺序表的按位查找(时间复杂度：O(1))GetElem(L,i)：按位查找操作，获取表L中第i个位置的元素的值 静态分配： 123456789101112131415161718192021222324252627282930313233343536//顺序表的按位查找（静态分配）#include &lt;stdio.h&gt;#define MaxSize 10 //定义最大长度typedef struct&#123; int data[MaxSize]; //用静态的“数组”存放数据元素 int length; //顺序表的当前长度&#125;SqList; //顺序表的类型定义//基本操作：初始化一个顺序表void InitList(SqList *L)&#123; for(int i=0;i&lt;MaxSize;i++)&#123; L-&gt;data[i]=0; //将所有数据元素设置为默认初始值 &#125; L-&gt;length=0; //顺序表初始长度为0&#125;int GetElem(SqList *L,int i)&#123; return L-&gt;data[i-1];&#125;int main()&#123; SqList L; //声明一个顺序表 InitList(&amp;L); //初始化顺序表 //...此处插入几个元素 int num=GetElem(&amp;L, 3); //查找表L中第3个位置的元素的值 return 0;&#125; 动态分配： 1234567891011121314151617181920212223242526272829303132333435//顺序表的按位查找（动态分配）#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define InitSize 10 //默认的最大长度typedef struct&#123; int *data; //指示动态分配数组的指针 int MaxSize; //顺序表的最大容量 int length; //顺序表的当前长度&#125;SeqList;void InitList(SeqList *L)&#123; //用malloc函数申请一片连续的存储空间 L-&gt;data=(int *)malloc(InitSize*sizeof(int)); L-&gt;length=0; L-&gt;MaxSize=InitSize;&#125;int GetElem(SeqList *L,int i)&#123; return L-&gt;data[i-1];&#125;int main()&#123; SeqList L; //声明一个顺序表 InitList(&amp;L); //初始化顺序表 //...往顺序表加入几个元素 int num=GetElem(&amp;L, 3); //查找表L中第3个位置的元素的值 return 0;&#125; 顺序表的按值查找(最好O(1),最坏O(n),平均O(n))LocateElem(L,e)：按值查找操作，在表L中查找具有给定关键字值的元素 1234567891011121314151617181920212223242526272829303132333435363738394041//顺序表的按值查找#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define InitSize 10 //默认的最大长度typedef struct&#123; int *data; //指示动态分配数组的指针 int MaxSize; //顺序表的最大容量 int length; //顺序表的当前长度&#125;SeqList;void InitList(SeqList *L)&#123; //用malloc函数申请一片连续的存储空间 L-&gt;data=(int *)malloc(InitSize*sizeof(int)); L-&gt;length=0; L-&gt;MaxSize=InitSize;&#125;//在顺序表L中查找第一个元素值等于e的元素，并返回其位序int LocateElem(SeqList *L,int e)&#123; for(int i=0;i&lt;L-&gt;length;i++)&#123; if(L-&gt;data[i] == e)&#123; return i+1; //数组下标为i的元素值等于e，返回其位序i+1 &#125; &#125; return 0; //退出循环，说明查找失败&#125;int main()&#123; SeqList L; //声明一个顺序表 InitList(&amp;L); //初始化顺序表 //...往顺序表加入几个元素 int num=LocateElem(&amp;L, 3); //查找表L中第3个位置的元素的值 return 0;&#125;","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构、算法笔记","slug":"数据结构、算法笔记","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"}]},{"title":"单链表的定义","slug":"数据结构和算法/数据结构、算法笔记/单链表的定义","date":"2020-01-24T16:00:00.000Z","updated":"2021-03-23T07:47:03.000Z","comments":true,"path":"2020/01/25/数据结构和算法/数据结构、算法笔记/单链表的定义/","link":"","permalink":"http://example.com/2020/01/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AE%9A%E4%B9%89/","excerpt":"","text":"单链表：用链式存储的方式实现线性表，每个结点除了存放数据元素外，还要存储指向下个节点的指针 单链表的特点： 不要求大片连续空间，改变容量方便 不可随机存取，要耗费一定空间存放指针 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;stdio.h&gt;#include&lt;stdbool.h&gt;#include&lt;stdlib.h&gt;typedef struct LNode&#123; //LNode:结点 int data; //数据域：每个结点存放一个数据元素 struct LNode *next; //指针域：指针指向下一个结点&#125;LNode,*LinkList; //typedef struct LNode *LinkList; 要表示一个单链表时，只需声明一个头指针L，指向单链表的第一个结点//初始化一个空的链表(不带头结点)//bool InitList(LinkList *L)&#123;// (*L)=NULL; //空表，暂时还没有任何结点，防止脏数据// return true;//&#125;//判断单链表是否为空(不带头结点)//bool Empty(LinkList *L)&#123;// if((*L) == NULL)&#123;// return true;// &#125;// else&#123;// return false;// &#125;//&#125;//这里LNode *和LinkList是等价的，LinkList强调这是一个单链表，LNode *强调这是一个结点//LNode * GetElem(LinkList L,int i)&#123;// int j=1;// LNode *p=L-&gt;next;// if(i == 0)&#123;// return L;// &#125;// if(i&lt;1)&#123;// return NULL;// &#125;// while(p != NULL &amp;&amp; j&lt;i)&#123;// p=p-&gt;next;// j++;// &#125;// return p;//&#125;//初始化一个单链表(带头结点)bool InitList(LinkList *L)&#123; (*L)=(LNode *)malloc(sizeof(LNode)); //分配一个头结点,并使得头指针*L指向这个头结点 if((*L) == NULL)&#123; //内存不足，分配失败 return false; &#125; (*L)-&gt;data=0; //头结点不存储数据 (*L)-&gt;next=NULL; //头结点之后暂时还没有结点 return true;&#125;//判断单链表是否为空(带头结点)bool Empty(LinkList *L)&#123; if((*L)-&gt;next == NULL)&#123; return true; &#125; else&#123; return false; &#125;&#125;int main()&#123; LinkList L; //等价于LNode *L; 声明一个指向单链表的第一个结点的指针，注意此处并没有创建一个结点 InitList(&amp;L); //初始化一个空表 //...后续代码&#125; 不带头结点写代码更麻烦，带头结点写代码更方便","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构、算法笔记","slug":"数据结构、算法笔记","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"}]},{"title":"单链表的插入和删除","slug":"数据结构和算法/数据结构、算法笔记/单链表的插入和删除","date":"2020-01-23T16:00:00.000Z","updated":"2021-03-23T07:46:52.000Z","comments":true,"path":"2020/01/24/数据结构和算法/数据结构、算法笔记/单链表的插入和删除/","link":"","permalink":"http://example.com/2020/01/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4/","excerpt":"","text":"单链表的插入按位序插入（带头结点）：在表L中的第i个位置上插入指定元素e（最好O(1),最坏O(n),平均O(n)） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;stdio.h&gt;#include&lt;stdbool.h&gt;#include&lt;stdlib.h&gt;typedef struct LNode&#123; //LNode:结点 int data; //数据域：每个结点存放一个数据元素 struct LNode *next; //指针域：指针指向下一个结点&#125;LNode,*LinkList; //typedef struct LNode *LinkList; 要表示一个单链表时，只需声明一个头指针L，指向单链表的第一个结点//初始化一个单链表(带头结点)bool InitList(LinkList *L)&#123; (*L)=(LNode *)malloc(sizeof(LNode)); //分配一个头结点,并使得头指针*L指向这个头结点 if((*L) == NULL)&#123; //内存不足，分配失败 return false; &#125; (*L)-&gt;data=0; //头结点不存储数据 (*L)-&gt;next=NULL; //头结点之后暂时还没有结点 return true;&#125;//在第i个位置插入元素e(带头结点)bool ListInsert(LinkList *L,int i,int e)&#123; if(i&lt;1)&#123; return false; &#125; LNode *p; //指针p指向当前扫描到的结点 int j=0; //当前p指向的是第几个结点 p=*L; //L指向头结点，头结点是第0个结点(不存数据) while(p != NULL &amp;&amp; j&lt;i-1)&#123; //循环找到第i-1个结点 p=p-&gt;next; j++; &#125; if(p == NULL)&#123; //i值不合法 return false; &#125; LNode *s=(LNode *)malloc(sizeof(LNode)); s-&gt;data=e; s-&gt;next=p-&gt;next; //这行代码跟下一行代码顺序不能调换 p-&gt;next=s; //将结点s连到p之后 return true; //插入成功&#125;int main()&#123; LinkList L; //等价于LNode *L; 声明一个指向单链表的第一个结点的指针，注意此处并没有创建一个结点 InitList(&amp;L); //初始化一个空表 //...后续代码 if(ListInsert(&amp;L, 2, 3))&#123; //在第2个位置插入元素3 printf(&quot;插入成功&quot;); &#125; else&#123; printf(&quot;插入失败&quot;); &#125;&#125; 按位序插入(不带头结点)：因为不存在“第0个”结点，因此i=1时需要特殊处理 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;stdio.h&gt;#include&lt;stdbool.h&gt;#include&lt;stdlib.h&gt;typedef struct LNode&#123; //LNode:结点 int data; //数据域：每个结点存放一个数据元素 struct LNode *next; //指针域：指针指向下一个结点&#125;LNode,*LinkList; //typedef struct LNode *LinkList; 要表示一个单链表时，只需声明一个头指针L，指向单链表的第一个结点//初始化一个空的链表(不带头结点)bool InitList(LinkList *L)&#123; (*L)=NULL; //空表，暂时还没有任何结点，防止脏数据 return true;&#125;//在第i个位置插入元素e(不带头结点)bool ListInsert(LinkList *L,int i,int e)&#123; if(i&lt;1)&#123; return false; &#125; //如果不带头结点，则插入、删除第1个元素时，需要更改头指针L if(i == 1)&#123; //插入第1个结点的操作与其他结点操作不同 LNode *s = (LNode *)malloc(sizeof(LNode)); s-&gt;data=e; s-&gt;next=*L; *L=s; //头指针指向新结点 return true; &#125; LNode *p; //指针p指向当前扫描到的结点 int j=0; //当前p指向的是第几个结点 p=*L; //L指向头结点，头结点是第0个结点(不存数据) while(p != NULL &amp;&amp; j&lt;i-1)&#123; //循环找到第i-1个结点 p=p-&gt;next; j++; &#125; if(p == NULL)&#123; //i值不合法 return false; &#125; LNode *s=(LNode *)malloc(sizeof(LNode)); s-&gt;data=e; s-&gt;next=p-&gt;next; //这行代码跟下一行代码顺序不能调换 p-&gt;next=s; //将结点s连到p之后 return true; //插入成功&#125;int main()&#123; LinkList L; //等价于LNode *L; 声明一个指向单链表的第一个结点的指针，注意此处并没有创建一个结点 InitList(&amp;L); //初始化一个空表 //...后续代码 if(ListInsert(&amp;L, 2, 3))&#123; //在第2个位置插入元素3 printf(&quot;插入成功&quot;); &#125; else&#123; printf(&quot;插入失败&quot;); &#125;&#125; 指定结点的后插操作（O(1)）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;stdio.h&gt;#include&lt;stdbool.h&gt;#include&lt;stdlib.h&gt;typedef struct LNode&#123; //LNode:结点 int data; //数据域：每个结点存放一个数据元素 struct LNode *next; //指针域：指针指向下一个结点&#125;LNode,*LinkList; //typedef struct LNode *LinkList; 要表示一个单链表时，只需声明一个头指针L，指向单链表的第一个结点//初始化一个单链表(带头结点)bool InitList(LinkList *L)&#123; (*L)=(LNode *)malloc(sizeof(LNode)); //分配一个头结点,并使得头指针*L指向这个头结点 if((*L) == NULL)&#123; //内存不足，分配失败 return false; &#125; (*L)-&gt;data=0; //头结点不存储数据 (*L)-&gt;next=NULL; //头结点之后暂时还没有结点 return true;&#125;//后插操作：在p结点之后插入元素e(带头结点)bool InsertNextNode(LNode *p,int e)&#123; if(p == NULL)&#123; //i值不合法 return false; &#125; LNode *s=(LNode *)malloc(sizeof(LNode)); if(s == NULL)&#123; //内存分配失败，某些情况下有可能分配失败（如内存不足） return false; &#125; s-&gt;data=e; //用结点s保存数据元素e s-&gt;next=p-&gt;next; //这行代码跟下一行代码顺序不能调换 p-&gt;next=s; //将结点s连到p之后 return true; //插入成功&#125;int main()&#123; LinkList L; //等价于LNode *L; 声明一个指向单链表的第一个结点的指针，注意此处并没有创建一个结点 InitList(&amp;L); //初始化一个空表 //...后续代码 if(InsertNextNode(L, 3))&#123; //在p结点位置后插入元素3 printf(&quot;插入成功&quot;); &#125; else&#123; printf(&quot;插入失败&quot;); &#125;&#125; 指定结点的前插操作：在p结点之前插入元素e（O(1)） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;stdio.h&gt;#include&lt;stdbool.h&gt;#include&lt;stdlib.h&gt;typedef struct LNode&#123; //LNode:结点 int data; //数据域：每个结点存放一个数据元素 struct LNode *next; //指针域：指针指向下一个结点&#125;LNode,*LinkList; //typedef struct LNode *LinkList; 要表示一个单链表时，只需声明一个头指针L，指向单链表的第一个结点//初始化一个单链表(带头结点)bool InitList(LinkList *L)&#123; (*L)=(LNode *)malloc(sizeof(LNode)); //分配一个头结点,并使得头指针*L指向这个头结点 if((*L) == NULL)&#123; //内存不足，分配失败 return false; &#125; (*L)-&gt;data=0; //头结点不存储数据 (*L)-&gt;next=NULL; //头结点之后暂时还没有结点 return true;&#125;//前插操作：在p结点之前插入元素e(带头结点)bool InsertPriorNode(LNode *p,int e)&#123; if(p == NULL)&#123; //i值不合法 return false; &#125; LNode *s=(LNode *)malloc(sizeof(LNode)); if(s == NULL)&#123; //内存分配失败，某些情况下有可能分配失败（如内存不足） return false; &#125; s-&gt;next=p-&gt;next; p-&gt;next=s; //新结点s连到p之后 s-&gt;data=p-&gt;data; //将p中元素复制到s中 p-&gt;data=e; //p中元素覆盖为e return true; //插入成功&#125;int main()&#123; LinkList L; //等价于LNode *L; 声明一个指向单链表的第一个结点的指针，注意此处并没有创建一个结点 InitList(&amp;L); //初始化一个空表 //...后续代码 if(InsertPriorNode(L, 3))&#123; //在p结点位置前插入元素3 printf(&quot;插入成功&quot;); &#125; else&#123; printf(&quot;插入失败&quot;); &#125;&#125; 单链表的删除按位序删除(带头结点，最坏、平均O(n),最好O(1))：删除表L中第i个位置的元素，并用e返回删除元素的值（找到第i-1个结点，并将其指针指向第i+1个结点，并释放第i个结点） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;stdio.h&gt;#include&lt;stdbool.h&gt;#include&lt;stdlib.h&gt;typedef struct LNode&#123; //LNode:结点 int data; //数据域：每个结点存放一个数据元素 struct LNode *next; //指针域：指针指向下一个结点&#125;LNode,*LinkList; //typedef struct LNode *LinkList; 要表示一个单链表时，只需声明一个头指针L，指向单链表的第一个结点//初始化一个单链表(带头结点)bool InitList(LinkList *L)&#123; (*L)=(LNode *)malloc(sizeof(LNode)); //分配一个头结点,并使得头指针*L指向这个头结点 if((*L) == NULL)&#123; //内存不足，分配失败 return false; &#125; (*L)-&gt;data=0; //头结点不存储数据 (*L)-&gt;next=NULL; //头结点之后暂时还没有结点 return true;&#125;//按位序删除(带头结点)bool ListDelete(LinkList *L,int i,int *e)&#123; if(i&lt;1)&#123; return false; &#125; LNode *p; //指针p指向当前扫描到的结点 int j=0; //当前p指向的是第几个结点 p=*L; //L指向头结点，头结点是第0个结点(不存数据) while(p != NULL &amp;&amp; j&lt;i-1)&#123; //循环找到第i-1个结点 p=p-&gt;next; j++; &#125; if(p == NULL)&#123; //i值不合法 return false; &#125; if(p-&gt;next == NULL)&#123; //在第i-1个结点之后已无其他结点 return false; &#125; LNode *q=p-&gt;next; //令q指向被删除结点 *e=q-&gt;data; //用e返回元素的值 p-&gt;next=q-&gt;next; //将*q结点从链中断开 free(q); //释放结点的存储空间 return true; //删除成功&#125;int main()&#123; LinkList L; //等价于LNode *L; 声明一个指向单链表的第一个结点的指针，注意此处并没有创建一个结点 InitList(&amp;L); //初始化一个空表 //...后续代码 int e=-1; //用变量e把删除的元素“带回来” if(ListDelete(&amp;L, 2, &amp;e))&#123; printf(&quot;已删除第2个元素，删除元素值为%d\\n&quot;,e); &#125; else&#123; printf(&quot;删除失败\\n&quot;); &#125;&#125; 指定结点的删除（O(1)）： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;stdio.h&gt;#include&lt;stdbool.h&gt;#include&lt;stdlib.h&gt;typedef struct LNode&#123; //LNode:结点 int data; //数据域：每个结点存放一个数据元素 struct LNode *next; //指针域：指针指向下一个结点&#125;LNode,*LinkList; //typedef struct LNode *LinkList; 要表示一个单链表时，只需声明一个头指针L，指向单链表的第一个结点//初始化一个单链表(带头结点)bool InitList(LinkList *L)&#123; (*L)=(LNode *)malloc(sizeof(LNode)); //分配一个头结点,并使得头指针*L指向这个头结点 if((*L) == NULL)&#123; //内存不足，分配失败 return false; &#125; (*L)-&gt;data=0; //头结点不存储数据 (*L)-&gt;next=NULL; //头结点之后暂时还没有结点 return true;&#125;//删除指定结点p(带头结点)//如果p是最后一个结点，这段代码就有点问题了，解决办法只能从表头开始依次寻找p的前驱，时间复杂度为O(n)//单链表的局限性：无法逆向检索，有时候不太方便bool DeleteNode(LNode *p)&#123; if(p == NULL)&#123; return false; &#125; LNode *q=p-&gt;next; //令q指向*p的后继结点 p-&gt;data=p-&gt;next-&gt;data; //和后继结点交换数据域 p-&gt;next=q-&gt;next; //将*q结点从链中“断开” free(q); //释放后继结点的存储空间 return true; //删除成功&#125;int main()&#123; LinkList L; //等价于LNode *L; 声明一个指向单链表的第一个结点的指针，注意此处并没有创建一个结点 InitList(&amp;L); //初始化一个空表 //...后续代码 if(DeleteNode(L))&#123; printf(&quot;删除成功\\n&quot;); &#125; else&#123; printf(&quot;删除失败\\n&quot;); &#125;&#125;","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构、算法笔记","slug":"数据结构、算法笔记","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"}]},{"title":"单链表的查找","slug":"数据结构和算法/数据结构、算法笔记/单链表的查找","date":"2020-01-22T16:00:00.000Z","updated":"2021-03-23T07:46:41.000Z","comments":true,"path":"2020/01/23/数据结构和算法/数据结构、算法笔记/单链表的查找/","link":"","permalink":"http://example.com/2020/01/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE/","excerpt":"","text":"单链表的按位查找(带头结点)：获取表L中第i个位置的元素的值，平均时间复杂度O(n) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;stdio.h&gt;#include&lt;stdbool.h&gt;#include&lt;stdlib.h&gt;typedef struct LNode&#123; //LNode:结点 int data; //数据域：每个结点存放一个数据元素 struct LNode *next; //指针域：指针指向下一个结点&#125;LNode,*LinkList; //typedef struct LNode *LinkList; 要表示一个单链表时，只需声明一个头指针L，指向单链表的第一个结点//初始化一个单链表(带头结点)bool InitList(LinkList *L)&#123; (*L)=(LNode *)malloc(sizeof(LNode)); //分配一个头结点,并使得头指针*L指向这个头结点 if((*L) == NULL)&#123; //内存不足，分配失败 return false; &#125; (*L)-&gt;data=0; //头结点不存储数据 (*L)-&gt;next=NULL; //头结点之后暂时还没有结点 return true;&#125;//按位查找，返回第i个元素(带头结点)LNode * GetElem(LinkList *L,int i)&#123; if(i&lt;0)&#123; return NULL; &#125; LNode *p; //指针p指向当前扫描到的结点 int j=0; //当前p指向的是第几个结点 p=*L; //L指向头结点，头结点是第0个结点（不存数据） while(p != NULL &amp;&amp; j&lt;i)&#123; //循环找到第i个结点 p=p-&gt;next; j++; &#125; return p;&#125;int main()&#123; LinkList L; //等价于LNode *L; 声明一个指向单链表的第一个结点的指针，注意此处并没有创建一个结点 InitList(&amp;L); //初始化一个空表 //...后续代码 LNode * a=GetElem(&amp;L, 3);&#125; 单链表的按值查找(带头结点)：在表L中查找具有给定关键字值的元素,平均时间复杂度O(n) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;stdio.h&gt;#include&lt;stdbool.h&gt;#include&lt;stdlib.h&gt;typedef struct LNode&#123; //LNode:结点 int data; //数据域：每个结点存放一个数据元素 struct LNode *next; //指针域：指针指向下一个结点&#125;LNode,*LinkList; //typedef struct LNode *LinkList; 要表示一个单链表时，只需声明一个头指针L，指向单链表的第一个结点//初始化一个单链表(带头结点)bool InitList(LinkList *L)&#123; (*L)=(LNode *)malloc(sizeof(LNode)); //分配一个头结点,并使得头指针*L指向这个头结点 if((*L) == NULL)&#123; //内存不足，分配失败 return false; &#125; (*L)-&gt;data=0; //头结点不存储数据 (*L)-&gt;next=NULL; //头结点之后暂时还没有结点 return true;&#125;//按值查找，找到数据域==e的结点(带头结点)LNode * LocateElem(LinkList *L,int e)&#123; LNode *p =(*L)-&gt;next; //从第1个结点开始查找数据域为e的结点 while(p != NULL &amp;&amp; p-&gt;data != e)&#123; p=p-&gt;next; &#125; return p; //找到后返回该结点指针，否则返回NULL&#125;//求表的长度（时间复杂度O(n)）int Length(LinkList *L)&#123; int len=0; //统计表长 LNode *p=*L; while(p-&gt;next != NULL)&#123; p=p-&gt;next; len++; &#125; return len;&#125;int main()&#123; LinkList L; //等价于LNode *L; 声明一个指向单链表的第一个结点的指针，注意此处并没有创建一个结点 InitList(&amp;L); //初始化一个空表 //...后续代码 LNode * a=LocateElem(&amp;L, 3); //找到数据域为3的结点，并返回 int b=Length(&amp;L); //返回表的长度&#125;","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构、算法笔记","slug":"数据结构、算法笔记","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"}]},{"title":"单链表的建立","slug":"数据结构和算法/数据结构、算法笔记/单链表的建立","date":"2020-01-21T16:00:00.000Z","updated":"2021-03-23T07:46:31.000Z","comments":true,"path":"2020/01/22/数据结构和算法/数据结构、算法笔记/单链表的建立/","link":"","permalink":"http://example.com/2020/01/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%BB%BA%E7%AB%8B/","excerpt":"","text":"如果给你很多个数据元素，要把它们存到一个空单链表里？ 尾插法(带头结点)，时间复杂度为O(n)：将数据元素一个一个的插入到单链表的尾部 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;stdio.h&gt;#include&lt;stdbool.h&gt;#include&lt;stdlib.h&gt;typedef struct LNode&#123; //LNode:结点 int data; //数据域：每个结点存放一个数据元素 struct LNode *next; //指针域：指针指向下一个结点&#125;LNode,*LinkList; //typedef struct LNode *LinkList; 要表示一个单链表时，只需声明一个头指针L，指向单链表的第一个结点//初始化一个单链表(带头结点)bool InitList(LinkList *L)&#123; (*L)=(LNode *)malloc(sizeof(LNode)); //分配一个头结点,并使得头指针*L指向这个头结点 if((*L) == NULL)&#123; //内存不足，分配失败 return false; &#125; (*L)-&gt;data=0; //头结点不存储数据 (*L)-&gt;next=NULL; //头结点之后暂时还没有结点 return true;&#125;//尾插法建立单链表LinkList List_TailInsert(LinkList *L)&#123; int x; LNode *s,*r=*L; //r为表尾指针 scanf(&quot;%d\\n&quot;,&amp;x); //输入结点的值 while(x != 9999)&#123; //输入9999表示结束 s=(LNode *)malloc(sizeof(LNode)); s-&gt;data=x; r-&gt;next=s; r=s; //r指向新的表尾结点，永远保持r指向最后一个结点 scanf(&quot;%d\\n&quot;,&amp;x); &#125; r-&gt;next=NULL; //尾结点指针置空 return *L;&#125;int main()&#123; LinkList L; //等价于LNode *L; 声明一个指向单链表的第一个结点的指针，注意此处并没有创建一个结点 InitList(&amp;L); //初始化一个空表 LinkList a=List_TailInsert(&amp;L); //...后续代码&#125; 头插法(带头结点)：将数据元素一个一个的插入到头结点之后(逆向建立单链表)，注意是每一个数据元素都放到头结点后一个的位置 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;stdio.h&gt;#include&lt;stdbool.h&gt;#include&lt;stdlib.h&gt;typedef struct LNode&#123; //LNode:结点 int data; //数据域：每个结点存放一个数据元素 struct LNode *next; //指针域：指针指向下一个结点&#125;LNode,*LinkList; //typedef struct LNode *LinkList; 要表示一个单链表时，只需声明一个头指针L，指向单链表的第一个结点//初始化一个单链表(带头结点)bool InitList(LinkList *L)&#123; (*L)=(LNode *)malloc(sizeof(LNode)); //分配一个头结点,并使得头指针*L指向这个头结点 if((*L) == NULL)&#123; //内存不足，分配失败 return false; &#125; (*L)-&gt;data=0; //头结点不存储数据 (*L)-&gt;next=NULL; //头结点之后暂时还没有结点 return true;&#125;//头插法建立单链表LinkList List_HeadInsert(LinkList *L)&#123; int x; LNode *s; scanf(&quot;%d\\n&quot;,&amp;x); //输入结点的值 while(x != 9999)&#123; //输入9999表示结束 s=(LNode *)malloc(sizeof(LNode)); s-&gt;data=x; s-&gt;next=(*L)-&gt;next; //s-&gt;next指向NULL (*L)-&gt;next=s; //将新结点插入表中，L为头指针 scanf(&quot;%d\\n&quot;,&amp;x); &#125; return *L;&#125;int main()&#123; LinkList L; //等价于LNode *L; 声明一个指向单链表的第一个结点的指针，注意此处并没有创建一个结点 InitList(&amp;L); //初始化一个空表 LinkList a=List_HeadInsert(&amp;L); //...后续代码&#125;","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构、算法笔记","slug":"数据结构、算法笔记","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"}]},{"title":"双链表","slug":"数据结构和算法/数据结构、算法笔记/双链表","date":"2020-01-20T16:00:00.000Z","updated":"2021-03-23T07:46:19.000Z","comments":true,"path":"2020/01/21/数据结构和算法/数据结构、算法笔记/双链表/","link":"","permalink":"http://example.com/2020/01/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%8F%8C%E9%93%BE%E8%A1%A8/","excerpt":"","text":"单链表：无法逆向检索，有时候不太方便双链表：可进可退，但存储密度要更低一点 双链表的初始化、插入、删除(带头结点)： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include&lt;stdio.h&gt;#include&lt;stdbool.h&gt;#include&lt;stdlib.h&gt;typedef struct DNode&#123; int data; //数据域 struct DNode *prior,*next; //指针域&#125;DNode,*DLinklist; //DLinklist等价于DNode *//初始化双链表bool InitDLinkList(DLinklist *L)&#123; (*L)=(DNode *)malloc(sizeof(DNode)); //分配一个头结点 if((*L) == NULL)&#123; //内存不足，分配失败 return false; &#125; (*L)-&gt;prior=NULL; //头结点的prior永远指向NULL (*L)-&gt;next=NULL; //头结点之后暂时还没有结点 return true;&#125;//判断双链表是否为空(带头结点)bool Empty(DLinklist *L)&#123; if((*L)-&gt;next == NULL)&#123; return true; &#125; else&#123; return false; &#125;&#125;//双链表的插入//在p结点之后插入s结点//如果要按位序插入，只需要从头结点找到这个位序的前驱结点，然后对这个前驱结点进行后插操作//前插操作也是找到该结点的前驱结点，然后对这个前驱结点进行后插操作bool InsertNextDNode(DNode *p,DNode *s)&#123; if(p == NULL || s == NULL)&#123; //非法参数 return false; &#125; s-&gt;next=p-&gt;next; //将结点*s插入到结点*p之后 if(p-&gt;next != NULL)&#123; //如果p结点有后继结点[如果是循环双链表，没有这个条件判断也是正确的] p-&gt;next-&gt;prior=s; &#125; s-&gt;prior=p; p-&gt;next=s; return true;&#125;//双链表的删除//删除p结点的后继结点bool DeleteNextDNode(DNode *p)&#123; if(p == NULL)&#123; return false; &#125; DNode *q=p-&gt;next; //找到p的后继结点q if(q == NULL)&#123; return false; //p没有后继 &#125; p-&gt;next=q-&gt;next; if(q-&gt;next != NULL)&#123; //q结点不是最后一个结点 q-&gt;next-&gt;prior=p; &#125; free(q); //释放结点空间 return true;&#125;//销毁一个双链表void DestoryList(DLinklist *L)&#123; //循环释放各个数据结点 while((*L)-&gt;next != NULL)&#123; DeleteNextDNode(*L); &#125; free(L); //释放头结点 L=NULL; //头指针指向NULL&#125;int main()&#123; DLinklist L; InitDLinkList(&amp;L); //初始化双链表 //...后续代码&#125; 双链表的遍历[双链表不可随机存取，按位查找，按值查找操作都只能用遍历的方式实现，时间复杂度O(n)] 123456789101112//后向遍历while(p != NULL)&#123; p=p-&gt;next;&#125;//前向遍历while(p != NULL)&#123; p=p-&gt;prior;&#125;//前向遍历，跳过头结点while(p-&gt;prior != NULL)&#123; p=p-&gt;prior;&#125;","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构、算法笔记","slug":"数据结构、算法笔记","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"}]},{"title":"循环链表","slug":"数据结构和算法/数据结构、算法笔记/循环链表","date":"2020-01-19T16:00:00.000Z","updated":"2021-03-23T07:46:08.000Z","comments":true,"path":"2020/01/20/数据结构和算法/数据结构、算法笔记/循环链表/","link":"","permalink":"http://example.com/2020/01/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/","excerpt":"","text":"单链表：表尾结点的next指针指向NULL，从一个结点出发只能找到后续的各个结点循环单链表：表尾结点的next指针指向头结点，从一个结点出发可以找到其他任何一个结点 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;stdio.h&gt;#include&lt;stdbool.h&gt;#include&lt;stdlib.h&gt;typedef struct LNode&#123; int data; //数据域 struct LNode *next; //指针域&#125;LNode,*LinkList; //LinkList等价于LNode *//初始化一个循环单链表bool InitList(LinkList *L)&#123; (*L)=(LNode *)malloc(sizeof(LNode)); //分配一个头结点 if((*L) == NULL)&#123; return false; //内存不足，分配失败 &#125; (*L)-&gt;next=(*L); //头结点next指针指向头结点 return true;&#125;//判断循环单链表是否为空bool Empty(LinkList *L)&#123; if((*L)-&gt;next == (*L))&#123; return true; &#125; else&#123; return false; &#125;&#125;//判断结点p是否为循环单链表的表尾结点bool isTail(LinkList *L,LNode *p)&#123; if(p-&gt;next == (*L))&#123; return true; &#125; else&#123; return false; &#125;&#125;int main()&#123; LinkList L; InitList(&amp;L); //初始化双链表 //...后续代码&#125; 双链表：表头结点的prior指向NULL，表尾结点的next指向NULL循环双链表：表头结点的prior指向表尾结点，表尾结点的next指向头结点 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;stdio.h&gt;#include&lt;stdbool.h&gt;#include&lt;stdlib.h&gt;typedef struct DNode&#123; int data; //数据域 struct DNode *prior,*next; //指针域&#125;DNode,*DLinklist; //DLinklist等价于DNode *//初始化空的循环双链表bool InitDLinkList(DLinklist *L)&#123; (*L)=(DNode *)malloc(sizeof(DNode)); //分配一个头结点 if((*L) == NULL)&#123; //内存不足，分配失败 return false; &#125; (*L)-&gt;prior=(*L); //头结点的prior指向头结点 (*L)-&gt;next=(*L); //头结点的next指向头结点 return true;&#125;//判断循环双链表是否为空(带头结点)bool Empty(DLinklist *L)&#123; if((*L)-&gt;next == (*L))&#123; return true; &#125; else&#123; return false; &#125;&#125;//判断结点p是否为循环双链表的表尾结点bool isTail(DLinklist *L,DNode *p)&#123; if(p-&gt;next == (*L))&#123; return true; &#125; else&#123; return false; &#125;&#125;int main()&#123; DLinklist L; InitDLinkList(&amp;L); //初始化循环双链表 //...后续代码&#125;","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构、算法笔记","slug":"数据结构、算法笔记","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"}]},{"title":"静态链表","slug":"数据结构和算法/数据结构、算法笔记/静态链表","date":"2020-01-18T16:00:00.000Z","updated":"2021-03-23T07:45:57.000Z","comments":true,"path":"2020/01/19/数据结构和算法/数据结构、算法笔记/静态链表/","link":"","permalink":"http://example.com/2020/01/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8/","excerpt":"","text":"静态链表：用数组的方式实现的链表 优点：增、删操作不需要大量移动元素缺点：不能随机存取，只能从头结点开始依次往后查找；容量固定不可变 适用场景：不支持指针的低级语言；数据元素数量固定不变的场景(如操作系统的文件分配表FAT) 123456789101112131415161718192021222324252627#include&lt;stdio.h&gt;#include&lt;stdbool.h&gt;#include&lt;stdlib.h&gt;#define MaxSize 10 //静态链表的最大长度//用代码定义一个静态链表struct Node&#123; int data; //存储数据元素 int next; //下一个元素的数组下标&#125;;//初始化静态链表：把a[0]的next设为-1，把其他结点的next设为一个特殊值用来表示结点空闲，如-2//查找：从头结点出发挨个往后遍历结点（O(n)）//插入位序为i的结点：1.找到一个空的结点，存入数据元素【如何判断结点为空？通过特殊值来判断】 2.从头结点出发找到位序为i-1的结点 3.修改i-1号结点的next 4.修改新结点的next//删除某个结点：1.从头结点出发找到前驱结点 2.修改前驱结点的游标 3.被删除结点的next设为特殊值int main()&#123; struct Node a[MaxSize]; //数组a作为静态链表 //...后续代码&#125;","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构、算法笔记","slug":"数据结构、算法笔记","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"}]},{"title":"顺序表和链表的比较","slug":"数据结构和算法/数据结构、算法笔记/顺序表和链表的比较","date":"2020-01-17T16:00:00.000Z","updated":"2021-03-23T07:45:46.000Z","comments":true,"path":"2020/01/18/数据结构和算法/数据结构、算法笔记/顺序表和链表的比较/","link":"","permalink":"http://example.com/2020/01/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%92%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E6%AF%94%E8%BE%83/","excerpt":"","text":"逻辑结构：都属于线性表，都是线性结构 存储结构： 顺序表：顺序存储，优点是支持随机存取，存储密度高；缺点是大片连续空间分配不方便，改变容量不方便 链表：链式存储，优点是离散的小空间分配方便，改变容量方便；缺点是不可随机存取，存储密度低 使用场景： 链表：表长难以预估，经常要增加/删除元素 顺序表：表长可预估，查询(搜索)操作较多","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构、算法笔记","slug":"数据结构、算法笔记","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"}]},{"title":"栈的基本概念","slug":"数据结构和算法/数据结构、算法笔记/栈的基本概念","date":"2020-01-16T16:00:00.000Z","updated":"2021-03-23T07:45:35.000Z","comments":true,"path":"2020/01/17/数据结构和算法/数据结构、算法笔记/栈的基本概念/","link":"","permalink":"http://example.com/2020/01/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%A0%88%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/","excerpt":"","text":"栈(Stack)是只允许在一端进行插入或删除操作的线性表【空栈、栈顶：允许插入和删除的一端、栈底：不允许插入和删除的一端】 特点：后进先出【Last In First Out(LIFO)】 栈的基本操作： InitStack(&amp;S)：初始化栈，构造一个空栈S，分配内存空间 DestroyStack(&amp;L)：销毁栈，销毁并释放栈S所占用的内存空间 Push(&amp;S,x)：进栈，若栈S未满，则将x加入使之成为新栈顶 Pop(&amp;S,&amp;x)：出栈，若栈S非空，则弹出栈顶元素，并用x返回【删除栈顶元素】 GetTop(S,&amp;x)：读栈顶元素，若栈S非空，则用x返回栈顶元素【不删除栈顶元素，查栈的使用场景中大多只访问栈顶元素】 StackEmpty(S)：判读一个栈S是否为空，若S为空，则返回true，否则返回false","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构、算法笔记","slug":"数据结构、算法笔记","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"}]},{"title":"栈的顺序存储实现","slug":"数据结构和算法/数据结构、算法笔记/栈的顺序存储实现","date":"2020-01-15T16:00:00.000Z","updated":"2021-03-23T07:45:25.000Z","comments":true,"path":"2020/01/16/数据结构和算法/数据结构、算法笔记/栈的顺序存储实现/","link":"","permalink":"http://example.com/2020/01/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%A0%88%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"顺序栈的缺点：栈的大小不可变 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;stdio.h&gt;#include&lt;stdbool.h&gt;#include&lt;stdlib.h&gt;#define MaxSize 10 //定义栈中元素的最大个数//顺序栈的定义typedef struct&#123; int data[MaxSize]; //静态数组存放栈中元素 int top; //栈顶指针，top指向当前栈顶元素&#125;SqStack; //Sq：sequence，顺序//初始化栈void InitStack(SqStack *S)&#123; S-&gt;top=-1; //初始化栈顶指针&#125;//判断栈空bool StackEmpty(SqStack *S)&#123; if(S-&gt;top == -1)&#123; return true; //栈空 &#125; else&#123; return false; //不空 &#125;&#125;//进栈操作bool Push(SqStack *S,int x)&#123; if(S-&gt;top==MaxSize-1)&#123; return false; //栈满，报错 &#125; S-&gt;top=S-&gt;top+1; //指针先+1 S-&gt;data[S-&gt;top]=x; //新元素入栈 return true;&#125;//出栈操作,并用x返回bool Pop(SqStack *S,int *x)&#123; if(S-&gt;top==-1)&#123; return false; //栈空，报错 &#125; (*x)=S-&gt;data[S-&gt;top]; //栈顶元素先出栈 S-&gt;top=S-&gt;top-1; //指针再-1，数据还残留在内存中，只是逻辑上被删除了 return true;&#125;//读栈顶元素操作bool GetTop(SqStack *S,int *x)&#123; if(S-&gt;top==-1)&#123; return false; //栈空，报错 &#125; (*x)=S-&gt;data[S-&gt;top]; //x记录栈顶元素 return true;&#125;int main()&#123; SqStack S; //声明一个顺序栈(分配空间) InitStack(&amp;S); //...后续操作&#125; 共享栈： 12345678910111213141516171819202122232425262728#include&lt;stdio.h&gt;#include&lt;stdbool.h&gt;#include&lt;stdlib.h&gt;#define MaxSize 10 //定义栈中元素的最大个数//共享栈：两个栈共享同一片空间typedef struct&#123; int data[MaxSize]; //静态数组存放栈中元素 int top0; //0号栈顶指针 int top1; //1号栈顶指针&#125;ShStack;//初始化栈void InitStack(ShStack *S)&#123; S-&gt;top0=-1; //初始化栈顶指针 S-&gt;top1=MaxSize;&#125;//栈满条件：top0+1==top1int main()&#123; ShStack S; //声明一个顺序栈(分配空间) InitStack(&amp;S); //...后续操作&#125;","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构、算法笔记","slug":"数据结构、算法笔记","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"}]},{"title":"栈的链式存储实现","slug":"数据结构和算法/数据结构、算法笔记/栈的链式存储实现","date":"2020-01-14T16:00:00.000Z","updated":"2021-03-23T07:45:14.000Z","comments":true,"path":"2020/01/15/数据结构和算法/数据结构、算法笔记/栈的链式存储实现/","link":"","permalink":"http://example.com/2020/01/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%A0%88%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"进栈操作：头插法建立单链表(对头结点的后插操作) 出栈操作：单链表的删除操作(对头结点的后删操作) 123456//链栈的定义(带头结点的初始化，不带头结点的初始化)typedef struct Linknode&#123; int data; //数据域 struct Linknode *next; //指针域&#125;*Listack;","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构、算法笔记","slug":"数据结构、算法笔记","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"}]},{"title":"队列的基本概念","slug":"数据结构和算法/数据结构、算法笔记/队列的基本概念","date":"2020-01-13T16:00:00.000Z","updated":"2021-03-23T07:45:03.000Z","comments":true,"path":"2020/01/14/数据结构和算法/数据结构、算法笔记/队列的基本概念/","link":"","permalink":"http://example.com/2020/01/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E9%98%9F%E5%88%97%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/","excerpt":"","text":"队列的定义：是只允许在一端进行插入，在另一端删除的线性表【空队列、队头：允许删除的一端、队尾：允许插入的一端】 特点：先进入队列的元素先出队【First In First Out(FIFO)】 队列的基本操作： InitQueue(&amp;Q)：初始化队列，构造一个空队列Q DestroyQueue(&amp;Q)：销毁队列，销毁并释放队列Q所占用的内存空间 EnQueue(&amp;Q,x)：入队，若队列Q未满，则将x加入使之成为新队尾 DeQueue(&amp;Q,&amp;x)：出队，若队列Q非空，则删除队头元素，并用x返回【删除队头元素】 GetHead(Q,&amp;x)：读队头元素，若队列Q非空，则用x返回队头元素【不删除队头元素，查队列的使用场景中大多只访问队头元素】 QueueEmpty(Q)：判断一个队列是否为空，若Q为空，则返回true，否则返回false","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构、算法笔记","slug":"数据结构、算法笔记","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"}]},{"title":"队列的顺序实现","slug":"数据结构和算法/数据结构、算法笔记/队列的顺序实现","date":"2020-01-12T16:00:00.000Z","updated":"2021-03-23T07:44:53.000Z","comments":true,"path":"2020/01/13/数据结构和算法/数据结构、算法笔记/队列的顺序实现/","link":"","permalink":"http://example.com/2020/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E9%98%9F%E5%88%97%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include&lt;stdio.h&gt;#include&lt;stdbool.h&gt;#include&lt;stdlib.h&gt;#define MaxSize 10 //定义队列中元素的最大个数//队列的顺序实现【front指向队头元素，rear指向队尾元素的后一个位置；还有一种情况是rear指向队尾元素】typedef struct&#123; int data[MaxSize]; //用静态数组存放队列元素 int front,rear; //队头指针和队尾指针 //int size; //第二种判断队列已满/已空的方法，定义一个size：队列当前长度 //int tag; //第三种判断队列已满/已空的方法：最近进行的是删除还是插入&#125;SqQueue;//初始化队列void InitQueue(SqQueue *Q)&#123; Q-&gt;front=Q-&gt;rear=0; //初始时队头、队尾指针指向0 //Q-&gt;size=0; //第二种判断队列已满/已空的方法，插入成功size++，删除成功size--,队空条件:size==0，队满条件：size==MaxSize //Q-&gt;tag=0; //第三种判断队列已满/已空的方法：每次删除操作成功时，都令tag=0,每次插入操作成功时都令tag=1；只有删除操作，才可能导致队空，只有插入操作，才可能导致队满；队空条件：front==rear &amp;&amp; tag==0，队满条件：front==rear &amp;&amp; tag==1&#125;//判断队列是否为空bool QueueEmpty(SqQueue *Q)&#123; if(Q-&gt;rear==Q-&gt;front)&#123; //队空条件 return true; &#125; else&#123; return false; &#125;&#125;//循环队列：入队操作bool EnQueue(SqQueue *Q,int x)&#123; if((Q-&gt;rear+1)%MaxSize == Q-&gt;front)&#123; //队列已满的条件：队尾指针的再下一个位置是队头，代价：牺牲一个存储单元 return false; //队满则报错 &#125; Q-&gt;data[Q-&gt;rear]=x; //新元素插入队尾 Q-&gt;rear=(Q-&gt;rear+1)%MaxSize; //队尾指针+1取模,用模运算将存储空间在逻辑上变成了“环状” //这是rear指向队尾元素的情况 //Q-&gt;rear=(Q-&gt;rear+1)%MaxSize; //Q-&gt;data[Q-&gt;rear]=x; return true;&#125;//循环队列：出队操作//出队：删除一个队头元素，并用x返回bool DeQueue(SqQueue *Q,int *x)&#123; if(Q-&gt;rear==Q-&gt;front)&#123; return false; //队空则报错 &#125; (*x)=Q-&gt;data[Q-&gt;front]; Q-&gt;front=(Q-&gt;front+1)%MaxSize; //队头指针后移 return true;&#125;//获取队头元素的值，用x返回bool GetHead(SqQueue *Q,int *x)&#123; if(Q-&gt;rear==Q-&gt;front)&#123; return false; &#125; (*x)=Q-&gt;data[Q-&gt;front]; return true;&#125;//队列元素个数：(rear+MaxSize-front)%MaxSizeint main()&#123; SqQueue Q; //声明一个队列，顺序存储 InitQueue(&amp;Q); //...后续操作&#125;","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构、算法笔记","slug":"数据结构、算法笔记","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"}]},{"title":"队列的链式实现","slug":"数据结构和算法/数据结构、算法笔记/队列的链式实现","date":"2020-01-11T16:00:00.000Z","updated":"2021-03-23T07:44:42.000Z","comments":true,"path":"2020/01/12/数据结构和算法/数据结构、算法笔记/队列的链式实现/","link":"","permalink":"http://example.com/2020/01/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E9%98%9F%E5%88%97%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"顺序存储：预分配的空间耗尽时队满链式存储：一般不会队满，除非内存不足 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include&lt;stdio.h&gt;#include&lt;stdbool.h&gt;#include&lt;stdlib.h&gt;//队列的链式实现(带头结点和不带头结点)typedef struct LinkNode&#123; //链式队列结点 int data; struct LinkNode *next;&#125;LinkNode;typedef struct&#123; //链式队列 LinkNode *front,*rear; //队列的队头和队尾指针 //int length; //求队列的长度&#125;LinkQueue;//初始化队列(带头结点)void InitQueue(LinkQueue *Q)&#123; //初始时，front、rear都指向头结点 Q-&gt;front=Q-&gt;rear=(LinkNode *)malloc(sizeof(LinkNode)); Q-&gt;front-&gt;next=NULL;&#125;//判断队列是否为空bool IsEmpty(LinkQueue *Q)&#123; if(Q-&gt;front==Q-&gt;rear)&#123; return true; &#125; else&#123; return false; &#125;&#125;//初始化(不带头结点)//void InitQueue(LinkQueue *Q)&#123;// //初始时，front、rear都指向NULL// Q-&gt;front=NULL;// Q-&gt;rear=NULL;//&#125;//判断队列是否为空(不带头结点)//bool IsEmpty(LinkQueue *Q)&#123;// if(Q-&gt;front==NULL)&#123;// return true;// &#125;// else&#123;// return false;// &#125;//&#125;//新元素入队(带头结点)void EnQueue(LinkQueue *Q,int x)&#123; LinkNode *s=(LinkNode *)malloc(sizeof(LinkNode)); s-&gt;data=x; s-&gt;next=NULL; Q-&gt;rear-&gt;next=s; //新结点插入到rear之后 Q-&gt;rear=s; //修改表尾指针&#125;//新元素入队(不带头结点)//void EnQueue(LinkQueue *Q,int x)&#123;// LinkNode *s=(LinkNode *)malloc(sizeof(LinkNode));// s-&gt;data=x;// s-&gt;next=NULL;// if(Q-&gt;front == NULL)&#123; //在空队列中插入第一个元素// Q-&gt;front=s; //修改队头队尾指针// Q-&gt;rear=s; //不带头结点的队列，第一个元素入队时需要特别处理// &#125;else&#123;// Q-&gt;rear-&gt;next=s; //新结点插入到rear之后// Q-&gt;rear=s; //修改rear指针// &#125;//&#125;//队头元素出队(带头结点)bool DeQueue(LinkQueue *Q,int *x)&#123; if(Q-&gt;front==Q-&gt;rear)&#123; return false; //空队 &#125; LinkNode *p=Q-&gt;front-&gt;next; *x=p-&gt;data; //用变量x返回队头元素 Q-&gt;front-&gt;next=p-&gt;next; //修改头结点的next指针 if(Q-&gt;rear==p)&#123; //此次是最后一个结点出队 Q-&gt;rear=Q-&gt;front; //修改rear指针 &#125; free(p); //释放结点空间 return true;&#125;//队头元素出队(不带头结点)//bool DeQueue(LinkQueue *Q,int *x)&#123;// if(Q-&gt;front==NULL)&#123;// return false; //空队// &#125;// LinkNode *p=Q-&gt;front; //p指向此次出队的结点// *x=p-&gt;data; //用变量x返回队头元素// Q-&gt;front=p-&gt;next; //修改front指针// if(Q-&gt;rear==p)&#123; //此次是最后一个结点出队// Q-&gt;front=NULL; //front指向NULL// Q-&gt;rear=NULL; //rear指向NULL// &#125;// free(p); //释放结点空间// return true;//&#125;int main()&#123; LinkQueue Q; //声明一个队列 InitQueue(&amp;Q); //初始化队列 //...后续操作&#125;","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构、算法笔记","slug":"数据结构、算法笔记","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"}]},{"title":"双端队列","slug":"数据结构和算法/数据结构、算法笔记/双端队列","date":"2020-01-10T16:00:00.000Z","updated":"2021-03-23T07:44:28.000Z","comments":true,"path":"2020/01/11/数据结构和算法/数据结构、算法笔记/双端队列/","link":"","permalink":"http://example.com/2020/01/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97/","excerpt":"","text":"双端队列：只允许从两端插入、两端删除的线性表【若只使用其中一端的插入、删除操作，则效果等同于栈】 输入受限的双端队列：只允许从一端插入、两端删除的线性表 输出受限的双端队列：只允许从两端插入、一端删除的线性表 在栈中合法的输出序列，在双端队列中必定合法","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构、算法笔记","slug":"数据结构、算法笔记","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"}]},{"title":"栈在括号匹配中的应用","slug":"数据结构和算法/数据结构、算法笔记/栈在括号匹配中的应用","date":"2020-01-09T16:00:00.000Z","updated":"2021-03-23T07:44:08.000Z","comments":true,"path":"2020/01/10/数据结构和算法/数据结构、算法笔记/栈在括号匹配中的应用/","link":"","permalink":"http://example.com/2020/01/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%A0%88%E5%9C%A8%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/","excerpt":"","text":"括号匹配问题： 遇到左括号就入栈，遇到右括号就消耗一个左括号 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;stdio.h&gt;#include&lt;stdbool.h&gt;#include&lt;stdlib.h&gt;//万一存满了，可以用链栈#define MaxSize 10 //定义栈中元素的最大个数typedef struct&#123; char data[MaxSize]; //静态数组存放栈中元素 int top; //栈顶指针&#125;SqStack;//初始化栈void InitStack(SqStack *S)&#123; S-&gt;top=-1; //初始化栈顶指针&#125;//判断栈空bool StackEmpty(SqStack *S)&#123; if(S-&gt;top == -1)&#123; return true; //栈空 &#125; else&#123; return false; //不空 &#125;&#125;//新元素入栈bool Push(SqStack *S,char x)&#123; if(S-&gt;top==MaxSize-1)&#123; return false; //栈满，报错 &#125; S-&gt;top=S-&gt;top+1; //指针先+1 S-&gt;data[S-&gt;top]=x; //新元素入栈 return true;&#125;//栈顶元素出栈，用x返回bool Pop(SqStack *S,char *x)&#123; if(S-&gt;top==-1)&#123; return false; //栈空，报错 &#125; (*x)=S-&gt;data[S-&gt;top]; //栈顶元素先出栈 S-&gt;top=S-&gt;top-1; //指针再-1，数据还残留在内存中，只是逻辑上被删除了 return true;&#125;bool bracketCheck(char str[],int length)&#123; SqStack S; InitStack(&amp;S); //初始化一个栈 for(int i=0;i&lt;length;i++)&#123; if(str[i]==&#x27;(&#x27; || str[i]==&#x27;[&#x27; || str[i]==&#x27;&#123;&#x27;)&#123; Push(&amp;S,str[i]); //扫描到左括号，入栈 &#125;else&#123; if(StackEmpty(&amp;S))&#123; //扫描到右括号，且当前栈空 return false; //匹配失败 &#125; char topElem; Pop(&amp;S,&amp;topElem); //栈顶元素出栈 if(str[i]==&#x27;)&#x27; &amp;&amp; topElem != &#x27;)&#x27;)&#123; return false; &#125; if(str[i]==&#x27;]&#x27; &amp;&amp; topElem != &#x27;[&#x27;)&#123; return false; &#125; if(str[i]==&#x27;&#125;&#x27; &amp;&amp; topElem != &#x27;&#123;&#x27;)&#123; return false; &#125; &#125; &#125; return StackEmpty(&amp;S); //检索完全部括号后，栈空说明匹配成功&#125;","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构、算法笔记","slug":"数据结构、算法笔记","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"}]},{"title":"栈在表达式求值中的应用","slug":"数据结构和算法/数据结构、算法笔记/栈在表达式求值中的应用","date":"2020-01-08T16:00:00.000Z","updated":"2021-03-23T07:43:57.000Z","comments":true,"path":"2020/01/09/数据结构和算法/数据结构、算法笔记/栈在表达式求值中的应用/","link":"","permalink":"http://example.com/2020/01/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%A0%88%E5%9C%A8%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/","excerpt":"","text":"可以不用界限符也能无歧义的表达运算顺序？【逆波兰表达式=后缀表达式，波兰表达式=前缀表达式】 中缀表达式转后缀表达式：初始化一个栈，用于保存暂时还不能确定运算顺序的运算符从左到右处理各个元素，直到末尾，可能遇到三种情况：1.遇到操作数，直接加入后缀表达式2.遇到界限符，遇到“(”直接入栈，遇到“)”则依次弹出栈内运算符并加入后缀表达式，直到弹出”(“为止，注意：”(“不加入后缀表达式3.遇到运算符，依次弹出栈中优先级高于或等于当前运算符的所有运算符，并加入后缀表达式，若碰到“(”或栈空则停止，之后再把当前运算符入栈按上述方法处理完所有字符后，将栈中剩余运算符依次弹出，并加入后缀表达式 用栈实现后缀表达式的计算：【栈是用于存放当前暂时还不能确定运算次序的操作数】1.从左到右扫描下一个元素，直到处理完所有元素2.若扫描到操作数则压入栈，并回到1；否则执行33.若扫描到运算符，则弹出两个栈顶元素，执行相应运算[注意先出栈的是右操作数]，运算结果压回栈底，回到1若表达式合法，则最后栈中只会留下一个元素，就是最终结果 用栈实现中缀表达式的计算：（中缀转后缀+后缀表达式求值，两个算法的结合）初始化两个栈，操作数栈和运算符栈若扫描到操作数，压入操作数栈若扫描到运算符或界限符，则按照“中缀转后缀”相同相同的逻辑压入运算符栈（期间也会弹出运算符，每当弹出一个运算符时，就需要再弹出两个操作数栈的栈顶元素并执行相应运算，运算结果再压回操作数栈） 用栈实现前缀表达式的计算：1.从右往左扫描下一个元素，直到处理完所有元素2.若扫描到操作数则压入栈，并回到1，否则执行33.若扫描到运算符，则弹出两个栈顶元素，执行相应运算[先出栈的是左操作数]，运算结果压回栈底，回到1","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构、算法笔记","slug":"数据结构、算法笔记","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"}]},{"title":"栈在递归中的应用","slug":"数据结构和算法/数据结构、算法笔记/栈在递归中的应用","date":"2020-01-07T16:00:00.000Z","updated":"2021-03-23T07:43:46.000Z","comments":true,"path":"2020/01/08/数据结构和算法/数据结构、算法笔记/栈在递归中的应用/","link":"","permalink":"http://example.com/2020/01/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%A0%88%E5%9C%A8%E9%80%92%E5%BD%92%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/","excerpt":"","text":"递归函数调用的特点：最后被调用的函数最先执行结束(LIFO) 函数调用时，需要用一个栈存储：调用返回地址、实参、局部变量 适合用“递归”算法解决：可以把原始问题转换为属性相同，但规模较小的问题 递归调用时，函数调用栈可称为“递归工作栈”，每进入一层递归，就将递归调用所需信息压入栈顶，每退出一层递归，就从栈顶弹出相应信息【缺点：效率低，太多层递归可能会导致栈溢出，可能包含很多重复计算】","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构、算法笔记","slug":"数据结构、算法笔记","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"}]},{"title":"队列的应用","slug":"数据结构和算法/数据结构、算法笔记/队列的应用","date":"2020-01-06T16:00:00.000Z","updated":"2021-03-23T07:43:35.000Z","comments":true,"path":"2020/01/07/数据结构和算法/数据结构、算法笔记/队列的应用/","link":"","permalink":"http://example.com/2020/01/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8/","excerpt":"","text":"队列的应用： 树的层次遍历 图的广度优先遍历 队列在操作系统中的应用：多个进程争抢着使用有限的系统资源时，FCFS（First Come First Service，先来先服务）是一种常用策略 打印数据缓冲区：打印机缓冲区用“队列”组织打印数据，可缓解主机与打印机速度不匹配的问题【先来先打印】","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构、算法笔记","slug":"数据结构、算法笔记","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"}]},{"title":"特殊矩阵的压缩存储","slug":"数据结构和算法/数据结构、算法笔记/特殊矩阵的压缩存储","date":"2020-01-05T16:00:00.000Z","updated":"2021-03-23T07:43:24.000Z","comments":true,"path":"2020/01/06/数据结构和算法/数据结构、算法笔记/特殊矩阵的压缩存储/","link":"","permalink":"http://example.com/2020/01/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E7%89%B9%E6%AE%8A%E7%9F%A9%E9%98%B5%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%AD%98%E5%82%A8/","excerpt":"","text":"普通矩阵的存储：可用二维数组存储【描述矩阵元素时，行、列号通常从1开始，而描述数组时通常下标从0开始】 特殊矩阵（某些特殊矩阵可以压缩存储空间）： 对称矩阵 三角矩阵 三对角矩阵 稀疏矩阵","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构、算法笔记","slug":"数据结构、算法笔记","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"}]},{"title":"串的定义和基本操作","slug":"数据结构和算法/数据结构、算法笔记/串的定义和基本操作","date":"2020-01-04T16:00:00.000Z","updated":"2021-03-23T07:43:13.000Z","comments":true,"path":"2020/01/05/数据结构和算法/数据结构、算法笔记/串的定义和基本操作/","link":"","permalink":"http://example.com/2020/01/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E4%B8%B2%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/","excerpt":"","text":"串：即字符串(String)，是由零个或多个字符组成的有限序列，串中字符的个数n称为串的长度，n=0时的串称为空串 S=&quot;Hello World!&quot;，有的地方用双引号(Java、C)，有的地方用单引号(Python)，注意里面包含空格，空格也是字符 子串：串中任意个连续的字符组成的子序列主串：包含子串的串字符在主串中的位置：字符在串中的序号子串在主串中的位置：子串的第一个字符在主串中的位置【注意位序从1开始，而不是从0开始】 空串：M=””空格串：N=” “，[每个空格字符占1B] 串是一种特殊的线性表，数据元素之间呈线性关系，串的数据对象限定为字符集(如中文字符、英文字符、数字字符、标点字符) 串的基本操作。如增删改查等通常以子串为操作对象 串的基本操作： StrAssign(&amp;T,chars)：赋值操作，把串T赋值为chars StrCopy(&amp;T,S)：复制操作，由串S复制得到串T StrEmpty(S)：判空操作，若S为空串，则返回true，否则返回False StrLength(S)：求串长，返回串S的元素个数 ClearString(&amp;S)：清空操作，将S清为空串 DestroyString(&amp;S)：销毁串，将串S销毁(回收存储空间) Concat(&amp;T,S1,S2)：串联接，用T返回由S1和S2联接而成的新串【问题：存储空间扩展？】 SubString(&amp;Sub,S,pos,len)：求子串，用Sub返回串S的第pos个字符起长度为len的子串 Index(S,T)：定位操作，若主串S中存在与串T值相同的子串，则返回它在主串S中第一次出现的位置；否则函数值为0 StrCompare(S,T)：比较操作，若S&gt;T，则返回值&gt;0；若S=T，则返回值=0；若S&lt;T，则返回值&lt;0【从第一个字符开始往后依次对比，先出现更大字符的串就更大；长串的前缀与短串相同时，长串更大；只有两个串完全相同时才相等】 字符集：英文字符(ASCII字符)、中英文(Unicode字符集，UIF-8,UIF-16)","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构、算法笔记","slug":"数据结构、算法笔记","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"}]},{"title":"串的存储结构","slug":"数据结构和算法/数据结构、算法笔记/串的存储结构","date":"2020-01-03T16:00:00.000Z","updated":"2021-03-23T07:43:02.000Z","comments":true,"path":"2020/01/04/数据结构和算法/数据结构、算法笔记/串的存储结构/","link":"","permalink":"http://example.com/2020/01/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E4%B8%B2%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/","excerpt":"","text":"串的顺序存储：【默认使用方案四】 12345678910111213141516171819202122232425262728293031#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#define MAXIEN 255 //预定义最大串长为255//静态数组实现(定长顺序存储)typedef struct&#123; char ch[MAXIEN]; //每个分量存储一个字符 int length; //串的实际长度&#125;SString;//动态数组实现(堆分配存储)typedef struct&#123; char *ch; //按串长分配存储区，ch指向串的基地址 int length; //串的长度&#125;HString;//初始化动态数组void Init(HString *S)&#123; S-&gt;ch=(char *)malloc(MAXIEN * sizeof(char)); //用完需要手动free S-&gt;length=0;&#125;int main()&#123; HString S; Init(&amp;S);&#125; 串的基本操作实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;stdbool.h&gt;#define MAXIEN 255 //预定义最大串长为255//静态数组实现(定长顺序存储)typedef struct&#123; char ch[MAXIEN]; //每个分量存储一个字符 int length; //串的实际长度&#125;SString;//基本操作的实现//1.求子串：用Sub返回串S的第pos个字符起长度为len的子串bool SubString(SString *Sub,SString *S,int pos,int len)&#123; //子串范围越界 if(pos+len-1 &gt; S-&gt;length)&#123; return false; &#125; for(int i=pos-1;i&lt;pos+len-1;i++)&#123; Sub-&gt;ch[i-pos+1]=S-&gt;ch[i]; &#125; Sub-&gt;length=len; return true;&#125;//2.比较操作：若S&gt;T，则返回值&gt;0；若S=T，则返回值=0；若S&lt;T，则返回值&lt;0int StrCompare(SString *S,SString *T)&#123; for(int i=1;i&lt;=S-&gt;length &amp;&amp; i&lt;=T-&gt;length;i++)&#123; if(S-&gt;ch[i] != T-&gt;ch[i])&#123; return S-&gt;ch[i]-T-&gt;ch[i]; &#125; &#125; //扫描过的所有字符都相同，则长度长的串更大 return S-&gt;length-T-&gt;length;&#125;//求串长，返回串S的元素个数[未完成代码]int StrLength(SString *S)&#123; return 0;&#125;//3.定位操作，若主串S中存在与串T值相同的子串，则返回它在主串S中第一次出现的位置，否则函数值为0int Index(SString *S,SString *T)&#123; int i=1,n=StrLength(S),m=StrLength(T); SString sub; //用于暂存字符串 while(i&lt;=n-m+1)&#123; SubString(&amp;sub, S, i, m); if(StrCompare(&amp;sub, T) != 0)&#123; ++i; &#125;else&#123; return i; //返回子串在主串中的位置 &#125; &#125; return 0; //S中不存在与T相等的子串&#125;int main()&#123; SString S=&#123;&quot;hello world!&quot;,12&#125;; SString Sub=&#123;&quot;&quot;,0&#125;; //初始化时清空数组 if(SubString(&amp;Sub, &amp;S, 3, 5))&#123; printf(&quot;%s\\n&quot;,Sub.ch); &#125;&#125; 串的链式存储：","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构、算法笔记","slug":"数据结构、算法笔记","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"}]},{"title":"串的朴素模式匹配算法","slug":"数据结构和算法/数据结构、算法笔记/串的朴素模式匹配算法","date":"2020-01-02T16:00:00.000Z","updated":"2021-03-23T07:42:49.000Z","comments":true,"path":"2020/01/03/数据结构和算法/数据结构、算法笔记/串的朴素模式匹配算法/","link":"","permalink":"http://example.com/2020/01/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E4%B8%B2%E7%9A%84%E6%9C%B4%E7%B4%A0%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95/","excerpt":"","text":"一定是主串中存在的才叫“子串” 模式串：想尝试在主串中找到的串，未必存在 串的模式匹配：在主串中找到与模式串相同的子串，并返回其所在位置【就是定位操作】 朴素模式匹配算法： 【比较好的情况：每个子串的第一个字符就与模式串不匹配，若模式串长度为m，主串长度为n，则匹配成功的最好时间复杂度：O(m)，匹配失败的最好时间复杂度：O(n-m+1)=O(n-m)=O(n)】 【若模式串长度为m，主串长度为n，则直接匹配成功/匹配失败最多需要(n-m+1)*m次比较，最坏时间复杂度：O(nm)，这种情况就是每个子串的前m-1个字符都和模式串匹配，只有第m个字符不匹配，所以指针需要回溯重新来匹配】 12345678910111213141516171819202122232425262728293031323334353637#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;stdbool.h&gt;#define MAXIEN 255 //预定义最大串长为255typedef struct&#123; char ch[MAXIEN]; //每个分量存储一个字符 int length; //串的实际长度&#125;SString;//只要有一个字符不同，就可以停止检查当前子串，所有对应位置的字符都相同，则匹配成功，返回kint Index(SString *S,SString *T)&#123; int k=1; //k记录当前检查的子串起始位置 int i=k,j=1; while(i&lt;=S-&gt;length &amp;&amp; j&lt;=S-&gt;length)&#123; if(S-&gt;ch[i] == T-&gt;ch[i])&#123; ++i; ++j; //继续比较后继字符 &#125; else&#123; k++; //检查下一个子串 i=k; j=1; &#125; &#125; if(j&lt;T-&gt;length)&#123; return k; &#125;else&#123; return 0; &#125;&#125;int main()&#123; SString S;&#125;","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构、算法笔记","slug":"数据结构、算法笔记","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"}]},{"title":"KMP算法","slug":"数据结构和算法/数据结构、算法笔记/KMP算法","date":"2020-01-01T16:00:00.000Z","updated":"2021-03-23T07:42:37.000Z","comments":true,"path":"2020/01/02/数据结构和算法/数据结构、算法笔记/KMP算法/","link":"","permalink":"http://example.com/2020/01/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/KMP%E7%AE%97%E6%B3%95/","excerpt":"","text":"朴素模式匹配算法的缺点：当某些子串与模式串能部分匹配时，主串的扫描指针i经常回溯，导致时间开销增加 改进思路：主串指针不回溯，只有模式串指针回溯 求模式串的next数组：当模式串的第j个字符匹配失败时，令模式串跳到next[j]再继续匹配 串的前缀：包含第一个字符，且不包含最后一个字符的子串串的后缀：包含最后一个字符，且不包含第一个字符的子串 手写求next： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;stdbool.h&gt;#define MAXIEN 255 //预定义最大串长为255typedef struct&#123; char ch[MAXIEN]; //每个分量存储一个字符 int length; //串的实际长度&#125;SString;//求模式串T的next数组void get_next(SString *T,int next[])&#123; int i=1,j=0; next[1]=0; while(i&lt;T-&gt;length)&#123; if(j==0 || T-&gt;ch[i] == T-&gt;ch[j])&#123; ++i; ++j; //若pi=pj，则next[j+1]=next[j]+1 next[i]=j; &#125; else&#123; //否则令j=next[j]，循环继续 j=next[j]; &#125; &#125;&#125;//KMP算法代码【平均时间复杂度O(n+m)】int Index_KMP(SString *S,SString *T)&#123; int i=1,j=1; int next[T-&gt;length+1]; get_next(T, next); //求模式串的next数组 while(i&lt;=S-&gt;length &amp;&amp; j&lt;=T-&gt;length)&#123; if(j==0 || S-&gt;ch[i] == T-&gt;ch[i])&#123; ++i; ++j; //继续比较后继字符 &#125;else&#123; j=next[j]; //模式串向右移动 &#125; &#125; if(j&gt;T-&gt;length)&#123; return i-T-&gt;length; //匹配成功 &#125;else&#123; return 0; &#125;&#125;int main()&#123; SString S;&#125; KMP算法存在的问题：多进行了一次无意义的对比 KMP算法进一步优化：nextval数组","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构、算法笔记","slug":"数据结构、算法笔记","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"}]},{"title":"145-大小写转换(C)","slug":"数据结构和算法/LeetCode/145-大小写转换(C)","date":"2019-12-31T16:00:00.000Z","updated":"2021-03-12T02:58:38.000Z","comments":true,"path":"2020/01/01/数据结构和算法/LeetCode/145-大小写转换(C)/","link":"","permalink":"http://example.com/2020/01/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/LeetCode/145-%E5%A4%A7%E5%B0%8F%E5%86%99%E8%BD%AC%E6%8D%A2(C)/","excerpt":"","text":"——— 123456789101112131415161718#include&lt;stdio.h&gt;**void** sw(**char** ch)&#123; **if**(ch &gt;= ‘a’ &amp;&amp; ch &lt;= ‘z’)&#123; printf(“%c\\n”,ch-32); &#125; **else**&#123; printf(“%c\\n”,ch+32); &#125;&#125;**int** main()&#123; **char** ch; scanf(“%c”,&amp;ch); sw(ch); **return** 0;&#125; ———","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"146-大小写转换II(C)","slug":"数据结构和算法/LeetCode/146-大小写转换II(C)","date":"2019-12-31T16:00:00.000Z","updated":"2021-03-12T02:58:26.000Z","comments":true,"path":"2020/01/01/数据结构和算法/LeetCode/146-大小写转换II(C)/","link":"","permalink":"http://example.com/2020/01/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/LeetCode/146-%E5%A4%A7%E5%B0%8F%E5%86%99%E8%BD%AC%E6%8D%A2II(C)/","excerpt":"","text":"——— 12345678910111213141516171819202122#include&lt;stdio.h&gt;#include&lt;string.h&gt;**char*** fun(**char** a[100])&#123; **int** I; **for** (I = 0; a[I] != ‘\\0’; I++)&#123; **if** (a[I] &gt;= ‘a’ &amp;&amp; a[I] &lt;= ‘z’)&#123; a[I] -= 32; &#125; &#125; **return** a;&#125;**int** main()&#123; **char** a[100]; printf(“请输入一个字符串：\\n”); fgets(a,100,stdin); //不能用gets()函数 printf(“结果为：%s\\n”,fun(a)); **return** 0;&#125; ———","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"222-Getter与Setter(C++)","slug":"数据结构和算法/LeetCode/222-Getter与Setter(C++)","date":"2019-12-31T16:00:00.000Z","updated":"2021-03-12T02:58:11.000Z","comments":true,"path":"2020/01/01/数据结构和算法/LeetCode/222-Getter与Setter(C++)/","link":"","permalink":"http://example.com/2020/01/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/LeetCode/222-Getter%E4%B8%8ESetter(C++)/","excerpt":"","text":"","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"225、用队列实现栈","slug":"数据结构和算法/LeetCode/225、用队列实现栈","date":"2019-12-31T16:00:00.000Z","updated":"2021-03-12T02:57:32.000Z","comments":true,"path":"2020/01/01/数据结构和算法/LeetCode/225、用队列实现栈/","link":"","permalink":"http://example.com/2020/01/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/LeetCode/225%E3%80%81%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88/","excerpt":"","text":"","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"225-在链表中找节点","slug":"数据结构和算法/LeetCode/225-在链表中找节点","date":"2019-12-31T16:00:00.000Z","updated":"2021-03-12T02:57:59.000Z","comments":true,"path":"2020/01/01/数据结构和算法/LeetCode/225-在链表中找节点/","link":"","permalink":"http://example.com/2020/01/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/LeetCode/225-%E5%9C%A8%E9%93%BE%E8%A1%A8%E4%B8%AD%E6%89%BE%E8%8A%82%E7%82%B9/","excerpt":"","text":"","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"37-反转一个3位整数(C、Java)","slug":"数据结构和算法/LeetCode/37-反转一个3位整数(C、Java)","date":"2019-12-31T16:00:00.000Z","updated":"2021-03-12T02:58:51.000Z","comments":true,"path":"2020/01/01/数据结构和算法/LeetCode/37-反转一个3位整数(C、Java)/","link":"","permalink":"http://example.com/2020/01/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/LeetCode/37-%E5%8F%8D%E8%BD%AC%E4%B8%80%E4%B8%AA3%E4%BD%8D%E6%95%B4%E6%95%B0(C%E3%80%81Java)/","excerpt":"","text":"——————————————— 问题： —————————————————— C解答： 1234567891011121314#include&lt;stdio.h&gt;**int** main()&#123; //m是指输入的3位整数；a指百位；b指十位；c指个位；n指输出的反转的数 **int** m,n,a,b,c; printf(“请输入一个三位整数：”); scanf(“%d”,&amp;m); a=m/100; c=m%10; b=m/10%10; n=c*100+b*10+a; printf(“反转后的三位整数是：%d\\n”,n);&#125; ———————— Java解答： public class Solution{ public int reverseInteger(int number){ //获取个位数 int num1=number % 10; //获取十位数 int num2=(number / 10) % 10; //获取百位数 int num3 =((number / 10) /10) % 10; //相加 return num3+num210+num1100; }}","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"整数反转","slug":"数据结构和算法/LeetCode/7、整数反转","date":"2019-12-31T16:00:00.000Z","updated":"2021-03-12T02:57:48.000Z","comments":true,"path":"2020/01/01/数据结构和算法/LeetCode/7、整数反转/","link":"","permalink":"http://example.com/2020/01/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/LeetCode/7%E3%80%81%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/","excerpt":"","text":"","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"树的基本概念","slug":"数据结构和算法/数据结构、算法笔记/树的基本概念","date":"2019-12-31T16:00:00.000Z","updated":"2021-03-23T07:42:25.000Z","comments":true,"path":"2020/01/01/数据结构和算法/数据结构、算法笔记/树的基本概念/","link":"","permalink":"http://example.com/2020/01/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/","excerpt":"","text":"树是n(n&gt;=0)个结点的有限集合，n=0时，称为空树 而任意非空树应满足： 有且仅有一个特定的称为根的结点 当n&gt;1时，其余结点可分为m(m&gt;0)个互不相交的有限集合，其中每一个集合本身又是一棵树，称为根结点的子树 基本术语： 祖先结点和子孙结点、双亲结点和孩子结点、兄弟结点 树中一个结点的子结点的个数称为该结点的度；树中各结点度的最大值称为树的度 度大于0的结点称为分支结点度为0的结点称为叶子结点 结点的层数【自顶向下】结点的高度【自底向上】结点的深度【自顶向下】树的高度(深度)是树中结点的最大层数树中每一层结点个数的最大值称为树的宽度 路径：树中两个结点之间的路径是由这两个结点之间所经过的结点序列构成的【树中的分支是有向的，即从双亲结点指向孩子结点，所以路径一定是自上而下的】 路径长度：路径上所经历边的个数 有序树：树中任意结点的子结点之间有顺序关系无序树：树中任意结点的子结点之间没有顺序关系，也叫自由树 树的性质： n个结点的树中只有n-1条边 树中的结点数等于所有结点的度数+1 度为m的树中第i层上至多有m^(i-1)个结点(i&gt;=1) 高度为h的m叉树至多有(m^h-1)/(m-1)个结点 具有n个结点的m叉树的最小高度为 森林：m(m&gt;=0)棵互不相交的树的集合","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构、算法笔记","slug":"数据结构、算法笔记","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"}]},{"title":"二叉树的概念","slug":"数据结构和算法/数据结构、算法笔记/二叉树的概念","date":"2019-12-30T16:00:00.000Z","updated":"2021-03-24T14:10:17.000Z","comments":true,"path":"2019/12/31/数据结构和算法/数据结构、算法笔记/二叉树的概念/","link":"","permalink":"http://example.com/2019/12/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5/","excerpt":"","text":"二叉树是n(n&gt;=0)个结点的有限集合1）n=0时，二叉树为空2）n&gt;0时，由根结点和两个互不相交的被称为根的左子树和右子树组成，左子树和右子树也分别是一棵二叉树 特点： 每个结点最多有两颗子树，所以二叉树中不存在度大于2的结点 二叉树的左右子树不能任意颠倒，如果某结点只有一棵子树，一定要指明它是左子树还是右子树 二叉树 VS 度为2的有序树：1）二叉树可以为空，而度为2的有序树至少有三个结点2）二叉树的孩子结点始终有左右之分，而度为2的有序树的孩子结点次序是相对的 斜树：所有结点都只有左子树的二叉树称为左斜树，所有结点都只有右子树的二叉树称为右斜树 每一层只有一个结点 斜树的结点个数与其深度相同 满二叉树：一棵高度为h，且含有2^h-1个结点的二叉树为满二叉树【在一棵二叉树中，所有分支结点都存在左子树和右子树，并且所有叶子都在同一层上】 叶子只能出现在最下一层 只有度为0和度为2的结点 完全二叉树：设一个高度为h、有n个结点的二叉树，当且仅当其每个结点都与高度为h的满二叉树中编号1～n的结点一一对应时，称为完全二叉树 深度为k的完全二叉树在k-1层是满二叉树 叶子结点只能出现在最下两层，且最下层的叶子结点都集中在左侧连续的位置 如果有度为1的结点，只可能有一个，且该结点只有左孩子 完全二叉树的性质： 二叉排序树：一棵二叉树，若树非空则具有如下性质：对任意结点若存在左子树或右子树，则其左子树上所有结点的关键字均小于该结点，右子树上所有结点的关键字均大于该结点 平衡二叉树：树上任意结点的左子树和右子树的高度差不超过1 二叉树的性质：","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构、算法笔记","slug":"数据结构、算法笔记","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"}]},{"title":"常量和变量以及自动推导","slug":"编程语言/Swift/常量和变量以及自动推导","date":"2019-12-30T16:00:00.000Z","updated":"2021-03-02T02:24:13.000Z","comments":true,"path":"2019/12/31/编程语言/Swift/常量和变量以及自动推导/","link":"","permalink":"http://example.com/2019/12/31/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Swift/%E5%B8%B8%E9%87%8F%E5%92%8C%E5%8F%98%E9%87%8F%E4%BB%A5%E5%8F%8A%E8%87%AA%E5%8A%A8%E6%8E%A8%E5%AF%BC/","excerpt":"","text":"Let定义常量、var定义变量【整数默认是Int，小数默认是Double】let x=20var y=1.5 自动推导：会根据设置数值的右侧代码，推断常量、变量的类型【但是在swift中任何时候都不会做隐式转换，任何两个类型不同的变量或者常量不允许直接去计算】let x=20let y=1.5let r1=x+Int(y)print(r1)","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"http://example.com/tags/Swift/"}]},{"title":"二叉树的存储结构","slug":"数据结构和算法/数据结构、算法笔记/二叉树的存储结构","date":"2019-12-29T16:00:00.000Z","updated":"2021-03-24T14:10:35.000Z","comments":true,"path":"2019/12/30/数据结构和算法/数据结构、算法笔记/二叉树的存储结构/","link":"","permalink":"http://example.com/2019/12/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/","excerpt":"","text":"二叉树的顺序存储：用一组连续的存储单元依次自上而下、自左至右存储完全二叉树上的结点元素 二叉树的链式存储：用链表来存放一棵二叉树，二叉树中每个结点用链表的一个链结点来存储","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构、算法笔记","slug":"数据结构、算法笔记","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"}]},{"title":"可选项：","slug":"编程语言/Swift/可选项：","date":"2019-12-29T16:00:00.000Z","updated":"2021-03-02T02:24:01.000Z","comments":true,"path":"2019/12/30/编程语言/Swift/可选项：/","link":"","permalink":"http://example.com/2019/12/30/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Swift/%E5%8F%AF%E9%80%89%E9%A1%B9%EF%BC%9A/","excerpt":"","text":"定义变量、常量如果需要指定准确的类型 可选项：一个变量，可以为本身的类型，也可以为nil 可选项不能直接计算：每次写!的时候，都需要程序员思考，是不是有可能为nil","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"http://example.com/tags/Swift/"}]},{"title":"二叉树的遍历","slug":"数据结构和算法/数据结构、算法笔记/二叉树的遍历","date":"2019-12-28T16:00:00.000Z","updated":"2021-03-24T14:10:50.000Z","comments":true,"path":"2019/12/29/数据结构和算法/数据结构、算法笔记/二叉树的遍历/","link":"","permalink":"http://example.com/2019/12/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/","excerpt":"","text":"二叉树的遍历：按某条搜索路径访问树中的每个结点，树的每个结点均被访问一次，而且只访问一次 先序遍历(递归实现)： 中序遍历(递归实现)： 中序遍历非递归算法： 后序遍历(递归实现)： 层次遍历： 由遍历序列构造二叉树：","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构、算法笔记","slug":"数据结构、算法笔记","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"}]},{"title":"控制流：","slug":"编程语言/Swift/控制流：","date":"2019-12-28T16:00:00.000Z","updated":"2021-03-02T02:23:48.000Z","comments":true,"path":"2019/12/29/编程语言/Swift/控制流：/","link":"","permalink":"http://example.com/2019/12/29/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Swift/%E6%8E%A7%E5%88%B6%E6%B5%81%EF%BC%9A/","excerpt":"","text":"———————— If和三目if letguardswitch ———————— If和三目: if let、guard: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556**import** UIKit**class** ViewController: UIViewController &#123; **override** **func** viewDidLoad() &#123; **super**.viewDidLoad() // Do any additional setup after loading the view. demo1() demo2() demo3() &#125; //一： **func** demo1()&#123; **let** oName: String? = “张三” **let** oAge: Int? = 20 **if** oName != **nil** &amp;&amp; oAge != **nil**&#123; print(“Mr” + oName! + “—“ + String(oAge!)) &#125; &#125; //二： //if let可以设置数值，进入分支后，name可以保证一定有值 //if let语句中不能使用&amp;&amp; ||条件 **func** demo2()&#123; **let** oName: String? = “张三” **let** oAge: Int? = 20 **if** **let** name = oName , **let** age = oAge&#123; print(“Mr” + name + “—“ + String(age)) &#125; &#125; //三：guard是和if let相反的指令 **func** demo3()&#123; **let** oName: String? = “张三” **let** oAge: Int? = 20 **guard** **let** name = oName **else**&#123; print(“name = nil”) **return** &#125; **guard** **let** age = oAge **else**&#123; print(“age = nil”) **return** &#125; //代码执行到此，name和age一定有值 print(“Mr” + name + “—“ + String(age)) &#125;&#125;","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"http://example.com/tags/Swift/"}]},{"title":"线索二叉树","slug":"数据结构和算法/数据结构、算法笔记/线索二叉树","date":"2019-12-27T16:00:00.000Z","updated":"2021-03-24T14:11:03.000Z","comments":true,"path":"2019/12/28/数据结构和算法/数据结构、算法笔记/线索二叉树/","link":"","permalink":"http://example.com/2019/12/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91/","excerpt":"","text":"线索化：若无左子树，则将左指针指向其前驱结点；若无右子树，则将右指针指向其后继结点","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构、算法笔记","slug":"数据结构、算法笔记","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"}]},{"title":"树的存储结构","slug":"数据结构和算法/数据结构、算法笔记/树的存储结构","date":"2019-12-26T16:00:00.000Z","updated":"2021-03-24T14:11:16.000Z","comments":true,"path":"2019/12/27/数据结构和算法/数据结构、算法笔记/树的存储结构/","link":"","permalink":"http://example.com/2019/12/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/","excerpt":"","text":"双亲表示法：采用一组连续的存储空间来存储每个结点，同时在每个结点中增设一个伪指针，指示双亲结点在数组中的位置，根结点的下标为0，其伪指针域为-1 123456789101112#define MAX_TREE_SIZE 100typedef struct&#123; int data; int parent;&#125;PINode;typedef struct&#123; PINode nodes[MAX_TREE_SIZE]; int n;&#125;PTree; 孩子表示法：将每个结点的孩子结点都用单链表连接起来形成一个线性结构，n个结点具有n个孩子链表 1234567891011121314151617#define MAX_TREE_SIZE 100typedef struct&#123; int child; struct CNode *next;&#125;CNode;typedef struct&#123; int data; struct CNode *child;&#125;PNode;typedef struct&#123; PNode nodes[MAX_TREE_SIZE]; int n;&#125;CTree; 孩子兄弟表示法： 12345typedef struct CSNode&#123; int data; struct CSNode *firstchild,*nextsibling;&#125;CSNode,CSTRee; 双亲表示法：寻找结点的双亲结点效率高，寻找结点的孩子结点效率低孩子表示法：寻找结点的孩子结点效率高，寻找结点的双亲结点效率低孩子兄弟表示法：寻找结点的孩子结点效率高，方便实现树转换为二叉树，寻找双亲结点的效率低","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构、算法笔记","slug":"数据结构、算法笔记","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"}]},{"title":"树和森林","slug":"数据结构和算法/数据结构、算法笔记/树和森林","date":"2019-12-25T16:00:00.000Z","updated":"2021-03-24T14:12:00.000Z","comments":true,"path":"2019/12/26/数据结构和算法/数据结构、算法笔记/树和森林/","link":"","permalink":"http://example.com/2019/12/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97/","excerpt":"","text":"树与二叉树的转换：左孩子右兄弟 森林与二叉树的转换： 树的遍历：按照某种方式访问树中的每个结点，且仅访问一次 先根遍历：若树非空，则先访问根结点，再按从左到右的顺序遍历根结点的每棵子树 后根遍历：若树非空，则先按从左到右的顺序遍历根结点的每棵子树，再访问根结点 层次遍历 森林的遍历： 先序遍历：若森林非空，则访问森林中第一棵树的根结点，先序遍历第一棵树的子树森林，先序遍历除去第一棵树之后剩余的树构成的子树森林 后序遍历：若森林非空，则后序遍历第一棵树的根结点的子树森林，访问第一棵树的根结点，后序遍历除去第一棵树之后剩余的树构成的子树森林","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构、算法笔记","slug":"数据结构、算法笔记","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"}]},{"title":"二叉排序树","slug":"数据结构和算法/数据结构、算法笔记/二叉排序树","date":"2019-12-24T16:00:00.000Z","updated":"2021-03-24T14:12:12.000Z","comments":true,"path":"2019/12/25/数据结构和算法/数据结构、算法笔记/二叉排序树/","link":"","permalink":"http://example.com/2019/12/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/","excerpt":"","text":"二叉排序树：BST，也称二叉查找树 二叉排序树或者为空树，或者为非空树，当为非空树时有如下特点：1）若左子树非空，则左子树上所有结点关键字值均小于根结点的关键字2）若右子树非空，则右子树上所有结点关键字值均大于根结点的关键字3）左、右子树本身也分别是一棵二叉排序树 二叉排序树的查找：二叉树非空时，查找根结点，若相等则查找成功；若不等，则当小于根结点值时查找左子树，当大于根结点的值时，查找右子树，当查找到叶结点仍没查找到相应的值，则查找失败 二叉排序树的插入：若二叉排序树为空，则直接插入结点；若二叉排序树非空，当值小于根结点时，插入左子树；当值大于根结点时，插入右子树；当值等于根结点时不进行插入 构造二叉排序树：读入一个元素并建立结点，若二叉树为空将其作为根结点；若二叉排序树非空，当值小于根结点时，插入左子树；当值大于根结点时，插入右子树；当值等于根结点时不进行插入 二叉排序树的删除：1）若被删除结点z是叶子结点，则直接删除2）若被删除结点z只有一棵子树，则让z的子树成为z父结点的子树，代替z结点3）若被删除结点z有两棵子树，则让z的‘中序序列直接后继’代替z，并删去直接后继结点 在二叉排序树中删除并插入某结点，得到的二叉排序树与原来不一定相同 二叉排序树的查找效率：","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构、算法笔记","slug":"数据结构、算法笔记","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"}]},{"title":"平衡二叉树","slug":"数据结构和算法/数据结构、算法笔记/平衡二叉树","date":"2019-12-23T16:00:00.000Z","updated":"2021-03-24T14:12:24.000Z","comments":true,"path":"2019/12/24/数据结构和算法/数据结构、算法笔记/平衡二叉树/","link":"","permalink":"http://example.com/2019/12/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/","excerpt":"","text":"平衡二叉树：AVL，任意结点的平衡因子的绝对值不超过1（平衡因子：左子树高度-右子树高度） 平衡二叉树的判断：利用递归的后续遍历过程1）判断左子树是一棵平衡二叉树2）判断右子树是一棵平衡二叉树3）判断以该结点为根的二叉树为平衡二叉树【判断条件：若左子树和右子树均为平衡二叉树，且左子树与右子树高度差的绝对值小于等于1，则平衡】 平衡二叉树的插入： 1）LL平衡旋转(右单旋转)原因：在结点A的左孩子的左子树上插入了新结点调整方法：右旋操作，将A的左孩子B代替A，将A结点称为B的右子树根结点，而B的原右子树则作为A的左子树 2）RR平衡旋转(左单旋转)原因：在结点A的右孩子的右子树上插入了新结点调整方法：左旋操作，将A的右孩子B代替A，将A结点称为B的左子树根结点，而B的原左子树则作为A的右子树 3）LR平衡旋转(先左后右双旋转)原因：在结点A的左孩子的右子树上插入了新结点调整方法：先左旋后右旋操作，将A的左孩子B的右孩子结点C代替B，然后再将C结点向上代替A的位置 4）RL平衡旋转(先右后左双旋转)原因：在结点A的右孩子的左子树上插入了新结点调整方法：先右旋后左旋操作，将A的右孩子B的左孩子结点C代替B，然后再将C结点向上代替A的位置","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构、算法笔记","slug":"数据结构、算法笔记","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"}]},{"title":"哈夫曼树","slug":"数据结构和算法/数据结构、算法笔记/哈夫曼树","date":"2019-12-22T16:00:00.000Z","updated":"2021-03-24T14:12:36.000Z","comments":true,"path":"2019/12/23/数据结构和算法/数据结构、算法笔记/哈夫曼树/","link":"","permalink":"http://example.com/2019/12/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91/","excerpt":"","text":"路径长度：路径上所经历边的个数结点的权：结点被赋予的数值 树的带权路径长度：WPL，树中所有叶结点的带权路径长度之和 哈夫曼树：也称最优二叉树，含有n个带权叶子结点带权路径长度最小的二叉树 哈夫曼树的构造算法：1）将n个结点作为n棵仅含有一个根结点的二叉树，构造森林F2）生成一个新结点，并从F中找出根结点权值最小的两棵树作为它的左右子树，且新结点的权值为两棵子树根结点的权值之和3）从F中删除这两棵树，并将新生成的树加入到F中4）重复2，3步骤，直到F中只有一棵树为止 哈夫曼树的性质：1）每个初始结点都会成为叶结点，双支结点都为新生成的结点2）权值越大离根结点越近，反之权值越小离根结点越远3）哈夫曼树中没有结点的度为14）n个叶子结点的哈夫曼树的结点总数为2n-1，其中度为2的结点数为n-1","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构、算法笔记","slug":"数据结构、算法笔记","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"}]},{"title":"图的基本概念","slug":"数据结构和算法/数据结构、算法笔记/图的基本概念","date":"2019-12-21T16:00:00.000Z","updated":"2021-03-24T14:12:48.000Z","comments":true,"path":"2019/12/22/数据结构和算法/数据结构、算法笔记/图的基本概念/","link":"","permalink":"http://example.com/2019/12/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/","excerpt":"","text":"图G由顶点集V和边集E组成，记为G=(V,E)，其中V(G)表示图G中顶点的有限非空集；E(G)表示图G中顶点之间的关系(边)集合|V|表示图G中顶点的个数，也称图G的阶；|E|表示图G中边的条数 无向图和有向图： 简单图和多重图： 在图中，权通常是对边赋予的有意义的数值量，边上带权的图称为带权图或网图： 完全图： 稠密图、稀疏图 顶点的度：以该顶点为一个端点的边的数目 无向图顶点v的度为以v为端点的边的个数，记为TD(v)；n顶点、e条边的无向图中度的总数为2e 有向图：出度指以v为起点的有向边的条数，记OD(v)；入度指以v为终点的有向边的条数，记ID(v)；TD(v)=OD(v)+ID(v)；n顶点、e条边的有向图中出度、入度为e 有向树：一个顶点的入度为0，其余顶点的入度均为1的有向图 路径：图中顶点v到顶点w的顶点序列，序列中顶点不重复的路径称为简单路径 路径长度：路径上边的数目，若该路径最短则称其为距离 回路：第一个顶点和最后一个顶点相同的路径 除了第一个顶点和最后一个顶点之外，其余顶点不重复出现的回路称为简单回路 子图：设有两个图G=(V,E)和G’=(V’,E’)，若V’是V的子集，且E’是E的子集，则称G’为G的子图；且若V(G)=V(G’)则称G’为G的生成子图 无向图只有连通：若从顶点v到顶点w有路径存在，则称v和w是连通【连通图：任意两个结点之间都是连通的】【连通分量：极大连通子图】 有向图只有强连通：若从顶点v到顶点w和顶点w到顶点v都有路径存在，则称v和w是强连通【强连通图：任意两个结点之间都是强连通的】【强连通分量：极大强连通子图】 对于G的一个(强)连通子图G’，如果不存在G的另一个(强)连通子图G’’，使得G’属于G’’，则称G’为G的(强)连通分量 极小连通子图：连通子图且包含的边最少 生成树：连通图包含全部顶点的一个极小连通子图(n个顶点图的生成树有n-1条边) 生成森林：非连通图所有连通分量的生成树组成连通森林","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构、算法笔记","slug":"数据结构、算法笔记","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"}]},{"title":"邻接矩阵法","slug":"数据结构和算法/数据结构、算法笔记/邻接矩阵法","date":"2019-12-20T16:00:00.000Z","updated":"2021-03-24T14:13:00.000Z","comments":true,"path":"2019/12/21/数据结构和算法/数据结构、算法笔记/邻接矩阵法/","link":"","permalink":"http://example.com/2019/12/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E6%B3%95/","excerpt":"","text":"图的邻接矩阵存储也称数组表示法，用一个一维数组存储图中的顶点，用一个二维数组存储图中的边，存储顶点之间邻接关系的二维数组称为邻接矩阵 邻接矩阵的性质：1）邻接矩阵的空间复杂度为O(n^2)，适用于稠密图2）无向图的邻接矩阵为对称矩阵3）无向图中第i行(或第i列)非0元素(非正无穷)的个数为第i个顶点的度4）有向图中第i行(或第i列)非0元素(非正无穷)的个数为第i个顶点的出度(入度)","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构、算法笔记","slug":"数据结构、算法笔记","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"}]},{"title":"邻接表法","slug":"数据结构和算法/数据结构、算法笔记/邻接表法","date":"2019-12-19T16:00:00.000Z","updated":"2021-03-25T00:55:46.000Z","comments":true,"path":"2019/12/20/数据结构和算法/数据结构、算法笔记/邻接表法/","link":"","permalink":"http://example.com/2019/12/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E9%82%BB%E6%8E%A5%E8%A1%A8%E6%B3%95/","excerpt":"","text":"邻接矩阵法存储稀疏图会有许多空间浪费 邻接表法：为每一个顶点建立一个单链表存放与它相邻的边 邻接表的特点：1）若G为无向图，存储空间为O(|V|+2|E|)若G为有向图，存储空间为O(|V|+|E|)2）邻接表更加适用于稀疏图3）若G为无向图，则结点的度为该结点边表的长度若G为有向图，则结点的出度为该结点边表的长度，计算入度则要遍历整个邻接表4）邻接表不唯一，边表结点的顺序根据算法和输入的不同可能会不同","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构、算法笔记","slug":"数据结构、算法笔记","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"}]},{"title":"十字链表","slug":"数据结构和算法/数据结构、算法笔记/十字链表","date":"2019-12-18T16:00:00.000Z","updated":"2021-03-25T02:21:38.000Z","comments":true,"path":"2019/12/19/数据结构和算法/数据结构、算法笔记/十字链表/","link":"","permalink":"http://example.com/2019/12/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%8D%81%E5%AD%97%E9%93%BE%E8%A1%A8/","excerpt":"","text":"十字链表：有向图的一种链式存储结构","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构、算法笔记","slug":"数据结构、算法笔记","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"}]},{"title":"邻接多重表","slug":"数据结构和算法/数据结构、算法笔记/邻接多重表","date":"2019-12-17T16:00:00.000Z","updated":"2021-03-25T02:54:59.000Z","comments":true,"path":"2019/12/18/数据结构和算法/数据结构、算法笔记/邻接多重表/","link":"","permalink":"http://example.com/2019/12/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E9%82%BB%E6%8E%A5%E5%A4%9A%E9%87%8D%E8%A1%A8/","excerpt":"","text":"用邻接表存储无向图，每条边的两个顶点分别在该边所依附的两个顶点的边表中，这种重复存储给图的某些操作带来不便，例如对已访问过的边做标记，或者要删除图中某一条边等，都需要找到表示同一条边的两个边表结点。 邻接多重表：主要用于存储无向图","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构、算法笔记","slug":"数据结构、算法笔记","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"}]},{"title":"图的基本操作","slug":"数据结构和算法/数据结构、算法笔记/图的基本操作","date":"2019-12-16T16:00:00.000Z","updated":"2021-03-25T03:41:39.000Z","comments":true,"path":"2019/12/17/数据结构和算法/数据结构、算法笔记/图的基本操作/","link":"","permalink":"http://example.com/2019/12/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/","excerpt":"","text":"Adjacent(G,x,y)：判断图G是否存在边&lt;x,y&gt;或(x,y)【邻接矩阵效率高】 Neighbors(G,x)：列出图G中与结点x邻接的边【无向图邻接表效率高，有向图邻接矩阵效率高】 InsertVertex(G,x)：在图G中插入顶点x DeleteVertex(G,x)：从图G中删除顶点x AddEdge(G,x,y)：若无向边(x,y)或者有向边&lt;x,y&gt;不存在，则向图G中添加该边 RemoveEdge(G,x,y)：若无向边(x,y)或者有向边&lt;x,y&gt;存在，则在图G中删除该边【邻接矩阵效率高】 FirstNeighbor(G,x)：求图G中顶点x的第一个邻接点，若有则返回顶点号，若没有邻接点或图不存在x，则返回-1NextNeighbor(G,x)：假设图G中顶点y是顶点x的一个邻接点，返回除y之外顶点x的下一个邻接点的顶点号，若y是x的最后一个邻接点，则返回-1 Get_edge_value(G,x,y)：获取图G中边(x,y)或&lt;x,y&gt;对应的权值vSet_edge_value(G,x,y)：设置图G中边(x,y)或&lt;x,y&gt;对应的权值为v","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构、算法笔记","slug":"数据结构、算法笔记","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"}]},{"title":"广度优先搜索","slug":"数据结构和算法/数据结构、算法笔记/广度优先搜索","date":"2019-12-15T16:00:00.000Z","updated":"2021-03-25T09:00:37.000Z","comments":true,"path":"2019/12/16/数据结构和算法/数据结构、算法笔记/广度优先搜索/","link":"","permalink":"http://example.com/2019/12/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/","excerpt":"","text":"图的遍历：从图中某一顶点出发，按照某种搜索方法沿着图中的边对图中的所有顶点访问一次且仅访问一次 广度优先搜索(BFS)：1）首先访问起始顶点v2）接着由v出发依次访问v的各个未被访问过的邻接顶点w1，w2…wi3）然后依次访问w1，w2…wi的所有未被访问过的邻接顶点4）从这些访问过的顶点出发，访问它们所有未被访问过的邻接顶点，以此类推 BFS算法的性能分析：1）空间复杂度：O(|V|)2）时间复杂度：邻接矩阵法O(|V|^2)，邻接表法O(|V|+|E|) 无权图单源最短路径问题：定义从顶点u到顶点v的最短路径d(u,v)为从u到v的任何路径中最少的边数，若从u到v没有通路，则d(u,v)=正无穷 广度优先生成树：在广度遍历过程中，我们可以得到一棵遍历树，称为广度优先生成树(生成森林)【邻接矩阵法的广度优先生成树唯一，邻接表法的不唯一】","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构、算法笔记","slug":"数据结构、算法笔记","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"}]},{"title":"深度优先搜索","slug":"数据结构和算法/数据结构、算法笔记/深度优先搜索","date":"2019-12-14T16:00:00.000Z","updated":"2021-03-25T09:34:29.000Z","comments":true,"path":"2019/12/15/数据结构和算法/数据结构、算法笔记/深度优先搜索/","link":"","permalink":"http://example.com/2019/12/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/","excerpt":"","text":"深度优先搜索DFS：【与树的先序遍历类似】1）首先访问起始顶点v2）接着由v出发访问v的任意一个邻接且未被访问的邻接顶点wi3）然后再访问与wi邻接且未被访问的任意顶点yi4）若wi没有邻接且未被访问的顶点时，退回到它的上一层顶点v5）重复上述过程，直到所有顶点被访问为止 借助递归(栈)+辅助标记数组来实现：【邻接矩阵法的DFS(BFS)序列唯一，邻接表法的不唯一】DFS序列：ACDEB DFS算法的性能分析：1）空间复杂度：O(|V|)2）时间复杂度：邻接矩阵法O(|V|^2)，邻接表法O(|V|+|E|) 深度优先生成树：在深度遍历过程中，我们可以得到一棵遍历树，称为深度优先生成树（生成森林）【邻接矩阵法的深度优先生成树唯一，邻接表法的不唯一】 遍历与连通性问题：1）在无向图中，在任意结点出发进行一次遍历(调用一次BFS或DFS)，若能访问全部结点，说明该无向图是连通的2）在无向图中，调用遍历函数(BFS或DFS)的次数为连通分量的个数有向图中上面两个结论都不成立：","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构、算法笔记","slug":"数据结构、算法笔记","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"}]},{"title":"最小生成树","slug":"数据结构和算法/数据结构、算法笔记/最小生成树","date":"2019-12-13T16:00:00.000Z","updated":"2021-03-25T14:06:37.000Z","comments":true,"path":"2019/12/14/数据结构和算法/数据结构、算法笔记/最小生成树/","link":"","permalink":"http://example.com/2019/12/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/","excerpt":"","text":"生成树：连通图包含全部顶点的一个极小连通子图 最小生成树：对于带权无向连通图G=(V,E)，G的所有生成树当中边的权值之和最小的生成树为G的最小生成树（MST） 性质：1）最小生成树不一定唯一，即最小生成树的树形不一定唯一，当带权无向连通图G的各边权值不等时或G只有结点数-1条边时，MST唯一2）最小生成树的权值是唯一的，且是最小3）最小生成树的边数为顶点数-1 Prim算法： 时间复杂度：O(|V|^2)，适用于稠密图 Kruskal算法： 时间复杂度：O(|E|log|E|)，适用于稀疏图","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构、算法笔记","slug":"数据结构、算法笔记","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"}]},{"title":"最短路径","slug":"数据结构和算法/数据结构、算法笔记/最短路径","date":"2019-12-12T16:00:00.000Z","updated":"2021-03-25T15:17:29.000Z","comments":true,"path":"2019/12/13/数据结构和算法/数据结构、算法笔记/最短路径/","link":"","permalink":"http://example.com/2019/12/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/","excerpt":"","text":"最短路径：两个顶点之间带权路径长度最短的路径为最短路径 在带权图当中，把从一个顶点v到另一个顶点u所经历的边的权值之和称为路径的带权路径长度 Dijkstra算法：带权图单源最短路径 时间复杂度：O(|V|^2) Dijkstra算法并不适用于含有负权边的图 Floyd算法：各顶点之间的最短路径 时间复杂度：O(|V|^3)","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构、算法笔记","slug":"数据结构、算法笔记","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"}]},{"title":"拓扑排序","slug":"数据结构和算法/数据结构、算法笔记/拓扑排序","date":"2019-12-11T16:00:00.000Z","updated":"2021-03-25T16:11:38.000Z","comments":true,"path":"2019/12/12/数据结构和算法/数据结构、算法笔记/拓扑排序/","link":"","permalink":"http://example.com/2019/12/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/","excerpt":"","text":"有向无环图：不存在环的有向图，简称DAG图 在一个表示工程的有向图中，用顶点表示活动，用弧表示活动之间的优先关系，称这样的有向图为顶点表示活动的网，简称AOV网 在AOV网中，不能出现回路 若从顶点vi到vj有一条路径，则在顶点序列中顶点vi必在vj之前，对一个有向图构造拓扑序列的过程称为拓扑排序 基本思想：1）从AOV网中选择一个没有前驱的顶点并输出2）从AOV网中删去该顶点以及所有以该顶点为尾的弧3）重复上述两步，直到全部顶点都被输出，或AOV网中不存在没有前驱的顶点 算法结束时没有访问所有顶点，则存在以剩下顶点组成的环 拓扑排序的结果不一定唯一 时间复杂度：O(|V|+|E|) 若邻接矩阵为三角矩阵，则存在拓扑排序，反之不一定成立","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构、算法笔记","slug":"数据结构、算法笔记","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"}]},{"title":"关键路径","slug":"数据结构和算法/数据结构、算法笔记/关键路径","date":"2019-12-10T16:00:00.000Z","updated":"2021-03-26T04:01:17.000Z","comments":true,"path":"2019/12/11/数据结构和算法/数据结构、算法笔记/关键路径/","link":"","permalink":"http://example.com/2019/12/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/","excerpt":"","text":"在一个表示工程的带权有向图中，用顶点表示事件，用有向边表示活动，边上的权值表示活动的持续时间，称这样的有向图为边表示活动的网，简称AOE网 在AOE网中，所有活动都完成才能到达终点，因此完成整个工程所必须花费的时间(即最短工期)应该为源点到终点的最大路径长度，具有最大路径长度的路径称为关键路径，关键路径上的活动称为关键活动 缩短关键活动时间可以加快整个工程，但缩短到一定大小时关键路径会发生改变 当网中关键路径不唯一时，只有加快的关键活动或关键活动组合包括在所有的关键路径上才能缩短工期","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构、算法笔记","slug":"数据结构、算法笔记","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"}]},{"title":"查找的基本概念","slug":"数据结构和算法/数据结构、算法笔记/查找的基本概念","date":"2019-12-09T16:00:00.000Z","updated":"2021-03-26T06:34:07.000Z","comments":true,"path":"2019/12/10/数据结构和算法/数据结构、算法笔记/查找的基本概念/","link":"","permalink":"http://example.com/2019/12/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%9F%A5%E6%89%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/","excerpt":"","text":"查找：在数据集合中寻找满足某种条件的数据元素的过程，查找结果分为查找成功和查找失败 查找表：用于查找的数据集合，由同一种数据类型(或记录)组成，可以是一个数组或链表等数据类型 查找表的操作：1）查询某个特定的数据元素是否在查找表中2）检索满足条件的某个特定的数据元素的各种属性3）从查找表中插入一个数据元素4）从查找表中删除一个数据元素 不涉及插入和删除操作的查找称为静态查找，涉及插入和删除操作的查找称为动态查找 关键字：数据元素中唯一标识该元素的某个数据项的值，使用基于关键字的查找，查找结果应该是唯一的 平均查找长度：查找时，关键字比较次数的平均值 线性表：适用于静态查找，主要采用顺序查找技术、折半查找技术树表：适用于动态查找，主要采用二叉排序树、平衡二叉树、B树等查找技术散列表：静态查找和动态查找均适用，主要采用散列查找技术","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构、算法笔记","slug":"数据结构、算法笔记","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"}]},{"title":"顺序查找","slug":"数据结构和算法/数据结构、算法笔记/顺序查找","date":"2019-12-08T16:00:00.000Z","updated":"2021-03-26T07:12:47.000Z","comments":true,"path":"2019/12/09/数据结构和算法/数据结构、算法笔记/顺序查找/","link":"","permalink":"http://example.com/2019/12/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE/","excerpt":"","text":"顺序查找：又称线性查找，主要用于在线性表中进行查找，从线性表的一端向另一端逐个将记录与给定值进行比较，若相等则查找成功，给出该记录在表中的位置；若整个表检测完仍未找到与给定值相等的记录，则查找失败，给出失败信息 对无序线性表进行查找： 对无序线性表进行顺序查找，查找失败时要遍历整个线性表 查找成功的比较次数为(n+1)/2，查找失败的比较次数为n+1【设置哨兵，哨兵就是待查值，存放在查找方向的尽头处，在查找过程中每次比较后，不用判断查找位置是否越界，从而提高了查找速度】 对有序线性表进行查找： 对关键字有序线性表进行顺序查找，查找失败时不一定要遍历整个线性表 有序线性表查找失败的比较次数：n/2+n/(n+1)","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构、算法笔记","slug":"数据结构、算法笔记","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"}]},{"title":"折半查找","slug":"数据结构和算法/数据结构、算法笔记/折半查找","date":"2019-12-07T16:00:00.000Z","updated":"2021-03-26T07:35:11.000Z","comments":true,"path":"2019/12/08/数据结构和算法/数据结构、算法笔记/折半查找/","link":"","permalink":"http://example.com/2019/12/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%8A%98%E5%8D%8A%E6%9F%A5%E6%89%BE/","excerpt":"","text":"折半查找：又称二分查找，仅适用于有序的顺序表 算法思想：1）首先将给定值key与表中中间位置元素的关键字比较2）若相等，则返回该元素的位置；若不等，则在前半部分或者是后半部分进行查找3）查找序列升序时，若key小于中间元素，则查找前半部分；若key大于中间元素，则查找后半部分4）重复该过程，直到找到查找的元素为止，或查找失败 注意low&lt;=high： 折半查找的判定树： 查找成功的平均比较次数：[log2(n+1)]-1，折半查找的时间复杂度为O(log2n) 顺序查找适用于顺序存储和链式存储，序列有序无序皆可；折半查找只适用于顺序存储，且要求序列一定有序","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构、算法笔记","slug":"数据结构、算法笔记","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"}]},{"title":"分块查找","slug":"数据结构和算法/数据结构、算法笔记/分块查找","date":"2019-12-06T16:00:00.000Z","updated":"2021-03-26T08:57:41.000Z","comments":true,"path":"2019/12/07/数据结构和算法/数据结构、算法笔记/分块查找/","link":"","permalink":"http://example.com/2019/12/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%88%86%E5%9D%97%E6%9F%A5%E6%89%BE/","excerpt":"","text":"分块查找：又称索引顺序查找，其查找性能介于折半查找和顺序查找之间 分块查找的使用前提是将线性表进行分块，并使其分块有序，所谓分块有序是指将线性表划分为若干块，每一块内不要求有序(即块内无序)，但要求第二块中所有记录的关键码均大于第一块中所有记录的关键码，第三块中所有记录的关键码均大于第二块中所有记录的关键码，以此类推(即块间有序) 分块查找还需要建立一个索引表，每块对应一个索引项，各索引项按关键码有序排序 分块查找需要分两步进行：第一步在索引表中确定待查关键码所在的块；第二步在相应块中查找待查关键码。由于索引表是按关键码有序排列，可使用顺序查找，也可使用折半查找；在块内进行查找时，由于块内是无序的，只能使用顺序查找","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构、算法笔记","slug":"数据结构、算法笔记","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"}]},{"title":"B树","slug":"数据结构和算法/数据结构、算法笔记/B树","date":"2019-12-05T16:00:00.000Z","updated":"2021-03-26T13:54:25.000Z","comments":true,"path":"2019/12/06/数据结构和算法/数据结构、算法笔记/B树/","link":"","permalink":"http://example.com/2019/12/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/B%E6%A0%91/","excerpt":"","text":"B树的定义： 查找：B树的查找类似于二叉排序树的查找，不同的是B树的每个结点是多关键码的有序表，在到达某个结点时，先在有序表中查找，若找到则查找成功；否则按照指针到相应的子树中查找，到达空指针(即外部结点)时，查找失败 在B树上的查找过程是一个顺指针查找结点和在结点中查找关键码交叉进行的过程。由于B树通常存储在磁盘上，则前一个查找操作是在磁盘上进行，而后一个查找操作是在内存中进行，即在磁盘上找到某结点后，先将结点的信息读入内存,然后再查找等于k的关键码。显然,在磁盘上进行一次查找比在内存中进行一次查找耗费的时间多得多，因此，在磁盘上进行查找的次数，即待查关键码所在结点在B树的层数，是决定B树查找效率的首要因素。 插入： 删除：","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构、算法笔记","slug":"数据结构、算法笔记","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"}]},{"title":"B+树","slug":"数据结构和算法/数据结构、算法笔记/B+树","date":"2019-12-04T16:00:00.000Z","updated":"2021-03-26T14:42:24.000Z","comments":true,"path":"2019/12/05/数据结构和算法/数据结构、算法笔记/B+树/","link":"","permalink":"http://example.com/2019/12/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/B+%E6%A0%91/","excerpt":"","text":"B+树的定义：","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构、算法笔记","slug":"数据结构、算法笔记","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"}]},{"title":"散列表的基本概念","slug":"数据结构和算法/数据结构、算法笔记/散列表的基本概念","date":"2019-12-03T16:00:00.000Z","updated":"2021-03-26T15:02:24.000Z","comments":true,"path":"2019/12/04/数据结构和算法/数据结构、算法笔记/散列表的基本概念/","link":"","permalink":"http://example.com/2019/12/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%95%A3%E5%88%97%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/","excerpt":"","text":"散列函数：一个把查找表中的关键字映射成该关键字对应的地址的函数 散列表：根据关键字而直接进行访问的数据结构，它建立了关键字与存储地址之间的一种直接映射关系 在散列技术中，由于记录的定位主要基于散列函数的计算,不需要进行关键码的多次比较，所以，一般情况下,散列技术的查找速度要比基于比较的查找技术的查找速度快。但是，散列技术-般不适用于多个记录有相同关键码的情况，也不适用于范围查找。散列技术最适合回答的问题是:如果有的话，哪个记录的关键码等于待查值。 冲突(碰撞)：散列函数可能会把多个不同的关键字映射到同一地址下的情况，同一地址下的多个关键字称为同义词","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构、算法笔记","slug":"数据结构、算法笔记","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"}]},{"title":"散列函数的设计和冲突处理","slug":"数据结构和算法/数据结构、算法笔记/散列函数的设计和冲突处理","date":"2019-12-02T16:00:00.000Z","updated":"2021-03-26T16:06:37.000Z","comments":true,"path":"2019/12/03/数据结构和算法/数据结构、算法笔记/散列函数的设计和冲突处理/","link":"","permalink":"http://example.com/2019/12/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%92%8C%E5%86%B2%E7%AA%81%E5%A4%84%E7%90%86/","excerpt":"","text":"散列函数的设计： 设计散列函数一般遵循以下基本原则:1）计算简单。散列函数不应该有很大的计算量，否则会降低查找效率;2）函数值(即散列地址)分布均匀中，希望散列函数能够把记录以相同的概率“散列”到散列表的所有地址空间中，这样才能保证存储空间的有效利用,并减少冲突。 冲突处理：","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构、算法笔记","slug":"数据结构、算法笔记","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"}]},{"title":"排序的基本概念","slug":"数据结构和算法/数据结构、算法笔记/排序的基本概念","date":"2019-12-01T16:00:00.000Z","updated":"2021-03-27T09:48:39.000Z","comments":true,"path":"2019/12/02/数据结构和算法/数据结构、算法笔记/排序的基本概念/","link":"","permalink":"http://example.com/2019/12/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%8E%92%E5%BA%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/","excerpt":"","text":"排序：重新排列表中的元素，使表中的元素满足按关键字递增或递减 算法的稳定性：若待排序表中有两个元素Ri和Rj，其对应的关键字Ki=Kj，且在排序前Ri在Rj前面，若使用某排序算法后，Ri仍然在Rj前面，则称这个排序算法是稳定的，否则称排序算法不稳定 算法的稳定性是算法的性质，并不能衡量一个算法的优劣 时空复杂度决定内部排序算法的性能 内部排序：指在排序期间元素全部存放在内存中的排序 外部排序：指在排序期间元素无法全部同时存放在内存中，必须在排序的过程中根据要求不断的在内、外存之间进行移动","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构、算法笔记","slug":"数据结构、算法笔记","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"}]},{"title":"直接插入排序","slug":"数据结构和算法/数据结构、算法笔记/直接插入排序","date":"2019-11-30T16:00:00.000Z","updated":"2021-03-27T10:37:42.000Z","comments":true,"path":"2019/12/01/数据结构和算法/数据结构、算法笔记/直接插入排序/","link":"","permalink":"http://example.com/2019/12/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/","excerpt":"","text":"插入排序：每次将一个待排序的序列插入到一个前面已排好序的子序列当中 直接插入排序(稳定的算法)：【空间复杂度为O(1)】【最好时间复杂度为O(n)，最坏、平均复杂度为O(n^2)】适用于顺序存储和链式存储","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构、算法笔记","slug":"数据结构、算法笔记","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"}]},{"title":"折半插入排序","slug":"数据结构和算法/数据结构、算法笔记/折半插入排序","date":"2019-11-29T16:00:00.000Z","updated":"2021-03-27T10:57:09.000Z","comments":true,"path":"2019/11/30/数据结构和算法/数据结构、算法笔记/折半插入排序/","link":"","permalink":"http://example.com/2019/11/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%8A%98%E5%8D%8A%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/","excerpt":"","text":"折半插入排序(稳定的算法)：【时间复杂度为O(n^2)】【空间复杂度为O(1)】只适用于顺序存储","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构、算法笔记","slug":"数据结构、算法笔记","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"}]},{"title":"希尔排序","slug":"数据结构和算法/数据结构、算法笔记/希尔排序","date":"2019-11-28T16:00:00.000Z","updated":"2021-03-27T11:27:23.000Z","comments":true,"path":"2019/11/29/数据结构和算法/数据结构、算法笔记/希尔排序/","link":"","permalink":"http://example.com/2019/11/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/","excerpt":"","text":"希尔排序(不稳定算法)：缩小增量排序【最坏时间复杂度为O(n^2)，空间复杂度为O(1)】只适用于顺序存储 基本思想：先将排序表分割成d个形如L[i,i+d,i+2d,…,i+kd]的特殊子表，分别进行直接插入排序，当整个表中的元素已呈“基本有序时”，再对全体记录进行一次直接插入排序【d1=n/2(取下界),d(i+1)=(di)/2(取下界)，直到最后一个dk=1】","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构、算法笔记","slug":"数据结构、算法笔记","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"}]},{"title":"冒泡排序","slug":"数据结构和算法/数据结构、算法笔记/冒泡排序","date":"2019-11-27T16:00:00.000Z","updated":"2021-03-28T02:23:53.000Z","comments":true,"path":"2019/11/28/数据结构和算法/数据结构、算法笔记/冒泡排序/","link":"","permalink":"http://example.com/2019/11/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/","excerpt":"","text":"冒泡排序(稳定的算法)：假设待排序表长为n，从前往后(从后往前)两两比较相邻元素的值，若为逆序(即A[i-1]&gt;A[i])，则交换他们直到序列比较结束【一次冒泡会将一个元素放置到它最终的位置上】 适用于顺序存储和链式存储 最好时间复杂度为O(n)，最坏、平均时间复杂度为O(n^2)，空间复杂度为O(1)：","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构、算法笔记","slug":"数据结构、算法笔记","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"}]},{"title":"快速排序","slug":"数据结构和算法/数据结构、算法笔记/快速排序","date":"2019-11-26T16:00:00.000Z","updated":"2021-03-28T03:03:53.000Z","comments":true,"path":"2019/11/27/数据结构和算法/数据结构、算法笔记/快速排序/","link":"","permalink":"http://example.com/2019/11/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/","excerpt":"","text":"快速排序(不稳定的算法)：【时间复杂度为O(high-low+1)】【最好、平均空间复杂度为O(log2(n))、最坏空间复杂度O(n)】【最好、平均时间复杂度为O(nlog2(n))、最坏时间复杂度为O(n^2)】 初始基本有序或逆序的情况下时间、空间复杂度最坏 适用于顺序存储(链式存储) Partition基本思路：初始化标记low为划分部分第一个元素的位置，high为最后一个元素的位置，然后不断的移动两标记并交换元素：1）high向前移动找到第一个比pivot小的元素2）low向后移动找到第一个比pivot大的元素3）交换当前两个位置的元素4）继续移动标记，执行1、2、3过程，直到low大于等于high为止","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构、算法笔记","slug":"数据结构、算法笔记","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"}]},{"title":"直接选择排序","slug":"数据结构和算法/数据结构、算法笔记/直接选择排序","date":"2019-11-25T16:00:00.000Z","updated":"2021-03-28T03:24:37.000Z","comments":true,"path":"2019/11/26/数据结构和算法/数据结构、算法笔记/直接选择排序/","link":"","permalink":"http://example.com/2019/11/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E7%9B%B4%E6%8E%A5%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/","excerpt":"","text":"选择排序(不稳定的算法)：【时间复杂度为O(n^2)】【空间复杂度为O(1)】 时间复杂度与初始序列无关 适用于顺序存储和链式存储","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构、算法笔记","slug":"数据结构、算法笔记","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"}]},{"title":"堆排序","slug":"数据结构和算法/数据结构、算法笔记/堆排序","date":"2019-11-24T16:00:00.000Z","updated":"2021-03-28T08:51:28.000Z","comments":true,"path":"2019/11/25/数据结构和算法/数据结构、算法笔记/堆排序/","link":"","permalink":"http://example.com/2019/11/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%A0%86%E6%8E%92%E5%BA%8F/","excerpt":"","text":"堆：n个关键字序列L[1…n]称为堆，当且仅当该序列满足：(1&lt;=i&lt;=(n/2)(取下界))1）若L(i)&lt;=L(2i)且L(i)&lt;=L(2i+1)，则称该堆为小根堆2）若L(i)&gt;=L(2i)且L(i)&gt;=L(2i+1)，则称该堆为大根堆 在排序过程中将L[1…n]视为一棵完全二叉树的顺序存储结构 堆的初始化(以大根堆为例)： 堆排序(不稳定的算法)：不断的输出栈顶元素，并向下调整【时间复杂度为O(nlog2(n))】【空间复杂度为O(1)】 适用于顺序存储(链式存储) 堆的插入：将新结点放置在末端然后进行向上调整","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构、算法笔记","slug":"数据结构、算法笔记","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"}]},{"title":"归并排序","slug":"数据结构和算法/数据结构、算法笔记/归并排序","date":"2019-11-23T16:00:00.000Z","updated":"2021-03-28T09:26:25.000Z","comments":true,"path":"2019/11/24/数据结构和算法/数据结构、算法笔记/归并排序/","link":"","permalink":"http://example.com/2019/11/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/","excerpt":"","text":"2路归并排序： 合并两个有序线性表： 归并排序(稳定的算法)：【时间复杂度O(nlog2(n))】【空间复杂度为O(n)】 适用于顺序存储和链式存储","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构、算法笔记","slug":"数据结构、算法笔记","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"}]},{"title":"基数排序","slug":"数据结构和算法/数据结构、算法笔记/基数排序","date":"2019-11-22T16:00:00.000Z","updated":"2021-03-28T10:12:49.000Z","comments":true,"path":"2019/11/23/数据结构和算法/数据结构、算法笔记/基数排序/","link":"","permalink":"http://example.com/2019/11/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/","excerpt":"","text":"基数排序：不基于比较，借助“分配”和“收集”两种操作对单逻辑关键字进行排序，分为最高位优先(MSD)和最低位优先(LSD) 以r为基数的最低位优先基数排序的过程(稳定的算法)：【时间复杂度为O(d(n+r))】【空间复杂度为O(r)】","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构、算法笔记","slug":"数据结构、算法笔记","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"}]},{"title":"内部排序算法的比较及应用","slug":"数据结构和算法/数据结构、算法笔记/内部排序算法的比较及应用","date":"2019-11-21T16:00:00.000Z","updated":"2021-03-28T10:26:56.000Z","comments":true,"path":"2019/11/22/数据结构和算法/数据结构、算法笔记/内部排序算法的比较及应用/","link":"","permalink":"http://example.com/2019/11/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%86%85%E9%83%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E6%AF%94%E8%BE%83%E5%8F%8A%E5%BA%94%E7%94%A8/","excerpt":"","text":"冒泡排序、直接选择排序、快速排序、堆排序：一趟排序可以确定一个元素的位置 应用：","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构、算法笔记","slug":"数据结构、算法笔记","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"}]},{"title":"外部排序的方法","slug":"数据结构和算法/数据结构、算法笔记/外部排序的方法","date":"2019-11-20T16:00:00.000Z","updated":"2021-03-28T11:04:38.000Z","comments":true,"path":"2019/11/21/数据结构和算法/数据结构、算法笔记/外部排序的方法/","link":"","permalink":"http://example.com/2019/11/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%A4%96%E9%83%A8%E6%8E%92%E5%BA%8F%E7%9A%84%E6%96%B9%E6%B3%95/","excerpt":"","text":"外部排序通常采用归并排序的方法 首先根据缓冲区的大小将外存上含有n个记录的文件分成若干长度为h的子文件，依次读入内存并利用有限的内部排序算法对它们进行排序，并将排序后得到的有序子文件重新写回外存，通常称这些有序子文件为归并段或顺串 然后对这些归并段进行逐趟归并，使归并段逐渐由小到大直至得到整个有序文件 外部排序的总时间：内部排序所需时间+外存信息读写时间+内部归并所需时间如果变成4路归并：","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构、算法笔记","slug":"数据结构、算法笔记","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"}]},{"title":"败者树","slug":"数据结构和算法/数据结构、算法笔记/败者树","date":"2019-11-19T16:00:00.000Z","updated":"2021-03-28T11:26:31.000Z","comments":true,"path":"2019/11/20/数据结构和算法/数据结构、算法笔记/败者树/","link":"","permalink":"http://example.com/2019/11/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E8%B4%A5%E8%80%85%E6%A0%91/","excerpt":"","text":"失败树：树形选择排序的一种变体，可视为一棵完全二叉树 每个叶结点存放各归并段在归并过程中当前参加比较的记录，内部结点用来记忆左右子树中的‘失败者’，胜利者向上继续进行比较，直到根结点","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构、算法笔记","slug":"数据结构、算法笔记","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"}]},{"title":"置换-选择排序","slug":"数据结构和算法/数据结构、算法笔记/置换-选择排序","date":"2019-11-18T16:00:00.000Z","updated":"2021-03-28T16:29:03.000Z","comments":true,"path":"2019/11/19/数据结构和算法/数据结构、算法笔记/置换-选择排序/","link":"","permalink":"http://example.com/2019/11/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E7%BD%AE%E6%8D%A2-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/","excerpt":"","text":"置换-选择排序：","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构、算法笔记","slug":"数据结构、算法笔记","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"}]},{"title":"最佳归并树","slug":"数据结构和算法/数据结构、算法笔记/最佳归并树","date":"2019-11-17T16:00:00.000Z","updated":"2021-03-28T16:48:46.000Z","comments":true,"path":"2019/11/18/数据结构和算法/数据结构、算法笔记/最佳归并树/","link":"","permalink":"http://example.com/2019/11/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%9C%80%E4%BD%B3%E5%BD%92%E5%B9%B6%E6%A0%91/","excerpt":"","text":"m路归并排序可用一棵m叉树描述 归并树：用来描述m归并，并只有度为0和度为m的结点的严格m叉树 带权路径长度之和为归并过程中的总读记录数： 用哈夫曼树构造的叫最佳归并树：","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构、算法笔记","slug":"数据结构、算法笔记","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"}]},{"title":"Objective-C概述：","slug":"编程语言/Objective-C/Objective-C概述：","date":"2019-09-29T16:00:00.000Z","updated":"2021-03-02T02:22:44.000Z","comments":true,"path":"2019/09/30/编程语言/Objective-C/Objective-C概述：/","link":"","permalink":"http://example.com/2019/09/30/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Objective-C/Objective-C%E6%A6%82%E8%BF%B0%EF%BC%9A/","excerpt":"","text":"Objective-C简称Obj-C或者OC Objective-C：面向对象的C语言，所以，OC的本质还是C语言 OC是在C的基础之上增加了一小部分的面向对象的语法，将C语言复杂的、繁琐的语法封装的更为简单 完全兼容C语言，也就是说在OC语言中可以写任意的C语言的代码 OC简要发展历史： 20世纪80年代初期，Brad Cox结合C语言和Smalltalk的优势设计出了Objective-C语言 1985年，乔布斯创建NeXT公司，致力于设计经济实惠且功能强大的工作站，并选择Unix作为其工作站的操作系统 后来，NeXT公司设计出了NextStep(使用OC语言编写的一套功能强大的界面工具包) 1995年，NeXT公司获得OC的全部商业版权 1996年，苹果公司收购NeXT，NextStep得到了Mac开发人员的广泛认可，NextStep更名为Cocoa，从此OC成为开发Mac平台的主力语言 随着iPhone、iPad的火爆，OC又成为了iOS平台上的中流砥柱 OC的未来： 苹果在2014年的WWDC大会上正式推出Swift，在2015年的WWDC上宣布年底发布的Swift 2.0将开源 Swift语言的优点：快速、现代、安全、互动且全面优于Objective-C语言 按照苹果的行事风格，Swift一定会取代OC成为iOS开发的主力语言，但是目前来看，要实现这一目标，还有一段路需要走【很多的企业在此之前他们已经使用Objective-C语言开发好了自己的程序，使用Swift重写是不可能的、Swift刚刚发布，还有很多Bug没有完善，企业不愿意当小白鼠、Swift本身还没有成型，在后期发布的版本中有大量的变化甚至包括语法的变化】 OC的光芒注定要被Swift的闪耀遮盖","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://example.com/tags/Objective-C/"}]},{"title":"Objective-C基础语法：","slug":"编程语言/Objective-C/Objective-C基础语法：","date":"2019-09-28T16:00:00.000Z","updated":"2021-03-02T02:22:32.000Z","comments":true,"path":"2019/09/29/编程语言/Objective-C/Objective-C基础语法：/","link":"","permalink":"http://example.com/2019/09/29/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Objective-C/Objective-C%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%EF%BC%9A/","excerpt":"","text":"OC程序源文件的后缀名是.m【m是message，代表OC中最重要的消息机制】C程序源文件的后缀名为.c #import指令： 1）以#开头，是一个预处理指令2）是#include指令的增强版，将文件的内容在预编译的时候拷贝到写指令的地方，同一个文件无论被#import多少次，只会包含一次；如果#include指令要实现这个效果，就必须要配合条件编译指令来实现3）简要原理：#import指令在包含文件的时候，底层会先判断这个文件是否被包含，如果被包含就会略过，否则才会包含 框架： 是一个功能集，苹果或者第三方事先将一些程序在开发程序的时候经常要用到的功能事先写好，把这些功能封装在一个一个的类或者函数中，这些函数和类的集合就叫做框架【有点像C语言的函数库】 Foundation:这个框架提供了一些最基础的功能【输入输出，数据类型】Foundation.h这个文件包含了Foundation框架中的其他的所有的头文件，所以，我们只要包含Foundation.h就相当于包含了Foundation框架中所有的头文件，那么Foundation框架中的所有的函数和类就可以直接使用 @autoreleasepool是自动释放池 NSLog函数： 是printf函数的增强版，向控制台输出信息 NSLog(@“格式控制字符串”，变量列表); 增强点：1）输出一些调试相关信息【执行这段代码的时间，程序的名称，进程编号，线程编号，输出的信息】2）在输出完信息之后会自动换行3）OC中其实新增了一些数据类型，NSLog函数不仅仅可以输出C数据类型变量的值还可以输出OC新增的数据类型的变量的值 如果在字符串的末尾加了一个‘\\n’代表换行，那么函数的自动换行功能就会失效 字符串的存储方式： C语言的字符串的存储方式：1）使用字符数组存储2）使用字符指针 OC中设计了一个更为好用的用来存储字符串的一个类型：NSStringNSString类型的指针变量专门用来存储OC字符串的地址 OC的字符串常量必须要使用一个前缀@符号，NSString类型的指针变量只能存储OC字符串的地址NSString *str=@“jack”; NSLog函数的第一个参数是一个OC字符串，所以NSLog函数的第一个实参应该以@符号开头 NS前缀：NextStep—&gt;Cocoa—&gt;Foundation框架之中 @符号：1）将C字符串转换为OC字符串2）OC中的绝大部分的关键字都是以@符号开头","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://example.com/tags/Objective-C/"}]},{"title":"终端写第一个OC程序：","slug":"编程语言/Objective-C/终端写第一个OC程序：","date":"2019-09-27T16:00:00.000Z","updated":"2021-03-02T02:22:20.000Z","comments":true,"path":"2019/09/28/编程语言/Objective-C/终端写第一个OC程序：/","link":"","permalink":"http://example.com/2019/09/28/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Objective-C/%E7%BB%88%E7%AB%AF%E5%86%99%E7%AC%AC%E4%B8%80%E4%B8%AAOC%E7%A8%8B%E5%BA%8F%EF%BC%9A/","excerpt":"","text":"OC程序的编译，链接，执行： 在.m文件中写上符合OC语法规范的源代码：clear清屏cd /Users/ljlmacbookair/Desktop/OC2touch main.m 使用编译器将源代码编译为目标文件【预处理，检查语法，编译】cc -c main.m 链接如果程序中使用到了框架中的函数或者类，那么在链接的时候，就必须要告诉编译器去哪一个框架中找这个函数或者类cc main.o -framework Foundation 链接成功以后就会生成一个a.out可执行文件，执行就可以了./a.out OC程序和C程序各个阶段的后缀名：源文件 目标文件 可执行文件 C .c .o .outOC .m .o .out","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://example.com/tags/Objective-C/"}]},{"title":"OC与C的对比：","slug":"编程语言/Objective-C/OC与C的对比：","date":"2019-09-26T16:00:00.000Z","updated":"2021-03-02T02:22:08.000Z","comments":true,"path":"2019/09/27/编程语言/Objective-C/OC与C的对比：/","link":"","permalink":"http://example.com/2019/09/27/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Objective-C/OC%E4%B8%8EC%E7%9A%84%E5%AF%B9%E6%AF%94%EF%BC%9A/","excerpt":"","text":"数据类型： OC中支持C语言的所有的数据类型 BOOL类型：可以存储YES或者NO中的任意一个数据；一般情况下BOOL类型的变量用来存储条件表达式的结果 typedef signed char BOOL;BOOL类型变量的本质实际上是一个有符号的char变量 Boolean类型的变量可以存储true或者false typedef unsigned char BOOL;Boolean类型变量的本质实际上是一个无符号的char变量 class 类型：类 id类型：万能指针 nil与NULL差不多 SEL：方法选择器 block：代码段 运算符：OC支持C语言中所有的运算符： 赋值运算符：= 算术运算符：+、-、*、/、% 复合赋值运算符：+=、-=、*=、/=、%= 自增与自减：++、—- 关系运算符：&gt;、&gt;=、&lt;、&lt;=、==、!= 逻辑运算符：&amp;&amp;、||、! 取地址运算符：&amp; 指针访问运算符：* 位运算符：&amp;、|、^、~ 控制语句：OC支持C所有的控制语句： if结构 switch-case结构 while循环 do-while循环 for循环 数组 函数 指针 关键字： OC支持C语言中全部的关键字，并且效果一致 OC也新增了一些关键字，OC新增的关键字绝大多数都是以@开头 @interface @implmentation @public 函数的定义和调用：函数的定义和调用与C语言的完全一致","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://example.com/tags/Objective-C/"}]},{"title":"面向过程和面向对象：","slug":"编程语言/Objective-C/面向过程和面向对象：","date":"2019-09-25T16:00:00.000Z","updated":"2021-03-02T02:21:56.000Z","comments":true,"path":"2019/09/26/编程语言/Objective-C/面向过程和面向对象：/","link":"","permalink":"http://example.com/2019/09/26/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Objective-C/%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E5%92%8C%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%9A/","excerpt":"","text":"优缺点分析： 面向过程的解决问题的缺点：后期的维护和修改不方便 面向对象的解决问题的优点：1）后期的维护和修改十分方便2）使用面向对象设计我们的程序，可以让我们的程序在后期的维护和修改当中更加的方便和快捷","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://example.com/tags/Objective-C/"}]},{"title":"类和对象：","slug":"编程语言/Objective-C/类和对象：","date":"2019-09-24T16:00:00.000Z","updated":"2021-03-02T02:21:44.000Z","comments":true,"path":"2019/09/25/编程语言/Objective-C/类和对象：/","link":"","permalink":"http://example.com/2019/09/25/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Objective-C/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%EF%BC%9A/","excerpt":"","text":"对象：现实生活中的一个具体存在，看得见摸得着，拿过来就可以直接使用 类：对一群具有相同特征或者行为的事物的一个统称，抽象的，不能直接使用 类是模版，类的对象是根据这个模版创建出来的，类模版中有什么，对象中就有什么，绝不可能多，也绝不可能少 设计类的三要素：1）类的名字2）这类事物具有的相同的特征3）这类事物具有的共同的行为 注意：1）类必须要有声明和实现2）类名的首字母必须要以大写开头3）属性的名字必须要以_开头（下划线） 定义类的语法： 位置：直接写在源文件中，不要写在main函数之中 类的定义分为两部分：1）类的声明 @inteface 类名：NSObject{ 这类事物具有的共同的特征，将他们定义为变量 } //一类事物不仅具有相同的特征还具有相同的行为，行为就是一个功能，C语言中使用函数来表示一个功能，OC的类具有的行为，我们使用方法来表示 //将方法的声明写在这里 (返回值类型)方法名称； @end 2）类的实现 @implementation 类名 //将方法的实现写在这里 @end 创建类的对象： 类名 *对象名=[类名 new]; 使用对象： 访问对象的属性：默认情况下，对象的属性是不允许被外界直接访问的，如果允许对象的属性可以被外界访问，那么就在声明属性的时候加一个@public关键字 访问对象属性的方式： 对象名-&gt;属性名=值；(*对象名).属性名； 无参方法的声明和实现： 有一个参数方法的声明和实现： 带多个参数方法的声明和实现： 在方法的实现中，可以直接访问属性，这个方法是通过哪一个对象来调用的，那么方法中的直接访问的属性就是哪一个对象的：","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://example.com/tags/Objective-C/"}]},{"title":"对象在内存中是如何存储的：","slug":"编程语言/Objective-C/对象在内存中是如何存储的：","date":"2019-09-23T16:00:00.000Z","updated":"2021-03-02T02:21:32.000Z","comments":true,"path":"2019/09/24/编程语言/Objective-C/对象在内存中是如何存储的：/","link":"","permalink":"http://example.com/2019/09/24/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Objective-C/%E5%AF%B9%E8%B1%A1%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E6%98%AF%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8%E7%9A%84%EF%BC%9A/","excerpt":"","text":"内存中的五大区域： 栈：存储局部变量 堆：程序员手动申请的字节空间 BSS段：存储未被初始化的全局变量、静态变量 数据段（常量区）：存储已被初始化的全局变量、静态变量、常量数据 代码段：存储代码，存储程序的代码 类加载：在程序运行期间，当某个类第一次被访问到的时候，会将这个类存储到内存中的代码段区域，这个过程叫做类加载；只有类在第一次被访问的时候才会做类加载，一旦类被加载到代码段以后，直到程序结束的时候才会被释放。1）在创建对象的时候，肯定是需要访问类的2）声明一个类的指针变量也会访问类的 对象在内存中究竟是如何存储的：假设这个写在函数之中：Person *p1=[Person new]; Person *p1：会在栈内存中申请一块空间，在栈内存中声明一个Person类型的指针变量p1。p1是一个指针变量，只能存储地址 [Person new]：真正在内存中创建对象的其实是这句代码 New做的事情： 在堆内存中申请一块合适大小的空间 在这个空间中根据类的模版创建对象，类模版中定义了什么属性，就把这些属性依次的声明在对象之中，对象中还有另外一个属性，叫做isa，是一个指针，指向对象所属的类在代码段中的地址 初始化对象的属性：如果属性的类型是基本数据类型，那么就赋值为0；如果是C语言的指针类型就赋值为NULL；如果是OC的类指针类型，就赋值为nil NULL(nil)只能作为指针变量的值，如果一个指针变量的值是NULL(nil)代表这个指针不指向内存中的任何一块空间，NULL(nil)其实是一个宏，就是0 建议：C指针用NULL，int *p1=NULL; OC的类指针用nil，Person *p1=nil; 如果一个类指针的值为nil，代表这个指针不指向任何对象：Person *p1=nil;这个时候，如果通过p1指针去访问p1指针指向的对象的属性，会运行报错；如果通过p1指针去调用对象的方法，运行不会报错但是方法不会执行，没有反应 返回对象的地址： 注意： 对象中只有属性，而没有方法，自己类的属性+一个isa指针指向代码段中的类 如何访问对象的属性：指针名-&gt;属性名；根据指针，找到指针所指的对象，再找到对象中的属性来访问 如何调用方法：[指针名 方法名];先根据指针名找到对象，对象发现要调用方法，再根据对象的isa指针找到类，然后调用类里的方法 为什么不把方法存储在对象中：因为每一个对象的方法的代码实现都是一模一样的，没有必要为每一个对象都保存一个方法，这样的话就太浪费空间了 同类型的指针变量之间是可以相互赋值的：Person *p1=[Person new];Person *p2=p1; 这是完全没有问题的，p1和p2的类型都是Person指针类型的，代表将p1的值赋值给p2，而p1的值是对象的地址，所以就把对象的地址赋值给了p2，所以p1和p2指向了同一个对象 目前为止，只要看见new，就说明新创建了一个对象：","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://example.com/tags/Objective-C/"}]},{"title":"分组导航标记、方法与函数的不同：","slug":"编程语言/Objective-C/分组导航标记、方法与函数的不同：","date":"2019-09-22T16:00:00.000Z","updated":"2021-03-02T02:21:19.000Z","comments":true,"path":"2019/09/23/编程语言/Objective-C/分组导航标记、方法与函数的不同：/","link":"","permalink":"http://example.com/2019/09/23/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Objective-C/%E5%88%86%E7%BB%84%E5%AF%BC%E8%88%AA%E6%A0%87%E8%AE%B0%E3%80%81%E6%96%B9%E6%B3%95%E4%B8%8E%E5%87%BD%E6%95%B0%E7%9A%84%E4%B8%8D%E5%90%8C%EF%BC%9A/","excerpt":"","text":"分组导航标记：1）#pragma mark 分组名：就会在导航条对应的位置显示一个标题2）#pragma mark -：就会在导航条对应的位置显示一条水平分割线3）#pragma mark - 分组名：就会在导航条对应的位置先产生一条水平分割线，再显示标题 方法与函数的不同： OC方法的声明只能写在@interface的大括弧的外面，实现只能写在@implementation之中函数除了在函数的内部和@interface的大括弧之中，其他地方都可以写 就算把函数写在类中，这个函数仍然不属于类，所以创建的对象中也没有这个函数注意：函数不要写在类中，虽然这样是可以的，但是千万不要这么做，因为这么做是极度不规范的 调用的方式不同：函数可以直接调用，但是方法必须要先创建对象，通过对象来调用 方法是属于类的，而函数是一个独立的 注意点： @interface是类的声明，@implementation是类的实现，它们之间不能相互嵌套 类必须先声明然后再实现 类的声明和实现必须都要有，特殊情况下可以只有实现没有声明，虽然可以这样，但是千万不要这么写，极不规范 类的声明必须要放在使用类的前面，实现可以放在使用类的后面 属性名一定要以下划线开头，这是规范；类名的每一个单词的首字母大写 属性不允许声明的时候初始化 OC方法必须要创建对象通过对象名来调用 如果方法只有声明，没有实现，编译器会给一个警告，不会报错 如果指针指向的对象有方法的声明而没有方法的实现，那么这个时候通过指针来调用这个方法在运行的时候就会报错 unrecognized selector sent to instance 0x100420510只要看到这个错误，说明要么对象中根本就没有这个方法，要么只有方法的声明而没有方法的实现","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://example.com/tags/Objective-C/"}]},{"title":"多文件开发、对象和方法：","slug":"编程语言/Objective-C/多文件开发、对象和方法：","date":"2019-09-21T16:00:00.000Z","updated":"2021-03-02T02:21:07.000Z","comments":true,"path":"2019/09/22/编程语言/Objective-C/多文件开发、对象和方法：/","link":"","permalink":"http://example.com/2019/09/22/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Objective-C/%E5%A4%9A%E6%96%87%E4%BB%B6%E5%BC%80%E5%8F%91%E3%80%81%E5%AF%B9%E8%B1%A1%E5%92%8C%E6%96%B9%E6%B3%95%EF%BC%9A/","excerpt":"","text":"多文件开发：所有的类都写在main.m这个源文件之中，导致后期的维护非常不方便，也不利于团队开发 推荐的方式：把一个类写在一个模块之中，而一个模块至少包含两个文件：.h头文件写类(方法)的声明，因为要用到Foundation框架中的NSObject类，所以要在这个头文件中引入Foundation框架的头文件.m实现文件写类(方法)的实现，先引入模块的头文件，这样才会有类的声明 如果要用到类，只需要引入这个模块的头文件就可以了 添加类模块的更简洁的方式：NewFile—Cocoa Class自动生成模块文件.h .m，自动的将类的声明和实现写好【填写的名称是决定模块文件的名称，类名是可以自己再改的，但是建议模块的文件名和模块中的类名保持一致，这样方便代码的管理】 对象和方法：对象作为方法的参数，对象作为方法的返回值类的本质是我们自定义的一个数据类型，因为对象在内存中的大小是由我们自己决定的，多写几个属性对象就大一些，少写几个属性对象占用的空间就小一些 数据类型：是在内存中开辟空间的一个模版 既然类是一个数据类型，那么类就可以作为方法的参数：- (void)test:(Dog *)dog; 注意： 当对象作为方法的参数的时候，参数类型是类指针- (void)test:(Dog *)dog; 调用方法的时候，如果方法的参数是一个对象，那么给实参的时候，实参要求也必须是一个符合要求的对象，否则就会出问题 当对象作为方法的参数传递的时候，是地址传递，所以在方法内部通过形参去修改形参指向的对象的时候，会影响实参变量指向的对象的值 对象也可以作为方法的返回值：当方法执行完毕后，如果有一个对象方法的内部不知道如何处理，并且这个对象是调用者翘首以盼的，那么这个时候我们就应该将这个对象返回 上帝杀人案例：","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://example.com/tags/Objective-C/"}]},{"title":"对象作为类的属性：","slug":"编程语言/Objective-C/对象作为类的属性：","date":"2019-09-20T16:00:00.000Z","updated":"2021-03-02T02:20:54.000Z","comments":true,"path":"2019/09/21/编程语言/Objective-C/对象作为类的属性：/","link":"","permalink":"http://example.com/2019/09/21/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Objective-C/%E5%AF%B9%E8%B1%A1%E4%BD%9C%E4%B8%BA%E7%B1%BB%E7%9A%84%E5%B1%9E%E6%80%A7%EF%BC%9A/","excerpt":"","text":"一个Target中的类无法直接在另外一个Target中访问 如果要访问其他Target中的类，找到其他Target中的类，右键Show in Finder，选中这个模块直接拖拽到当前类中（上面两个按钮要勾上） 类的属性代表这类事物具有的共同的特征，代表这个类所拥有的东西类的方法代表这个类所具备的行为，这个类所具备的功能 对象作为类的属性【人拥有一条狗，狗拥有圈圈】 属性的本质是变量，在创建对象的时候，对象中的属性是按照类模版中的规定挨个挨个的创建出来的，类模版中属性是什么类型，那么对象中的属性就是什么类型 如果对象的属性是另外一个类的对象，这个属性仅仅是一个指针变量而已，并没有对象产生，这个时候还要为这个属性赋值一个对象的地址才可以正常使用","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://example.com/tags/Objective-C/"}]},{"title":"猜拳游戏：","slug":"编程语言/Objective-C/猜拳游戏：","date":"2019-09-19T16:00:00.000Z","updated":"2021-03-02T02:20:42.000Z","comments":true,"path":"2019/09/20/编程语言/Objective-C/猜拳游戏：/","link":"","permalink":"http://example.com/2019/09/20/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Objective-C/%E7%8C%9C%E6%8B%B3%E6%B8%B8%E6%88%8F%EF%BC%9A/","excerpt":"","text":"枚举或者结构体定义在什么地方：如果只是一个类要用，那么就定义在这个类的头文件中；如果多个类要用，那么就定义在一个单独的头文件中 123456789101112131415161718192021//Player.h#import &lt;Foundation/Foundation.h&gt;#import &quot;FistType.h&quot;@interface Player : NSObject&#123; @public NSString *_name; int _score; FistType _selectedType;&#125;- (void)showFist;//根据传入的整型的数返回对应字符串拳头- (NSString *)fistTypeWithNumber:(int)number;@end 1234567891011121314151617181920212223242526272829303132333435363738394041//Player.m#import &quot;Player.h&quot;@implementation Player- (void)showFist&#123; //提示用户选择拳头 NSLog(@&quot;亲爱的玩家[%@]，请选择你要出的拳头 1.剪刀 2.石头 3.布&quot;,_name); //接收用户输入的拳头 int userSelect=0; scanf(&quot;%d&quot;,&amp;userSelect); //显示用户选择的拳头 //要取出整型的数代表的字符串的拳头的类型 NSString *type=[self fistTypeWithNumber:userSelect]; //如果要在方法中调用当前对象的另外一个方法：[self 方法名];self代表当前对象 NSLog(@&quot;玩家[%@]出的拳头是:%@&quot;,_name,type); //将用户选择的拳头存储在当前对象的属性中 _selectedType=userSelect;&#125;- (NSString *)fistTypeWithNumber:(int)number&#123; switch (number) &#123; case 1: return @&quot;剪刀&quot;; case 2: return @&quot;石头&quot;; case 3: return @&quot;布&quot;; default: return @&quot;你输入的不对哟，请重新输入&quot;; &#125;&#125;@end 123456789101112131415161718//Robot.h#import &lt;Foundation/Foundation.h&gt;#import &quot;FistType.h&quot;@interface Robot : NSObject&#123; @public NSString *_name; FistType _selectedType; int _score;&#125;- (void)showFist;@end 123456789101112131415161718192021222324252627282930313233343536//Robot.m#import &quot;Robot.h&quot;#import &quot;stdlib.h&quot;@implementation Robot- (void)showFist&#123; //随机出拳 int robotSelect=arc4random_uniform(3)+1; //显示随机出的拳头 NSString *type=[self fistTypeWithNumber:robotSelect]; NSLog(@&quot;机器人[%@]出的拳头是：%@&quot;,_name,type); //将出的拳头保存在当前对象的属性中 _selectedType=robotSelect;&#125;- (NSString *)fistTypeWithNumber:(int)number&#123; switch (number) &#123; case 1: return @&quot;剪刀&quot;; case 2: return @&quot;石头&quot;; case 3: return @&quot;布&quot;; default: return @&quot;你输入的不对哟，请重新输入&quot;; &#125;&#125;@end 1234567891011121314151617//Judge.h#import &lt;Foundation/Foundation.h&gt;#import &quot;Robot.h&quot;#import &quot;Player.h&quot;@interface Judge : NSObject&#123; @public NSString *_name;&#125;- (void)caiJueWithPlayer:(Player *)player andRobot:(Robot *)robot;@end 123456789101112131415161718192021222324252627282930313233343536373839404142//Judge.m#import &quot;Judge.h&quot;@implementation Judge- (void)caiJueWithPlayer:(Player *)player andRobot:(Robot *)robot&#123; //先拿到玩家和机器人出的拳头 FistType playerType=player-&gt;_selectedType; FistType robotType=robot-&gt;_selectedType; //判断输赢，为胜利的对象加分，显示结果 /* 剪刀1 石头2 布3 1 3 -2 2 1 1 3 2 1 */ NSLog(@&quot;我是裁判[%@],现在我来宣布比赛结果&quot;,_name); if(playerType-robotType==-2 || playerType-robotType==1)&#123; //玩家胜利，提示 NSLog(@&quot;恭喜玩家[%@]取得了胜利&quot;,player-&gt;_name); //为玩家加分 player-&gt;_score++; &#125; else if(playerType==robotType)&#123; //平局 NSLog(@&quot;[%@]、[%@]你们真是心有灵犀一点通啊！&quot;,player-&gt;_name,robot-&gt;_name); &#125; else&#123; //机器人胜利 NSLog(@&quot;恭喜机器人[%@]取得了胜利&quot;,robot-&gt;_name); robot-&gt;_score++; &#125; //显示得分 NSLog(@&quot;---玩家：[%@]:[%d]----------机器人：[%@]:[%d]&quot;,player-&gt;_name,player-&gt;_score,robot-&gt;_name,robot-&gt;_score);&#125; @end 12345678910111213141516//FistType.htypedef enum&#123; //剪刀枚举 FistTypeJianDao=1, //石头枚举 FistTypeShiTou=2, //布枚举 FistTypeBu=3, &#125;FistType; 123456789101112131415161718192021222324252627282930313233//main.m#import &lt;Foundation/Foundation.h&gt;#import &quot;Judge.h&quot;int main(int argc, const char * argv[]) &#123; Player *xiaoMing=[Player new]; xiaoMing-&gt;_name=@&quot;小明&quot;; Robot *aGou=[Robot new]; aGou-&gt;_name=@&quot;阿尔法狗&quot;; Judge *heiShao=[Judge new]; heiShao-&gt;_name=@&quot;黑哨&quot;; while(1)&#123; [xiaoMing showFist]; [aGou showFist]; [heiShao caiJueWithPlayer:xiaoMing andRobot:aGou]; NSLog(@&quot;还要再玩一把嘛(y/n)&quot;); char ans=&#x27;a&#x27;; rewind(stdin); scanf(&quot;%c&quot;,&amp;ans); if(ans != &#x27;y&#x27;)&#123; NSLog(@&quot;欢迎下次再来玩哦！&quot;); break; &#125; &#125;&#125; 执行结果：","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://example.com/tags/Objective-C/"}]},{"title":"异常处理：","slug":"编程语言/Objective-C/异常处理：","date":"2019-09-18T16:00:00.000Z","updated":"2021-03-02T02:20:29.000Z","comments":true,"path":"2019/09/19/编程语言/Objective-C/异常处理：/","link":"","permalink":"http://example.com/2019/09/19/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Objective-C/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%EF%BC%9A/","excerpt":"","text":"一般情况下，错误指的是我们写的源代码不符合语法规范，然后编译报错，导致程序无法编译 Bug指的是程序可以编译、链接、执行，但程序执行的结果并不是我们所预想的那样，可以通过调试寻找发生Bug的原因 异常指的是程序可以编译、链接、执行，当程序在执行的时候，处于某种特定条件下程序的执行就会终止，后果是程序会立即崩溃，立即终止运行并且后面的代码不会执行了 异常处理的目的：为了让程序在执行的时候如果发生了异常而不崩溃，继续往下执行 语法： @try{ &#125; @catch(NSException *ex)&#123; &#125; 将有可能发生异常的代码放在@try中，当@try中的代码在执行的时候如果发生了异常，不会崩溃，而是会立即跳转到@catch中去执行里面的代码，当@catch的代码执行完毕后，结束@try…@catch往下执行，如果@try中的代码在执行的时候没有发生异常，就会略过@catch往下执行 当@try中的代码在执行的时候发生了异常，@try块发生异常的后面的代码不会执行，而是立即转到@catch 注意： @catch中的代码只有在@try的代码发生异常的时候才会执行，所以，@catch中我们一般情况下写处理异常的代码（发生这个异常之后，要做什么事情） @catch的参数NSException *ex，通过%@打印出ex指向的对象的值，可以拿到发生异常的原因 @try…@catch后面还可以跟一个@finally{}，@finally中的代码，无论@try中是否发生了异常都会被执行 @try…@catch并不是万能的，不是所有的运行时错误都可以处理的【C语言的异常是无法处理的】，在实际的开发过程中，使用@try用的相对比较少的，避免异常我们最常用的方式还是逻辑判断","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://example.com/tags/Objective-C/"}]},{"title":"类方法：","slug":"编程语言/Objective-C/类方法：","date":"2019-09-17T16:00:00.000Z","updated":"2021-03-02T02:20:19.000Z","comments":true,"path":"2019/09/18/编程语言/Objective-C/类方法：/","link":"","permalink":"http://example.com/2019/09/18/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Objective-C/%E7%B1%BB%E6%96%B9%E6%B3%95%EF%BC%9A/","excerpt":"","text":"OC中的方法分为两种： 对象方法/实例方法：如果想要调用对象方法就必须要先创建对象，通过对象名来调用 类方法：类方法的调用不依赖于对象，如果要调用类方法，不需要去创建对象，而是直接通过类名来调用 类方法的声明：【只有“+”“-”号的区别】+ (返回值类型)方法名; 调用：[类名 类方法名];（不需要创建对象） 类方法和对象方法的调用过程： 类方法的特点：1）节约空间：因为调用类方法不需要创建对象2）提高效率：因为调用类方法不需要拐弯，直接找到类，直接执行类中的类方法 在类方法中不能直接访问属性（类方法在执行的时候有可能还没有对象，虽然不能直接访问属性，但是我们可以在类方法中创建一个对象，访问这个对象的属性）1）属性是在对象创建的时候，跟随着对象一起创建在对象之中2）类第一次被访问的时候会做类加载，是把类的代码存储在代码段 在类方法中也不能通过self直接调用当前类的其他的对象方法，因为对象方法只能通过对象来调用，而这个时候没有对象 在对象方法中可以直接调用类方法 如果方法不需要直接访问属性也不需要直接调用其他的对象方法，那么我们就可以将这个方法定义为类方法，这样就节约空间提高效率 关于类方法的规范：1）如果我们写一个类，那么就要求为这个类提供一个和类名同名的类方法，这个方法创建一个最纯洁的对象返回2）如果你希望创建的对象的属性的值由调用者指定，那么就为这个类方法带参数","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://example.com/tags/Objective-C/"}]},{"title":"NSString：","slug":"编程语言/Objective-C/NSString：","date":"2019-09-16T16:00:00.000Z","updated":"2021-03-02T02:20:07.000Z","comments":true,"path":"2019/09/17/编程语言/Objective-C/NSString：/","link":"","permalink":"http://example.com/2019/09/17/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Objective-C/NSString%EF%BC%9A/","excerpt":"","text":"1）NSString是一个数据类型，用来保存OC字符串2）NSString是Foundation框架中的一个类，作用是存储OC字符串的，所以OC中的字符串本质上是用NSString对象来存储的 其实完整的标准的创建NSString对象的方式：NSString *str0=[NSString new];NSString *str1=[NSString string];这种方式创建的字符串是空字符串 @“” 但是，NSString是我们最常用的一个对象，所以OC使用了一种更为简单的方式来创建字符串对象：直接使用@来表示一个OC字符串@“jack”;(这个其实本质上是一个NSString对象) NSString *str=@“jack”;【str的值是这个对象的地址，%p打印的是指针变量的值；%@打印的是指针变量指向的对象】NSString *str1=[NSString stringWithFormat:@“jack”]; NSString最常用的类方法： + (instancetype)stringWithUTF8String:(const char *)nullTerminatedCString;Instancetype作为返回值，代表返回的是当前这个类的对象作用：将C语言的字符串转换为OC字符串对象 + (instancetype)stringWithFormat:(NSString *)format,….作用：拼接一个字符串对象，使用变量或者其他数据拼接成OC字符串 NSString最常用的对象方法： length方法，返回值为NSUInteger，其实就是unsigned long得到字符串的字符的个数，可以处理中文 得到字符串中指定下标的字符* (unichar)characterAtIndex:(NSUInteger)index;返回值是unichar，其实就是unsinged short，占据两个字节 如果要输出unichar变量的值使用%C(中文输出) 判断两个字符串的内容是否相同，不要用==去判断，因为这样有可能会出问题： 判断相等的方式：* (BOOL)isEqualToString:(NSString *)aString; 比较字符串的大小 * (NSComparisonResult)compare:(NSString *)string;完全可以使用int来接收结果，因为返回值是一个枚举返回值如果是-1（小于），0（等于），1（大于）","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://example.com/tags/Objective-C/"}]},{"title":"匿名对象：","slug":"编程语言/Objective-C/匿名对象：","date":"2019-09-15T16:00:00.000Z","updated":"2021-03-02T02:19:55.000Z","comments":true,"path":"2019/09/16/编程语言/Objective-C/匿名对象：/","link":"","permalink":"http://example.com/2019/09/16/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Objective-C/%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1%EF%BC%9A/","excerpt":"","text":"如果我们创建一个对象，没有用一个指针存储这个对象的地址，也就是没有任何指针指向这个对象，那么这个对象就叫做匿名对象 因为new实际上是一个类方法，这个方法做的事情就是创建对象，返回值是创建的对象的地址，[Person new]这句代码的结果实际上就是创建的那个对象的指针，那我们可以直接使用 注意点：1）匿名对象只能使用一次2）每次创建匿名对象都是不同的对象 什么时候使用匿名对象：1）如果某个对象的成员只会被我们使用一次，用完之后这个对象再也不需要了，那么就可以使用匿名对象2）如果方法的参数是一个对象，而调用者为这个参数赋值的对象就是专门来给这个方法传递的并且这个对象调用者不会再使用，那么这个时候就可以直接为方法传递一个匿名对象（上帝杀人）","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://example.com/tags/Objective-C/"}]},{"title":"面向对象的三大特征：","slug":"编程语言/Objective-C/面向对象的三大特征：","date":"2019-09-14T16:00:00.000Z","updated":"2021-03-02T02:19:44.000Z","comments":true,"path":"2019/09/15/编程语言/Objective-C/面向对象的三大特征：/","link":"","permalink":"http://example.com/2019/09/15/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Objective-C/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81%EF%BC%9A/","excerpt":"","text":"封装：类就是更高级别的封装，类将数据和行为封装为了一个整体 优点： 屏蔽内部的实现，外界不需要知道内部是如何实现的，只需要知道这个对象有什么用 方便操作 后期的维护十分的便利 属性的封装： 存在的问题：为对象的属性赋值的时候，语法上其实只要数据的类型是属性的类型就是可以的，但是情理上这么做是不合的（人的年龄） 解决问题：1）将属性的@public去掉2）为类提供一个方法，这个方法专门为这个属性赋值，这个方法我们叫做setter setter方法：1）这个方法是一个对象方法，因为这个方法要为属性赋值；2）这个方法没有返回值；3）这个方法的名称必须以set开头，跟上去掉下划线首字母大写的属性名；4）这个方法一定是有参数的，参数的类型和属性的类型一致，参数的名称和属性的名称一致（去掉下划线）5）在方法的实现中，判断传入的数据是否符合逻辑，如果符合逻辑则赋值，否则做默认处理6）外界想要为对象的属性赋值，那么就调用这个对象的setter方法，将要赋值的数据传入这个方法 以上又有一个问题：在外界无法取出属性的值了 getter方法：1）是一个对象方法，因为这个方法做的事情是拿到属性的值返回2）有返回值，返回值的类型和属性的类型一致3）这个方法的名称直接就是属性的名称（去掉下划线）4）这个方法没有参数 只要属性需要被外界访问，就要为这个属性封装setter和getter，哪怕在赋值或者取值的时候没有任何逻辑验证 只读封装：为属性封装的时候，只提供getter，不提供setter只写封装：为属性封装的时候，只提供setter，不提供getter","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://example.com/tags/Objective-C/"}]},{"title":"对象与对象之间的关系：","slug":"编程语言/Objective-C/对象与对象之间的关系：","date":"2019-09-13T16:00:00.000Z","updated":"2021-03-02T02:19:31.000Z","comments":true,"path":"2019/09/14/编程语言/Objective-C/对象与对象之间的关系：/","link":"","permalink":"http://example.com/2019/09/14/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Objective-C/%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%AF%B9%E8%B1%A1%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB%EF%BC%9A/","excerpt":"","text":"组合关系：一个类是由其他的几个类联合起来组合而成【计算机由主板、显卡等组成】 依赖关系：一个对象的方法的参数是另外一个对象【人依赖于手机】 耦合度：当修改一个对象的时候对另外一个对象的影响程度【低耦合，高耦合】 高内聚：一个对象仅仅做与自己相关的事情【单一职责原则】 关联关系：一个类作为另外一个类的属性，但是它们不是组合关系，而是一个拥有的关系【人拥有狗】 继承关系","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://example.com/tags/Objective-C/"}]},{"title":"static关键字：","slug":"编程语言/Objective-C/static关键字：","date":"2019-09-12T16:00:00.000Z","updated":"2021-03-02T02:19:19.000Z","comments":true,"path":"2019/09/13/编程语言/Objective-C/static关键字：/","link":"","permalink":"http://example.com/2019/09/13/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Objective-C/static%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%9A/","excerpt":"","text":"static不能修饰属性，也不能修饰方法，可以修饰方法中的局部变量 如果方法中的局部变量被static修饰，那么这个变量就会被变成静态变量，存储在常量区，当方法执行完毕之后，不会回收，下次再执行这个方法的时候，直接使用而不用再声明了 如果方法的返回值是当前类的对象，那么方法的返回值就写instancetype","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://example.com/tags/Objective-C/"}]},{"title":"self关键字：","slug":"编程语言/Objective-C/self关键字","date":"2019-09-11T16:00:00.000Z","updated":"2021-03-02T02:19:07.000Z","comments":true,"path":"2019/09/12/编程语言/Objective-C/self关键字/","link":"","permalink":"http://example.com/2019/09/12/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Objective-C/self%E5%85%B3%E9%94%AE%E5%AD%97/","excerpt":"","text":"在方法的内部可以定义一个和属性名相同的局部变量，这个时候，如果在方法中访问这个同名的变量，访问的是局部变量，如果需要访问属性就需要使用关键字self self可以在对象方法和类方法中使用，self是一个指针，在对象方法中self指向当前对象，在类方法中self指向当前类 self在对象方法中使用：作用：1）可以使用self显示的访问当前对象的属性：self-&gt;属性，代表访问的是当前对象的这个属性2）可以使用self来调用当前对象的其他的对象方法 必须使用self的场景：1）如果在方法中存在和属性同名的局部变量，你如果想要访问同名的局部变量，直接写就可以了，你如果想要访问当前对象的同名属性，必须使用self2）在对象方法中，如果要调用当前对象的其他的对象方法，必须使用self 属性要求以下划线开头，局部变量不要求以下划线开头，按照这个规范来，实际上是不会重名的 self在类方法中使用：self是一个指针，指向当前这个类在代码段中的地址【就相当于这个类】 作用：可以在类方法中使用self来显示的调用本类的其他的类方法 总结取到类在代码段中的地址的方式：1）调试查看对象的isa指针的值2）在类方法中查看self的值3）调用对象的对象方法class，就会返回这个对象所属的类在代码段中的地址4）调用类的类方法class，就会返回这个类在代码段中的地址 12345Person *p1=[Person new];NSLog(@&quot;%p&quot;,[p1 class]);NSLog(@&quot;%p&quot;,[Person class]); 对象方法可以声明多次，但是只会认为有一次，只能实现一次，否则会报错【对象方法之间是不能重名的；类方法之间也不能重名；但是对象方法和类方法是可以重名的，通过类名来调用，调用的就是类方法，通过对象名来调，调用的就是对象方法】 注意：1）在对象方法中，self代表当前对象，所以可以通过self访问当前对象的成员，在对象方法中，不能使用self调用本类的类方法2）在类方法中，self代表当前这个类，所以，可以通过self调用当前类的其他的类方法，在类方法中，不能通过self访问对象的成员，不能直接去访问属性和调用对象的方法","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://example.com/tags/Objective-C/"}]},{"title":"继承、NSObject：","slug":"编程语言/Objective-C/继承、NSObject：","date":"2019-09-10T16:00:00.000Z","updated":"2021-03-02T02:18:53.000Z","comments":true,"path":"2019/09/11/编程语言/Objective-C/继承、NSObject：/","link":"","permalink":"http://example.com/2019/09/11/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Objective-C/%E7%BB%A7%E6%89%BF%E3%80%81NSObject%EF%BC%9A/","excerpt":"","text":"继承的目的：儿子类想拥有父亲类中的所有的成员，但是不想自己去定义，而是想凭空拥有 继承的语法：@interface 子类名：父类名 @end 术语：@interface Student:Person1）Student类从Person类继承，Student类是Person类的子类，Person类是Student类的父类2）Student类从Person类派生，Student类是Person类的派生类，Person类是Student类的基类 在新创建类模版的时候指定父类，Xcode就会自动的帮助你完成一系列事情 继承是类在继承，而不是对象在继承，我们创建对象，对象与对象之间是毫无关系的，只是子类对象中拥有父类对象中的同样的成员 千万不要为了继承而去继承，不要为了仅仅是得到某个类的成员你就不顾伦理去乱继承（人继承狗类？） 子类从父类继承，就意味着子类拥有了父类的所有成员，包括属性和方法 如果有一个成员不是所有的子类都拥有的，那么这个成员就不应该定义在父类之中，因为一旦定义在父类之中，那么所有的子类全都有了，父类中只定义所有的子类都拥有的 继承的特点：1）单根性：一个类只能有一个父类，不能有多个父类2）传递性：A类从B类继承，B类从C类继承，那么A类就同时拥有B、C类的成员 NSObject类是OC中所有类的祖宗类，因为OC中的类全部都是直接的或者间接的从它继承 NSObject类：这是Foundation框架中的类，在这个类中有一个类方法new，这个方法是用来创建对象的，方法的返回值是创建的这个对象的指针；也就是说，如果要创建类的对象，就必须要调用这个new方法，如果我们想要让我们的类具备创建对象的能力，就必须要让我们的类直接或者间接的从NSObject类继承 在NSObject类之中，还定义了一个属性，这个属性叫做isa指针，所以每一个子类对象中都有一个叫做isa指针 子类中不能存在和父类同名的属性","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://example.com/tags/Objective-C/"}]},{"title":"super关键字（特指这个方法是从父类继承过来的）：","slug":"编程语言/Objective-C/super关键字（特指这个方法是从父类继承过来的）：","date":"2019-09-09T16:00:00.000Z","updated":"2021-03-02T02:18:41.000Z","comments":true,"path":"2019/09/10/编程语言/Objective-C/super关键字（特指这个方法是从父类继承过来的）：/","link":"","permalink":"http://example.com/2019/09/10/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Objective-C/super%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%88%E7%89%B9%E6%8C%87%E8%BF%99%E4%B8%AA%E6%96%B9%E6%B3%95%E6%98%AF%E4%BB%8E%E7%88%B6%E7%B1%BB%E7%BB%A7%E6%89%BF%E8%BF%87%E6%9D%A5%E7%9A%84%EF%BC%89%EF%BC%9A/","excerpt":"","text":"1）可以用在类方法和对象方法之中 2）在对象方法中可以使用super关键字调用当前对象从父类继承过来的对象方法 12[self sayHi];[super sayHi]; 3）在类方法中，super关键字可以调用当前类从父类继承过来的类方法【类方法也能被子类继承，父类中的类方法可以使用父类名来调用，也可以使用子类名调用】 1234[Person hehe];[Student hehe];[self hehe];[super hehe]; 4）super只能用来调用父类的对象方法或者类方法，不能用来访问属性","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://example.com/tags/Objective-C/"}]},{"title":"访问修饰符：用来修饰属性","slug":"编程语言/Objective-C/访问修饰符：用来修饰属性","date":"2019-09-08T16:00:00.000Z","updated":"2021-03-02T02:18:29.000Z","comments":true,"path":"2019/09/09/编程语言/Objective-C/访问修饰符：用来修饰属性/","link":"","permalink":"http://example.com/2019/09/09/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Objective-C/%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6%EF%BC%9A%E7%94%A8%E6%9D%A5%E4%BF%AE%E9%A5%B0%E5%B1%9E%E6%80%A7/","excerpt":"","text":"可以限定对象的属性在哪一段范围之中访问 @private私有的，被@private修饰的属性只能在本类的内部访问，只能在本类的方法实现中访问 @protected受保护的，被@protected修饰的属性只能在本类和本类的子类中访问，只能在本类和子类的方法实现中访问 @package：被@package修饰的属性，可以在当前框架中访问 @public：公共的，被@public修饰的属性可以在任意的地方访问 如果不为属性指定访问修饰符，那么默认的就是@protected 子类仍然可以继承父类的私有属性，只不过在子类中无法去直接访问从父类继承过来的私有属性，但是如果父类中有一个方法在为属性赋值或者取值，那么子类可以调用这个方法间接的访问父类的私有属性 访问修饰符的作用域：从写访问修饰符的地方开始往下，直到遇到另外一个访问修饰符或者结束大括弧为止，中间的所有的属性都应用于这个访问修饰符 1234567891011@interface Person:NSObject&#123; @private NSString *_name; @public int _age; int _x; @protected int _y;&#125; 使用建议：1）@public无论什么情况下都不要使用，属性不要直接暴露给外界2）@private如果属性只想在本类中使用，不想在子类中使用，那么就使用它3）@protected：如果你希望属性只在本类和本类的子类中使用推荐使用默认的@protected 访问修饰符只能用来修饰属性，不能用来修饰方法","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://example.com/tags/Objective-C/"}]},{"title":"私有属性和私有方法","slug":"编程语言/Objective-C/私有属性和私有方法","date":"2019-09-07T16:00:00.000Z","updated":"2021-03-02T02:18:17.000Z","comments":true,"path":"2019/09/08/编程语言/Objective-C/私有属性和私有方法/","link":"","permalink":"http://example.com/2019/09/08/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Objective-C/%E7%A7%81%E6%9C%89%E5%B1%9E%E6%80%A7%E5%92%8C%E7%A7%81%E6%9C%89%E6%96%B9%E6%B3%95/","excerpt":"","text":"我们刚才讲的@private修饰的属性叫做私有属性，只能在类的内部访问，但是在外界的时候，Xcode仍然会提示这个对象中有这个属性，只不过没权访问，我们想要实现的效果是真私有，让外界不知道对象里面有这么一个属性 其实在@implementation之中也可以写一个大括弧，把属性定义在@implementation的大括弧之中，这里面的属性，是一个私有属性，各种访问修饰符无效，外界根本就不会提示 将属性定义在@implementation之中和将属性定义在@interface之中并标记为@private唯一的区别：提示和不提示，都不能在外界访问 私有方法：方法不写声明只写实现，那么这个方法就是一个私有方法，只能在本类的其他方法中调用，不能在外界调用","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://example.com/tags/Objective-C/"}]},{"title":"里氏替换原则—LSP","slug":"编程语言/Objective-C/里氏替换原则—LSP","date":"2019-09-06T16:00:00.000Z","updated":"2021-03-02T02:18:03.000Z","comments":true,"path":"2019/09/07/编程语言/Objective-C/里氏替换原则—LSP/","link":"","permalink":"http://example.com/2019/09/07/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Objective-C/%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99%E2%80%94LSP/","excerpt":"","text":"子类可以替换父类的位置，并且程序的功能不受影响 1234Person *p1=[Person new];Student *s1=[Student new];Person *p2=[Student new]; 为什么？1）父类指针迫切的需求要一个父类对象，而我们给了一个子类对象，这是完全没有问题的【你想要一个人，我给你一个学生】2）因为父类中拥有的成员子类都有，所以不会影响程序的功能 里氏替换原则的表现形式：当一个父类指针指向一个子类对象的时候，这里就有里氏替换原则 里氏替换原则的作用：1）一个指针中不仅可以存储本类对象的地址还可以存储子类对象的地址2）如果一个指针的类型是NSObject类型的，那么这个指针中可以存储任意的OC对象的地址3）如果一个数组的元素的类型是一个OC指针类型的，那么这个数组中不仅可以存储本类对象还可以存储子类对象 12345Person *ps[3];ps[0]=[Person new];ps[1]=[Student new];ps[2]=[ItCastStu new]; 4）如果一个数组的元素是NSObject指针类型，那么意味着任意的OC对象都可以存储到这个数组之中 123456NSObject *objs[4];objs[0]=[Person new];objs[1]=[Student new];objs[2]=[ItCastStu new];objs[3]=@&quot;jack&quot;; 5）如果一个方法的参数是一个对象，那么我们在为这个参数传值的时候可以传递一个本类对象，也可以传递一个子类对象，对方法中的代码不会有丝毫的影响 123456789101112God *ys=[God new];Person *p1=[Person new];[p1 setName:@&quot;大狗&quot;];Student *s1=[Student new];[s1 setName:@&quot;小明&quot;];ItCastStu *stu=[ItCastStu new];[stu setName:@&quot;小东&quot;];[ys killWithPerson:stu]; 当一个父类指针指向一个子类对象的时候，通过这个父类指针就只能去调用子类对象中的父类成员，子类独有的成员无法访问","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://example.com/tags/Objective-C/"}]},{"title":"方法重写：","slug":"编程语言/Objective-C/方法重写：","date":"2019-09-05T16:00:00.000Z","updated":"2021-03-02T02:17:47.000Z","comments":true,"path":"2019/09/06/编程语言/Objective-C/方法重写：/","link":"","permalink":"http://example.com/2019/09/06/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Objective-C/%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99%EF%BC%9A/","excerpt":"","text":"子类从父类继承，子类就继承了父类的方法，就意味着子类拥有了这个功能，但是有的时候，虽然子类也拥有父类的这个行为，但是这个行为的具体的实现和父类不同 如何重写：直接在自己类的实现中将这个方法重新实现一遍就可以了 当一个父类指针指向一个子类对象的时候，通过这个父类指针调用的方法如果在子类对象中重写了，那么调用的就是子类重写的方法","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://example.com/tags/Objective-C/"}]},{"title":"多态：","slug":"编程语言/Objective-C/多态：","date":"2019-09-04T16:00:00.000Z","updated":"2021-03-02T02:17:32.000Z","comments":true,"path":"2019/09/05/编程语言/Objective-C/多态：/","link":"","permalink":"http://example.com/2019/09/05/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Objective-C/%E5%A4%9A%E6%80%81%EF%BC%9A/","excerpt":"","text":"指的是同一个行为，对于不同的事物具有完全不同的表现形式 1234567Person *p1=[Chinese new];Person *p2=[Japanese new];Person *p3=[Korea new];[p1 sayHi];[p2 sayHi];[p3 sayHi];","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://example.com/tags/Objective-C/"}]},{"title":"Description方法","slug":"编程语言/Objective-C/Description方法","date":"2019-09-03T16:00:00.000Z","updated":"2021-03-02T02:17:20.000Z","comments":true,"path":"2019/09/04/编程语言/Objective-C/Description方法/","link":"","permalink":"http://example.com/2019/09/04/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Objective-C/Description%E6%96%B9%E6%B3%95/","excerpt":"","text":"%p打印的是指针变量的值%@打印的是指针指向的对象 如果我们使用%@打印一个对象，发现输出的格式：&lt;对象所属的类名：对象的地址&gt; 当我们使用%@打印一个对象的时候，NSLog函数的底层实现：1）调用传入的对象的Description方法2）拿到这个方法的返回值，这个返回值是一个字符串3）将这个字符串输出 Description方法是定义在NSObject类之中的，所以每一个OC对象都有这个方法，这个方法在NSObject类中的实现是这样的：返回的字符串格式 @“&lt;对象所属的类名：对象的地址&gt;” 如果使用%@打印一个对象的时候，你希望这个对象打印的格式是我们自己自定义的，那么就可以重写Description方法","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://example.com/tags/Objective-C/"}]},{"title":"创建一个对象，这个对象在内存中是如何分配的?","slug":"编程语言/Objective-C/创建一个对象，这个对象在内存中是如何分配的?","date":"2019-09-02T16:00:00.000Z","updated":"2021-03-02T02:17:09.000Z","comments":true,"path":"2019/09/03/编程语言/Objective-C/创建一个对象，这个对象在内存中是如何分配的?/","link":"","permalink":"http://example.com/2019/09/03/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Objective-C/%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%EF%BC%8C%E8%BF%99%E4%B8%AA%E5%AF%B9%E8%B1%A1%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E6%98%AF%E5%A6%82%E4%BD%95%E5%88%86%E9%85%8D%E7%9A%84?/","excerpt":"","text":"1）子类对象中有自己的属性和所有父类的属性 2）代码段中的每一个类都有一个叫做isa的指针，这个指针指向它的父类，一直指到NSObject 子类方法重写以后，调用的就是子类重写的方法了","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://example.com/tags/Objective-C/"}]},{"title":"结构体和类的区别：","slug":"编程语言/Objective-C/结构体和类的区别：","date":"2019-09-01T16:00:00.000Z","updated":"2021-03-02T02:16:58.000Z","comments":true,"path":"2019/09/02/编程语言/Objective-C/结构体和类的区别：/","link":"","permalink":"http://example.com/2019/09/02/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Objective-C/%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A/","excerpt":"","text":"相同点：都可以将多个数据封装为一个整体123456struct Date&#123; int year; int month; int day;&#125;; 1234567@interface Date:NSObject&#123; int year; int month; int day;&#125;@end 不同点：1）结构体只能封装数据，而类不仅可以封装数据还可以封装行为【如果表示的这个实体，不仅是由多个数据组成，这个实体还具有行为，只能使用类】 2）结构体变量分配在栈空间（如果是一个局部变量的情况下），而对象分配在堆空间【栈的特点：空间相对较小，但是存储在栈中的数据访问的效率更高一些；堆的特点：空间相对较大，但是存储在堆中的数据访问的效率相对较低】 3）赋值不同： 12345678910//结构体：Student//类：PersonStudent s1=&#123;“jack”,19,GenderMale&#125;;Student s2=s1;Person *p1=[Person new];Person *p2=p1;","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://example.com/tags/Objective-C/"}]},{"title":"类的本质：","slug":"编程语言/Objective-C/类的本质：","date":"2019-08-31T16:00:00.000Z","updated":"2021-03-02T02:16:46.000Z","comments":true,"path":"2019/09/01/编程语言/Objective-C/类的本质：/","link":"","permalink":"http://example.com/2019/09/01/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Objective-C/%E7%B1%BB%E7%9A%84%E6%9C%AC%E8%B4%A8%EF%BC%9A/","excerpt":"","text":"1）类第一次被访问的时候，就会被加载到代码段中存储（类加载）2）类一旦被加载到代码段之后是不会被回收的，除非程序结束 类是以什么样的形式存储在代码段的：1）任何存储在内存中的数据都有一个数据类型2）任何在内存中申请的空间也有自己的类型Person *p1=[Person new];3)在代码段存储类的那块空间是什么类型？ 在代码段中存储类的步骤：1）先在代码段中创建一个Class对象，Class是Foundation框架中的一个类，这个Class对象就是用来存储类信息的2）将类的信息存储在这个Class对象之中，这个Class对象至少有三个属性：存储的这个类的名称，存储的这个类的属性，存储的这个类的方法 所以类是以Class对象的形式存储在代码段的，存储类的这个Class对象，我们也叫做类对象，用来存储类的一个对象 所以存储类的类对象也有一个叫做isa指针的属性，这个指针指向存储父类的类对象 如何拿到存储在代码段中的类对象：1）调用类的类方法class就可以得到存储类的类对象的地址【声明Class指针的时候不需要加，因为在typedef的时候已经加了】 12Class c1=[Person class];NSLog(@&quot;c1 = %p&quot;,c1); 2）调用对象的对象方法class，就可以得到存储这个对象所属的类的Class对象的地址 12Person *p1=[Person new];Class c2=[p1 class]; 3）对象中的isa指针的值其实就是代码段中存储类的类对象的地址 如何使用类对象：1）拿到存储类的类对象以后，Class c1=[Person class];c1对象就是Person类，c1完全等价于Person 2）使用类对象来调用类的类方法 3）可以使用类对象来调用new方法，创建存储在类对象中的类的对象 12Class c1=[Person class];Person *p1=[c1 new]; 4）注意：使用类对象只能调用类的类方法，因为类对象就等价于存在其中的类","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://example.com/tags/Objective-C/"}]},{"title":"SEL","slug":"编程语言/Objective-C/SEL","date":"2019-08-30T16:00:00.000Z","updated":"2021-03-02T02:16:34.000Z","comments":true,"path":"2019/08/31/编程语言/Objective-C/SEL/","link":"","permalink":"http://example.com/2019/08/31/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Objective-C/SEL/","excerpt":"","text":"SEL全称叫做selector选择器，是一个数据类型，所以要在内存中申请空间存储数据 SEL其实是一个类，SEL对象是用来存储一个方法的 如何将方法存储在类对象之中：1）先创建一个SEL对象2）将方法的信息存储在这个SEL对象之中3）再将这个SEL对象作为类对象的属性 因为SEL是一个typedef类型的，在自定义的时候已经加了，所以我们在声明SEL指针的时候不需要加 12SEL s1=@selector(sayHi);NSLog(@&quot;s1 = %p&quot;,s1); 调用方法的本质：[p1 sayHi]; 内部的原理：1）先拿到存储sayHi方法的SEL对象，也就是拿到存储sayHi方法的SEL数据，SEL消息2）将这个SEL消息发送给p1对象3）这个时候，p1对象接收到SEL消息以后，就知道要调用方法4）根据对象的isa指针找到存储类的类对象5）找到这个类对象以后，在这个类对象中去搜寻是否有和传入的SEL数据相匹配的，如果有就执行，如果没有再找父类，直到NSObject OC最重要的一个机制：消息机制，调用方法的本质其实就是为对象发送SEL消息[p1 sayHi]; 为p1对象发送一条sayHi消息 手动的为对象发送SEL消息：1）先得到方法的SEL数据2）将这个SEL消息发送给p1对象 调用对象的方法，将SEL数据发送给对象：- (id)performSelector:(SEL)aSelector; 1234567Person *p1=[Person new];SEL s1=@selector(sayHi);[p1 performSelector:s1];[p1 sayHi]; 调用一个对象的方法有两种：1）[对象名 方法名];2）手动的为对象发送SEL消息 注意：1）如果方法有参数，那么方法名是带了冒号的2）如果方法有参数，要传递参数就调用另外一个方法* (id)performSelector:(SEL)aSelector withObject:(id)object; * (id)performSelector:(SEL)aSelector withObject:(id)object1 withObject:(id)object2;3)如果有多个参数，那就重新创建一个类把多个参数封装进去 1234Person *p1=[Person new];SEL s1=@selector(eatWithFood:);[p1 performSelector:s1 withObject:@&quot;红烧肉&quot;];","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://example.com/tags/Objective-C/"}]},{"title":"点语法","slug":"编程语言/Objective-C/点语法","date":"2019-08-29T16:00:00.000Z","updated":"2021-03-02T02:16:22.000Z","comments":true,"path":"2019/08/30/编程语言/Objective-C/点语法/","link":"","permalink":"http://example.com/2019/08/30/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Objective-C/%E7%82%B9%E8%AF%AD%E6%B3%95/","excerpt":"","text":"OC的对象如果要为属性赋值或者取值，就要调用对应的getter或者setter方法 12345Person *p1=[Person new];[p1 setName:@&quot;jack&quot;];[p1 setAge:18];[p1 setGender:GenderMale]; OC中使用点语法来访问对象的属性： 语法：对象名.去掉下划线的属性名 12p1.name=@&quot;jack&quot;; //这个时候就会将@&quot;jack&quot;赋值给p1对象的_name属性NSString *name=p1.name; //把p1对象的_name属性的值取出来 点语法的原理： 注意：1）在getter和setter中慎用点语法，因为有可能会造成无限递归，程序崩溃 1234- (void)setAge:(int)age&#123; self.age=age; //[self setAge:age];&#125; 2）3）如果属性没有封装getter和setter是无法使用点语法的，因为点语法的本质是getter和setter方法","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://example.com/tags/Objective-C/"}]},{"title":"property","slug":"编程语言/Objective-C/@property","date":"2019-08-28T16:00:00.000Z","updated":"2021-03-02T02:16:09.000Z","comments":true,"path":"2019/08/29/编程语言/Objective-C/@property/","link":"","permalink":"http://example.com/2019/08/29/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Objective-C/@property/","excerpt":"","text":"写一个类：1）要先为类写属性2）再声明属性的getter和setter3）再实现getter和setter @property 作用：自动生成getter、setter方法的声明，因为是生成方法的声明，所以应该写在@interface类的声明之中 语法：@property 数据类型 名称；@property int age; 原理：","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://example.com/tags/Objective-C/"}]},{"title":"synthesize","slug":"编程语言/Objective-C/@synthesize","date":"2019-08-27T16:00:00.000Z","updated":"2021-03-02T02:15:56.000Z","comments":true,"path":"2019/08/28/编程语言/Objective-C/@synthesize/","link":"","permalink":"http://example.com/2019/08/28/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Objective-C/@synthesize/","excerpt":"","text":"作用：自动生成getter、setter方法的实现，所以应该写在类的实现之中 语法：@synthesize @property名称; @synthesize做的事情： 问题：希望@synthesize不要去自动生成私有属性了，getter和setter的实现中操作我们已经写好的属性就可以了 语法：@synthesize @property名称 = 已经存在的属性名;【@synthesize age=_age;】1）不会再去生成私有属性2）直接生成setter和getter的实现Setter的实现：把参数的值直接赋值给指定的属性，是没有做任何逻辑验证的Getter的实现：直接返回指定的属性的值 如果setter或者getter有自己的逻辑验证，那么就自己在类的实现中重写就可以了 批量声明：1）如果多个@property的类型一致，可以批量声明 @property float height,weight; 2）@synthesize也可以批量声明（类型不一致也可以） @synthesize name = _name,age = _age,weight = _weight,height = _height;","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://example.com/tags/Objective-C/"}]},{"title":"property增强（Xcode4.4之后）","slug":"编程语言/Objective-C/@property增强（Xcode4.4之后）","date":"2019-08-26T16:00:00.000Z","updated":"2021-03-02T02:15:45.000Z","comments":true,"path":"2019/08/27/编程语言/Objective-C/@property增强（Xcode4.4之后）/","link":"","permalink":"http://example.com/2019/08/27/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Objective-C/@property%E5%A2%9E%E5%BC%BA%EF%BC%88Xcode4.4%E4%B9%8B%E5%90%8E%EF%BC%89/","excerpt":"","text":"只需要写一个@property，编译器就会自动的1）生成私有属性2）生成getter、setter的声明3）生成getter、setter的实现 使用注意：1）@property的类型一定要和属性的类型一致，名称要和属性的名称一致，只是去掉下划线2）也可以批量声明相同类型的@property3）@property生成的方法实现没有做任何的逻辑验证setter：直接赋值getter：直接返回所以我么可以重写setter来自定义验证逻辑，如果重写了setter还会自动生成getter，如果重写了getter还会自动生成setter；如果同时重写setter和getter，那么就不会自动生成私有属性了，那么就自己定义一个私有属性就可以了4）如果你想为类写一个属性，并且为这个属性封装setter和getter，一个@property就搞定5）父类的@property一样可以被子类继承，@property生成的属性是私有的，在子类的内部无法直接访问生成的私有属性，但是可以通过setter和getter来访问","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://example.com/tags/Objective-C/"}]},{"title":"动态类型和静态类型","slug":"编程语言/Objective-C/动态类型和静态类型","date":"2019-08-25T16:00:00.000Z","updated":"2021-03-02T02:15:28.000Z","comments":true,"path":"2019/08/26/编程语言/Objective-C/动态类型和静态类型/","link":"","permalink":"http://example.com/2019/08/26/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Objective-C/%E5%8A%A8%E6%80%81%E7%B1%BB%E5%9E%8B%E5%92%8C%E9%9D%99%E6%80%81%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"OC是一门弱语言：编译器在编译的时候，语法检查的时候没有那么严格，不管你怎么写都是可以的 强类型的语言：编译器在编译的时候，做语法检查的时候，行就是行，不行就是不行 静态类型：指的是一个指针指向的对象是一个本类对象动态类型：指的是一个指针指向的对象不是本类对象 编译检查：编译器在编译的时候，能不能通过一个指针去调用指针指向的对象的方法？判断原则：看指针所属的类型之中是否有这个方法，如果有就认为可以调用，编译通过，如果这个类中没有，那么编译报错【苹果下的编译器的名字叫LLVM】 我们可以将指针的类型做转换，来达到骗过编译器的目的 12Animal *a1=[Pig new];[(Pig *)a1 eat]; 运行检查：编译检查只是骗过了编译器，但是这个方法究竟能不能执行？所以在运行的时候，会去检查对象中是否真的有这个方法，如果有就执行，如果没有就报错 LSP父类指针指向子类对象，实际上任意的指针可以指向任意的对象，编译器是不会报错的；当一个子类指针指向一个父类对象的时候，编译器允许通过子类指针去调用子类独有的方法，但是在运行的时候是会出问题的，因为父类对象中根本没有子类成员","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://example.com/tags/Objective-C/"}]},{"title":"NSObject指针和id指针","slug":"编程语言/Objective-C/NSObject指针和id指针","date":"2019-08-24T16:00:00.000Z","updated":"2021-03-02T02:15:17.000Z","comments":true,"path":"2019/08/25/编程语言/Objective-C/NSObject指针和id指针/","link":"","permalink":"http://example.com/2019/08/25/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Objective-C/NSObject%E6%8C%87%E9%92%88%E5%92%8Cid%E6%8C%87%E9%92%88/","excerpt":"","text":"NSObject是OC中所有类的基类，根据LSP，NSObject指针就可以指向任意的OC对象，所以，NSObject指针是一个万能指针，可以指向任意的OC对象 缺点：如果要调用指向的子类对象的独有的方法，就必须要做类型转换 12345678NSObject *obj1=[Person new];[(Person *)obj1 sayHi];NSObject *obj2=[Student new];[(Student *)obj2 study];NSObject *obj3=@&quot;jack&quot;;[(NSString *)obj3 length]; id指针：是一个万能指针，可以指向任意的OC对象 id是一个typedef自定义类型，在定义的时候已经加了，所以，声明id指针的时候不需要再加了 通过NSObject指针去调用对象的方法的时候，编译器会做编译检查通过id类型的指针去调用对象的方法的时候，编译器直接通过，无论你调用什么方法【该运行错误的还是运行错误】 注意：id指针只能调用对象的方法，不能使用点语法，如果使用点语法就会直接报编译错误 如果我们要声明一个万能指针，不要使用NSObject，而是使用id","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://example.com/tags/Objective-C/"}]},{"title":"instancetype：","slug":"编程语言/Objective-C/instancetype：","date":"2019-08-23T16:00:00.000Z","updated":"2021-03-02T02:14:54.000Z","comments":true,"path":"2019/08/24/编程语言/Objective-C/instancetype：/","link":"","permalink":"http://example.com/2019/08/24/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Objective-C/instancetype%EF%BC%9A/","excerpt":"","text":"父类中的类方法创建一个父类对象返回:1）如果返回值写为父类类型的，那么子类来调用这个方法得到的就是父类指针，解决方式：把返回值改为id类型的2）方法的内部创建对象的时候，不要写死了，因为写死创建的对象就固定了，我们希望哪一个类来调用这个方法就创建哪一个类的对象，解决方式：把类名写为self，哪一个类来调用这个方法，self就指的是哪一个类，创建的就是哪一个类的对象3）方法的返回值是id类型的，问题就是任意指针都可以接收这个方法的返回值，编译器连个警告都没有解决方式：如果方法的返回值是instancetype，代表方法的返回值是当前这个类的对象 使用建议：1）如果方法内部是在创建当前类的对象，不要写死成类名[类名 new];而是用self代替类名2）如果方法的返回值是当前类的对象，也不要写死了，而是写成instancetype id和instancetype的区别：1）instancetype只能作为方法的返回值，不能在其他地方使用id既可以声明指针变量，也可以作为参数，也可以作为返回值2）instancetype是一个有类型的，代表当前类的对象id是一个无类型的指针，仅仅是一个地址","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://example.com/tags/Objective-C/"}]},{"title":"动态类型检测：","slug":"编程语言/Objective-C/动态类型检测：","date":"2019-08-22T16:00:00.000Z","updated":"2021-03-02T02:14:42.000Z","comments":true,"path":"2019/08/23/编程语言/Objective-C/动态类型检测：/","link":"","permalink":"http://example.com/2019/08/23/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Objective-C/%E5%8A%A8%E6%80%81%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%B5%8B%EF%BC%9A/","excerpt":"","text":"编译——运行 我们就希望，可以写代码来先判断一下对象中是否有这个方法，如果有再去执行，如果没有就不去执行 1）判断对象中是否有指定的对象方法【最常用】* (BOOL)respondsToSelector:(SEL)aSelector; 2）判断类中是否有指定的类方法【最常用】+ (BOOL)instancesRespondToSelector:(SEL)aSelector; 3）判断指定的对象是否为指定类的对象或者子类对象* (BOOL)isKindOfClass:(Class)aClass;【判断s1对象是否为NSObject对象或者NSObject的子类对象】 4）判断对象是否为指定类的对象，不包括子类* (BOOL)isMemberOfClass:(Class)aClass; 5）判断类是否为另外一个类的子类+ (BOOL)isSubclassOfClass:(Class)aClass;","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://example.com/tags/Objective-C/"}]},{"title":"构造方法：","slug":"编程语言/Objective-C/构造方法：","date":"2019-08-21T16:00:00.000Z","updated":"2021-03-02T02:14:31.000Z","comments":true,"path":"2019/08/22/编程语言/Objective-C/构造方法：/","link":"","permalink":"http://example.com/2019/08/22/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Objective-C/%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%EF%BC%9A/","excerpt":"","text":"类名 *指针名=[类名 new]; new方法的内部，其实是先调用的alloc方法，再调用的init方法 alloc方法是一个类方法，作用：哪一个类调用这个方法，就创建哪个类的对象，并把对象返回init方法是一个对象方法，作用：初始化对象 创建对象的完整步骤：应该先使用alloc创建一个对象，然后再使用init初始化这个对象，才可以使用这个对象；虽然没有初始化的对象有的时候也可以使用，但是千万不要这么做，使用一个未经初始化的对象是极其危险的 init方法（构造方法）： 作用：初始化对象，为对象的属性赋初始值 所以我们创建一个对象如果没有为这个对象的属性赋值，这个对象的属性是有默认值的，我们每次新创建一个对象，这个对象的属性都被初始化了 我们想要让创建的对象的属性的默认值不是nil、NULL、0，而是我们自定义的，那么这个时候，我们就可以重写init方法 调用父类init方法的原因：因为父类的init方法会初始化父类的属性，所以必须要保证当前对象中的父类属性也同时被初始化 赋值给self的原因是调用父类的init方法，会返回初始化成功的对象，实际上返回的就是当前对象，但是我们要判断是否初始化成功 重写init方法以后，这样每次创建出来的对象的属性都是一样的但是，我想创建对象的时候，对象的属性的值由创建对象的人来指定，而不是写死在init方法中 自定义构造方法的规范：1）自定义构造方法的返回值必须是instancetype2）自定义构造方法的名称必须以initWith开头3）方法的实现和init的要求一样这个时候就不能直接[Dog new]了","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://example.com/tags/Objective-C/"}]},{"title":"内存管理概述：","slug":"编程语言/Objective-C/内存管理概述：","date":"2019-08-20T16:00:00.000Z","updated":"2021-03-02T02:14:19.000Z","comments":true,"path":"2019/08/21/编程语言/Objective-C/内存管理概述：/","link":"","permalink":"http://example.com/2019/08/21/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Objective-C/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E8%BF%B0%EF%BC%9A/","excerpt":"","text":"内存的作用：存储数据 1）如何将数据存储到内存之中：声明一个变量2）当数据不再被使用的时候，占用的内存空间如何被释放？ 内存中的五大区域：1）栈：局部变量，当局部变量的作用域被执行完毕之后，这个局部变量就会被系统立即回收2）堆：OC对象，使用C函数申请的空间3）BSS段：未初始化的全局变量、静态变量，一旦初始化就回收，并转存到数据段之中4）数据段：已经初始化的全局变量、静态变量，直到程序结束的时候才会被回收5）代码段：代码，程序结束的时候，系统会自动回收存储在代码段中的数据 栈、BSS段、数据段、代码段，存储在它们中的数据的回收是由系统自动完成的，不需要我们干预 分配在堆区中的OC对象是肯定需要被回收的，但系统不会自动回收，直到程序结束的时候才会被回收【轰炸机的小游戏，肯定不能等到程序结束才回收，因为有些人玩的时间很长】 内存管理的范围：只需要管理存储在堆中的OC对象的回收，其他区域中的数据的回收是系统自动管理的 对象应该什么时候被回收：当有人使用这个对象的时候，这个对象就千万不能回收；只有在没有任何人使用这个对象的时候才可以回收 引用计数器： 每一个对象都有一个属性，叫做retainCount，叫做引用计数器，类型是unsigned long，占据8个字节 引用计数器的作用：用来记录当前这个对象有多少个人在使用它，默认情况下，创建一个对象出来，这个对象的引用计数器的默认值是1 当多一个人使用这个对象的时候，应该先让这个对象的引用计数器的值+1，代表这个对象多一个人使用 当这个对象少一个人使用的时候，应该先让这个对象的引用计数器的值-1，代表这个对象少一个人使用 当这个对象的引用计数器变为0的时候，代表这个对象无人使用，这个时候系统就会自动回收这个对象，在对象被回收的时候，会自动调用对象的dealloc方法 如何操作引用计数器： 为对象发送一条retain消息，对象的引用计数器就会+1，当多一个人使用对象的时候才发 为对象发送一条release消息，对象的引用计数器就会-1，当少一个人使用对象的时候才发 为对象发送一条retainCount消息，就可以取到对象的引用计数器的值 内存管理的分类： MRC：Manual Reference Counting手动引用计数，手动内存管理（2011年以前，iOS5之前）：当多一个人使用对象的时候，要求程序员手动的发送retain消息，少一个人使用的时候程序员手动的发送release消息 ARC：Automatic Reference Counting自动引用计数，自动内存管理：系统自动的在合适的地方发送retain，release消息","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://example.com/tags/Objective-C/"}]},{"title":"第一个MRC程序：","slug":"编程语言/Objective-C/第一个MRC程序：","date":"2019-08-19T16:00:00.000Z","updated":"2021-03-02T02:14:07.000Z","comments":true,"path":"2019/08/20/编程语言/Objective-C/第一个MRC程序：/","link":"","permalink":"http://example.com/2019/08/20/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Objective-C/%E7%AC%AC%E4%B8%80%E4%B8%AAMRC%E7%A8%8B%E5%BA%8F%EF%BC%9A/","excerpt":"","text":"要写MRC的程序，必须先把Xcode默认的ARC模式关闭，开启MRC 在ARC机制下，retain，release，dealloc这些方法无法调用 重写dealloc方法的规范：必须要调用父类的dealloc方法，并且要放在最后一句代码 测试引用数据：1）新创建一个对象，这个对象的引用计数器的值默认是12）当对象的引用计数器变为0的时候，对象就会被系统立即回收，并自动调用dealloc方法3）为对象发送retain消息，对象的引用计数器就会+1 为对象发送release消息，并不是回收对象，而是让对象的引用计数器-1，当对象的引用计数器的值变为0的时候，对象才会被系统立即回收","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://example.com/tags/Objective-C/"}]},{"title":"内存管理的原则：","slug":"编程语言/Objective-C/内存管理的原则：","date":"2019-08-18T16:00:00.000Z","updated":"2021-03-02T02:13:55.000Z","comments":true,"path":"2019/08/19/编程语言/Objective-C/内存管理的原则：/","link":"","permalink":"http://example.com/2019/08/19/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Objective-C/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E5%8E%9F%E5%88%99%EF%BC%9A/","excerpt":"","text":"1）有对象的创建，就要匹配一个release2）retain的次数和release的次数要匹配3）谁用谁retain，谁不用谁release4）只有在多一个人用的时候才retain，少一个人使用的时候才release 有始有终，有加就有减，有retain就应该匹配一个release，一定要平衡","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://example.com/tags/Objective-C/"}]},{"title":"野指针与僵尸对象：","slug":"编程语言/Objective-C/野指针与僵尸对象：","date":"2019-08-17T16:00:00.000Z","updated":"2021-03-02T02:13:41.000Z","comments":true,"path":"2019/08/18/编程语言/Objective-C/野指针与僵尸对象：/","link":"","permalink":"http://example.com/2019/08/18/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Objective-C/%E9%87%8E%E6%8C%87%E9%92%88%E4%B8%8E%E5%83%B5%E5%B0%B8%E5%AF%B9%E8%B1%A1%EF%BC%9A/","excerpt":"","text":"C语言中的野指针：定义一个指针变量，没有初始化，这个指针变量的值是一个垃圾值，指向一块随机的空间，这个指针就叫做野指针 OC中的野指针：指针指向的对象已经被回收了，这样的指针就叫做野指针 内存回收的本质：申请一个变量实际上就是向系统申请指定字节数的空间，这些空间系统就不会再分配给别人了；当变量被回收的时候，代表变量占用的字节空间从此以后系统就可以分配给别人使用了，但是字节空间中存储的数据还在（这就是野指针的来源） 对象回收的本质：对象占用的空间可以分配给别人，当这个对象占用的空间没有分配给别人之前，其实对象数据还在 僵尸对象：一个已经被释放的对象，但是这个对象所占的空间还没有分配给别人，这样的对象叫做僵尸对象；我们通过野指针去访问僵尸对象的时候，有可能没问题，也有可能有问题，当僵尸对象占用的空间还没有分配给别人的时候就没问题 我们认为只要对象成为了僵尸对象，无论如何都不允许访问了，就希望如果访问的是僵尸对象，无论如何都会报错 Xcode有一个僵尸对象的实时检查机制，可以将这个机制打开，打开之后，只要访问的是僵尸对象，无论空间是否分配，就会报错 为什么不默认打开僵尸对象检测：一旦打开僵尸对象检测，那么在每访问一个对象的时候，都会先检查这个对象是否为一个僵尸对象，这样是极其消耗性能的 如何避免僵尸对象错误？当一个指针成为野指针以后，将这个指针的值设置为nil当一个指针的值为nil，通过这个指针去调用对象的方法（包括使用点语法）的时候，不会报错，只是没有任何反应；但是如果通过直接访问属性，就会报错 无法复活一个僵尸对象","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://example.com/tags/Objective-C/"}]},{"title":"单个对象的内存管理：","slug":"编程语言/Objective-C/单个对象的内存管理：","date":"2019-08-16T16:00:00.000Z","updated":"2021-03-02T02:13:30.000Z","comments":true,"path":"2019/08/17/编程语言/Objective-C/单个对象的内存管理：/","link":"","permalink":"http://example.com/2019/08/17/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Objective-C/%E5%8D%95%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%9A/","excerpt":"","text":"内存泄露：指的是一个对象没有被及时的回收，在该回收的时候而没有被回收，一直驻留在内存中，直到程序结束的时候才回收 单个对象的内存泄漏情况：1）有对象的创建，而没有对应的release2）retain的次数和release的次数不匹配3）在不适当的时候，为指针赋值为nil4）在方法中为传入的对象进行不适当的retain 如何保证单个对象可以被回收：1）有对象的创建就必须要匹配一个release2）retain次数和release次数一定要匹配3）只有在指针成为野指针的时候才赋值nil4）在方法中不要随意的为传入的对象retain","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://example.com/tags/Objective-C/"}]},{"title":"setter方法内存管理：","slug":"编程语言/Objective-C/setter方法内存管理：","date":"2019-08-15T16:00:00.000Z","updated":"2021-03-02T02:13:18.000Z","comments":true,"path":"2019/08/16/编程语言/Objective-C/setter方法内存管理：/","link":"","permalink":"http://example.com/2019/08/16/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Objective-C/setter%E6%96%B9%E6%B3%95%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%9A/","excerpt":"","text":"这辆车多了一个人使用： 当传进来的对象赋值给当前对象的属性，代表传入的对象多了一个人使用，所以我们应该先为这个传入的对象发送一条retain消息，再赋值；当当前对象销毁的时候，代表属性指向的对象少一个人使用，就应该在dealloc中release 宝马车未被销毁，发生内存泄露：当我们将传入的Car对象赋值给_car属性的时候，有两重意思：一个是_car属性原本指向的对象少一个人使用，另一个是新传入的对象多一个人使用；所以我们应该先将_car属性原本指向的对象release，再将传入的新对象retain 出现僵尸对象错误的原因：在于新旧对象是同一个对象解决的方案：当发现新旧对象是同一个对象的时候，什么都不用做；只有当新旧对象不是同一个对象的时候，才release旧的，retain新的 1234567891011121314151617181920#import&lt;Foundation/Foundation.h&gt;#import &quot;Person.h&quot;int main(int argc,const char * argv[])&#123; Person *p1=[Person new]; Car *bmw=[Car new]; bmw.speed=100; p1.car=bmw; [bmw release]; bmw.speed=200; p1.car=bmw; [p1 release]; return 0;&#125; 12345678910111213#import&lt;Foundation/Foundation.h&gt;@interface Car : NSObject&#123; int _speed;&#125;- (void)setSpeed:(int)speed;- (int)speed;- (void)run;@end 1234567891011121314151617181920212223242526#import &quot;Car.h&quot;@implementation Car- (void)dealloc&#123; NSLog(@&quot;速度为%d的车子销毁了.&quot;,_speed); [super dealloc];&#125;- (void)setSpeed:(int)speed&#123; _speed=speed;&#125;- (int)speed&#123; return _speed;&#125;- (void)run&#123; NSLog(@&quot;速度为%d的车正在行驶&quot;,_speed);&#125;@end 1234567891011121314#import&lt;Foundation/Foundation.h&gt;#import &quot;Car.h&quot;@interface Person : NSObject&#123; Car *_car;&#125;- (void)setCar:(Car *)car;- (Car *)car;- (void)drive;@end 123456789101112131415161718192021222324252627282930313233#import &quot;Person.h&quot;@implementation Person- (void)dealloc&#123; NSLog(@&quot;人死了&quot;); [_car release]; [super dealloc];&#125;- (void)setCar:(Car *)car&#123; //说明新旧对象不是同一个对象 if(_car != car)&#123; [_car release]; //才去release旧的 _car = [car retain]; //retain新的 &#125;&#125;- (Car *)car&#123; return _car;&#125;- (void)drive&#123; NSLog(@&quot;走啊，去拉萨&quot;); [_car run];&#125;@end 特别注意：我们内存管理的范围是OC对象，所以，只有属性的类型是OC对象的时候，这个属性的setter方法才要像上面那样写【对象类型就是类或协议所声明的指针类型，例如:NSString *string ,其中，NSString是一个类，NSString *是它指针类型或叫对象类型。】","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://example.com/tags/Objective-C/"}]},{"title":"property参数","slug":"编程语言/Objective-C/@property参数","date":"2019-08-14T16:00:00.000Z","updated":"2021-03-02T02:13:06.000Z","comments":true,"path":"2019/08/15/编程语言/Objective-C/@property参数/","link":"","permalink":"http://example.com/2019/08/15/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Objective-C/@property%E5%8F%82%E6%95%B0/","excerpt":"","text":"1）@property可以带参数的：@property(参数1，参数2，参数3…..) 数据类型 名称; @property的四组参数：1）与多线程相关的两个参数：atomic（默认值）、nonatomic2）与生成的setter方法的实现相关的参数：assign（默认值）、retain3）与生成只读、读写相关的参数：readonly、readwrite（默认值）4）与生成的getter、setter方法名字相关的参数：getter、setter 使用参数注意：1）同一组参数只能使用一个（getter、setter可以同时使用）2）参数的顺序可以随意（一般默认顺序就好） Atomic：如果写atomic，这个时候生成的setter方法的代码就会被加上一把线程安全锁；特点：安全但效率低下Nonatomic：如果写nonatomic，这个时候生成的setter方法的代码就不会加线程安全锁；特点：不安全但效率高 建议：要效率，选择使用nonatomic Assign：生成的setter方法的实现就是直接赋值Retain：生成的setter方法的实现就是标准的MRC内存管理代码，也就是先判断新旧对象是否为同一个对象，如果不是则release旧的，retain新的 当属性的类型是OC对象类型的时候，那么就使用retain当属性的类型是非OC对象的时候，使用assign 千万注意：retain参数只是生成标准的setter方法为标准的MRC内存管理代码，不会自动的在dealloc中生成release的代码，所以，我们还要自己手动的在dealloc中release readwrite：代表同时生成getter、setterreadonly：只会生成getter，不会生成setter 默认情况下，@property生成的getter、setter方法的名字都是最标准的名字，其实我们可以通过参数来指定@property生成的方法的名字 getter=getter方法名字，用来指定@property生成的getter方法的名字setter=setter方法名字，用来指定@property生成的setter方法的名字（注意，setter方法是带参数的，所以要加一个冒号！！） 如果使用getter、setter修改了生成的方法的名字，在使用点语法的时候，编译器会转换成调用修改后的名字的代码 一般情况下不要去改名字：1）无论什么情况都不要改setter方法的名字，因为默认情况下生成的名字就已经是最标准的了2）什么时候修改getter方法的名字：当属性的类型是一个BOOL类型的时候，就修改这个getter的名字以is开头提高代码的阅读性","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://example.com/tags/Objective-C/"}]},{"title":"class和循环retain","slug":"编程语言/Objective-C/@class和循环retain","date":"2019-08-13T16:00:00.000Z","updated":"2021-03-02T02:12:54.000Z","comments":true,"path":"2019/08/14/编程语言/Objective-C/@class和循环retain/","link":"","permalink":"http://example.com/2019/08/14/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Objective-C/@class%E5%92%8C%E5%BE%AA%E7%8E%AFretain/","excerpt":"","text":"当两个类相互包含的时候：Person.h中包含Book.h，而Book.h中又包含Person.h，这个时候就会出现循环引用的问题，就会造成无限递归，而导致无法编译通过 解决方案：.h头文件：其中一边不要使用#import引入对方的头文件，而是使用@class 类名；来标注这是一个类，这样子就可以在不引入对方头文件的情况下告诉编译器这是一个类【@class Book;（有分号）】.m头文件：在.m文件中再# import对方的头文件就可以使用了【#import “Book.h”】(其实不引入也可以，只是会有警告) @class与@import的区别：1）#import是将指定的文件的内容拷贝到写指令的地方2）@class并不会拷贝任何内容，只是告诉编译器这是一个类，这样编译器在编译的时候才可以知道这是一个类 当两个对象相互引用的时候（A对象的属性是B对象，B对象的属性是A对象），这个时候，如果两边都使用retain，那么就会发生内存泄露 解决方案：一端使用retain，另外一端使用assign，使用assign的那一端在dealloc中不再需要release了 注意：这里有一个很特别的点[p1 read];要放在[b1 release];之前，否则会出现僵尸对象","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://example.com/tags/Objective-C/"}]},{"title":"自动释放池：","slug":"编程语言/Objective-C/自动释放池：","date":"2019-08-12T16:00:00.000Z","updated":"2021-03-02T02:12:43.000Z","comments":true,"path":"2019/08/13/编程语言/Objective-C/自动释放池：/","link":"","permalink":"http://example.com/2019/08/13/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Objective-C/%E8%87%AA%E5%8A%A8%E9%87%8A%E6%94%BE%E6%B1%A0%EF%BC%9A/","excerpt":"","text":"原理：存入到自动释放池中的对象，在自动释放池被销毁的时候，会自动调用存储在该自动释放池中的所有对象的release方法 可以解决的问题：将创建的对象，存入到自动释放池之中，就不再需要手动的release这个对象了，因为池子销毁的时候，就会自动的调用池中所有的对象的release 如何创建自动释放池：@autoreleasepool{ }这对大括弧代表这个自动释放池的范围 如何将对象存储到自动释放池之中：在自动释放池之中调用对象的autorelease方法，就会将这个对象存入到当前自动释放池之中 这个autorelease方法返回的是对象本身，所以我们可以这么写：@autoreleasepool{ Person *p1=[[[Person alloc] init] autorelease];}这个时候，当这个自动释放池执行完毕之后，就会立即为这个自动释放池中的对象发送一条release消息 八大注意：1）只有在自动释放池中调用了对象的autorelease方法，这个对象才会被存储到这个自动释放池之中，如果只是将对象的创建代码写在自动释放池之中，而没有调用对象的autorelease方法，是不会将这个对象存储到这个自动释放池之中的2）对象的创建可以在自动释放池的外面，在自动释放池之中调用对象的autorelease方法，就可以将这个对象存储到这个自动释放池之中3）如果对象的autorelease方法的调用放在自动释放池的外面，是无法将其存储到这个自动释放池之中的，autorelease的调用只有放在自动释放池之中，才可以将其存储到自动释放池4）当自动释放池结束的时候，仅仅是对存储在自动释放池中的对象发送一条release消息，而不是销毁对象5）如果在自动释放池中调用同一个对象的autorelease方法多次，就会将对象存储多次到自动释放池之中，在自动释放池结束的时候，会为对象发送多条release消息，那么这个时候就会出现僵尸对象错误6）如果在自动释放池中调用了存储到自动释放池中的对象的release方法，在自动释放池结束的时候，还会再调用对象的release方法，这个时候就有可能会造成野指针操作（也可以调用存储在自动释放池中的对象的retain方法）7）将对象存储到自动释放池并不会使对象的引用计数器+1，所以其好处就是：创建对象将对象存储在自动释放池，就不需要再写一个release了8）自动释放池可以嵌套，调用对象的autorelease方法，会将对象加入到当前自动释放池之中，只有在当前自动释放池结束的时候才会向对象发送release消息","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://example.com/tags/Objective-C/"}]},{"title":"类方法的规范：","slug":"编程语言/Objective-C/类方法的规范：","date":"2019-08-11T16:00:00.000Z","updated":"2021-03-02T02:12:31.000Z","comments":true,"path":"2019/08/12/编程语言/Objective-C/类方法的规范：/","link":"","permalink":"http://example.com/2019/08/12/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Objective-C/%E7%B1%BB%E6%96%B9%E6%B3%95%E7%9A%84%E8%A7%84%E8%8C%83%EF%BC%9A/","excerpt":"","text":"一般情况下，要求提供与自定义构造方法相同功能的类方法，这样可以快速的创建一个对象；使用类方法创建的对象，要求这个对象在方法中就已经被autorelease过了，这样，我们只要在自动释放池中调用类方法来创建对象，那么创建的对象就会被自动的加入到自动释放池中","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://example.com/tags/Objective-C/"}]},{"title":"ARC机制概述","slug":"编程语言/Objective-C/ARC机制概述","date":"2019-08-10T16:00:00.000Z","updated":"2021-03-02T02:12:17.000Z","comments":true,"path":"2019/08/11/编程语言/Objective-C/ARC机制概述/","link":"","permalink":"http://example.com/2019/08/11/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Objective-C/ARC%E6%9C%BA%E5%88%B6%E6%A6%82%E8%BF%B0/","excerpt":"","text":"Automatic Reference Counting，自动引用计数，即ARC，系统自动的帮助我们去计算对象的引用计数器的值 在程序中使用ARC非常简单，只需要向往常那样编写代码，只不过永远不要写retain，release，autorelease这三个关键字就好，永远不要手动的调用dealloc【在dealloc方法中不要调用父类dealloc】，这是ARC最基本的原则，当ARC开启时，编译器就会自动的在合适的地方插入retain，release，autorelease代码，编译器自动为对象做引用计数 ARC机制下，对象何时被释放：本质：对象的引用计数器为0的时候，自动释放表象：只要没有强指针指向这个对象，这个对象就会立即回收 强指针与弱指针： 强指针：默认情况下，我们声明一个指针，这个指针就是一个强指针，我们也可以用__strong(两个下划线)来显示的声明这是一个强指针 弱指针：使用__weak标识的指针就叫做弱指针 无论是强指针还是弱指针都是指针，都可以用来存储地址，这一点没有任何区别，都可以通过这个指针访问对象的成员；唯一的区别就是在ARC模式下，它们用来作为回收对象的基准：如果一个对象没有任何强类型的指针指向这个对象的时候，对象就会被立即释放","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://example.com/tags/Objective-C/"}]},{"title":"ARC下的单个对象的内存管理：","slug":"编程语言/Objective-C/ARC下的单个对象的内存管理：","date":"2019-08-09T16:00:00.000Z","updated":"2021-03-02T02:12:04.000Z","comments":true,"path":"2019/08/10/编程语言/Objective-C/ARC下的单个对象的内存管理：/","link":"","permalink":"http://example.com/2019/08/10/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Objective-C/ARC%E4%B8%8B%E7%9A%84%E5%8D%95%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%9A/","excerpt":"","text":"1）当指向对象的所有的强指针被回收的时候，对象就会被立即回收2）当所有指向对象的强指针赋值为nil的时候，对象就会被立即回收 注意：不能创建对象用一个弱指针存储这个对象的指针，这样的话，刚创建出来的对象，就没有任何强指针指向，创建出来就被回收 在ARC机制下，当对象被回收的时候，原来指向这个对象的弱指针会被自动设置为nil","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://example.com/tags/Objective-C/"}]},{"title":"property另外两个参数：","slug":"编程语言/Objective-C/@property另外两个参数：","date":"2019-08-08T16:00:00.000Z","updated":"2021-03-02T02:11:50.000Z","comments":true,"path":"2019/08/09/编程语言/Objective-C/@property另外两个参数：/","link":"","permalink":"http://example.com/2019/08/09/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Objective-C/@property%E5%8F%A6%E5%A4%96%E4%B8%A4%E4%B8%AA%E5%8F%82%E6%95%B0%EF%BC%9A/","excerpt":"","text":"在ARC的机制下，@property参数不能使用retain，因为retain代表生成的setter方法是MRC的标准内存管理代码 ARC机制下关注的重点：当一个类的属性是一个OC对象的时候，这个属性应该声明为强类型的还是弱类型的，很明显应该声明为强类型的【人未死车已报废】 如何控制@property生成的私有属性是一个强类型的还是一个弱类型的？使用参数：strong（默认值）和weak 使用建议：1）在ARC机制下，如果属性的类型是OC对象类型的，绝大多数场景下使用strong2）在ARC机制下，如果属性的类型不是OC对象类型的，使用assign3）strong和weak都是应用在属性的类型是OC对象的时候","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://example.com/tags/Objective-C/"}]},{"title":"ARC机制下的循环引用：","slug":"编程语言/Objective-C/ARC机制下的循环引用：","date":"2019-08-07T16:00:00.000Z","updated":"2021-03-02T02:11:38.000Z","comments":true,"path":"2019/08/08/编程语言/Objective-C/ARC机制下的循环引用：/","link":"","permalink":"http://example.com/2019/08/08/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Objective-C/ARC%E6%9C%BA%E5%88%B6%E4%B8%8B%E7%9A%84%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%EF%BC%9A/","excerpt":"","text":"在ARC机制下，当两个对象相互引用的时候，如果两边都使用strong，那么就会出现内存泄漏，解决方案：一端使用strong，一端使用weak","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://example.com/tags/Objective-C/"}]},{"title":"MRC、ARC兼容与转换：","slug":"编程语言/Objective-C/MRC、ARC兼容与转换：","date":"2019-08-06T16:00:00.000Z","updated":"2021-03-02T02:11:18.000Z","comments":true,"path":"2019/08/07/编程语言/Objective-C/MRC、ARC兼容与转换：/","link":"","permalink":"http://example.com/2019/08/07/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Objective-C/MRC%E3%80%81ARC%E5%85%BC%E5%AE%B9%E4%B8%8E%E8%BD%AC%E6%8D%A2%EF%BC%9A/","excerpt":"","text":"兼容：如果程序使用的是ARC机制开发的，但是其中某个类使用的是MRC，这个时候双击使用MRC的那个文件输入命令：-fno-obj-arc MRC转换为ARC：Edit——&gt;Convert——&gt;To Objective-C ARC…","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://example.com/tags/Objective-C/"}]},{"title":"分类/类别/类目(category)：","slug":"编程语言/Objective-C/分类类别类目(category)：","date":"2019-08-05T16:00:00.000Z","updated":"2021-03-02T02:10:20.000Z","comments":true,"path":"2019/08/06/编程语言/Objective-C/分类类别类目(category)：/","link":"","permalink":"http://example.com/2019/08/06/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Objective-C/%E5%88%86%E7%B1%BB%E7%B1%BB%E5%88%AB%E7%B1%BB%E7%9B%AE(category)%EF%BC%9A/","excerpt":"","text":"让一个类占多个模块，将功能相似的方法定义在同一个模块中 分类的使用：如果要访问分类中定义的成员，就要把分类的头文件引进来 分类的作用：1）将一个类分为多个模块2）为一个已经存在的类添加方法（扩展一个类） 使用分类的注意事项：1）分类只能增加方法，不能增加属性2）在分类之中可以写@property，但是不会自动生成私有属性，也不会自动生成getter、setter的实现，只会生成getter、setter的声明，所以需要自己写getter和setter的实现，也需要自己定义属性，这个属性必须在本类中3）在分类的方法实现中不可以直接访问本类的真私有属性（定义在本类的@implementation之中，@interface中的可以访问），但是可以通过调用本类的getter和setter来访问属性4）分类中可以存在和本类同名的方法，当分类中有和本类中同名的方法的时候，优先调用分类的方法，哪怕没有引入分类的头文件；如果多个分类中有相同的方法，优先调用最后编译的分类","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://example.com/tags/Objective-C/"}]},{"title":"非正式协议：","slug":"编程语言/Objective-C/非正式协议：","date":"2019-08-04T16:00:00.000Z","updated":"2021-03-02T02:10:03.000Z","comments":true,"path":"2019/08/05/编程语言/Objective-C/非正式协议：/","link":"","permalink":"http://example.com/2019/08/05/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Objective-C/%E9%9D%9E%E6%AD%A3%E5%BC%8F%E5%8D%8F%E8%AE%AE%EF%BC%9A/","excerpt":"","text":"为系统自带的类写分类，这个就叫做非正式协议 分类的作用：1）将一个类分为多个模块2）为一个已经存在的类添加方法（扩展一个类） 如果想为NSString写一个方法：（此方法无参数，因为NSString本身就是字符串）","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://example.com/tags/Objective-C/"}]},{"title":"知识点补充：","slug":"编程语言/Objective-C/知识点补充：","date":"2019-08-03T16:00:00.000Z","updated":"2021-03-02T02:09:46.000Z","comments":true,"path":"2019/08/04/编程语言/Objective-C/知识点补充：/","link":"","permalink":"http://example.com/2019/08/04/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Objective-C/%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A1%A5%E5%85%85%EF%BC%9A/","excerpt":"","text":"ARC机制与垃圾回收机制(GC)的区别： GC：程序在运行期间有一个东西叫做垃圾回收器，不断的扫描堆中的对象是否无人使用，若无人使用则回收 ARC：不是运行时，而是在编译的时候就在合适的地方插入retain，release……..插入的代码足以让对象无人使用的时候引用计数器为0，则回收 此程序main函数中第一行宝马的引用计数器应为1，第二行执行后p1为1，宝马这时应该为2，但是此程序实际上宝马的引用计数器不是2，还是1；错误原因在于构造方法_car=car;这一句，直接将car赋值给属性_car，并没有做retain，release，这一行应该改为self.car=car;","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://example.com/tags/Objective-C/"}]},{"title":"延展(Extension)：","slug":"编程语言/Objective-C/延展(Extension)：","date":"2019-08-02T16:00:00.000Z","updated":"2021-03-02T02:09:29.000Z","comments":true,"path":"2019/08/03/编程语言/Objective-C/延展(Extension)：/","link":"","permalink":"http://example.com/2019/08/03/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Objective-C/%E5%BB%B6%E5%B1%95(Extension)%EF%BC%9A/","excerpt":"","text":"1）是一个特殊的分类，所以延展也是类的一部分2）特殊之处：没有名字；只有声明没有实现，和本类共享一个实现 语法： @interface 本类名（） @end 没有实现，和本类共享一个实现 延展和分类的区别：1）分类有名字，延展没有名字，是一个匿名的分类2）每一个分类都有单独的声明和实现，而延展只有声明，没有单独的实现，和本类共享一个实现3）分类中只能新增方法，而延展中任意的成员都可以写4）分类中可以写@property，但是只会生成getter、setter的声明；延展中写@property，会自动生成私有属性，也会生成getter、setter的声明和实现 延展的应用场景：1）要为类写一个私有的@property，生成的getter、setter方法只能在类的内部访问，不能在外部访问【@property生成私有属性、生成getter、setter的实现，不要声明】2）延展不会独占一个文件，都是将延展直接写在本类的实现文件中，这个时候写在延展中的成员，就相当于是这个类的私有成员，只能在本类的实现中访问，外部不能访问 注意：1）如果想要为类写一个真私有属性，虽然我们可以定义在@implementation之中，但是不要这么写，这样很不规范，写一个延展，将这个私有属性定义在延展中2）如果要为类写一个私有方法，建议将声明写在延展中，实现写在本类的实现中，提高代码的阅读性3）如果想要为类写一个私有的@property，就直接写在延展中就可以了4）延展天生就是来私有化类的成员的，如果类的成员只希望在类的内部访问，那么就将其定义在延展中，如果类的成员允许被外界访问，定义在本类的@interface中","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://example.com/tags/Objective-C/"}]},{"title":"block的基本使用：","slug":"编程语言/Objective-C/block的基本使用：","date":"2019-08-01T16:00:00.000Z","updated":"2021-03-02T02:09:17.000Z","comments":true,"path":"2019/08/02/编程语言/Objective-C/block的基本使用：/","link":"","permalink":"http://example.com/2019/08/02/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Objective-C/block%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%EF%BC%9A/","excerpt":"","text":"1）block是一个数据类型，我们可以声明一个block类型的变量2）不同类型的变量中可以存储不同类型的数据，block类型的变量中专门存储一段代码，这段代码可以有参数，可以有返回值 Block变量的声明：1）虽然block变量中是用来存储一段代码的，但是一个block变量中并不是任意的一段代码都可以存进去的，而是有限定的；也就是说，声明block变量的时候，必须要指定这个block变量存储的代码是否有参数，是否有返回值，一旦指定以后，这个block变量中就只能存储这样的代码段了2）语法：返回值类型 (^block变量的名称)(参数列表); 初始化block变量：1）原理：写一个符合block要求的代码段，存储到block变量中就可以了2）代码段的书写格式： ^返回值类型(参数类型)&#123; 代码段; &#125;; 如何执行存储在block变量中的代码段：语法格式：block变量名();【有参数就传参数，有返回值就接】","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://example.com/tags/Objective-C/"}]},{"title":"block的简写：","slug":"编程语言/Objective-C/block的简写：","date":"2019-07-31T16:00:00.000Z","updated":"2021-03-02T02:09:05.000Z","comments":true,"path":"2019/08/01/编程语言/Objective-C/block的简写：/","link":"","permalink":"http://example.com/2019/08/01/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Objective-C/block%E7%9A%84%E7%AE%80%E5%86%99%EF%BC%9A/","excerpt":"","text":"1）如果我们写的代码段没有返回值，那么代码段的void可以省略【既没有参数也没有返回值，代码段的void和小括弧都省略，只写一个^】注意：这里说的是代码段的返回值如果是void可以省略，声明block变量的返回值无论是什么都不可以省略2）如果我们写的代码段没有参数，那么代码段的小括弧可以省略3）声明block变量的时候，如果有指定参数，可以只写参数的类型而不写参数的名称注意：这个地方我们说的是声明block变量的时候，代码段的类型和名称都要写4）无论代码段是否有返回值，在写代码的时候，可以不写返回值类型，省略；如果在写代码段的时候，省略了返回值，这个时候系统会自动的确定返回值的类型，如果代码段中没有返回任何数据，那么它会认为这个代码段是没有返回值的，如果代码段中有返回数据，返回的数据是什么类型它就会认为这个代码段是什么类型 建议：仍然按照我们最标准的写法来写block变量和block代码段，因为这样可以提高代码的阅读性","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://example.com/tags/Objective-C/"}]},{"title":"简化block变量的复杂定义：","slug":"编程语言/Objective-C/简化block变量的复杂定义：","date":"2019-07-30T16:00:00.000Z","updated":"2021-03-02T02:08:53.000Z","comments":true,"path":"2019/07/31/编程语言/Objective-C/简化block变量的复杂定义：/","link":"","permalink":"http://example.com/2019/07/31/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Objective-C/%E7%AE%80%E5%8C%96block%E5%8F%98%E9%87%8F%E7%9A%84%E5%A4%8D%E6%9D%82%E5%AE%9A%E4%B9%89%EF%BC%9A/","excerpt":"","text":"定义block变量的时候，类型很长： Typedef的使用场景：将一个长类型定义为一个短类型","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://example.com/tags/Objective-C/"}]},{"title":"关于block块访问外部变量的值的问题","slug":"编程语言/Objective-C/关于block块访问外部变量的值的问题","date":"2019-07-29T16:00:00.000Z","updated":"2021-03-02T02:08:42.000Z","comments":true,"path":"2019/07/30/编程语言/Objective-C/关于block块访问外部变量的值的问题/","link":"","permalink":"http://example.com/2019/07/30/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Objective-C/%E5%85%B3%E4%BA%8Eblock%E5%9D%97%E8%AE%BF%E9%97%AE%E5%A4%96%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E5%80%BC%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"","text":"1）在block代码块的内部可以取定义在外部的变量的值，包括定义在外部的局部变量和全局变量2）在block代码块的内部可以修改全局变量的值，但是不能修改定义在外部的局部变量的值3）如果你希望我们定义的局部变量可以允许在block代码的内部去修改，那么就为这个局部变量加一个__block(两个下划线)的修饰符","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://example.com/tags/Objective-C/"}]},{"title":"block作为函数的参数：","slug":"编程语言/Objective-C/block作为函数的参数：","date":"2019-07-28T16:00:00.000Z","updated":"2021-03-02T02:07:12.000Z","comments":true,"path":"2019/07/29/编程语言/Objective-C/block作为函数的参数：/","link":"","permalink":"http://example.com/2019/07/29/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Objective-C/block%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0%EF%BC%9A/","excerpt":"","text":"定义： 调用：1）如果要调用的函数的参数是block类型的，那么要求在调用的时候传入一个和形参block要求的代码段2）调用的时候，可以先将代码段存储到一个block变量中，然后再传递这个block变量；也可以直接将符合要求的代码段写在小括弧中传递3）小技巧：通过Xcode提示可以快速的生成block代码段的框架 将block作为函数的参数可以实现什么效果：可以将调用者自己写的一段代码传递到函数的内部去执行","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://example.com/tags/Objective-C/"}]},{"title":"应用实例：","slug":"编程语言/Objective-C/应用实例：","date":"2019-07-27T16:00:00.000Z","updated":"2021-03-02T02:06:52.000Z","comments":true,"path":"2019/07/28/编程语言/Objective-C/应用实例：/","link":"","permalink":"http://example.com/2019/07/28/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Objective-C/%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B%EF%BC%9A/","excerpt":"","text":"写一个数组类，给这个数组类提供一个方法，将一个国家字符串数组进行排序： 比较j和j+1这两个字符串，我们直接比较的是字母顺序，但是这么写的话就写死了 比较这两个字符串的大小，不要方法的内部自己写代码去比，因为不管写什么代码都会写死的，让调用者自己写一段代码来比较这两个字符串的大小 当方法的内部需要执行一个功能，但是这个功能具体的实现函数的内部不确定，那么这个时候，就使用block让调用者将这个功能的具体实现传递进来","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://example.com/tags/Objective-C/"}]},{"title":"block作为函数的返回值","slug":"编程语言/Objective-C/block作为函数的返回值","date":"2019-07-26T16:00:00.000Z","updated":"2021-03-02T02:06:40.000Z","comments":true,"path":"2019/07/27/编程语言/Objective-C/block作为函数的返回值/","link":"","permalink":"http://example.com/2019/07/27/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Objective-C/block%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC/","excerpt":"","text":"当将block作为函数的返回值的时候，返回值的类型就必须要使用typedef定义的短类型","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://example.com/tags/Objective-C/"}]},{"title":"block与函数的异同：","slug":"编程语言/Objective-C/block与函数的异同：","date":"2019-07-25T16:00:00.000Z","updated":"2021-03-02T02:06:28.000Z","comments":true,"path":"2019/07/26/编程语言/Objective-C/block与函数的异同：/","link":"","permalink":"http://example.com/2019/07/26/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Objective-C/block%E4%B8%8E%E5%87%BD%E6%95%B0%E7%9A%84%E5%BC%82%E5%90%8C%EF%BC%9A/","excerpt":"","text":"相同点：都是封装一段代码 不同的：1）block是一个数据类型，可以声明block类型的变量；而函数就只是函数2）block可以作为函数的参数，而函数不能直接作为函数的参数","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://example.com/tags/Objective-C/"}]},{"title":"协议的基本使用(protocol)：","slug":"编程语言/Objective-C/协议的基本使用(protocol)：","date":"2019-07-24T16:00:00.000Z","updated":"2021-03-02T02:06:14.000Z","comments":true,"path":"2019/07/25/编程语言/Objective-C/协议的基本使用(protocol)：/","link":"","permalink":"http://example.com/2019/07/25/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Objective-C/%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8(protocol)%EF%BC%9A/","excerpt":"","text":"作用：专门用来声明一大堆方法（不能声明属性，也不能实现方法，只能用来写方法的声明），只要某个类遵守了这个协议，就相当于拥有这个协议中的所有的方法声明，而不用自己去定义 协议的声明： @protocol 协议名称 方法的声明; @end 在协议中，只能用来声明方法，就是专门用来写方法声明的，就是用来被类遵守的 如果想要让一个类拥有协议中定义的所有的方法声明，那么就让这个类遵守这个协议，类只要遵守一个协议，那么这个类就拥有了这个协议中定义的所有的方法的声明 @interface 类名 ： 父类名 &lt;协议名称&gt; @end ：表示继承&lt;&gt;表示遵守的协议 这个类只是拥有了这个协议中的方法的声明而已，没有实现，所以这个类还应该实现协议中的方法 如果类不实现协议中的方法，其实也不会报错，编译器只是会报警告；但是当创建对象，来调用这个没有实现的协议中的方法的时候，就会报错 类是单继承，但是协议可以多遵守@interface 类名：父类名 &lt;协议名称1，协议名称2……&gt; @end","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://example.com/tags/Objective-C/"}]},{"title":"required与optional","slug":"编程语言/Objective-C/@required与@optional","date":"2019-07-23T16:00:00.000Z","updated":"2021-03-02T02:06:00.000Z","comments":true,"path":"2019/07/24/编程语言/Objective-C/@required与@optional/","link":"","permalink":"http://example.com/2019/07/24/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Objective-C/@required%E4%B8%8E@optional/","excerpt":"","text":"当一个类遵守了一份协议，这个类只是拥有了这个协议中的方法的声明而已，没有实现，所以这个类还应该实现协议中的方法；如果类不实现协议中的方法，其实也不会报错，编译器只是会报警告；但是当创建对象，来调用这个没有实现的协议中的方法的时候，就会报错 这两个修饰符是专门用来修饰协议中的方法的 在协议中，如果方法的声明被@required修饰，那么遵守这个协议的类必须要实现这个方法，否则编译器会发出警告；如果方法的声明被@optional修饰，那么遵守这个协议的类如果不实现这个方法，编译器也不会发出警告 这两个关键字的主要作用：在于程序员沟通，告诉遵守协议的类，哪些方法是必须要实现的（@required必须实现，@optional可实现可不实现），因为这些方法我会调用 默认的是：@required","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://example.com/tags/Objective-C/"}]},{"title":"协议之间的继承：","slug":"编程语言/Objective-C/协议之间的继承：","date":"2019-07-22T16:00:00.000Z","updated":"2021-03-02T02:05:41.000Z","comments":true,"path":"2019/07/23/编程语言/Objective-C/协议之间的继承：/","link":"","permalink":"http://example.com/2019/07/23/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Objective-C/%E5%8D%8F%E8%AE%AE%E4%B9%8B%E9%97%B4%E7%9A%84%E7%BB%A7%E6%89%BF%EF%BC%9A/","excerpt":"","text":"协议与协议之间可以相互继承 语法： @protocol 协议名称 &lt;父协议名称&gt; @end 效果：子协议中不仅有自己的方法的声明，还有父协议中的所有的方法的声明；如果某个类遵守了某份协议，那么这个类就拥有了这个协议和这个协议的父协议中的所有方法的声明 类的名称可以和协议的名称一致：在Foundation框架中，有一个类叫做NSObject，是所有OC类的基类在Foundation框架中，有一个协议叫做NSObject NSObject协议被NSObject类遵守，所以，NSObject协议中的所有的方法全部的OC类都拥有了，这么说，所有的OC类都遵守了NSObject协议，NSObject协议也叫做基协议 写协议的规范：要求所有的协议都必须直接的或间接的从NSObject基协议继承","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://example.com/tags/Objective-C/"}]},{"title":"协议的类型限制(代理设计模式)：","slug":"编程语言/Objective-C/协议的类型限制(代理设计模式)：","date":"2019-07-21T16:00:00.000Z","updated":"2021-03-02T02:05:29.000Z","comments":true,"path":"2019/07/22/编程语言/Objective-C/协议的类型限制(代理设计模式)：/","link":"","permalink":"http://example.com/2019/07/22/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Objective-C/%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%B1%BB%E5%9E%8B%E9%99%90%E5%88%B6(%E4%BB%A3%E7%90%86%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F)%EF%BC%9A/","excerpt":"","text":"NSObject&lt;协议名称1，协议名称2….&gt; *指针名;Id&lt;协议名称1，协议名称2….&gt; 指针名; 这个时候，这个指针可以指向遵守了指定协议的任意对象，如果指定的对象没有遵守这个协议，会报一个警告【多个协议必须同时遵守，只遵守一个也会报警告】 为什么要做协议的类型限制：1）遵守了某个协议的类，，就相当于这个类拥有了这个协议所定义的行为2）因为我要调用这个对象中的协议方法，只有类遵守了协议，这个类中才一定会有协议方法","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://example.com/tags/Objective-C/"}]},{"title":"框架","slug":"编程语言/Objective-C/框架","date":"2019-07-20T16:00:00.000Z","updated":"2021-03-02T02:05:17.000Z","comments":true,"path":"2019/07/21/编程语言/Objective-C/框架/","link":"","permalink":"http://example.com/2019/07/21/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Objective-C/%E6%A1%86%E6%9E%B6/","excerpt":"","text":"框架：苹果或者第三方事先写好了一些功能很厉害的类，把这些类交给我们使用，这些类的集合我们叫做框架 Foundation框架：是一个包，这里面有很多类、函数、定义了一些数据类型，这个框架中的类都是一些最基础的类(NSString、NSObject)，其他的框架都是基于Foundation框架的","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://example.com/tags/Objective-C/"}]},{"title":"NSString类：","slug":"编程语言/Objective-C/NSString类：","date":"2019-07-19T16:00:00.000Z","updated":"2021-03-02T02:05:05.000Z","comments":true,"path":"2019/07/20/编程语言/Objective-C/NSString类：/","link":"","permalink":"http://example.com/2019/07/20/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Objective-C/NSString%E7%B1%BB%EF%BC%9A/","excerpt":"","text":"NSString是一个数据类型，保存OC字符串的，实际上NSString的本质是一个类使用这种方式创建的字符串是一个空的字符@“” 当我们调用NSString的类方法来创建对象的时候，创建的字符串对象是存储在堆区 OC提供了一种更为快速的创建字符串对象的方式，使用前缀@ @“jack”;本质上这是一个NSString对象，这个NSString对象中存储的是”jack”这个字符串，这个字符串对象是存储在常量区（数据段）的 NSString的恒定性：当在内存中创建一个字符串对象以后，这个字符串对象的内容就无法更改，当我们重新为字符串指针初始化值的时候，并不是修改原来的字符串对象，而是重新的创建一个字符串对象，将这个字符串对象的地址重新赋值给字符串指针变量 当系统准备要在内存中创建字符串对象的时候，会先检查内存中是否有相同内容的字符串对象，如果有直接指向，如果没有才会重新创建 存储在常量区的数据不会被回收，所以存储在常量区的字符串对象也不会被回收【堆区也一样】","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://example.com/tags/Objective-C/"}]},{"title":"字符串对象常用方法：","slug":"编程语言/Objective-C/字符串对象常用方法：","date":"2019-07-18T16:00:00.000Z","updated":"2021-03-02T02:04:54.000Z","comments":true,"path":"2019/07/19/编程语言/Objective-C/字符串对象常用方法：/","link":"","permalink":"http://example.com/2019/07/19/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Objective-C/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AF%B9%E8%B1%A1%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%EF%BC%9A/","excerpt":"","text":"1）使用拼接的方式创建一个NSString对象2）得到字符串的长度3）得到字符串中指定下标的字符4）判断两个字符串的内容是否相等【不能使用==去比较，因为==比较的是字符串指针变量的值，而我们要比的是两个字符串指针指向的字符串对象的内容是否相同】5）将C语言的字符串转换为OC字符串对象6）将OC字符串对象转换为C语言的字符串 7）将字符串内容写入到磁盘上的某一个文件之中 参数1:将字符串内容写入到哪一个文件之中，写上文件的路径 参数2:YES，先将内容写入到一个临时文件，如果成功再将这个文件搬到指定的目录【安全，效率低】；NO，直接将内容写入到指定的文件【不安全，效率高】；推荐使用NO 参数3:指定写入的时候使用的编码 参数4:二级指针，要传递一个NSError指针的地址，如果写入成功，这个指针的值就是nil，如果写入失败，这个指针就会指向一个错误的对象，这个对象描述了发生错误的信息【这个对象的localizedDescription方法可以得到发生错误的简要信息】，所以我们要判断是否写入成功，也可以判断这个指针的值是否为nil 如果不想知道发生错误的原因，那么第四个参数给nil就可以了 返回值是BOOL类型的，代表是否写入成功 8）从磁盘上的文件中读取文件中的内容","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://example.com/tags/Objective-C/"}]},{"title":"使用URL来读写字符串数据","slug":"编程语言/Objective-C/使用URL来读写字符串数据","date":"2019-07-17T16:00:00.000Z","updated":"2021-03-02T02:04:42.000Z","comments":true,"path":"2019/07/18/编程语言/Objective-C/使用URL来读写字符串数据/","link":"","permalink":"http://example.com/2019/07/18/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Objective-C/%E4%BD%BF%E7%94%A8URL%E6%9D%A5%E8%AF%BB%E5%86%99%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%95%B0%E6%8D%AE/","excerpt":"","text":"优势：既可以读写本地磁盘文件，还可以读写网页文件、ftp服务器上的文件","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://example.com/tags/Objective-C/"}]},{"title":"字符串的比较：","slug":"编程语言/Objective-C/字符串的比较：","date":"2019-07-16T16:00:00.000Z","updated":"2021-03-02T02:04:29.000Z","comments":true,"path":"2019/07/17/编程语言/Objective-C/字符串的比较：/","link":"","permalink":"http://example.com/2019/07/17/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Objective-C/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%AF%94%E8%BE%83%EF%BC%9A/","excerpt":"","text":"1）2）忽略大小写的比较3）只比较字符串中数字的大小【格式相同】","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://example.com/tags/Objective-C/"}]},{"title":"字符串的开始和结束判断：","slug":"编程语言/Objective-C/字符串的开始和结束判断：","date":"2019-07-15T16:00:00.000Z","updated":"2021-03-02T02:04:15.000Z","comments":true,"path":"2019/07/16/编程语言/Objective-C/字符串的开始和结束判断：/","link":"","permalink":"http://example.com/2019/07/16/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Objective-C/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%BC%80%E5%A7%8B%E5%92%8C%E7%BB%93%E6%9D%9F%E5%88%A4%E6%96%AD%EF%BC%9A/","excerpt":"","text":"判断字符串是否以指定的字符串开头： 判断字符串是否以指定的字符串结尾：","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://example.com/tags/Objective-C/"}]},{"title":"字符串的搜索：","slug":"编程语言/Objective-C/字符串的搜索：","date":"2019-07-14T16:00:00.000Z","updated":"2021-03-02T02:04:03.000Z","comments":true,"path":"2019/07/15/编程语言/Objective-C/字符串的搜索：/","link":"","permalink":"http://example.com/2019/07/15/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Objective-C/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%90%9C%E7%B4%A2%EF%BC%9A/","excerpt":"","text":"在主串中搜索子串： 1）这个方法是从前往后搜索，第一次匹配的子串： 2）从后往前搜索NSRange结构体：是Foundation框架中定义的一个结构体，结构体变量一般用来表示一段范围 声明并初始化结构体变量的方式：1）2）3）4）Foundation框架中定义了一个函数，这个函数可以快速的创建一个NSRange结构体变量5）Foundation框架中定义了一个函数，可以将一个NSRange结构体变量转换为NSString","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://example.com/tags/Objective-C/"}]},{"title":"字符串的截取：","slug":"编程语言/Objective-C/字符串的截取：","date":"2019-07-13T16:00:00.000Z","updated":"2021-03-02T02:03:36.000Z","comments":true,"path":"2019/07/14/编程语言/Objective-C/字符串的截取：/","link":"","permalink":"http://example.com/2019/07/14/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Objective-C/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%88%AA%E5%8F%96%EF%BC%9A/","excerpt":"","text":"1）从指定的下标处一直截取到最后2）从第0个开始截取指定的个数3）截取指定的一段范围","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://example.com/tags/Objective-C/"}]},{"title":"字符串的替换：","slug":"编程语言/Objective-C/字符串的替换：","date":"2019-07-12T16:00:00.000Z","updated":"2021-03-02T02:03:24.000Z","comments":true,"path":"2019/07/13/编程语言/Objective-C/字符串的替换：/","link":"","permalink":"http://example.com/2019/07/13/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Objective-C/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9B%BF%E6%8D%A2%EF%BC%9A/","excerpt":"","text":"将字符串中的第一个参数替换为第二个参数（全部替换）这个方法还可以做删除，原理是将其替换为@“”","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://example.com/tags/Objective-C/"}]},{"title":"字符串的类型转换：","slug":"编程语言/Objective-C/字符串的类型转换：","date":"2019-07-11T16:00:00.000Z","updated":"2021-03-02T02:03:12.000Z","comments":true,"path":"2019/07/12/编程语言/Objective-C/字符串的类型转换：/","link":"","permalink":"http://example.com/2019/07/12/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Objective-C/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%EF%BC%9A/","excerpt":"","text":"注意：从头开始转换，能转换多少就是多少，当遇到不能转换的时候就停止转换","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://example.com/tags/Objective-C/"}]},{"title":"字符串的其他常用方法：","slug":"编程语言/Objective-C/字符串的其他常用方法：","date":"2019-07-10T16:00:00.000Z","updated":"2021-03-02T02:03:00.000Z","comments":true,"path":"2019/07/11/编程语言/Objective-C/字符串的其他常用方法：/","link":"","permalink":"http://example.com/2019/07/11/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Objective-C/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%85%B6%E4%BB%96%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%EF%BC%9A/","excerpt":"","text":"1）去掉字符串前后的空格，中间的空格无法去掉2）将字符串转换为大写或小写3）去掉字符串前后的小写字母或大写字母4）去掉头尾指定的字符串","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://example.com/tags/Objective-C/"}]},{"title":"NSMutableString：","slug":"编程语言/Objective-C/NSMutableString：","date":"2019-07-09T16:00:00.000Z","updated":"2021-03-02T02:02:48.000Z","comments":true,"path":"2019/07/10/编程语言/Objective-C/NSMutableString：/","link":"","permalink":"http://example.com/2019/07/10/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Objective-C/NSMutableString%EF%BC%9A/","excerpt":"","text":"会耗费很长的时间，每次循环的时候都会创建一个新的字符串对象，因为字符串的恒定性 NSMutableString是Foundation框架中的一个类，从NSString继承，所以NSMutableString对象是用来存储字符串数据的，NSMutableString在父类NSString的基础之上做了扩展，存储在NSMutableString对象中的字符串数据可以更改，具备可变性 往可变字符串对象中追加字符串【第二个是以拼接的方式追加】 NSMutableString从NSString继承，在使用NSString的地方完全可以使用NSMutableString 使用NSMutableString来做大批量的字符串拼接：【NSMutableString只有一个，每次修改的时候直接修改的是这个对象中的数据】 平时使用NSString，做大量拼接的时候使用NSMutableString","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://example.com/tags/Objective-C/"}]},{"title":"NSArray：","slug":"编程语言/Objective-C/NSArray：","date":"2019-07-08T16:00:00.000Z","updated":"2021-03-02T02:02:36.000Z","comments":true,"path":"2019/07/09/编程语言/Objective-C/NSArray：/","link":"","permalink":"http://example.com/2019/07/09/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Objective-C/NSArray%EF%BC%9A/","excerpt":"","text":"是Foundation框架中的一个类，这个类的对象是来存储多个数据的，具备数组的功能，所以NSArray是OC中的数组最常用的创建数组的方式：【只能存储OC对象】简写方式： 取出对应的元素的值：1）2） NSArray数组的其他常用方法：1）得到数组中元素的个数2）判断数组中是否包含指定的元素3）查找指定的元素在NSArray数组中第一次出现的下标 NSArray数组的遍历：1）使用for循环2）声明在for()中的变量叫做迭代变量【执行原理：将数组中的第一个元素的值赋值给迭代变量，执行循环体，再将数组中的第二个元素的值赋值给迭代变量，再执行循环体】 3）使用block遍历","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://example.com/tags/Objective-C/"}]},{"title":"NSArray与字符串的两个方法：","slug":"编程语言/Objective-C/NSArray与字符串的两个方法：","date":"2019-07-07T16:00:00.000Z","updated":"2021-03-02T02:02:24.000Z","comments":true,"path":"2019/07/08/编程语言/Objective-C/NSArray与字符串的两个方法：/","link":"","permalink":"http://example.com/2019/07/08/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Objective-C/NSArray%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%96%B9%E6%B3%95%EF%BC%9A/","excerpt":"","text":"1）将数组中的元素连接起来组成一个新的字符串2）将字符串以指定的分隔符分成一个数组，每一部分就是数组的一个元素","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://example.com/tags/Objective-C/"}]},{"title":"NSMutableArray：","slug":"编程语言/Objective-C/NSMutableArray：","date":"2019-07-06T16:00:00.000Z","updated":"2021-03-02T02:01:56.000Z","comments":true,"path":"2019/07/07/编程语言/Objective-C/NSMutableArray：/","link":"","permalink":"http://example.com/2019/07/07/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Objective-C/NSMutableArray%EF%BC%9A/","excerpt":"","text":"NSMutableArray是NSArray的子类，NSMutableArray仍然是一个数组，具备NSArray数组的特点 NSMutableArray相对于父类做的扩展：NSMutableArray数组的元素可以动态的新增和删除 NSMutableArray数组的创建：1）这样创建出来的数组对象数组的元素是0，仍然是有意义的，因为我们可以动态的新增和删除元素2） 往可变数组中新增元素：1）2）3）将另外一个数组中的每一个元素添加到可变数组中 在可变数组中指定的下标中插入一个元素： 删除可变数组中指定下标的元素： 删除可变数组中所有的指定的元素： 删除指定范围中的所有指定的元素： 删除最后一个元素： 删除所有元素：","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://example.com/tags/Objective-C/"}]},{"title":"NSNumber：","slug":"编程语言/Objective-C/NSNumber：","date":"2019-07-05T16:00:00.000Z","updated":"2021-03-02T02:01:47.000Z","comments":true,"path":"2019/07/06/编程语言/Objective-C/NSNumber：/","link":"","permalink":"http://example.com/2019/07/06/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Objective-C/NSNumber%EF%BC%9A/","excerpt":"","text":"无论是NSArray还是NSMutableArray里面都只能存储OC对象，基本数据类型是无法存储的 NSNumber是Foundation框架中定义好的一个类，这个类的对象的作用就是用来包装基本数据类型的1）先将基本数据类型包装到NSNumber对象中2）再将NSNumber对象存储到NSArray数组中 简写方式：【@10代表是一个NSNumber对象，这个对象中包装的是整型的10】 如果后面的数据是一个变量，那么这个变量就必须要使用小括弧括起来：","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://example.com/tags/Objective-C/"}]},{"title":"NSDictionary与NSMutableDictionary：","slug":"编程语言/Objective-C/NSDictionary与NSMutableDictionary：","date":"2019-07-04T16:00:00.000Z","updated":"2021-03-02T02:01:35.000Z","comments":true,"path":"2019/07/05/编程语言/Objective-C/NSDictionary与NSMutableDictionary：/","link":"","permalink":"http://example.com/2019/07/05/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Objective-C/NSDictionary%E4%B8%8ENSMutableDictionary%EF%BC%9A/","excerpt":"","text":"NSArray与NSMutableArray的缺点：数组元素的下标不固定，都有可能会发生变化，无法通过下标来唯一确定数组中的元素 存储数据的时候，必须要为存储的数据取一个别名，这个别名的作用就是用来确定别名对应的数据的，这种存储数据的方式就叫做键值对的存储方式（Key-Value） 它们是数组，是以键值对的形式存储数据的，往这个数组中存储数据的同时必须要指定这个数据的别名才可以，要找到存储在这个数组中的数据，通过别名来找，而不是通过下标 NSDictionary：字典数组 创建字典数组：1）这种方式无意义2）3）简要方式 使用：1）根据别名取值：2）键值对的数量：3）4）5）遍历字典数组【字典数组中的数据无法使用下标去取，所以普通的for循环就无用了】 1.使用for in循环遍历出来的是字典数组中所有的键，再通过键取出对应的值2.使用block遍历 字典数组存储数据的原理：1）并不是按照顺序依次存储的2）存储键值对的时候，会根据键和数组的长度做一个哈希算法，算出一个下标，将这个键值对存储在该下标处3）取值的时候也是做哈希算法 与NSArray对比：1）NSArray数组的元素是按照顺序来存储的，字典数组中存储的下标是算出来的2）存储的效率NSArray要高一些如果取值的时候是把所有的数据取出来，NSArray效率高如果只是取数组中指定的几个元素，字典数组效率高 NSMutableDictionary：存储在其中的元素可以动态的新增和删除 创建可变字典数组：1）有意义2） 新增键值对：【如果键重复，后添加的就会替换原有的】 删除所有键值对：删除某一个键值对： 字典数组的信息持久化：保存到plist文件里：从plist文件中还原：","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://example.com/tags/Objective-C/"}]},{"title":"集合的内存管理：","slug":"编程语言/Objective-C/集合的内存管理：","date":"2019-07-03T16:00:00.000Z","updated":"2021-03-02T02:01:21.000Z","comments":true,"path":"2019/07/04/编程语言/Objective-C/集合的内存管理：/","link":"","permalink":"http://example.com/2019/07/04/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Objective-C/%E9%9B%86%E5%90%88%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%9A/","excerpt":"","text":"NSArray：集合NSDictionary：字典集合 在MRC模式下，将对象存储到集合之中，会为这个对象的引用计数器+1，当集合销毁的时候，就会向存储在集合中的所有对象发送一条release消息 使用@[]或者@{}创建的集合已经被autorelease过了直接调用和类同名的类方法创建的对象也是被autorelease过了 在ARC模式下，集合的元素是一个强类型的指针","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://example.com/tags/Objective-C/"}]},{"title":"NSFileManager：","slug":"编程语言/Objective-C/NSFileManager：","date":"2019-07-02T16:00:00.000Z","updated":"2021-03-02T02:01:08.000Z","comments":true,"path":"2019/07/03/编程语言/Objective-C/NSFileManager：/","link":"","permalink":"http://example.com/2019/07/03/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Objective-C/NSFileManager%EF%BC%9A/","excerpt":"","text":"NSFileManager是Foundation框架提供的一个类，用来操作磁盘上的文件和文件夹，对它们进行创建、删除、复制、拷贝、移动 NSFileManager类的对象是以单例模式创建的： 常用方法之判断：1）判断指定的文件或者文件夹在磁盘上是否真实的存在2）判断指定的路径是否真实的存储在我们的磁盘之上，并且判断这个路径是一个文件夹路径还是一个文件路径3）判断指定的文件夹或者文件是否可以读取4）判断指定的文件夹或者文件是否可以写入5）判断指定的文件夹或者文件是否可以删除 常用方法之获取信息：1）获取指定文件或者文件夹的属性信息只是想拿到文件或文件夹的大小信息：2）获取指定目录下的所有的文件和目录【所有的都拿到】3）获取指定目录下所有的子目录和文件【不包括孙子辈】 常用方法之文件/目录的创建：1）在指定的目录创建文件2）在指定的目录创建文件夹【第2个参数：YES做一路创建，NO就不会】3）拷贝文件4）移动/剪切文件—文件的重命名5）删除文件【删除的文件不会倒在废纸篓，而是直接删除】","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://example.com/tags/Objective-C/"}]},{"title":"OC中的结构体：","slug":"编程语言/Objective-C/OC中的结构体：","date":"2019-07-01T16:00:00.000Z","updated":"2021-03-02T02:00:54.000Z","comments":true,"path":"2019/07/02/编程语言/Objective-C/OC中的结构体：/","link":"","permalink":"http://example.com/2019/07/02/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Objective-C/OC%E4%B8%AD%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93%EF%BC%9A/","excerpt":"","text":"在Foundation框架中，已经定义好了一个结构体CGPoint 声明CGPoint变量并初始化的方式：4）Foundation框架中提供的函数来快速的创建一个CGPoint变量 —————————————— CGSize： CZSize声明并初始化的方式： ————————————— CGRect和NSRect： CGRect的声明和初始化：","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://example.com/tags/Objective-C/"}]},{"title":"NSValue：","slug":"编程语言/Objective-C/NSValue：","date":"2019-06-30T16:00:00.000Z","updated":"2021-03-02T02:00:42.000Z","comments":true,"path":"2019/07/01/编程语言/Objective-C/NSValue：/","link":"","permalink":"http://example.com/2019/07/01/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Objective-C/NSValue%EF%BC%9A/","excerpt":"","text":"NSRange、CGPoint、CGSize、CGRect这些都是结构体，他们的变量是无法存储到集合之中，要先将这些结构体变量存储到OC对象中，再将OC对象存储到集合之中","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://example.com/tags/Objective-C/"}]},{"title":"NSDate：","slug":"编程语言/Objective-C/NSDate：","date":"2019-06-29T16:00:00.000Z","updated":"2021-03-24T13:20:18.000Z","comments":true,"path":"2019/06/30/编程语言/Objective-C/NSDate：/","link":"","permalink":"http://example.com/2019/06/30/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Objective-C/NSDate%EF%BC%9A/","excerpt":"","text":"可以得到当前的时间，得到的是当前系统的格林威治时间（0时区），北京是东八区 转换成自己想要输出的格式：【日期转换为字符串】将字符串转换为日期： 在当前格林威治的时间基础上增加多少秒：【负数表示减少】 计算时间之差： 拿到日期的各个部分：1）2）","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://example.com/tags/Objective-C/"}]},{"title":"C++基础：","slug":"编程语言/C++语言/C++基础：","date":"2019-06-29T16:00:00.000Z","updated":"2021-03-12T03:18:06.000Z","comments":true,"path":"2019/06/30/编程语言/C++语言/C++基础：/","link":"","permalink":"http://example.com/2019/06/30/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C++%E8%AF%AD%E8%A8%80/C++%E5%9F%BA%E7%A1%80%EF%BC%9A/","excerpt":"","text":"常量：用于记录程序中不可更改的数据 C++定义常量的两种方式：1）#define 常量名 常量值2）const修饰的变量 利用sizeof关键字可以统计数据类型所占内存的大小【sizeof（数据类型/变量）】 字符型变量并不是把字符本身放到内存中存储，而是将对应的ASCII编码放入到存储单元【a-97，A-65】 水平制表符\\t：可以整齐的输出数据，水平制表符与前面的字符永远占据八个空格 反斜杠：\\ 两种风格字符串：1）C风格字符串：char 变量名[] = “字符串值”2）C++风格字符串：string 变量名 = “字符串值”【使用这种风格字符串时要包含一个头文件#include 】 Cin数据的输入Cout数据的输出 Bool类型非零即真 算术运算符【+(正号)、-(负号)、+、-、、/、%、++、- -】赋值运算符【=、+=、-=、=、/=、%=】比较运算符【==、！=、&lt;、&gt;、&lt;=、&gt;=】逻辑运算符【！非、&amp;&amp;与、||或】 前置递增先对变量进行++，再计算表达式后置递增先计算表达式，后对变量进行++ 程序流程结构：顺序结构、选择结构【if语句、三目运算符、switch语句】、循环结构【while、do while、for】 跳转语句：break、continue、goto Break出现在switch条件语句中，作用是终止case并跳出switch，出现在循环语句中，作用是跳出当前的循环语句，出现在嵌套循环中，跳出最近的内层循环语句 Continue在循环语句中跳过本次循环中余下尚未执行的语句，继续执行下一次循环【可以筛选条件，奇数输出，偶数不输出】 Goto语句：无条件的跳转语句 三目运算符：表达式1？表达式2:表达式3 在C++中三目运算符返回的是变量，可以继续赋值 Switch语句中的表达式类型只能是整型或者字符型 系统生成随机数：rand()%100，会生成0～99的随机数【伪随机数】 添加随机数种子，利用当前系统时间生成随机数，防止每次随机数都一样： 12#include&lt;ctime&gt;srand((unsigned int)time(NULL));","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"C++语言","slug":"C-语言","permalink":"http://example.com/tags/C-%E8%AF%AD%E8%A8%80/"}]},{"title":"copy和mutableCopy：","slug":"编程语言/Objective-C/copy和mutableCopy：","date":"2019-06-28T16:00:00.000Z","updated":"2021-03-24T13:20:35.000Z","comments":true,"path":"2019/06/29/编程语言/Objective-C/copy和mutableCopy：/","link":"","permalink":"http://example.com/2019/06/29/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Objective-C/copy%E5%92%8CmutableCopy%EF%BC%9A/","excerpt":"","text":"无论在MRC还是ARC下，如果属性的类型是NSString类型的，@property参数使用copy Copy是一个方法，定义在NSObject类之中，作用是拷贝对象 没有产生新对象，而是直接将对象本身的地址返回，这种拷贝我们叫做浅拷贝：【拷贝出来的是不可变字符串对象】 有产生一个新对象，这样的拷贝我们叫做深拷贝【是一个不可变的字符串对象】 mutableCopy：定义在NSObject类之中，作用是拷贝对象 可变字符串对象，深拷贝： 可变字符串对象，深拷贝： 若字符串对象存储在常量区中，存储在常量区的数据是不允许被回收的，所以存储在常量区的字符串对象的引用计数器是一个很大的数，并且retain和release无效若字符串存储在堆区，这个字符串对象和普通的对象是一样的，引用计数器默认是1 字符串对象如果是浅拷贝，会将对象的引用计数器+1；如果是深拷贝，原来的对象的引用计数器不变，新拷贝出来的对象的引用计数器为1 1）2）3） Copy方法的确是定义在NSObject类中的一个方法，但是copy方法的内部还调用了另外一个方法：copyWithZone，这个方法是定义在NSCoping协议之中的，因为我们的类没有遵守这个协议，所以当我们自定义的类调用copy方法的时候就会出错 解决方案：【return self;就是浅拷贝了】","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://example.com/tags/Objective-C/"}]},{"title":"数组：","slug":"编程语言/C++语言/数组：","date":"2019-06-28T16:00:00.000Z","updated":"2021-03-12T03:17:54.000Z","comments":true,"path":"2019/06/29/编程语言/C++语言/数组：/","link":"","permalink":"http://example.com/2019/06/29/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C++%E8%AF%AD%E8%A8%80/%E6%95%B0%E7%BB%84%EF%BC%9A/","excerpt":"","text":"一维数组的定义方式：1）数据类型 数组名[数组长度];2）数据类型 数组名[数组长度]={值1，值2…};3）数据类型 数组名[]={值1，值2…}; 如果在初始化数据的时候，没有全部填写完，会用0来填补剩余数据 一维数组名称的用途：1）可以统计整个数组在内存中的长度2）可以获取数组在内存中的首地址：cout&lt;&lt;arr&lt;&lt;endl；cout&lt;&lt;&amp;arr[0]&lt;&lt;endl; 数组名是一个常量，不可以进行赋值操作 二维数组定义方式：1）数据类型 数组名[行数][列数]；2）数据类型 数组名[行数][列数]=｛｛数据1，数据2｝，｛数据3，数据4｝｝；3）数据类型 数组名[行数][列数]=｛数据1，数据2，数据3，数据4｝；4）数据类型 数组名[][列数]={数据1，数据2，数据3，数据4};","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"C++语言","slug":"C-语言","permalink":"http://example.com/tags/C-%E8%AF%AD%E8%A8%80/"}]},{"title":"单例模式：","slug":"编程语言/Objective-C/单例模式：","date":"2019-06-27T16:00:00.000Z","updated":"2021-03-24T13:20:51.000Z","comments":true,"path":"2019/06/28/编程语言/Objective-C/单例模式：/","link":"","permalink":"http://example.com/2019/06/28/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Objective-C/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%EF%BC%9A/","excerpt":"","text":"一个类的对象，无论在何时创建，无论在什么地方创建，也无论创建多少次，创建出来的都是同一个对象 无论如何创建对象，最终都会调用alloc方法来创建，alloc方法的内部，其实什么都没做，只是调用了allocWithZone方法，实际上真正申请空间创建对象的事情是allocWithZone方法在做 实现单例模式的方法：重写allocWithZone方法【规范：如果类是一个单例模式，要求为类提供一个类方法，来返回这个单例对象，类方法必须以shared类名；default类名】单例对象可以被共享，存储在单例对象中的数据可以被共享；如果数据需要被整个程序所共享，那么将数据以属性的方式存储在单例对象中","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://example.com/tags/Objective-C/"}]},{"title":"函数：","slug":"编程语言/C++语言/函数：","date":"2019-06-27T16:00:00.000Z","updated":"2021-03-12T03:17:41.000Z","comments":true,"path":"2019/06/28/编程语言/C++语言/函数：/","link":"","permalink":"http://example.com/2019/06/28/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C++%E8%AF%AD%E8%A8%80/%E5%87%BD%E6%95%B0%EF%BC%9A/","excerpt":"","text":"值传递的时候，形参发生任何的改变，都不会影响实参 地址传递：利用指针作为函数的参数，可以修改实参的值 函数的声明可以写多次，但是定义只能有一次 函数的分文件编写：1）创建后缀名为.h的头文件，在头文件中写函数的声明2）创建后缀名为.cpp的源文件，在源文件中写函数的定义","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"C++语言","slug":"C-语言","permalink":"http://example.com/tags/C-%E8%AF%AD%E8%A8%80/"}]},{"title":"指针：","slug":"编程语言/C++语言/指针：","date":"2019-06-26T16:00:00.000Z","updated":"2021-03-12T03:17:29.000Z","comments":true,"path":"2019/06/27/编程语言/C++语言/指针：/","link":"","permalink":"http://example.com/2019/06/27/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C++%E8%AF%AD%E8%A8%80/%E6%8C%87%E9%92%88%EF%BC%9A/","excerpt":"","text":"指针前加一个代表解引用，找到指针指向的内存中的数据【p】 不管是什么数据类型，在32位操作系统上指针是占据4个字节空间大小，在64位操作系统上占据8个字节空间大小 int *p =NULL；空指针：指针变量指向内存中编号为0的空间，用来初始化指针变量，空指针指向的内存是不可以访问的【0～255之间的内存编号是系统占用的，因此不可以访问】 野指针：指针变量指向非法的内存空间 空指针和野指针都不是我们申请的空间，因此不要访问 Const修饰指针的三种情况：1）const修饰指针：常量指针【const int *p=&amp;a；指针的指向可以修改，但是指针指向的值不可以修改）2）const修饰常量：指针常量【int * const p=&amp;a；指针的指向不可以改，指针指向的值可以改】3）const既修饰指针又修饰常量【const int * const p=&amp;a；指针的指向和指针指向的值都不可以改】","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"C++语言","slug":"C-语言","permalink":"http://example.com/tags/C-%E8%AF%AD%E8%A8%80/"}]},{"title":"结构体：","slug":"编程语言/C++语言/结构体：","date":"2019-06-25T16:00:00.000Z","updated":"2021-03-12T03:17:18.000Z","comments":true,"path":"2019/06/26/编程语言/C++语言/结构体：/","link":"","permalink":"http://example.com/2019/06/26/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C++%E8%AF%AD%E8%A8%80/%E7%BB%93%E6%9E%84%E4%BD%93%EF%BC%9A/","excerpt":"","text":"结构体属于用户自定义的数据类型，允许用户存储不同的数据类型 在结构体中可以定义另一个结构体作为成员 值传递传参的时候会耗费大量的内存空间，用地址传递可以减少内存空间，而且不会复制新的副本出来 结构体中用const来防止误操作： ————————————— 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;struct Hero&#123; string name; int age; string sex;&#125;;//冒泡排序void bubbleSort(struct Hero heroArray[],int len)&#123; for(int i=0;i&lt;len-1;i++)&#123; for(int j=0;j&lt;len-1-i;j++)&#123; if(heroArray[j].age&gt;heroArray[j+1].age)&#123; struct Hero temp=heroArray[j]; heroArray[j]=heroArray[j+1]; heroArray[j+1]=temp; &#125; &#125; &#125;&#125;void printHero(struct Hero heroArray[],int len)&#123; for(int i=0;i&lt;len;i++)&#123; cout&lt;&lt;“姓名： “&lt;&lt;heroArray[I].name&lt;&lt;“年龄： “&lt;&lt;heroArray[I].age&lt;&lt;“性别：”&lt;&lt;heroArray[I].sex&lt;&lt;endl; &#125;&#125;int main(int argc, char *argv[]) &#123; struct Hero heroArray[5]=&#123; &#123;“刘备”,23,”男”&#125;, &#123;“关羽”,22,”男”&#125;, &#123;“张飞”,20,”男”&#125;, &#123;“赵云”,21,”男”&#125;, &#123;“貂蝉”,19,”女”&#125;, &#125;; int len=sizeof(heroArray)/sizeof(heroArray[0]); bubbleSort(heroArray,len); printHero(heroArray,len); &#125;","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"C++语言","slug":"C-语言","permalink":"http://example.com/tags/C-%E8%AF%AD%E8%A8%80/"}]},{"title":"通讯录管理系统：","slug":"编程语言/C++语言/通讯录管理系统：","date":"2019-06-24T16:00:00.000Z","updated":"2021-03-12T03:17:06.000Z","comments":true,"path":"2019/06/25/编程语言/C++语言/通讯录管理系统：/","link":"","permalink":"http://example.com/2019/06/25/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C++%E8%AF%AD%E8%A8%80/%E9%80%9A%E8%AE%AF%E5%BD%95%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%EF%BC%9A/","excerpt":"","text":"系统需求：1）添加联系人：向通讯录中添加新人，信息包括（姓名、性别、年龄、联系电话、家庭住址），最多记录1000人2）显示联系人：显示通讯录中所有联系人的信息3）删除联系人：按照姓名进行删除指定联系人4）查找联系人：按照姓名查看指定联系人信息5）修改联系人：按照姓名重新修改指定联系人6）清空联系人：清空通讯录中所有信息7）退出通讯录：退出当前使用的通讯录 ——————————— 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359// main.cpp// 通讯录管理系统// Created by 廖家龙 on 2020/10/8./* 本系统需要改进的点：姓名和地址显示不出中文 */#include &lt;iostream&gt;#include &lt;string&gt;#define MAX 1000 //通讯录存储的最大人数**using** **namespace** std;//1-显示菜单界面**void** showMenu()&#123; cout&lt;&lt;“************************”&lt;&lt;endl; cout&lt;&lt;“***** 1、添加联系人 *****”&lt;&lt;endl; cout&lt;&lt;“***** 2、显示联系人 *****”&lt;&lt;endl; cout&lt;&lt;“***** 3、删除联系人 *****”&lt;&lt;endl; cout&lt;&lt;“***** 4、查找联系人 *****”&lt;&lt;endl; cout&lt;&lt;“***** 5、修改联系人 *****”&lt;&lt;endl; cout&lt;&lt;“***** 6、清空联系人 *****”&lt;&lt;endl; cout&lt;&lt;“***** 0、退出通讯录 *****”&lt;&lt;endl; cout&lt;&lt;“************************”&lt;&lt;endl;&#125;//3-联系人结构体**struct** Person&#123; string m_Name; //姓名 **int** m_Sex; //性别：1、男 2、女 **int** m_Age; //年龄 string m_Phone; //电话 string m_Addr; //住址&#125;;//3-通讯录结构体**struct** Addressbooks&#123; **struct** Person personArray[MAX]; //通讯录中保存的联系人数组 **int** m_Size; //通讯录中人员个数&#125;;//3-添加联系人**void** addPerson(Addressbooks *abs)&#123; //判断通讯录是否已满，如果满了就不再添加 **if**(abs-&gt;m_Size == MAX)&#123; Cout&lt;&lt;“通讯录已满，无法添加！”&lt;&lt;endl; **return**; &#125; **else**&#123; //添加具体的联系人 //姓名 string name; cout&lt;&lt;“请输入姓名：”&lt;&lt;endl; cin&gt;&gt;name; abs-&gt;personArray[abs-&gt;m_Size].m_Name=name; //性别 cout&lt;&lt;“请输入性别：(1—男、2—女)”&lt;&lt;endl; **int** sex=0; **while**(**true**)&#123; //如果输入的是1或者2，可以退出循环，因为输入的是正确的值；如果输入有误，重新输入 cin&gt;&gt;sex; **if**(sex == 1 || sex == 2)&#123; abs-&gt;personArray[abs-&gt;m_Size].m_Sex=sex; **break**; &#125; Cout&lt;&lt;“输入有误，请重新输入！”&lt;&lt;endl; &#125; //年龄 cout&lt;&lt;“请输入年龄：(0~200)”&lt;&lt;endl; **int** age=0; **while**(**true**)&#123; cin&gt;&gt;age; **if**(age &gt;= 0 &amp;&amp; age &lt;= 200)&#123; abs-&gt;personArray[abs-&gt;m_Size].m_Age=age; **break**; &#125; Cout&lt;&lt;“输入有误，请重新输入！”&lt;&lt;endl; &#125; //电话 cout&lt;&lt;“请输入联系电话：”&lt;&lt;endl; string phone; cin&gt;&gt;phone; abs-&gt;personArray[abs-&gt;m_Size].m_Phone=phone; //住址 cout&lt;&lt;“请输入家庭住址：”&lt;&lt;endl; string address; cin&gt;&gt;address; abs-&gt;personArray[abs-&gt;m_Size].m_Addr=address; //更新通讯录的人数 abs-&gt;m_Size++; cout&lt;&lt;“添加成功！”&lt;&lt;endl; //system(“pause”); //请按任意键继续 //system(“cls”); //清屏操作 &#125;&#125;//4-显示所有联系人**void** showPerson(Addressbooks *abs)&#123; //判断通讯录中人数是否为0.如果为0，提示记录为空；如果不为0，显示记录的联系人信息 **if**(abs-&gt;m_Size == 0)&#123; cout&lt;&lt;“当前记录为空！”&lt;&lt;endl; &#125; **else**&#123; **for**(**int** I=0;i&lt;abs-&gt;m_Size;i++)&#123; cout&lt;&lt;“姓名：”&lt;&lt;abs-&gt;personArray[I].m_Name&lt;&lt;“\\t”; cout&lt;&lt;“性别：”&lt;&lt;(abs-&gt;personArray[I].m_Sex == 1 ? “男”: “女”)&lt;&lt;“\\t”; cout&lt;&lt;“年龄：”&lt;&lt;abs-&gt;personArray[I].m_Age&lt;&lt;“\\t”; cout&lt;&lt;“电话：”&lt;&lt;abs-&gt;personArray[I].m_Phone&lt;&lt;“\\t”; cout&lt;&lt;“住址：”&lt;&lt;abs-&gt;personArray[I].m_Addr&lt;&lt;endl; &#125; &#125; //system(“pause”); //请按任意键继续 //system(“cls”); //清屏操作&#125;//5-检测联系人是否存在，如果存在返回联系人所在数组中的具体位置，不存在返回-1**int** isExist(Addressbooks *abs,string name)&#123; **for**(**int** I=0;i&lt;abs-&gt;m_Size;i++)&#123; //找到用户输入的姓名了 **if**(abs-&gt;personArray[I].m_Name == name)&#123; **return** I; &#125; &#125; **return** -1;&#125;//5-删除指定的联系人**void** deletePerson(Addressbooks *abs)&#123; Cout&lt;&lt;“请输入您要删除的联系人：”&lt;&lt;endl; string name; cin&gt;&gt;name; //ret == -1 未查到；ret != -1 已查到 **int** ret =isExist(abs,name); **if**(ret != -1)&#123; //查找到此人，要进行删除操作 **for**(**int** I=ret;i&lt;abs-&gt;m_Size;i++)&#123; //数据前移 abs-&gt;personArray[I]=abs-&gt;personArray[I+1]; &#125; Abs-&gt;m_Size—; //更新通讯录中的人员数 cout&lt;&lt;“删除成功！”&lt;&lt;endl; &#125; **else**&#123; cout&lt;&lt;“查无此人！”&lt;&lt;endl; &#125; //system(“pause”); //请按任意键继续 //system(“cls”); //清屏操作&#125;//6-查找指定联系人的信息**void** findPerson(Addressbooks *abs)&#123; Cout&lt;&lt;“请输入您要查找的联系人：”&lt;&lt;endl; string name; cin&gt;&gt;name; //判断指定的联系人是否在通讯录中 **int** ret=isExist(abs, name); //找到联系人 **if**(ret != -1)&#123; cout&lt;&lt;“姓名：”&lt;&lt;abs-&gt;personArray[ret].m_Name&lt;&lt;“\\t”; cout&lt;&lt;“性别：”&lt;&lt;(abs-&gt;personArray[ret].m_Sex == 1 ? “男”: “女”)&lt;&lt;“\\t”; cout&lt;&lt;“年龄：”&lt;&lt;abs-&gt;personArray[ret].m_Age&lt;&lt;“\\t”; cout&lt;&lt;“电话：”&lt;&lt;abs-&gt;personArray[ret].m_Phone&lt;&lt;“\\t”; cout&lt;&lt;“住址：”&lt;&lt;abs-&gt;personArray[ret].m_Addr&lt;&lt;endl; &#125; //未找到联系人 **else**&#123; cout&lt;&lt;“查无此人！”&lt;&lt;endl; &#125; //system(“pause”); //请按任意键继续 //system(“cls”); //清屏操作&#125;//7-修改指定联系人的信息**void** modifyPerson(Addressbooks *abs)&#123; Cout&lt;&lt;“请输入您要修改的联系人：”&lt;&lt;endl; string name; cin&gt;&gt;name; **int** ret = isExist(abs, name); **if**(ret != -1)&#123; //姓名 string name; cout&lt;&lt;“请输入姓名：”&lt;&lt;endl; cin&gt;&gt;name; abs-&gt;personArray[ret].m_Name=name; //性别 cout&lt;&lt;“请输入性别：(1—男、2—女)”&lt;&lt;endl; **int** sex=0; **while**(**true**)&#123; cin&gt;&gt;sex; **if**(sex == 1 || sex == 2)&#123; abs-&gt;personArray[ret].m_Sex=sex; **break**; &#125; Cout&lt;&lt;“输入有误，请重新输入！”&lt;&lt;endl; &#125; //年龄 cout&lt;&lt;“请输入年龄：(0~200)”&lt;&lt;endl; **int** age=0; **while**(**true**)&#123; cin&gt;&gt;age; **if**(age &gt;= 0 &amp;&amp; age &lt;= 200)&#123; abs-&gt;personArray[ret].m_Age=age; **break**; &#125; Cout&lt;&lt;“输入有误，请重新输入！”&lt;&lt;endl; &#125; //电话 cout&lt;&lt;“请输入联系电话：”&lt;&lt;endl; string phone; cin&gt;&gt;phone; abs-&gt;personArray[ret].m_Phone=phone; //地址 cout&lt;&lt;“请输入家庭住址：”&lt;&lt;endl; string address; cin&gt;&gt;address; abs-&gt;personArray[ret].m_Addr=address; cout&lt;&lt;“修改成功！”&lt;&lt;endl; &#125; **else**&#123; cout&lt;&lt;“查无此人！”&lt;&lt;endl; &#125; //system(“pause”); //请按任意键继续 //system(“cls”); //清屏操作&#125;//8-清空所有联系人//将通讯录所有联系人信息清除掉，只要将通讯录记录的联系人数量置于0，做逻辑清空即可**void** cleanPerson(Addressbooks *abs)&#123; abs-&gt;m_Size=0; cout&lt;&lt;“通讯录已清空！”&lt;&lt;endl; //system(“pause”); //请按任意键继续 //system(“cls”); //清屏操作&#125;**int** main(**int** argc, **const** **char** * argv[]) &#123; // insert code here… //创建用户选择输入的变量 **int** select=0; //3-创建通讯录结构体变量 Addressbooks abs; //3-初始化通讯录中当前人员个数 abs.m_Size=0; **while**(**true**)&#123; //1-调用显示菜单界面的函数 showMenu(); cin&gt;&gt;select; **switch**(select)&#123; //添加联系人 **case** 1: addPerson(&amp;abs); //利用地址传递，可以修饰实参 **break**; //显示联系人 **case** 2: showPerson(&amp;abs); **break**; //删除联系人 **case** 3: /* //case中如果代码很长会报错，这个时候可以加一个大括号，代表一个代码段 &#123; Cout&lt;&lt;“请输入要删除联系人的姓名：”&lt;&lt;endl; string name; cin&gt;&gt;name; if(isExist(&amp;abs, name) == -1)&#123; Cout&lt;&lt;“查无此人！”; &#125; else&#123; Cout&lt;&lt;“找到此人！”; &#125; &#125; */ deletePerson(&amp;abs); **break**; //查找联系人 **case** 4: findPerson(&amp;abs); **break**; //修改联系人 **case** 5: modifyPerson(&amp;abs); **break**; //清空联系人 **case** 6: cleanPerson(&amp;abs); **break**; //2-退出通讯录 **case** 0: cout&lt;&lt;“欢迎下次使用”&lt;&lt;endl; //system(“pause”); **return** 0; **break**; **default**: **break**; &#125; &#125; //system(“pause”); **return** 0;&#125;","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"C++语言","slug":"C-语言","permalink":"http://example.com/tags/C-%E8%AF%AD%E8%A8%80/"}]},{"title":"程序的内存分区模型：","slug":"编程语言/C++语言/程序的内存分区模型：","date":"2019-06-23T16:00:00.000Z","updated":"2021-03-12T03:16:53.000Z","comments":true,"path":"2019/06/24/编程语言/C++语言/程序的内存分区模型：/","link":"","permalink":"http://example.com/2019/06/24/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C++%E8%AF%AD%E8%A8%80/%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA%E6%A8%A1%E5%9E%8B%EF%BC%9A/","excerpt":"","text":"C++程序在执行时，将内存大方向划分为4个区域1）代码区：存放函数体的二进制代码，由操作系统进行管理2）全局区：存放全局变量和静态变量以及常量【静态变量：static int s_a=10;】【常量分为字符串常量和const修饰的全局变量】3）栈区：由编译器自动分配释放，存放函数的参数值，局部变量和const修饰的局部变量等4）堆区：由程序员分配和释放，若程序不释放，程序结束时由操作系统回收 内存四区的意义：不同区域存放的数据，赋予不同的生命周期，给我们更大的灵活编程 程序运行前：在程序编译后，生成了exe可执行程序，未执行该程序前分为两个区域：1）代码区：存放CPU执行的机器指令；代码区是共享的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可；代码区是只读的，使其只读的原因是防止程序意外的修改了它的指令2）全局区：全局变量和静态变量存放在此；全局区还包含了常量区，字符串常量和其他常量也存放在此；该区域的数据在程序结束后由操作系统释放 程序运行后：1）栈区：由编译器自动分配释放，存放函数的参数值，局部变量等；不要返回局部变量的地址，栈区开辟的数据由编译器自动释放 第一次可以打印正确的数字，是因为编译器做了保留；第二次这个数据就不再保留了：2）堆区：在C++中主要利用new在堆区开辟内存，释放利用操作符delete【利用new创建的数据，会返回该数据对应的类型的指针】 在堆区创建数组：int * arr = new int[10];释放堆区数组：delete[] arr;","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"C++语言","slug":"C-语言","permalink":"http://example.com/tags/C-%E8%AF%AD%E8%A8%80/"}]},{"title":"C++中的引用：","slug":"编程语言/C++语言/C++中的引用：","date":"2019-06-22T16:00:00.000Z","updated":"2021-03-12T03:16:40.000Z","comments":true,"path":"2019/06/23/编程语言/C++语言/C++中的引用：/","link":"","permalink":"http://example.com/2019/06/23/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C++%E8%AF%AD%E8%A8%80/C++%E4%B8%AD%E7%9A%84%E5%BC%95%E7%94%A8%EF%BC%9A/","excerpt":"","text":"作用：给变量起别名 引用注意事项：1）引用必须初始化2）引用在初始化后，不可以改变 引用做函数参数：函数传参时，可以利用引用的技术让形参修饰实参，可以简化指针修改实参 引用做函数返回值：不要返回局部变量引用；函数的调用可以作为左值 引用的本质：在C++内部实现是一个指针常量 常量引用：常量引用主要用来修饰形参，防止误操作，在函数形参列表中，可以加const修饰形参，防止形参改变实参","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"C++语言","slug":"C-语言","permalink":"http://example.com/tags/C-%E8%AF%AD%E8%A8%80/"}]},{"title":"函数高级：","slug":"编程语言/C++语言/函数高级：","date":"2019-06-21T16:00:00.000Z","updated":"2021-03-12T03:16:29.000Z","comments":true,"path":"2019/06/22/编程语言/C++语言/函数高级：/","link":"","permalink":"http://example.com/2019/06/22/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C++%E8%AF%AD%E8%A8%80/%E5%87%BD%E6%95%B0%E9%AB%98%E7%BA%A7%EF%BC%9A/","excerpt":"","text":"函数默认参数：在C++中，函数的形参列表中的形参是可以有默认值的 函数占位参数：C++中函数的形参列表里可以有占位参数，用来做占位，调用函数时必须填补该位置 函数重载：函数名可以相同，提高复用性 函数重载满足条件：1）同一个作用域下2）函数名称相同3）函数参数类型不同或者个数不同或者顺序不同 注意：函数的返回值不可以作为重载的条件 函数重载的注意事项：","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"C++语言","slug":"C-语言","permalink":"http://example.com/tags/C-%E8%AF%AD%E8%A8%80/"}]},{"title":"封装：","slug":"编程语言/C++语言/封装：","date":"2019-06-20T16:00:00.000Z","updated":"2021-03-12T03:16:16.000Z","comments":true,"path":"2019/06/21/编程语言/C++语言/封装：/","link":"","permalink":"http://example.com/2019/06/21/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C++%E8%AF%AD%E8%A8%80/%E5%B0%81%E8%A3%85%EF%BC%9A/","excerpt":"","text":"C++面向对象的三大特征：封装、继承、多态 C++认为万事万物皆为对象，对象上有其属性和行为 封装的意义：1）将属性和行为作为一个整体，表现生活中的事物2）将属性和行为加以权限控制【public：公共权限(类内可以访问，类外可以访问)、protected：保护权限(类内可以访问，类外不可以访问)、private：私有权限(类内可以访问，类外不可以访问)】 Struct和class的区别（都可以表示一个类）：1）struct默认权限为公共2）class默认权限为私有 将成员属性设置为私有的优点：1）可以自己控制读写权限【提供一个public接口让外界访问】2）对于写权限，我们可以检测数据的有效性","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"C++语言","slug":"C-语言","permalink":"http://example.com/tags/C-%E8%AF%AD%E8%A8%80/"}]},{"title":"对象的初始化和清理：","slug":"编程语言/C++语言/对象的初始化和清理：","date":"2019-06-19T16:00:00.000Z","updated":"2021-03-12T03:16:05.000Z","comments":true,"path":"2019/06/20/编程语言/C++语言/对象的初始化和清理：/","link":"","permalink":"http://example.com/2019/06/20/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C++%E8%AF%AD%E8%A8%80/%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E6%B8%85%E7%90%86%EF%BC%9A/","excerpt":"","text":"—————1、构造函数和析构函数： C++中的面向对象来源于生活，每个对象也都会有初始设置以及对象销毁前的清理数据的设置 构造函数和析构函数：对象的初始化和清理是两个非常重要的安全问题，一个对象或者变量没有初始状态，对其使用后果是未知的，同样的使用完一个对象或变量没有及时清理，也会造成一定的安全问题；C++利用了构造函数和析构函数解决上述问题，这两个函数将会被编译器自动调用，完成对象初始化和清理工作； 对象的初始化和清理工作是编译器强制要我们做的事情，因此如果我们不提供构造和析构，编译器会提供；但是编译器提供的构造函数和析构函数是空实现 构造函数：主要作用于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用析构函数：主要作用在对象销毁前系统自动调用，执行一些清理工作 构造函数语法：类名(){}1）构造函数没有返回值也不写void2）函数名称与类名相同3）构造函数可以有参数，因此可以发生重载4）程序在调用对象时会自动调用构造，无须手动调用，而且只会调用一次 析构函数语法：～类名(){}1）析构函数没有返回值也不写void2）函数名称与类名相同，在名称前加上符号～3）析构函数不可以有参数，因此不可以发生重载4）程序在对象销毁前会自动调用析构，无须手动调用，而且只会调用一次 ——————————2、构造函数的分类及调用： 两种分类方式：1）按参数分类：有参构造和无参构造2）按类型分类：普通构造和拷贝构造 三种调用方式：括号法、显示法、隐式转换法 ——————3、拷贝构造函数调用时机： C++中拷贝构造函数调用时机通常有三种情况：1）使用一个已经创建完毕的对象来初始化一个新对象2）值传递的方式给函数参数传值3）以值方式返回局部对象—————————4、构造函数调用规则： 默认情况下，C++编译器至少给一个类添加三个函数：1）默认构造函数（无参，函数体为空）2）默认析构函数（无参，函数体为空）3）默认拷贝构造函数，对属性进行值拷贝 构造函数调用规则：1）如果用户定义有参构造函数，C++不再提供默认无参构造函数，但是会提供默认拷贝构造2）如果用户定义拷贝构造函数，C++不会再提供其他构造函数 —————————5、深拷贝与浅拷贝 浅拷贝：简单的赋值拷贝操作深拷贝：在堆区重新申请空间，进行拷贝操作—————————6、初始化列表： C++提供了初始化列表语法，用来初始化属性 ———————————7、类对象作为类成员 C++类中的成员可以是另一个类的对象，我们称该成员为对象成员 ————8、静态成员 静态成员就是在成员变量和成员函数前加上关键字static，称为静态成员 静态成员分为：1）静态成员变量：所有对象共享同一份数据，在编译阶段分配内存，类内声明，类外初始化2）静态成员函数：所有对象共享同一个函数，静态成员函数只能访问静态成员变量","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"C++语言","slug":"C-语言","permalink":"http://example.com/tags/C-%E8%AF%AD%E8%A8%80/"}]},{"title":"C++对象模型和this指针：","slug":"编程语言/C++语言/C++对象模型和this指针：","date":"2019-06-18T16:00:00.000Z","updated":"2021-03-12T03:15:54.000Z","comments":true,"path":"2019/06/19/编程语言/C++语言/C++对象模型和this指针：/","link":"","permalink":"http://example.com/2019/06/19/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C++%E8%AF%AD%E8%A8%80/C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E5%92%8Cthis%E6%8C%87%E9%92%88%EF%BC%9A/","excerpt":"","text":"——————成员变量和成员函数分开存储： 在C++中，类内的成员变量和成员函数分开存储 只有非静态成员变量才属于类的对象上 —————————this指针： 每一个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码，那么这一块代码是如何区分哪个对象调用自己的呢？ C++通过提供特殊的对象指针，this指针，解决上述问题，this指针指向被调用的成员函数所属的对象 This指针是隐含每一个非静态成员函数内的一种指针，不需要定义，直接使用即可 This指针的用途：1）当形参和成员变量同名时，可用this指针来区分2）在类的非静态成员函数中返回对象本身，可使用return *this； ———————————空指针访问成员函数： C++中空指针也是可以调用成员函数的，但是也要注意有没有用到this指针 如果用到this指针，需要加以判断保证代码的健壮性 ——————————const修饰成员函数： 常函数：成员函数后加const后我们称这个函数为常函数；常函数内不可以修改成员属性；成员属性声明时加关键字mutable后，在常函数中依然可以修改 常对象：声明对象前加const称该对象为常对象，常对象只能调用常函数","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"C++语言","slug":"C-语言","permalink":"http://example.com/tags/C-%E8%AF%AD%E8%A8%80/"}]},{"title":"友元：","slug":"编程语言/C++语言/友元：","date":"2019-06-17T16:00:00.000Z","updated":"2021-03-12T03:15:42.000Z","comments":true,"path":"2019/06/18/编程语言/C++语言/友元：/","link":"","permalink":"http://example.com/2019/06/18/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C++%E8%AF%AD%E8%A8%80/%E5%8F%8B%E5%85%83%EF%BC%9A/","excerpt":"","text":"在程序里，有些私有属性也想让类外特殊的一些函数或者类进行访问，就需要用到友元的技术 友元的目的就是让一个函数或者类访问另一个类中的私有成员，友元的关键字为friend 友元的三种实现：1）全局函数做友元2）类做友元3）成员函数做友元 全局函数做友元： 友元类（类做友元）： 成员函数做友元【为啥顺序不能变？？】： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;iostream&gt;**using** **namespace** std;**class** Building;**class** goodGay&#123; **public**: Building *building; //可访问Building中的私有成员 **void** visit(); //不可访问Building中的私有成员 **void** visit1(); goodGay(); &#125;;**class** Building&#123; **friend** **void** goodGay::visit();//表示goodGay类中的成员函数visit()作为本类的好朋友 **public**: Building()&#123; SittingRoom = “客厅”; BedRoom = “卧室”; &#125; **public**: string SittingRoom; **private**: string BedRoom; &#125;;goodGay::goodGay()&#123; building = **new** Building;&#125;**void** goodGay::visit()&#123; cout&lt;&lt;“visit函数正在访问：”&lt;&lt;building-&gt;SittingRoom&lt;&lt;endl; cout&lt;&lt;“visit函数正在访问：”&lt;&lt;building-&gt;BedRoom&lt;&lt;endl;&#125;**void** goodGay::visit1()&#123; cout&lt;&lt;“visit2函数正在访问：”&lt;&lt;building-&gt;SittingRoom&lt;&lt;endl; //cout&lt;&lt;“visit函数正在访问：”&lt;&lt;building-&gt;BedRoom&lt;&lt;endl;&#125;**int** main()&#123; goodGay gg; gg.visit(); gg.visit1();&#125;","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"C++语言","slug":"C-语言","permalink":"http://example.com/tags/C-%E8%AF%AD%E8%A8%80/"}]},{"title":"C++运算符重载：","slug":"编程语言/C++语言/C++运算符重载：","date":"2019-06-16T16:00:00.000Z","updated":"2021-03-12T03:15:31.000Z","comments":true,"path":"2019/06/17/编程语言/C++语言/C++运算符重载：/","link":"","permalink":"http://example.com/2019/06/17/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C++%E8%AF%AD%E8%A8%80/C++%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%EF%BC%9A/","excerpt":"","text":"运算符重载：对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型 加号运算符重载：实现两个自定义数据类型相加的计算【对于内置的数据类型的表达式的运算符是不可能改变的；不要滥用运算符重载】 左移运算符重载：可以输出自定义数据类型 递增运算符重载：通过重载递增运算符，实现自己的整型数据 赋值运算符重载： C++编译器至少给一个类添加4个函数：1）默认构造函数（无参，函数体为空）2）默认析构函数（无参，函数体为空）3）默认拷贝构造函数，对属性进行值拷贝4）赋值运算符operator=，对属性进行值拷贝 如果类中有属性指向堆区，做赋值操作时也会出现深浅拷贝问题 关系运算符重载：重载关系运算符，可以让两个自定义类型对象进行对比操作 函数调用运算符()重载：由于重载后使用的方式非常像函数的调用，因此称为仿函数；仿函数没有固定的写法，非常灵活","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"C++语言","slug":"C-语言","permalink":"http://example.com/tags/C-%E8%AF%AD%E8%A8%80/"}]},{"title":"继承：","slug":"编程语言/C++语言/继承：","date":"2019-06-15T16:00:00.000Z","updated":"2021-03-12T03:15:18.000Z","comments":true,"path":"2019/06/16/编程语言/C++语言/继承：/","link":"","permalink":"http://example.com/2019/06/16/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C++%E8%AF%AD%E8%A8%80/%E7%BB%A7%E6%89%BF%EF%BC%9A/","excerpt":"","text":"继承是面向对象三大特性之一 定义某些类时，下级别的成员除了拥有上一级的共性，还有自己的特性，这个时候我们就可以考虑利用继承的技术，减少重复代码 继承方式：公共继承、保护继承、私有继承 继承中的对象模型： 继承中的构造和析构顺序：子类继承父类后，当创建子类对象，也会调用父类的构造函数；先构造父类，再构造子类，析构的顺序与构造的顺序相反 继承同名成员处理方式： 当子类与父类出现同名的成员，如何通过子类对象访问到子类或者父类中同名的数据呢？1）访问子类同名成员，直接访问即可2）访问父类同名成员，需要加作用域 继承同名静态成员处理方式：静态成员和非静态成员出现同名，处理方式一致；访问子类同名成员，直接访问即可；访问父类同名成员，需要加作用域 多继承：C++允许一个类继承多个类，多继承可能会引发父类中有同名成员出现，需要加作用域区分；C++实际开发中不建议用多继承class Son:public Base1,public Base2 菱形继承：两个派生类继承同一个基类，又有某个类同时继承着两个派生类，这种继承被称为菱形继承，或者钻石继承 出现的问题：1）羊继承了动物的数据，驼同样继承了动物的数据，当羊驼使用数据时，就会产生二义性2）羊驼继承自动物的数据继承了两份，但是这份数据我们只需要一份就可以","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"C++语言","slug":"C-语言","permalink":"http://example.com/tags/C-%E8%AF%AD%E8%A8%80/"}]},{"title":"多态：","slug":"编程语言/C++语言/多态：","date":"2019-06-14T16:00:00.000Z","updated":"2021-03-12T03:15:06.000Z","comments":true,"path":"2019/06/15/编程语言/C++语言/多态：/","link":"","permalink":"http://example.com/2019/06/15/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C++%E8%AF%AD%E8%A8%80/%E5%A4%9A%E6%80%81%EF%BC%9A/","excerpt":"","text":"多态是C++面向对象三大特性之一 多态分为两类：1）静态多态：函数重载和运算符重载属于静态多态，复用函数名2）动态多态：派生类和虚函数实现运行时多态 静态多态和动态多态的区别：1）静态多态的函数地址早绑定，编译阶段确定函数地址2）动态多态的函数地址晚绑定，运行阶段确定函数地址 多态的底层原理： 分别利用普通写法和多态技术，设计实现两个操作数进行运算的计算器类： 多态的优点：代码组织结构清晰、可读性强、利于前期和后期的扩展以及维护 纯虚函数和抽象类：在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容，因此可以将虚函数改为纯虚函数，当类中有了纯虚函数，这个类也称为抽象类 抽象类特点：1）无法实例化对象2）子类必须重写抽象类中的纯虚函数，否则也属于抽象类 虚析构和纯虚析构： 多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码 解决方式：将父类中的析构函数改为虚析构或者纯虚析构 虚析构和纯虚析构共性：1）可以解决父类指针释放子类对象2）都需要有具体的函数实现 虚析构和纯虚析构的区别：如果是纯虚析构，该类属于抽象类，无法实例化对象","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"C++语言","slug":"C-语言","permalink":"http://example.com/tags/C-%E8%AF%AD%E8%A8%80/"}]},{"title":"C++文件操作：","slug":"编程语言/C++语言/C++文件操作：","date":"2019-06-13T16:00:00.000Z","updated":"2021-03-12T03:14:55.000Z","comments":true,"path":"2019/06/14/编程语言/C++语言/C++文件操作：/","link":"","permalink":"http://example.com/2019/06/14/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C++%E8%AF%AD%E8%A8%80/C++%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%EF%BC%9A/","excerpt":"","text":"程序运行时产生的数据都属于临时数据，程序一旦运行结束都会被释放，通过文件可以将数据持久化 C++中对文件操作需要包含头文件 文件类型分为两种：1）文本文件：文件以文本的ASCII码形式存储在计算机中2）二进制文件：文件以文本的二进制形式存储在计算机中，用户一般不能直接读懂它们 操作文件的三大类：1）ofstream：写操作2）ifstream：读操作3）fstream：读写操作 文本文件： 写文件的步骤：1）包含头文件：#include2）创建流对象：ofstream ofs;3）打开文件：ofs.open(“文件路径”,打开方式);4）写数据：ofs&lt;&lt;“写入的数据”;5）关闭文件：ofs.close(); 文件打开方式【文件打开方式可以配合使用，利用|操作符】：1）ios::in 为读文件而打开文件2）ios::out 为写文件而打开文件3）ios::ate 初始位置：文件尾4）ios::app 追加方式写文件5）ios::trunc 如果文件存在先删除，再创建6）iOS::binary 二进制方式 读文件的步骤：1）包含头文件：#include2）创建流对象：ifstream ifs;3）打开文件并判断文件是否打开成功：ifs.open(“文件路径”,打开方式);4）读数据：四种方式读取5）关闭文件：ifs.close(); 二进制文件：以二进制的方式对文件进行读写操作，打开方式要指定为ios::binary 二进制方式写文件主要利用流对象调用成员函数write函数原型：ostream&amp; write(const char * buffer,int len);参数解释：字符指针buffer指向内存中的一段存储空间，len是读写的字节数 二进制方式读文件主要利用流对象调用成员函数read函数原型：istream&amp; read(char *buffer,int len);参数解释：字符指针buffer指向内存中的一段存储空间，len是读写的字节数","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"C++语言","slug":"C-语言","permalink":"http://example.com/tags/C-%E8%AF%AD%E8%A8%80/"}]},{"title":"职工管理系统：","slug":"编程语言/C++语言/职工管理系统：","date":"2019-06-12T16:00:00.000Z","updated":"2021-03-12T03:14:44.000Z","comments":true,"path":"2019/06/13/编程语言/C++语言/职工管理系统：/","link":"","permalink":"http://example.com/2019/06/13/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C++%E8%AF%AD%E8%A8%80/%E8%81%8C%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%EF%BC%9A/","excerpt":"","text":"","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"C++语言","slug":"C-语言","permalink":"http://example.com/tags/C-%E8%AF%AD%E8%A8%80/"}]},{"title":"函数模板：","slug":"编程语言/C++语言/函数模板：","date":"2019-06-11T16:00:00.000Z","updated":"2021-03-12T03:14:33.000Z","comments":true,"path":"2019/06/12/编程语言/C++语言/函数模板：/","link":"","permalink":"http://example.com/2019/06/12/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C++%E8%AF%AD%E8%A8%80/%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%EF%BC%9A/","excerpt":"","text":"模板就是建立通用的模具，大大提高复用性 模板的特点：模板不可以直接使用，它只是一个框架；模板的通用并不是万能的 ———————————————函数模板： C++另一种编程思想称为泛型编程，主要利用的技术就是模板 C++提供两种模板机制：函数模板和类模板 函数模板的作用：建立一个通用函数，其函数返回值类型和形参类型可以不具体制定，用一个虚拟的类型来代表 函数模板注意事项：1）自动类型推导，必须推导出一致的数据类型T才可以使用2）模板必须要确定出T的数据类型，才可以使用 普通函数与函数模板的区别：1）普通函数调用时可以发生自动类型转换（隐式类型转换）2）函数模板调用时，如果利用自动类型推导，不会发生隐式类型转换；如果利用显式指定类型的方式，可以发生隐式类型转换 建议使用显示指定类型的方式，调用函数模板，因为可以自己确定通用类型T 普通函数与函数模板的调用规则：1）如果函数模板和普通函数都可以实现，优先调用普通函数2）可以通过空模板参数列表来强制调用函数模板3）函数模板也可以发生重载4）如果函数模板可以产生更好的匹配，优先调用函数模板 模板的局限性：模板的通用性并不是万能的 因此C++为了解决这种问题，提供模板的重载，可以为这些特定的类型提供具体化的模板","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"C++语言","slug":"C-语言","permalink":"http://example.com/tags/C-%E8%AF%AD%E8%A8%80/"}]},{"title":"类模板：","slug":"编程语言/C++语言/类模板：","date":"2019-06-10T16:00:00.000Z","updated":"2021-03-12T03:14:22.000Z","comments":true,"path":"2019/06/11/编程语言/C++语言/类模板：/","link":"","permalink":"http://example.com/2019/06/11/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C++%E8%AF%AD%E8%A8%80/%E7%B1%BB%E6%A8%A1%E6%9D%BF%EF%BC%9A/","excerpt":"","text":"","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"C++语言","slug":"C-语言","permalink":"http://example.com/tags/C-%E8%AF%AD%E8%A8%80/"}]},{"title":"IP地址形式输出：","slug":"数据结构和算法/C实例/IP地址形式输出：","date":"2018-12-31T16:00:00.000Z","updated":"2021-03-12T03:05:25.000Z","comments":true,"path":"2019/01/01/数据结构和算法/C实例/IP地址形式输出：/","link":"","permalink":"http://example.com/2019/01/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/C%E5%AE%9E%E4%BE%8B/IP%E5%9C%B0%E5%9D%80%E5%BD%A2%E5%BC%8F%E8%BE%93%E5%87%BA%EF%BC%9A/","excerpt":"","text":"源代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//任意输入32位的二进制数，编程实现将该二进制数转换成IP地址形式//输入：11111111111111111111111100000000，输出：255.255.255.0#include&lt;stdio.h&gt;int bin_dec(int x,int n)&#123; if(n==0)&#123; return 1; &#125; return x*bin_dec(x,n-1);&#125;int main()&#123; int i; int ip[4]=&#123;0&#125;; char a[33]; printf(&quot;输入32位二进制数：\\n&quot;); scanf(&quot;%s&quot;,a); for(i=0;i&lt;8;i++)&#123; if(a[i]==&#x27;1&#x27;)&#123; ip[0]+=bin_dec(2,7-i); &#125; &#125; for(i=8;i&lt;16;i++)&#123; if(a[i]==&#x27;1&#x27;)&#123; ip[1]+=bin_dec(2,15-i); &#125; &#125; for(i=16;i&lt;24;i++)&#123; if(a[i]==&#x27;1&#x27;)&#123; ip[2]+=bin_dec(2,23-i); &#125; &#125; for(i=24;i&lt;32;i++)&#123; if(a[i]==&#x27;1&#x27;)&#123; ip[3]+=bin_dec(2,31-i); &#125; if(a[i]==&#x27;\\0&#x27;)&#123; break; &#125; &#125; printf(&quot;IP地址为:\\n&quot;); printf(&quot;%d.%d.%d.%d\\n&quot;,ip[0],ip[1],ip[2],ip[3]);&#125;","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"C实例","slug":"C实例","permalink":"http://example.com/tags/C%E5%AE%9E%E4%BE%8B/"}]},{"title":"‘#’字棋","slug":"数据结构和算法/C实例/‘#’字棋","date":"2018-12-31T16:00:00.000Z","updated":"2021-03-12T03:01:46.000Z","comments":true,"path":"2019/01/01/数据结构和算法/C实例/‘#’字棋/","link":"","permalink":"http://example.com/2019/01/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/C%E5%AE%9E%E4%BE%8B/%E2%80%98#%E2%80%99%E5%AD%97%E6%A3%8B/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071**#include&lt;stdio.h&gt;****int main()&#123;**** const int size=3;**** int board[size][size];**** int i,j;**** int numofX;**** int numofo;**** int result=-1;//-1;**没人赢，**1:X**赢，**0:o**赢 ** //**读入矩阵** for(I=0;i&lt;size;i++)&#123;**** for(j=0;j&lt;size;j++)&#123;**** scanf(“%d”,&amp;board[I][j]);**** &#125;**** &#125;** ** //**检查行** for(I=0;i&lt;size &amp;&amp; result==-1;i++)&#123;**** numofo=numofX=0;**** for(j=0;j&lt;size;j++)&#123;**** if(board[I][j]==1)&#123;**** numofX++;**** &#125;else&#123;**** numofo++;**** &#125;**** &#125;**** if(numofo==size)&#123;**** result=0;**** &#125;else if(numofX==size)&#123;**** result =1;**** &#125;**** &#125;** ** //**检查列** if(result==-1)&#123;**** for(j=0;j&lt;size &amp;&amp; result==-1;j++)&#123;**** numofo=numofX=0;**** for(I=0;i&lt;size;i++)&#123;**** if(board[I][j]==1)&#123;**** numofX++;**** &#125;else&#123;**** numofo++;**** &#125;**** &#125;**** if(numofo==size)&#123;**** result=0;**** &#125;else if(numofX==size)&#123;**** result =1;**** &#125;**** &#125;****&#125;** ** //**检查对角线** numofo=numofX=0;**** for(I=0;i&lt;size;i++)&#123;**** if(board[I][I]==1)&#123;**** numofX++;**** &#125;else&#123;**** numofo++;**** &#125;**** &#125;**** if(numofo==size)&#123;**** result=0;**** &#125;else if(numofX==size)&#123;**** result =1;**** &#125;** ** numofo=numofX=0;**** for(I=0;i&lt;size;i++)&#123;**** if(board[I][size-i-1]==1)&#123;**** numofX++;**** &#125;else&#123;**** numofo++;**** &#125;**** &#125;****&#125;**","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"C实例","slug":"C实例","permalink":"http://example.com/tags/C%E5%AE%9E%E4%BE%8B/"}]},{"title":"一数三平方：","slug":"数据结构和算法/C实例/一数三平方：","date":"2018-12-31T16:00:00.000Z","updated":"2021-03-12T03:06:01.000Z","comments":true,"path":"2019/01/01/数据结构和算法/C实例/一数三平方：/","link":"","permalink":"http://example.com/2019/01/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/C%E5%AE%9E%E4%BE%8B/%E4%B8%80%E6%95%B0%E4%B8%89%E5%B9%B3%E6%96%B9%EF%BC%9A/","excerpt":"","text":"源代码： 1234567891011121314151617181920212223242526272829303132//有这样一个六位数，它本身是一个整数的平方，其高三位和低三位也分别是一个整数的平方，如225625=475^2,求满足上述条件的所有六位数。#include&lt;stdio.h&gt;#include&lt;math.h&gt;int main()&#123; long i,n,n1,n2,n3,n4,count=0; printf(&quot;这样的数有: \\n&quot;); for(i=100000;i&lt;=999999;i++)&#123; n=(long)sqrt(i); if(i==n*n)&#123; n1=i/1000; n2=i%1000; n3=(long)sqrt(n1); n4=(long)sqrt(n2); if(n1==n3*n3&amp;&amp;n2==n4*n4)&#123; count++; printf(&quot;%ld &quot;,i); &#125; &#125; &#125; printf(&quot;\\n满足条件的有：%ld个&quot;,count); printf(&quot;\\n&quot;);&#125;","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"C实例","slug":"C实例","permalink":"http://example.com/tags/C%E5%AE%9E%E4%BE%8B/"}]},{"title":"两数相除：","slug":"数据结构和算法/C实例/两数相除：","date":"2018-12-31T16:00:00.000Z","updated":"2021-03-12T03:11:23.000Z","comments":true,"path":"2019/01/01/数据结构和算法/C实例/两数相除：/","link":"","permalink":"http://example.com/2019/01/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/C%E5%AE%9E%E4%BE%8B/%E4%B8%A4%E6%95%B0%E7%9B%B8%E9%99%A4%EF%BC%9A/","excerpt":"","text":"指针作为函数的返回值： 源代码： 12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;int divide(int a,int b,int *result)&#123; int ret=1; if(b==0)&#123; ret=0; &#125;else&#123; *result=a/b; &#125; return ret; //return:如果除法成功，返回1；否则返回0&#125;int main(int argc, const char * argv[]) &#123; // insert code here... int a=5,b=2; int c=0; if(divide(a,b,&amp;c))&#123; printf(&quot;%d/%d=%d\\n&quot;,a,b,c); &#125; return 0;&#125;","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"C实例","slug":"C实例","permalink":"http://example.com/tags/C%E5%AE%9E%E4%BE%8B/"}]},{"title":"交换两个变量的值","slug":"数据结构和算法/C实例/交换两个变量的值","date":"2018-12-31T16:00:00.000Z","updated":"2021-03-12T03:01:23.000Z","comments":true,"path":"2019/01/01/数据结构和算法/C实例/交换两个变量的值/","link":"","permalink":"http://example.com/2019/01/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/C%E5%AE%9E%E4%BE%8B/%E4%BA%A4%E6%8D%A2%E4%B8%A4%E4%B8%AA%E5%8F%98%E9%87%8F%E7%9A%84%E5%80%BC/","excerpt":"","text":"123456789**//**交换**a**和**b**的值**#include&lt;stdio.h&gt;****int main()&#123;**** int a=5,b=6,t;**** t=5;**** a=b;**** b=t;**** printf(“a=%d,b=%d\\n”,a,b);**** return 0;****&#125;** 12345678910**#include&lt;stdio.h&gt;****int main()&#123;**** int a=5,b=6;** ** a=a+b;**** b=a-b;**** a=a-b;** ** printf(“a=%d,b=%d\\n”,a,b);****&#125;** 12345678910#include&lt;stdio.h&gt;int main()&#123; int a=5,b=6; a=a ^ b; b=a ^ b; a=a ^ b; printf(“a=%d,b=%d\\n”,a,b);&#125; 123456789101112#include&lt;stdio.h&gt;void swap(int *pa,int *pb)&#123; int t=*pa; *pa=*pb; *pb=t;&#125;int main()&#123; int a=5,b=6; swap(&amp;a, &amp;b); printf(“a=%d,b=%d\\n”,a,b);&#125;","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"C实例","slug":"C实例","permalink":"http://example.com/tags/C%E5%AE%9E%E4%BE%8B/"}]},{"title":"亲密数：","slug":"数据结构和算法/C实例/亲密数：","date":"2018-12-31T16:00:00.000Z","updated":"2021-03-12T03:07:58.000Z","comments":true,"path":"2019/01/01/数据结构和算法/C实例/亲密数：/","link":"","permalink":"http://example.com/2019/01/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/C%E5%AE%9E%E4%BE%8B/%E4%BA%B2%E5%AF%86%E6%95%B0%EF%BC%9A/","excerpt":"","text":"源代码： 123456789101112131415161718192021222324252627282930313233343536//如果整数A的全部因子（不包括A）之和等于B，且整数B的全部因子（不包括B）之和等于A，则将A和B称为亲密数，如220的全部因子（不包括220）之和：1+2+4+5+10+11+20+22+44+55+110等于284，284的全部因子（不包括284）之和：1+2+4+71+142等于220，故220和284为亲密数。求10000以内的所有亲密数。#include&lt;stdio.h&gt;int main()&#123; int i,j,k,sum1,sum2; for(i=1;i&lt;=10000;i++)&#123; sum1=0; sum2=0; for(j=1;j&lt;i;j++)&#123; if(i%j==0)&#123; sum1+=j; &#125; &#125; for(k=1;k&lt;sum1;k++)&#123; if(sum1%k==0)&#123; sum2+=k; &#125; &#125; if(sum2==i&amp;&amp;i!=sum1&amp;&amp;i&lt;sum1)&#123; printf(&quot;%5d=&gt;%5d\\n&quot;,i,sum1); &#125; &#125;&#125;","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"C实例","slug":"C实例","permalink":"http://example.com/tags/C%E5%AE%9E%E4%BE%8B/"}]},{"title":"任意次方后的最后三位：","slug":"数据结构和算法/C实例/任意次方后的最后三位：","date":"2018-12-31T16:00:00.000Z","updated":"2021-03-12T03:07:04.000Z","comments":true,"path":"2019/01/01/数据结构和算法/C实例/任意次方后的最后三位：/","link":"","permalink":"http://example.com/2019/01/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/C%E5%AE%9E%E4%BE%8B/%E4%BB%BB%E6%84%8F%E6%AC%A1%E6%96%B9%E5%90%8E%E7%9A%84%E6%9C%80%E5%90%8E%E4%B8%89%E4%BD%8D%EF%BC%9A/","excerpt":"","text":"源代码： 1234567891011121314151617181920212223//编程求一个整数任意次方后的最后三位数，即求x^y的最后三位数，x和y的值由键盘输入。//本实例的算法思想如下：题中要求一个数的任意次方，首先要考虑计算结果是否越界，如何避免产生越界问题同时又不使结果产生误差，这里在求次方时每乘一次都取其后三位，这样就不会出现越界问题，又可完成题目要求。#include&lt;stdio.h&gt;int main()&#123; int i,x,y,z=1; printf(&quot;please input two numbers:x,y(x^y):\\n&quot;); scanf(&quot;%d%d&quot;,&amp;x,&amp;y); for(i=1;i&lt;=y;i++)&#123; z=z*x % 1000; &#125; if(z&gt;=100)&#123; printf(&quot;%d^%d的最后三位是：%d\\n&quot;,x,y,z); &#125;else&#123; printf(&quot;%d^%d的最后三位:00%d\\n&quot;,x,y,z); &#125;&#125;","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"C实例","slug":"C实例","permalink":"http://example.com/tags/C%E5%AE%9E%E4%BE%8B/"}]},{"title":"任意正数的逆序","slug":"数据结构和算法/C实例/任意正数的逆序","date":"2018-12-31T16:00:00.000Z","updated":"2021-03-12T03:03:33.000Z","comments":true,"path":"2019/01/01/数据结构和算法/C实例/任意正数的逆序/","link":"","permalink":"http://example.com/2019/01/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/C%E5%AE%9E%E4%BE%8B/%E4%BB%BB%E6%84%8F%E6%AD%A3%E6%95%B0%E7%9A%84%E9%80%86%E5%BA%8F/","excerpt":"","text":"","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"C实例","slug":"C实例","permalink":"http://example.com/tags/C%E5%AE%9E%E4%BE%8B/"}]},{"title":"使用公式打印下列华氏温度与摄氏温度对照表","slug":"数据结构和算法/C实例/使用公式打印下列华氏温度与摄氏温度对照表","date":"2018-12-31T16:00:00.000Z","updated":"2021-03-12T03:00:23.000Z","comments":true,"path":"2019/01/01/数据结构和算法/C实例/使用公式打印下列华氏温度与摄氏温度对照表/","link":"","permalink":"http://example.com/2019/01/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/C%E5%AE%9E%E4%BE%8B/%E4%BD%BF%E7%94%A8%E5%85%AC%E5%BC%8F%E6%89%93%E5%8D%B0%E4%B8%8B%E5%88%97%E5%8D%8E%E6%B0%8F%E6%B8%A9%E5%BA%A6%E4%B8%8E%E6%91%84%E6%B0%8F%E6%B8%A9%E5%BA%A6%E5%AF%B9%E7%85%A7%E8%A1%A8/","excerpt":"","text":"1）**#include&lt;stdio.h&gt;**//程序中允许出现空格、制表符或换行符之处，都可以使用注释//当fahr=0,20,…,300时，分别打印华氏温度和摄氏温度对照表main(){** int fahr,celsius;**** int lower,upper,step;** ** lower=0;//温度表的下限 upper=300;//温度表的上限 step=20;//步长** fahr=lower;** while(fahr&lt;=upper){**** celsius=5 * (fahr-32) / 9; // 5 / 9=0**** printf(“%3d\\t%6d\\n”,fahr,celsius);**** fahr=fahr+step;**** }**} 2）**#include&lt;stdio.h&gt;**main(){** float fahr,celsius;**** int lower,upper,step;** ** lower=0;//温度表的下限 upper=300;//温度表的上限 step=20;//步长//%3.0f表明待打印的浮点数（即fahr）至少占3个字符宽，且不带小数点和小数部分；%6.1f表明另一个待打印的数（celsius）至少占6个字符宽，且小数点后面有1位数字。 //格式说明可以省略宽度和精度，例如，%6f表示待打印的浮点数至少有6个字符宽；%.2f指定待打印的浮点数的小数点后有两位小数，但宽度没有限制；%f则仅仅要求按照浮点数打印该数 fahr=lower;**** while(fahr&lt;=upper){**** celsius=(5.0/9.0)(fahr-32.0);*** printf(“%3.0f %6.1f\\n”,fahr,celsius);**** fahr=fahr+step;**** }**} 3）修改温度转换程序，使之能在转换表的顶部打印一个标题**#include&lt;stdio.h&gt;**main(){** float fahr,celsius;**** int lower,upper,step;** ** lower=0;//温度表的下限 upper=300;//温度表的上限 step=20;//步长** printf(“Fahr Celsius\\n”);** fahr=lower;**** while(fahr&lt;=upper){**** celsius=(5.0/9.0)(fahr-32.0);*** printf(“%3.0f %6.1f\\n”,fahr,celsius);**** fahr=fahr+step;**** }**} 4）编写一个程序打印摄氏温度转换为相应华氏温度的转换表**#include&lt;stdio.h&gt;**main(){** float fahr,celsius;**** int lower,upper,step;** ** lower=0;//温度表的下限 upper=300;//温度表的上限 step=20;//步长** printf(“Celsius Fahr\\n”);** celsius=lower;**** while(celsius&lt;=upper){**** fahr=(9.0celsius)/5.032.0;**** printf(“%3.0f %6.1f\\n”,celsius,fahr);**** celsius=celsius+step;**** }**} 5）使用for循环打印华氏温度**-摄氏温度对照表#include&lt;stdio.h&gt;**main(){** int fahr;** ** for(fahr=0;fahr&lt;=300;fahr=fahr+20)**** printf(“%3d %6.1f\\n”,fahr,(5.0/9.0)(fahr-32));*}//在允许使用某种类型变量值的任何场合，都可以使用该类型的更复杂的表达式。因为printf函数的第三个参数必须是与**%6.1f**匹配的浮点值，所以可以在此处使用任何浮点表达式6）修改温度转换程序，要求以逆序（即按照从300度递减到0度的顺序）打印温度转换表 1234567#include&lt;stdio.h&gt;main()&#123; int fahr; for(fahr=300;fahr&gt;=0;fahr=fahr-20) printf(“%3d %6.1f\\n”,fahr,(5.0/9.0)*(fahr-32));&#125; 7）符号常量【# define指令可以把符号名（或称为符号常量）定义为一个特定的字符串（#define 名字 替换文本），名字与普通变量名的形式相同，它们都是以字母打头的字母和数字序列；替换文本可以是任何字符序列，而不仅限于数字】 12345678910111213#include&lt;stdio.h&gt;#define LOWER 0//表的下限#define UPPER 300//表的上限#define STEP 29//步长main()&#123; int fahr; for(fahr=LOWER;fahr&lt;=UPPER;fahr=fahr+STEP) printf(“%3d %6.1f\\n”,fahr,(5.0/9.0)*(fahr-32));&#125;//符号常量名通常用大写字母拼写，这样可以很容易与用小写字母拼写的变量名相区别//其中，LOWER，UPPER与STEP都是符号常量，而非变量，因此不需要出现在声明中。【注意，#define指令行的末尾没有分号】","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"C实例","slug":"C实例","permalink":"http://example.com/tags/C%E5%AE%9E%E4%BE%8B/"}]},{"title":"产生不重复的随机数","slug":"数据结构和算法/C实例/产生不重复的随机数","date":"2018-12-31T16:00:00.000Z","updated":"2021-03-12T03:02:28.000Z","comments":true,"path":"2019/01/01/数据结构和算法/C实例/产生不重复的随机数/","link":"","permalink":"http://example.com/2019/01/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/C%E5%AE%9E%E4%BE%8B/%E4%BA%A7%E7%94%9F%E4%B8%8D%E9%87%8D%E5%A4%8D%E7%9A%84%E9%9A%8F%E6%9C%BA%E6%95%B0/","excerpt":"","text":"","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"C实例","slug":"C实例","permalink":"http://example.com/tags/C%E5%AE%9E%E4%BE%8B/"}]},{"title":"判断正整数的位数：","slug":"数据结构和算法/C实例/判断正整数的位数：","date":"2018-12-31T16:00:00.000Z","updated":"2021-03-12T03:08:13.000Z","comments":true,"path":"2019/01/01/数据结构和算法/C实例/判断正整数的位数：/","link":"","permalink":"http://example.com/2019/01/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/C%E5%AE%9E%E4%BE%8B/%E5%88%A4%E6%96%AD%E6%AD%A3%E6%95%B4%E6%95%B0%E7%9A%84%E4%BD%8D%E6%95%B0%EF%BC%9A/","excerpt":"","text":"1） 源代码： 12345678910111213141516171819202122#include&lt;stdio.h&gt;int main()&#123; int x,n=0; scanf(&quot;%d&quot;,&amp;x); //先要去做数位数去位数的事情 n++; x/=10; while(x&gt;0)&#123; n++; x/=10; &#125; printf(&quot;%d\\n&quot;,n); return 0;&#125; 2） 源代码： 1234567891011121314151617#include&lt;stdio.h&gt;int main()&#123; int x,n=0; scanf(&quot;%d&quot;,&amp;x); do&#123; x/=10; n++; &#125;while(x&gt;0); printf(&quot;%d\\n&quot;,n); return 0;&#125;","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"C实例","slug":"C实例","permalink":"http://example.com/tags/C%E5%AE%9E%E4%BE%8B/"}]},{"title":"哥德巴赫猜想：","slug":"数据结构和算法/C实例/哥德巴赫猜想：","date":"2018-12-31T16:00:00.000Z","updated":"2021-03-12T03:09:56.000Z","comments":true,"path":"2019/01/01/数据结构和算法/C实例/哥德巴赫猜想：/","link":"","permalink":"http://example.com/2019/01/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/C%E5%AE%9E%E4%BE%8B/%E5%93%A5%E5%BE%B7%E5%B7%B4%E8%B5%AB%E7%8C%9C%E6%83%B3%EF%BC%9A/","excerpt":"","text":"源代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162//验证100以内的正偶数都能分解为两个素数之和，即验证哥德巴赫猜想对100以内（大于二）的正偶数成立。#include&lt;stdio.h&gt;int ss(int i)&#123; int j; if(i&lt;=1)&#123; return 0; &#125; if(i==2)&#123; return 1; &#125; for(j=2;j&lt;i;j++)&#123; if(i%j==0)&#123; return 0; &#125; else if(i!=j+1)&#123; continue; &#125; else&#123; return 1; &#125; &#125; return 0;&#125;int main()&#123; int i,j,k,flag1,flag2,n=0; for(i=4;i&lt;100;i+=2)&#123; for(k=2;k&lt;=i/2;k++)&#123; j=i-k; flag1=ss(k); if(flag1)&#123; flag2=ss(j); if(flag2)&#123; printf(&quot;%3d=%3d+%3d,&quot;,i,k,j); n++; if(n%8==0)&#123; printf(&quot;\\n&quot;); &#125; &#125; &#125; &#125; &#125; printf(&quot;\\n&quot;);&#125;","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"C实例","slug":"C实例","permalink":"http://example.com/tags/C%E5%AE%9E%E4%BE%8B/"}]},{"title":"大小写转换：","slug":"数据结构和算法/C实例/大小写转换：","date":"2018-12-31T16:00:00.000Z","updated":"2021-03-12T03:10:46.000Z","comments":true,"path":"2019/01/01/数据结构和算法/C实例/大小写转换：/","link":"","permalink":"http://example.com/2019/01/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/C%E5%AE%9E%E4%BE%8B/%E5%A4%A7%E5%B0%8F%E5%86%99%E8%BD%AC%E6%8D%A2%EF%BC%9A/","excerpt":"","text":"源代码： 12345678910111213141516//字母在ASCII表中是顺序排列的//大写字母和小写字母是分开排列的，并不在一起//&#x27;a&#x27;-&#x27;A&#x27;可以得到两段之间的距离，于是a+&#x27;a&#x27;-&#x27;A&#x27;可以把一个大写字母变成小写字母，而a+&#x27;A&#x27;-&#x27;a&#x27;可以把一个小写字母变成大写字母#include&lt;stdio.h&gt;int main()&#123; char m=&#x27;a&#x27;; char n=&#x27;A&#x27;; printf(&quot;%d\\n&quot;,m-n); printf(&quot;%c\\n&quot;,n+32); printf(&quot;%c\\n&quot;,m-32);&#125;","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"C实例","slug":"C实例","permalink":"http://example.com/tags/C%E5%AE%9E%E4%BE%8B/"}]},{"title":"字符串数组的排序","slug":"数据结构和算法/C实例/字符串数组的排序","date":"2018-12-31T16:00:00.000Z","updated":"2021-03-12T03:02:04.000Z","comments":true,"path":"2019/01/01/数据结构和算法/C实例/字符串数组的排序/","link":"","permalink":"http://example.com/2019/01/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/C%E5%AE%9E%E4%BE%8B/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%95%B0%E7%BB%84%E7%9A%84%E6%8E%92%E5%BA%8F/","excerpt":"","text":"以字母的顺序排序： 以长度排序：","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"C实例","slug":"C实例","permalink":"http://example.com/tags/C%E5%AE%9E%E4%BE%8B/"}]},{"title":"判断三角形的类型：","slug":"数据结构和算法/C实例/判断三角形的类型：","date":"2018-12-31T16:00:00.000Z","updated":"2021-03-12T03:08:28.000Z","comments":true,"path":"2019/01/01/数据结构和算法/C实例/判断三角形的类型：/","link":"","permalink":"http://example.com/2019/01/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/C%E5%AE%9E%E4%BE%8B/%E5%88%A4%E6%96%AD%E4%B8%89%E8%A7%92%E5%BD%A2%E7%9A%84%E7%B1%BB%E5%9E%8B%EF%BC%9A/","excerpt":"","text":"源代码： 12345678910111213141516171819202122232425262728293031323334//根据输入的三角形的三条边判断三角形的类型，并输出它的面积和类型//实例中要注意“&amp;&amp;”和“｜｜”的恰当使用。当需要同时满足多种情况时，使用“&amp;&amp;”逻辑运算符，而当只需要满足几种情况中的一种时，则使用“｜｜”逻辑运算符。#include&lt;stdio.h&gt;#include&lt;math.h&gt;int main()&#123; float a,b,c; float s ,area; scanf(&quot;%f,%f,%f&quot;,&amp;a,&amp;b,&amp;c); if(a+b&gt;c &amp;&amp; b+c&gt;a &amp;&amp; a+c&gt;b)&#123; s=(a+b+c)/2; area=(float)sqrt(s*(s-a)*(s-b)*(s-c)); printf(&quot;面积是：%f\\n&quot;,area); if(a==b &amp;&amp; a==c)&#123; printf(&quot;等边三角形\\n&quot;); &#125; else if(a==b || a==c || b==c)&#123; printf(&quot;等腰三角形\\n&quot;); &#125; else if((a*a + b*b ==c*c)||(a*a + c*c == b*b)||(b*b+c*c==a*a))&#123; printf(&quot;直角三角形\\n&quot;); &#125; else&#123; printf(&quot;普通三角形&quot;); &#125; &#125; else printf(&quot;不能构成三角形&quot;);&#125;","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"C实例","slug":"C实例","permalink":"http://example.com/tags/C%E5%AE%9E%E4%BE%8B/"}]},{"title":"对小数进行四舍五入：","slug":"数据结构和算法/C实例/对小数进行四舍五入：","date":"2018-12-31T16:00:00.000Z","updated":"2021-03-12T03:10:34.000Z","comments":true,"path":"2019/01/01/数据结构和算法/C实例/对小数进行四舍五入：/","link":"","permalink":"http://example.com/2019/01/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/C%E5%AE%9E%E4%BE%8B/%E5%AF%B9%E5%B0%8F%E6%95%B0%E8%BF%9B%E8%A1%8C%E5%9B%9B%E8%88%8D%E4%BA%94%E5%85%A5%EF%BC%9A/","excerpt":"","text":"源代码： 12345678910111213141516171819202122232425//请用户输入一个实数（浮点型），编写算法对这个实数进行四舍五入到个位的运算// 12.56----13 12.45----12#include&lt;stdio.h&gt;int main()&#123; //让用户输入一个小数 double num=0.0; printf(&quot;请输入一个小数：&quot;); scanf(&quot;%lf&quot;,&amp;num); //对这个数进行四舍五入计算 int i=num;//拿到整数部分 double xiaoShu=num-i;//小数部分 if(xiaoShu &gt;= 0.5)&#123; i++; &#125; printf(&quot;i=%d\\n&quot;,i);&#125;","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"C实例","slug":"C实例","permalink":"http://example.com/tags/C%E5%AE%9E%E4%BE%8B/"}]},{"title":"字符输入输出：","slug":"数据结构和算法/C实例/字符输入输出：","date":"2018-12-31T16:00:00.000Z","updated":"2021-03-12T03:05:50.000Z","comments":true,"path":"2019/01/01/数据结构和算法/C实例/字符输入输出：/","link":"","permalink":"http://example.com/2019/01/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/C%E5%AE%9E%E4%BE%8B/%E5%AD%97%E7%AC%A6%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%EF%BC%9A/","excerpt":"","text":"源代码： 123456789101112131415161718192021222324252627282930//标准库提供的输入/输出模型非常简单，无论文本从何处输入，输出到何处，其输入/输出都是按照字符流的方式处理。文本流是由多行字符构成的字符序列，而每行字符则由0个或多个字符组成，行末是一个换行符。标准库负责使每个输入/输出流都能够遵守这一模型。使用标准库的C语言程序员不必关心在程序之外这些行是如何表示的//每次调用时，getchar函数从文本流中读入下一个输入字符，并将其作为结果值返回【c=getter()】//每次调用putchar函数时将打印一个字符【putchar(c)】，putchar与printf这两个函数可以交替使用，输出的次序与调用的次序一致/* putchar: int putchar(int c); 向标准输出写一个字符 返回写了几个字符，EOF(-1)表示写失败*//* getchar: int getchar(void); 从标准输入读入一个字符 返回类型是int是为了返回EOF(-1)*///control-C 强制退出，程序并没有停止//control-D 正常退出//shell#include&lt;stdio.h&gt;int main()&#123; int ch; while((ch=getchar()) != EOF)&#123; putchar(ch); &#125; printf(&quot;EOF\\n&quot;);&#125; 文件复制： 源代码： 123456789101112131415161718192021//文件复制：#include &lt;stdio.h&gt;//将输入复制到输出int main()&#123; //字符在键盘、屏幕或其他的任何地方无论以什么形式表现，它在机器内部都是以位模式存储的，char类型专门用于存储这种字符型数据 //这里之所以不把c声明成char类型，是因为它必须足够大，除了能存储任何可能的字符外还要能存储文件结束符EOF int c; //EOF：end of file //EOF定义在头文件&lt;stdio.h&gt;中，是一个整型数，它与任何char类型的值都不相同 // !=的优先级比=的优先级要高 while((c=getchar()) != EOF)&#123; putchar(c); &#125;&#125; 字符计数：1） 源代码： 12345678910111213//字符计数：#include&lt;stdio.h&gt;int main()&#123; long nc; nc=0; while(getchar() != EOF)&#123; ++nc; &#125; printf(&quot; %ld\\n&quot;,nc);&#125; 2） 源代码： 12345678910#include&lt;stdio.h&gt;int main()&#123; double nc; for(nc=0;getchar() != EOF;++nc)&#123; ; //单独的分号称为空语句 &#125; printf(&quot; %.0f\\n&quot;,nc);&#125; 行计数： 源代码： 12345678910111213141516//行计数（统计行数等价于统计换行符的个数）#include&lt;stdio.h&gt;int main()&#123; int c,n1; n1=0; while((c=getchar()) != EOF)&#123; if(c == &#x27;\\n&#x27;)&#123; ++n1; &#125; &#125; printf(&quot;%d\\n&quot;,n1);&#125; 单词计数： 源代码： 12345678910111213141516171819202122232425262728293031//单词计数：//统计行数、字符数与单词数(任何其中不包含空格、制表符或换行符的字符序列)#include &lt;stdio.h&gt;#define IN 1//在单词内#define OUT 0//在单词外int main()&#123; int c,nl,nw,nc,state; state=OUT; nl=nw=nc=0;//在兼有值与赋值两种功能的表达式中，赋值结合次序是由右至左：nl=(nw=(nc=0)); while((c=getchar()) != EOF)&#123; ++nc; if(c == &#x27;\\n&#x27;)&#123; ++nl; &#125; // ||代表OR（逻辑或） // &amp;&amp;代表AND（逻辑与），它仅比||高一个优先级 if(c==&#x27; &#x27; || c==&#x27;\\n&#x27; || c== &#x27;\\t&#x27;)&#123; state=OUT; &#125; //程序执行时，每当遇到单词的第一个字符，它就作为一个新单词加以统计 else if(state==OUT)&#123; state=IN; ++nw; &#125; &#125; //nl:行数；nw:单词数；nc：字符数 printf(&quot;%d %d %d\\n&quot;,nl,nw,nc-1);&#125; 统计各个数字、空白符（包括空格符、制表符及换行符）以及所有其他字符出现的次数： 源代码： 1234567891011121314151617181920212223242526272829//统计各个数字、空白符（包括空格符、制表符及换行符）以及所有其他字符出现的次数#include&lt;stdio.h&gt;int main()&#123; int c,i,nwhite,nother; //数组下标可以是任何整型表达式、包括整型变量（如i）以及整型常量 int ndigit[10];//C语言中，数组下标总是从0开始 nwhite=nother=0; for(i=0;i&lt;10;++i)&#123; ndigit[i]=0; &#125; while((c=getchar()) != EOF)&#123; if(c &gt;= &#x27;0&#x27; &amp;&amp; c&lt;= &#x27;9&#x27;)&#123; ++ndigit[c-&#x27;0&#x27;]; &#125; else if(c==&#x27; &#x27; || c==&#x27;\\n&#x27; ||c==&#x27;\\t&#x27;)&#123; ++nwhite; &#125; else&#123; ++nother; &#125; &#125; printf(&quot;digit=&quot;); for(i=0;i&lt;10;++i)&#123; printf(&quot; %d&quot;,ndigit[i]); &#125; printf(&quot;,white space=%d,other=%d\\n&quot;,nwhite,nother);&#125;","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"C实例","slug":"C实例","permalink":"http://example.com/tags/C%E5%AE%9E%E4%BE%8B/"}]},{"title":"序列前n项和：","slug":"数据结构和算法/C实例/序列前n项和：","date":"2018-12-31T16:00:00.000Z","updated":"2021-03-12T03:06:15.000Z","comments":true,"path":"2019/01/01/数据结构和算法/C实例/序列前n项和：/","link":"","permalink":"http://example.com/2019/01/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/C%E5%AE%9E%E4%BE%8B/%E5%BA%8F%E5%88%97%E5%89%8Dn%E9%A1%B9%E5%92%8C%EF%BC%9A/","excerpt":"","text":"1）源代码： 1234567891011121314151617// f(n)=1+1/2+1/3+1/4+...+1/n#include&lt;stdio.h&gt;int main()&#123; int n,i; double sum=0.0; scanf(&quot;%d&quot;,&amp;n); for(i=1;i&lt;=n;i++)&#123; sum+=1.0/i; &#125; printf(&quot;f(%d)=%f\\n&quot;,n,sum);&#125; 2） 源代码： 12345678910111213141516171819// f(n)=1-1/2+1/3-1/4+...+1/n#include&lt;stdio.h&gt;int main()&#123; int n,i; double sum=0.0; int sign=1; scanf(&quot;%d&quot;,&amp;n); for(i=1;i&lt;=n;i++)&#123; sum+=sign*1.0/i; sign=-sign; &#125; printf(&quot;f(%d)=%f\\n&quot;,n,sum);&#125; 3） 源代码： 123456789101112131415161718192021222324//计算序列2/1+3/2+5/3+8/5+...的前N项之和，注意该序列从第2项起，每一项的分子是前一项分子与分母的和，分母是前一项的分子#include&lt;stdio.h&gt;int main()&#123; int n; double dividend=2,divisor=1; double sum=0.0; int i; double t; scanf(&quot;%d&quot;,&amp;n); for(i=1;i&lt;=n;i++)&#123; sum+=dividend/divisor; t=dividend; dividend=dividend+divisor; divisor=t; &#125; printf(&quot;%.2f\\n&quot;,sum);&#125;","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"C实例","slug":"C实例","permalink":"http://example.com/tags/C%E5%AE%9E%E4%BE%8B/"}]},{"title":"学生管理系统","slug":"数据结构和算法/C实例/学生管理系统","date":"2018-12-31T16:00:00.000Z","updated":"2021-03-12T03:00:09.000Z","comments":true,"path":"2019/01/01/数据结构和算法/C实例/学生管理系统/","link":"","permalink":"http://example.com/2019/01/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/C%E5%AE%9E%E4%BE%8B/%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/","excerpt":"","text":"//// main.c//学生系统//// Created by廖家龙on 2020/6/15.// Copyright © 2020 liuyuecao. All rights reserved.// #include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt; #define NUM 20 //性别枚举，表示学员的性别typedef enum{** GenderMale,**** GenderFemale**} Gender; //学生结构体，表示一个学生数据typedef struct{** int id;//学生编号 char name;//学生姓名 int age;//学生年龄 Gender gender;//学生性别 int score;//学生成绩} Student;* //结构体数组，这个数组中存储的是10个学生的信息Student students[NUM]={** {1,”jack”,18,GenderMale,100},**** {2,”rose”,21,GenderFemale,45},**** {3,”lily”,26,GenderFemale,23},**** {4,”jim1”,12,GenderMale,89},**** {5,”poly”,3,GenderMale,67},**** {6,”meimei”,19,GenderFemale,89},**** {7,”likai”,31,GenderMale,88},**** {8,”Qiang”,45,GenderMale,12},**** {9,”aDong”,29,GenderMale,76},**** {10,”asan”,35,GenderMale,91},**}; //代表数组中真正的存储了多少个学生的信息int realLength=10; //显示一级菜单，并接收用户的选择int showMenu(); //查询学生void query(); //新增学生void addStudent(); //删除学生void deleteStudent(); //修改学生void modifyStudent(); //显示查询的二级菜单int showQueryMenu(); //查询所有的学生信息void queryAll(); //根据编号查询void queryById(); //根据姓名查询void queryByName(); //根据年龄查询void queryByAge(); //根据性别查询void queryByGender(); //根据成绩查询void queryByScore(); int main(int argc, const char * argv[]) { ** while(1){** ** //1.显示操作菜单，并接收用户的选择 int userSelect=showMenu();** ** //2.判断用户的选择，根据用户的选择来做不同的事情 switch (userSelect) {**** case 1:**** //查询学生 query();**** break;**** case 2:**** //新增学生 addStudent();**** break;**** case 3:**** //删除学生 deleteStudent();**** break;**** case 4:**** //修改学生 modifyStudent();**** break;**** default:**** //结束程序 break;**** }**}} //显示一级菜单，并接收用户的选择int showMenu(){** //1.显示菜单 printf(“\\n”);** printf(“欢迎使用学生管理系统\\n”);** printf(“ 1.查询学生\\n”);** printf(“ 2.新增学生\\n”);** printf(“ 3.删除学生\\n”);** printf(“ 4.修改学生\\n”);** printf(“ 5.退出系统\\n”);** printf(“*******************************\\n”);**** //接收用户的选择 printf(“请输入你的选择：”);**** int userSelect=0;**** scanf(“%d”,&amp;userSelect);**** //3.将用户的选择返回 return userSelect;**} //查询学生void query(){ ** //1.显示查询的二级菜单，并接收用户的选择 int userSelect=showQueryMenu();**** //2.判断用户的选择，根据用户的选择作出不同的查询 switch (userSelect) {**** case 1:**** //查询所有学生信息 queryAll();**** break;**** case 2:**** //根据编号查询 queryById();**** break;**** case 3:**** //根据姓名查询 queryByName();**** break;**** case 4:**** //根据年龄查询 queryByAge();**** break;**** case 5:**** //根据性别查询 queryByGender();**** break;**** default:**** //根据成绩查询 queryByScore();**** break;**** }**} //显示查询的二级菜单int showQueryMenu(){ ** //1.显示查询的二级菜单 printf(“\\n”);** printf(“欢迎使用学生管理系统\\n”);** printf(“ 1.查询所有学生信息\\n”);** printf(“ 2.根据编号查询\\n”);** printf(“ 3.根据姓名查询\\n”);** printf(“ 4.根据年龄查询\\n”);** printf(“ 5.根据性别查询\\n”);** printf(“ 6.根据成绩查询\\n”);** printf(“**********************************\\n”);** ** //2.接收用户的选择 printf(“请输入你要进行的查询编号：”);**** int userSelect=0;**** scanf(“%d”,&amp;userSelect);**** //3.返回用户的选择 return userSelect;**} //新增学生void addStudent(){** //1.输入要新增的学生的信息 //编号不输入，让系统自动生成** //1.1.先输入姓名 printf(“请输入新增的学生的姓名：”); ** char name1[10];** ** rewind(stdin);** ** fgets(name1,10,stdin);**** size_t len=strlen(name1);** ** if(name1[len-1] == ‘\\n’){**** name1[len-1]=‘\\0’;**** }** ** char name=calloc(len+1,sizeof(char));*** strcpy(name, name1);** ** //1.2.输入年龄 printf(“请输入新增的学生的年龄：”);**** int age =0;**** scanf(“%d”,&amp;age);** ** //1.3.输入性别 printf(“请输入新增的学生的性别：0—&gt;男0—&gt;女”);**** int gender =0;**** scanf(“%d”,&amp;gender);** ** //1.4.输入成绩 printf(“请输入新增的学生的成绩：”);**** int score =0;**** scanf(“%d”,&amp;score);** ** //2.创建结构体变量 Student stu={students[realLength-1].id+1,name,age,gender,score};** ** //3.将输入的学生的信息保存在数组中 students[realLength]=stu;**** realLength++;**} //删除学生void deleteStudent(){ ** printf(“请输入要删除的学生的编号：”);**** int id=0;**** scanf(“%d”,&amp;id);** ** int deleteIndex=-1;**** for(int I=0;i&lt;realLength;i++){**** if(students[I].id==id){**** deleteIndex=I;**** break;**** }**** }** ** if(deleteIndex==-1){**** printf(“你输入的编号有误”);**** return;**** }** ** for(int I=deleteIndex+1;i&lt;realLength;i++){**** students[i-1]=students[I];**** }** ** realLength—;** } //修改学生void modifyStudent(){ } //查询所有的学生信息void queryAll(){ ** printf(“编号\\t\\t姓名\\t\\t年龄\\t\\t性别\\t\\t成绩\\t\\t\\n”);** ** for(int I=0;i&lt;realLength;i++){** ** printf(“%d\\t\\t%s\\t\\t%d\\t\\t%s\\t\\t%d\\n”,**** students[I].id,**** students[I].name,**** students[I].age,**** students[I].gender==GenderMale ? “男”:”女”,**** students[I].score**** );**** }** } //根据编号查询void queryById(){ } //根据姓名查询void queryByName(){ } //根据年龄查询void queryByAge(){ } //根据性别查询void queryByGender(){ } //根据成绩查询void queryByScore(){ ** //1.让用户输入一个最小成绩，再让用户输入一个最大成绩 int min=0,max=0;**** printf(“请输入最小成绩和最大成绩，使用空格分隔：”);**** scanf(“%d%d”,&amp;min,&amp;max);** ** //3.打印 printf(“编号\\t\\t姓名\\t\\t年龄\\t\\t性别\\t\\t成绩\\t\\t\\n”);** ** for(int I=0;i&lt;realLength;i++){**** if(students[I].score &gt;= min &amp;&amp; students[I].score &lt;= max){**** printf(“%d\\t\\t%s\\t\\t%d\\t\\t%s\\t\\t%d\\n”,**** students[I].id,**** students[I].name,**** students[I].age,**** students[I].gender==GenderMale ? “男”:”女”,**** students[I].score**** );**** }**** }** }","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"C实例","slug":"C实例","permalink":"http://example.com/tags/C%E5%AE%9E%E4%BE%8B/"}]},{"title":"将数组元素左边部分全是奇数，右边全是偶数，时间复杂度为O(n)：","slug":"数据结构和算法/C实例/将数组元素左边部分全是奇数，右边全是偶数，时间复杂度为O(n)：","date":"2018-12-31T16:00:00.000Z","updated":"2021-03-12T03:08:52.000Z","comments":true,"path":"2019/01/01/数据结构和算法/C实例/将数组元素左边部分全是奇数，右边全是偶数，时间复杂度为O(n)：/","link":"","permalink":"http://example.com/2019/01/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/C%E5%AE%9E%E4%BE%8B/%E5%B0%86%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E5%B7%A6%E8%BE%B9%E9%83%A8%E5%88%86%E5%85%A8%E6%98%AF%E5%A5%87%E6%95%B0%EF%BC%8C%E5%8F%B3%E8%BE%B9%E5%85%A8%E6%98%AF%E5%81%B6%E6%95%B0%EF%BC%8C%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%BAO(n)%EF%BC%9A/","excerpt":"","text":"源代码： 12345678910111213141516171819202122232425262728293031323334#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123; int ary[11]=&#123;1,2,3,4,5,6,7,8,9,10,11&#125;; int i=0,j=10; int temp; while(i&lt;j)&#123; while(ary[i]%2!=0)&#123; i++; &#125; while(ary[j]%2==0)&#123; j--; &#125; if(i&lt;j)&#123; temp=ary[i]; ary[i]=ary[j]; ary[j]=temp; &#125; &#125; for(i=0;i&lt;11;i++)&#123; printf(&quot;%d &quot;,ary[i]); &#125;&#125;","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"C实例","slug":"C实例","permalink":"http://example.com/tags/C%E5%AE%9E%E4%BE%8B/"}]},{"title":"尼科彻斯定理：","slug":"数据结构和算法/C实例/尼科彻斯定理：","date":"2018-12-31T16:00:00.000Z","updated":"2021-03-12T03:08:40.000Z","comments":true,"path":"2019/01/01/数据结构和算法/C实例/尼科彻斯定理：/","link":"","permalink":"http://example.com/2019/01/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/C%E5%AE%9E%E4%BE%8B/%E5%B0%BC%E7%A7%91%E5%BD%BB%E6%96%AF%E5%AE%9A%E7%90%86%EF%BC%9A/","excerpt":"","text":"源代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//尼科彻斯定理的内容是：任何一个整数的立方都可以写成一串连续奇数的和。#include&lt;stdio.h&gt;int main()&#123; int i,k=0,l,n,m,sum,flag=1; printf(&quot;please input a number:\\n&quot;); scanf(&quot;%d&quot;,&amp;n); m=n*n*n; i=m/2; if(i%2==0)&#123; i=i+1; &#125; while(flag==1&amp;&amp;i&gt;=1)&#123; sum=0; k=0; while(1)&#123; sum+=(i-2*k); k++; if(sum==m)&#123; printf(&quot;%d*%d*%d=%d=&quot;,n,n,n,m); for(l=0;l&lt;k-1;l++)&#123; &#125;; printf(&quot;%d+&quot;,i-1*2); printf(&quot;%d\\n&quot;,i-(k-1)*2); flag=0; break; &#125; if(sum&gt;m)&#123; break; &#125; &#125; i-=2; &#125;&#125;","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"C实例","slug":"C实例","permalink":"http://example.com/tags/C%E5%AE%9E%E4%BE%8B/"}]},{"title":"打印最长的输入行","slug":"数据结构和算法/C实例/打印最长的输入行","date":"2018-12-31T16:00:00.000Z","updated":"2021-03-12T03:01:34.000Z","comments":true,"path":"2019/01/01/数据结构和算法/C实例/打印最长的输入行/","link":"","permalink":"http://example.com/2019/01/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/C%E5%AE%9E%E4%BE%8B/%E6%89%93%E5%8D%B0%E6%9C%80%E9%95%BF%E7%9A%84%E8%BE%93%E5%85%A5%E8%A1%8C/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435**#include&lt;stdio.h&gt;****#define MAXLINE 1000//**允许输入行的最大长度**//getline**函数：将一行读入到**s**中并返回其长度**int getline1(char s[],int lim)&#123;**** int c,i;**** for(i=0;i&lt;lim-1 &amp;&amp; (c=getchar()) != EOF &amp;&amp; c != ‘\\n’;++i)&#123;**** s[i]=c;**** &#125;**** if(c==‘\\n’)&#123;**** s[I]=c;**** ++I;**** &#125;**** s[I]=‘\\0’;**** return I;****&#125;****//copy**函数：将**from**复制到**to**；这里假定**to**足够大**void copy(char to[],char from[])&#123;**** int I;**** I=0;**** while((to[I]=from[I]) != ‘\\0’)&#123;**** ++I;**** &#125;****&#125;****//**打印最长的输入行**main()&#123;**** int len;//**当前行长度** int max;//**目前为止发现的最长行的长度** char line[MAXLINE];//**当前的输入行** char longest[MAXLINE];//**用于保存最长的行 ** max=0;**** while((len=getline1(line,MAXLINE)) &gt;0)&#123;**** if(len&gt;max)&#123;**** max=len;**** copy(longest,line);**** &#125;**** &#125;**** if(max&gt;0)&#123; //**存在这样的行** printf(“%s”,longest);**** &#125;**** return 0;****&#125;** 1234567891011121314151617181920212223242526272829303132333435363738394041**#include&lt;stdio.h&gt;****#define MAXLINE 1000//**允许输入行的最大长度** int max;//**目前为止发现的最长行的长度** char line[MAXLINE];//**当前的输入行** char longest[MAXLINE];//**用于保存最长的行**//getline**函数：将一行读入到**s**中并返回其长度**int getline1(void)&#123;**** int c,i;**** extern char line[];** ** for(I=0;i&lt;MAXLINE-1 &amp;&amp; (c=getchar()) != EOF &amp;&amp; c != ‘\\n’;++i)&#123;**** line[I]=c;**** &#125;**** if(c==‘\\n’)&#123;**** line[I]=c;**** ++I;**** &#125;**** line[I]=‘\\0’;**** return I;****&#125;****//copy**函数：将**from**复制到**to**；这里假定**to**足够大**void copy(void)&#123;**** int I;**** extern char line[],longest[];** ** I=0;**** while((longest[I]=line[I]) != ‘\\0’)&#123;**** ++I;**** &#125;****&#125;****//**打印最长的输入行**main()&#123;**** int len;//**当前行长度** extern int max;**** extern char longest[];** ** max=0;**** while((len=getline1()) &gt;0)&#123;**** if(len&gt;max)&#123;**** max=len;**** copy();**** &#125;**** &#125;**** if(max&gt;0)&#123; //**存在这样的行** printf(“%s”,longest);**** &#125;**** return 0;****&#125;**","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"C实例","slug":"C实例","permalink":"http://example.com/tags/C%E5%AE%9E%E4%BE%8B/"}]},{"title":"打印三角形、乘法表：","slug":"数据结构和算法/C实例/打印三角形、乘法表：","date":"2018-12-31T16:00:00.000Z","updated":"2021-03-12T03:11:10.000Z","comments":true,"path":"2019/01/01/数据结构和算法/C实例/打印三角形、乘法表：/","link":"","permalink":"http://example.com/2019/01/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/C%E5%AE%9E%E4%BE%8B/%E6%89%93%E5%8D%B0%E4%B8%89%E8%A7%92%E5%BD%A2%E3%80%81%E4%B9%98%E6%B3%95%E8%A1%A8%EF%BC%9A/","excerpt":"","text":"打印三角形：1） 源代码： 123456789101112131415#include&lt;stdio.h&gt;int main()&#123; //i=2，在第2行打印2颗星 for(int i=1;i&lt;=10;i++)&#123; for(int j=0;j&lt;i;j++)&#123; printf(&quot;*&quot;); &#125; printf(&quot;\\n&quot;); &#125;&#125; 2） 源代码： 1234567891011121314151617181920212223242526#include&lt;stdio.h&gt;int main()&#123; //打印上10行 //i=2，在第2行打印2颗星 for(int i=1;i&lt;=10;i++)&#123; for(int j=0;j&lt;i;j++)&#123; printf(&quot;*&quot;); &#125; printf(&quot;\\n&quot;); &#125; //打印下9行 for(int i=1;i&lt;=9;i++)&#123; for(int j=0;j&lt;10-i;j++)&#123; printf(&quot;*&quot;); &#125; printf(&quot;\\n&quot;); &#125;&#125; 3） 源代码： 12345678910111213141516171819#include&lt;stdio.h&gt;int main()&#123; for(int i=1;i&lt;=10;i++)&#123; for(int j=0;j&lt;10-i;j++)&#123; printf(&quot; &quot;); &#125; for(int k=0;k&lt;i;k++)&#123; printf(&quot;*&quot;); &#125; printf(&quot;\\n&quot;); &#125;&#125; 打印下三角的乘法表： 源代码： 123456789101112131415161718192021222324#include&lt;stdio.h&gt;int main()&#123; int n; scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=i;j++)&#123; printf(&quot;%d*%d=%d&quot;,j,i,i*j); if(i*j&lt;10)&#123; printf(&quot; &quot;); &#125; else&#123; printf(&quot; &quot;); &#125; &#125; printf(&quot;\\n&quot;); &#125;&#125;","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"C实例","slug":"C实例","permalink":"http://example.com/tags/C%E5%AE%9E%E4%BE%8B/"}]},{"title":"打渔晒网问题：","slug":"数据结构和算法/C实例/打渔晒网问题：","date":"2018-12-31T16:00:00.000Z","updated":"2021-03-12T03:10:58.000Z","comments":true,"path":"2019/01/01/数据结构和算法/C实例/打渔晒网问题：/","link":"","permalink":"http://example.com/2019/01/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/C%E5%AE%9E%E4%BE%8B/%E6%89%93%E6%B8%94%E6%99%92%E7%BD%91%E9%97%AE%E9%A2%98%EF%BC%9A/","excerpt":"","text":"源代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778//如果一个渔夫从2011年1月1日开始每三天打一次渔，两天晒一次网，//编程实现当输入2011年1月1日以后的任意一天，输出该渔夫是在打渔还是在晒网。#include&lt;stdio.h&gt;int leap(int a)&#123; if((a % 4 == 0 &amp;&amp; a % 100 != 0) || a % 400 == 0)&#123; return 1; &#125; else&#123; return 0; &#125;&#125;int number(int year,int m,int d)&#123; int sum =0,i,j; int a[12]=&#123; 31,28,31,30,31,30,31,31,30,31,30,31 &#125;; int b[12]=&#123; 31,29,31,30,31,30,31,31,30,31,30,31 &#125;; if(leap(year)==1)&#123; for(i=0;i&lt;m-1;i++)&#123; sum+=b[i]; &#125; &#125; else&#123; for(i=0;i&lt;m-1;i++)&#123; sum+=a[i]; &#125; &#125; for(j=2011;j&lt;year;j++)&#123; if(leap(j)==1)&#123; sum+=366; &#125; else&#123; sum+=365; &#125; &#125; sum+=d; return sum;&#125;int main()&#123; int year,month,day,n; printf(&quot;please input year,month,day:\\n&quot;); scanf(&quot;%d%d%d&quot;,&amp;year,&amp;month,&amp;day); n=number(year,month,day); if((n%5)&lt;4&amp;&amp;(n%5)&gt;0)&#123; printf(&quot;%d:%d:%d 打渔\\n&quot;,year,month,day); &#125; else&#123; printf(&quot;%d:%d:%d 晒网\\n&quot;,year,month,day); &#125;&#125;","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"C实例","slug":"C实例","permalink":"http://example.com/tags/C%E5%AE%9E%E4%BE%8B/"}]},{"title":"水仙花数：","slug":"数据结构和算法/C实例/水仙花数：","date":"2018-12-31T16:00:00.000Z","updated":"2021-03-12T03:06:51.000Z","comments":true,"path":"2019/01/01/数据结构和算法/C实例/水仙花数：/","link":"","permalink":"http://example.com/2019/01/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/C%E5%AE%9E%E4%BE%8B/%E6%B0%B4%E4%BB%99%E8%8A%B1%E6%95%B0%EF%BC%9A/","excerpt":"","text":"源代码： 1234567891011121314151617181920212223242526//水仙花数是指一个N位正整数（N&gt;=3），它的每个位上的数字的N次幂之和等于它本身，例如：153=1^3+5^3+3^3#include &lt;stdio.h&gt;int main()&#123; int hun, ten, ind, n; printf(&quot;result is:\\n&quot;); for( n=100; n&lt;1000; n++ )&#123; /*整数的取值范围*/ hun = n / 100; ten = (n-hun*100) / 10; ind = n % 10; if(n == hun*hun*hun + ten*ten*ten + ind*ind*ind)&#123; /*各位上的立方和是否与原数n相等*/ printf(&quot;%d &quot;, n); &#125; &#125; printf(&quot;\\n&quot;); return 0;&#125;","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"C实例","slug":"C实例","permalink":"http://example.com/tags/C%E5%AE%9E%E4%BE%8B/"}]},{"title":"斐波那契数列：","slug":"数据结构和算法/C实例/斐波那契数列：","date":"2018-12-31T16:00:00.000Z","updated":"2021-03-12T03:10:10.000Z","comments":true,"path":"2019/01/01/数据结构和算法/C实例/斐波那契数列：/","link":"","permalink":"http://example.com/2019/01/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/C%E5%AE%9E%E4%BE%8B/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%EF%BC%9A/","excerpt":"","text":"源代码： 12345678910111213141516171819202122232425//斐波那契数列的特点是：第1个和第2个数都为1，从第3个数开始，该数是前两个数之和。求这个数列的前30个元素。#include&lt;stdio.h&gt;int main()&#123; int i; long f[31]; f[1]=1,f[2]=1; for(i=3;i&lt;31;i++)&#123; f[i]=f[i-1]+f[i-2]; &#125; for(i=1;i&lt;31;i++)&#123; printf(&quot;%ld &quot;,f[i]); if(i%5==0)&#123; printf(&quot;\\n&quot;); &#125; &#125;&#125;","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"C实例","slug":"C实例","permalink":"http://example.com/tags/C%E5%AE%9E%E4%BE%8B/"}]},{"title":"求100～200之间的素数：","slug":"数据结构和算法/C实例/求100～200之间的素数：","date":"2018-12-31T16:00:00.000Z","updated":"2021-03-12T03:07:46.000Z","comments":true,"path":"2019/01/01/数据结构和算法/C实例/求100～200之间的素数：/","link":"","permalink":"http://example.com/2019/01/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/C%E5%AE%9E%E4%BE%8B/%E6%B1%82100%EF%BD%9E200%E4%B9%8B%E9%97%B4%E7%9A%84%E7%B4%A0%E6%95%B0%EF%BC%9A/","excerpt":"","text":"源代码： 123456789101112131415161718192021222324252627282930313233//素数是大于1的整数，除了能被自身和1整除外，不能被其他正整数整除。#include&lt;stdio.h&gt;#include&lt;math.h&gt;int main()&#123; int i,j,n=0; for(i=100;i&lt;=200;i++)&#123; for(j=2;j&lt;=sqrt(i);j++)&#123; if(i%j==0)&#123; break; &#125; else if(j&gt;sqrt(i)-1)&#123; printf(&quot;%d &quot;,i); n++; if(n%5==0)&#123; printf(&quot;\\n&quot;); &#125; &#125; else&#123; continue; &#125; &#125; &#125;&#125;","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"C实例","slug":"C实例","permalink":"http://example.com/tags/C%E5%AE%9E%E4%BE%8B/"}]},{"title":"求n！：","slug":"数据结构和算法/C实例/求n！：","date":"2018-12-31T16:00:00.000Z","updated":"2021-03-12T03:07:16.000Z","comments":true,"path":"2019/01/01/数据结构和算法/C实例/求n！：/","link":"","permalink":"http://example.com/2019/01/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/C%E5%AE%9E%E4%BE%8B/%E6%B1%82n%EF%BC%81%EF%BC%9A/","excerpt":"","text":"求10！： 源代码： 123456789101112131415161718192021222324//编写代码实现求10！//要将求得的阶乘最终结果定义为单精度或双精度型，如果定义为整型，很容易出现溢出现象。#include&lt;stdio.h&gt;int main(void)&#123; int i=2,n=10; float fac=1; if(n==0||n==1)&#123; printf(&quot;factorial is 1.\\n&quot;); return 0; &#125; while(i&lt;=n)&#123; fac=fac*i; i++; &#125; printf(&quot;factorial of %d is:%.2f.\\n&quot;,n,fac);&#125; 求n！： 源代码： 1234567891011121314151617181920212223//n!#include&lt;stdio.h&gt;int main()&#123; int n,fact=1; printf(&quot;输入一个正整数n: &quot;); scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++)&#123; fact *= i; &#125; // while(i&lt;=n)&#123;// fact *= i;// i++;// &#125; printf(&quot;%d! = %d\\n&quot;,n,fact);&#125;","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"C实例","slug":"C实例","permalink":"http://example.com/tags/C%E5%AE%9E%E4%BE%8B/"}]},{"title":"求平均数","slug":"数据结构和算法/C实例/求平均数","date":"2018-12-31T16:00:00.000Z","updated":"2021-03-12T03:01:00.000Z","comments":true,"path":"2019/01/01/数据结构和算法/C实例/求平均数/","link":"","permalink":"http://example.com/2019/01/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/C%E5%AE%9E%E4%BE%8B/%E6%B1%82%E5%B9%B3%E5%9D%87%E6%95%B0/","excerpt":"","text":"123456789101112131415**//**算平均数：让用户输入一系列的正整数，最后输入**-1**表示输入结束，然后程序计算出这些数字的平均数，输入的数字的个数**#include&lt;stdio.h&gt;****int main()&#123;**** int number;**** int sum=0;**** int count=0;** ** scanf(“%d”,&amp;number);**** while(number != -1)&#123;**** sum+=number;**** count++;**** scanf(“%d”,&amp;number);**** &#125;**** printf(“**输入的数字个数为**%d\\n”,count);**** printf(“**输入数字的平均数为**%f\\n”,1.0*sum/count);****&#125;** 123456789101112131415161718192021222324252627//计算用户输入的数字的平均数，并输出所有大于平均数的数#include&lt;stdio.h&gt;int main()&#123; int x; double sum=0; int cnt=0; printf(“请输入数字的数量：”); scanf(“%d”,&amp;cnt); if(cnt&gt;0)&#123; int number[cnt]; scanf(“%d”,&amp;x); while(x != -1)&#123; number[cnt]=x; sum+=x; cnt++; scanf(“%d”,&amp;x); &#125; printf(“%f\\n”,sum/cnt); int I; for(I=0;i&lt;cnt;i++)&#123; if(number[I]&gt;sum/cnt)&#123; printf(“%d\\n”,number[I]); &#125; &#125; &#125;&#125;","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"C实例","slug":"C实例","permalink":"http://example.com/tags/C%E5%AE%9E%E4%BE%8B/"}]},{"title":"求幂函数power(m,n)：","slug":"数据结构和算法/C实例/求幂函数power(m,n)：","date":"2018-12-31T16:00:00.000Z","updated":"2021-03-12T03:05:07.000Z","comments":true,"path":"2019/01/01/数据结构和算法/C实例/求幂函数power(m,n)：/","link":"","permalink":"http://example.com/2019/01/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/C%E5%AE%9E%E4%BE%8B/%E6%B1%82%E5%B9%82%E5%87%BD%E6%95%B0power(m,n)%EF%BC%9A/","excerpt":"","text":"源代码： 123456789101112131415161718192021222324252627282930/* 求幂的函数power(m,n)，用于计算整数m的n次幂，其中n是正整数（标准库中提供了一个计算x^y的函数pow(x,y)）*/#include&lt;stdio.h&gt;//power函数的参数使用的名字只在power函数内部有效，对其他任何函数都是不可见的，其他函数可以使用与之相同的参数名字而不会引起冲突//我们通常把函数定义中圆括号内列表中出现的变量称为形式参数，而把函数调用中与形式参数对应的值称为实际参数//在C语言中，所有函数参数都是“通过值”传递的，也就是说，传递给被调用函数的参数值存放在临时变量中，而不是存放在原来的变量中；在C语言中，被调用函数不能直接修改主调函数中变量的值，而只能修改其私有的临时副本的值int power(int base,int n)&#123; int p=1; for(int i=1;i&lt;=n;++i)&#123; p=p*base; &#125; return p;&#125;int main()&#123; int i=3; printf(&quot;%d %d %d\\n&quot;,i,power(2,i),power(-3,i)); return 0;&#125;","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"C实例","slug":"C实例","permalink":"http://example.com/tags/C%E5%AE%9E%E4%BE%8B/"}]},{"title":"求最大公约数","slug":"数据结构和算法/C实例/求最大公约数","date":"2018-12-31T16:00:00.000Z","updated":"2021-03-12T03:00:45.000Z","comments":true,"path":"2019/01/01/数据结构和算法/C实例/求最大公约数/","link":"","permalink":"http://example.com/2019/01/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/C%E5%AE%9E%E4%BE%8B/%E6%B1%82%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0/","excerpt":"","text":"123456789101112131415161718192021**//**枚举求最大公约数**#include&lt;stdio.h&gt;****int main()&#123;**** int a,b;**** int min;**** scanf(“%d %d”,&amp;a,&amp;b);**** if(a&lt;b)&#123;**** min=a;**** &#125;else&#123;**** min=b;**** &#125;**** int ret=0;**** int I;**** for(I=1;i&lt;min;i++)&#123;**** if(a%I==0)&#123;**** if(b%I==0)&#123;**** ret=i;**** &#125;**** &#125;**** &#125;**** printf(“%d**和**%d**的最大公约数是**%d.\\n”,a,b,ret);****&#125;** 123456789101112**//**辗转相除法求最大公约数**#include&lt;stdio.h&gt;****int main()&#123;**** int a,b;**** int t;**** scanf(“%d %d”,&amp;a,&amp;b);**** while(b!=0)&#123;**** t=a%b;**** a=b;**** b=t;**** &#125;**** printf(“**最大公约数**=%d\\n”,a);****&#125;** 12345678910111213141516//约分#include&lt;stdio.h&gt;int main()&#123; int dividend,divisor; scanf(“%d/%d”,&amp;dividend,&amp;divisor); int a=dividend; int b=divisor; int t; while(b&gt;0)&#123; t=a%b; a=b; b=t; &#125; printf(“%d/%d\\n”,dividend/a,divisor/a);&#125;","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"C实例","slug":"C实例","permalink":"http://example.com/tags/C%E5%AE%9E%E4%BE%8B/"}]},{"title":"求散列之和S=a+aa+aaa+…+aaa…a(n个a)：","slug":"数据结构和算法/C实例/求散列之和S=a+aa+aaa+…+aaa…a(n个a)：","date":"2018-12-31T16:00:00.000Z","updated":"2021-03-12T03:07:28.000Z","comments":true,"path":"2019/01/01/数据结构和算法/C实例/求散列之和S=a+aa+aaa+…+aaa…a(n个a)：/","link":"","permalink":"http://example.com/2019/01/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/C%E5%AE%9E%E4%BE%8B/%E6%B1%82%E6%95%A3%E5%88%97%E4%B9%8B%E5%92%8CS=a+aa+aaa+%E2%80%A6+aaa%E2%80%A6a(n%E4%B8%AAa)%EF%BC%9A/","excerpt":"","text":"源代码： 12345678910111213141516171819202122//输入两个整数a和n，a的范围是[0,9],n的范围是[1,8],求散列之和S=a+aa+aaa+…+aaa…a(n个a)#include&lt;stdio.h&gt;int main()&#123; int a,n; scanf(&quot;%d %d&quot;,&amp;a,&amp;n); int sum=0; int i; int t=0; for(i=0;i&lt;n;i++)&#123; t=t*10+a; sum += t; &#125; printf(&quot;%d\\n&quot;,sum);&#125;","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"C实例","slug":"C实例","permalink":"http://example.com/tags/C%E5%AE%9E%E4%BE%8B/"}]},{"title":"特殊的完全平方数：","slug":"数据结构和算法/C实例/特殊的完全平方数：","date":"2018-12-31T16:00:00.000Z","updated":"2021-03-12T03:06:40.000Z","comments":true,"path":"2019/01/01/数据结构和算法/C实例/特殊的完全平方数：/","link":"","permalink":"http://example.com/2019/01/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/C%E5%AE%9E%E4%BE%8B/%E7%89%B9%E6%AE%8A%E7%9A%84%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0%EF%BC%9A/","excerpt":"","text":"源代码： 1234567891011121314151617181920212223242526272829303132//在3位整数100～999中查找符合如下条件的整数并在屏幕上输出：这个数既是完全平方数，又有两个数字相同，如121，144等。#include&lt;stdio.h&gt;int main()&#123; int i,j; int hun,ten,data; printf(&quot;结果是:\\n&quot;); for(i=100;i&lt;=999;i++)&#123; j=10; while(j*j&lt;=i)&#123; if(i==j*j)&#123; hun=i/100; data=i-hun*100; ten=data/10; data=data-ten*10; if(hun==ten||hun==data||ten==data)&#123; printf(&quot;%5d&quot;,i); &#125; &#125; j++; &#125; &#125; printf(&quot;\\n&quot;);&#125;","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"C实例","slug":"C实例","permalink":"http://example.com/tags/C%E5%AE%9E%E4%BE%8B/"}]},{"title":"素数","slug":"数据结构和算法/C实例/素数","date":"2018-12-31T16:00:00.000Z","updated":"2021-03-12T03:03:08.000Z","comments":true,"path":"2019/01/01/数据结构和算法/C实例/素数/","link":"","permalink":"http://example.com/2019/01/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/C%E5%AE%9E%E4%BE%8B/%E7%B4%A0%E6%95%B0/","excerpt":"","text":"","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"C实例","slug":"C实例","permalink":"http://example.com/tags/C%E5%AE%9E%E4%BE%8B/"}]},{"title":"猜字谜游戏","slug":"数据结构和算法/C实例/猜字谜游戏","date":"2018-12-31T16:00:00.000Z","updated":"2021-03-12T03:03:21.000Z","comments":true,"path":"2019/01/01/数据结构和算法/C实例/猜字谜游戏/","link":"","permalink":"http://example.com/2019/01/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/C%E5%AE%9E%E4%BE%8B/%E7%8C%9C%E5%AD%97%E8%B0%9C%E6%B8%B8%E6%88%8F/","excerpt":"","text":"产生一个随机数：1）先引入一个系统头文件#include&lt;stdlib.h&gt;2）int num=arc4random_uniform(10);将产生一个0～9的随机数int num=arc4random_uniform(11)+10;将产生一个10～20的随机数 随机数：每次召唤rand（）就得到一个随机的整数","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"C实例","slug":"C实例","permalink":"http://example.com/tags/C%E5%AE%9E%E4%BE%8B/"}]},{"title":"给定不超过6的正整数A，考虑从A开始连续4个数字，请输出所有由它们组成的无重复数字的3位数：","slug":"数据结构和算法/C实例/给定不超过6的正整数A，考虑从A开始连续4个数字，请输出所有由它们组成的无重复数字的3位数：","date":"2018-12-31T16:00:00.000Z","updated":"2021-03-12T03:09:39.000Z","comments":true,"path":"2019/01/01/数据结构和算法/C实例/给定不超过6的正整数A，考虑从A开始连续4个数字，请输出所有由它们组成的无重复数字的3位数：/","link":"","permalink":"http://example.com/2019/01/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/C%E5%AE%9E%E4%BE%8B/%E7%BB%99%E5%AE%9A%E4%B8%8D%E8%B6%85%E8%BF%876%E7%9A%84%E6%AD%A3%E6%95%B4%E6%95%B0A%EF%BC%8C%E8%80%83%E8%99%91%E4%BB%8EA%E5%BC%80%E5%A7%8B%E8%BF%9E%E7%BB%AD4%E4%B8%AA%E6%95%B0%E5%AD%97%EF%BC%8C%E8%AF%B7%E8%BE%93%E5%87%BA%E6%89%80%E6%9C%89%E7%94%B1%E5%AE%83%E4%BB%AC%E7%BB%84%E6%88%90%E7%9A%84%E6%97%A0%E9%87%8D%E5%A4%8D%E6%95%B0%E5%AD%97%E7%9A%843%E4%BD%8D%E6%95%B0%EF%BC%9A/","excerpt":"","text":"源代码： 12345678910111213141516171819202122232425262728293031323334#include&lt;stdio.h&gt;int main()&#123; int a=6; scanf(&quot;%d&quot;,&amp;a); int i,j,k; int cnt=0; for(i=a;i&lt;=a+3;i++)&#123; for(j=a;j&lt;=a+3;j++)&#123; for(k=a;k&lt;=a+3;k++)&#123; if(i != j &amp;&amp; i != k &amp;&amp; j != k)&#123; cnt++; printf(&quot;%d%d%d&quot;,i,j,k); if(cnt==6)&#123; printf(&quot;\\n&quot;); cnt=0; &#125; else&#123; printf(&quot; &quot;); &#125; &#125; &#125; &#125; &#125;&#125;","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"C实例","slug":"C实例","permalink":"http://example.com/tags/C%E5%AE%9E%E4%BE%8B/"}]},{"title":"翻转数组：","slug":"数据结构和算法/C实例/翻转数组：","date":"2018-12-31T16:00:00.000Z","updated":"2021-03-12T03:10:22.000Z","comments":true,"path":"2019/01/01/数据结构和算法/C实例/翻转数组：/","link":"","permalink":"http://example.com/2019/01/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/C%E5%AE%9E%E4%BE%8B/%E7%BF%BB%E8%BD%AC%E6%95%B0%E7%BB%84%EF%BC%9A/","excerpt":"","text":"源代码： 1234567891011121314151617181920#include&lt;stdio.h&gt; int main()&#123; int arr[]=&#123;10,210,21302,132,43,24,3,5,46,4&#125;; int len=sizeof(arr)/sizeof(arr[0]); for(int i=0;i&lt;len/2;i++)&#123; int temp = arr[i]; arr[i] = arr[len-1-i]; arr[len-1-i] = temp; &#125; for(int i=0;i&lt;len;i++)&#123; printf(&quot;%d &quot;,arr[i]); &#125;&#125;","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"C实例","slug":"C实例","permalink":"http://example.com/tags/C%E5%AE%9E%E4%BE%8B/"}]},{"title":"统计数组中每一种数字出现的次数：","slug":"数据结构和算法/C实例/统计数组中每一种数字出现的次数：","date":"2018-12-31T16:00:00.000Z","updated":"2021-03-12T03:06:27.000Z","comments":true,"path":"2019/01/01/数据结构和算法/C实例/统计数组中每一种数字出现的次数：/","link":"","permalink":"http://example.com/2019/01/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/C%E5%AE%9E%E4%BE%8B/%E7%BB%9F%E8%AE%A1%E6%95%B0%E7%BB%84%E4%B8%AD%E6%AF%8F%E4%B8%80%E7%A7%8D%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0%EF%BC%9A/","excerpt":"","text":"源代码： 123456789101112131415161718192021222324252627282930313233//写一个程序，输入数量不确定的[0,9]范围内的整数，统计每一种数字出现的次数，输入-1表示结束#include&lt;stdio.h&gt;int main()&#123; const int number=10; int x; int count[number]; int i; //初始化数组：count[number]=0 for(i=0;i&lt;number;i++)&#123; count[i]=0; &#125; scanf(&quot;%d&quot;,&amp;x); while(x != -1)&#123; if(x&gt;=0 &amp;&amp; x&lt;= 9)&#123; count[x]++; &#125; scanf(&quot;%d&quot;,&amp;x); &#125; for(i=0;i&lt;number;i++)&#123; printf(&quot;%d:%d\\n&quot;,i,count[i]); &#125;&#125;","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"C实例","slug":"C实例","permalink":"http://example.com/tags/C%E5%AE%9E%E4%BE%8B/"}]},{"title":"自守数：","slug":"数据结构和算法/C实例/自守数：","date":"2018-12-31T16:00:00.000Z","updated":"2021-03-12T03:05:37.000Z","comments":true,"path":"2019/01/01/数据结构和算法/C实例/自守数：/","link":"","permalink":"http://example.com/2019/01/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/C%E5%AE%9E%E4%BE%8B/%E8%87%AA%E5%AE%88%E6%95%B0%EF%BC%9A/","excerpt":"","text":"源代码： 1234567891011121314151617181920212223242526272829303132//自守数是指一个数的平方的尾数等于该数自身的自然数，如25^2=625,76^2=5776,9376^2=87909376.#include&lt;stdio.h&gt;int main()&#123; long mul,number,k,ll,kk; printf(&quot;列出200000以内的自守数:\\n&quot;); for(number=0;number&lt;200000;number++)&#123; for(mul=number,k=1;(mul/=10)&gt;0;k*=10)&#123;&#125;; //由number的位数确定截取数字进行乘法时的系数k kk=k*10; //kk为截取部分积时的系数 mul=0; //积的最后n位 ll=10; //ll为截取乘数相应位时的系数 while(k&gt;0)&#123; mul=(mul+(number%(k*10))*(number%ll-number%(ll/10)))%kk; //(部分积+截取被乘数的后N位*截取乘数的第M位)，%kk再截取部分积 k/=10; //k为截取被乘数时的系数 ll*=10; &#125; if(number==mul)&#123; //判断若为自守数则输出 printf(&quot;%ld &quot;,number); &#125; &#125;&#125;","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"C实例","slug":"C实例","permalink":"http://example.com/tags/C%E5%AE%9E%E4%BE%8B/"}]},{"title":"计算log2X：","slug":"数据结构和算法/C实例/计算log2X：","date":"2018-12-31T16:00:00.000Z","updated":"2021-03-12T03:09:05.000Z","comments":true,"path":"2019/01/01/数据结构和算法/C实例/计算log2X：/","link":"","permalink":"http://example.com/2019/01/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/C%E5%AE%9E%E4%BE%8B/%E8%AE%A1%E7%AE%97log2X%EF%BC%9A/","excerpt":"","text":"源代码： 12345678910111213141516171819#include&lt;stdio.h&gt;int main()&#123; int x; int ret=0; scanf(&quot;%d&quot;,&amp;x); int t=x;//计算之前先保存原始的值 while(x&gt;1)&#123; x/=2; ret++; &#125; printf(&quot;log2 of %d is %d.\\n&quot;,t,ret);&#125;","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"C实例","slug":"C实例","permalink":"http://example.com/tags/C%E5%AE%9E%E4%BE%8B/"}]},{"title":"计算时间差：","slug":"数据结构和算法/C实例/计算时间差：","date":"2018-12-31T16:00:00.000Z","updated":"2021-03-12T03:09:16.000Z","comments":true,"path":"2019/01/01/数据结构和算法/C实例/计算时间差：/","link":"","permalink":"http://example.com/2019/01/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/C%E5%AE%9E%E4%BE%8B/%E8%AE%A1%E7%AE%97%E6%97%B6%E9%97%B4%E5%B7%AE%EF%BC%9A/","excerpt":"","text":"1） 源代码： 12345678910111213141516171819//计算时间差#include&lt;stdio.h&gt;int main()&#123; int hour1,minute1; int hour2,minute2; scanf(&quot;%d:%d&quot;,&amp;hour1,&amp;minute1); scanf(&quot;%d:%d&quot;,&amp;hour2,&amp;minute2); int t1=hour1*60+minute1; int t2=hour2*60+minute2; int t=t2-t1; printf(&quot;时间差是%d小时%d分。\\n&quot;,t/60,t%60);&#125; 2） 源代码： 12345678910111213141516171819202122#include&lt;stdio.h&gt;int main()&#123; int hour1,minute1; int hour2,minute2; scanf(&quot;%d:%d&quot;,&amp;hour1,&amp;minute1); scanf(&quot;%d:%d&quot;,&amp;hour2,&amp;minute2); int ih=hour2-hour1; int im=minute2-minute1; if(im&lt;0)&#123; im=60+im; ih--; &#125; printf(&quot;时间差是%d小时%d分。\\n&quot;,ih,im);&#125;","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"C实例","slug":"C实例","permalink":"http://example.com/tags/C%E5%AE%9E%E4%BE%8B/"}]},{"title":"走迷宫小游戏","slug":"数据结构和算法/C实例/走迷宫小游戏","date":"2018-12-31T16:00:00.000Z","updated":"2021-03-12T03:02:16.000Z","comments":true,"path":"2019/01/01/数据结构和算法/C实例/走迷宫小游戏/","link":"","permalink":"http://example.com/2019/01/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/C%E5%AE%9E%E4%BE%8B/%E8%B5%B0%E8%BF%B7%E5%AE%AB%E5%B0%8F%E6%B8%B8%E6%88%8F/","excerpt":"","text":"","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"C实例","slug":"C实例","permalink":"http://example.com/tags/C%E5%AE%9E%E4%BE%8B/"}]},{"title":"进制转换","slug":"数据结构和算法/C实例/进制转换","date":"2018-12-31T16:00:00.000Z","updated":"2021-03-12T03:01:12.000Z","comments":true,"path":"2019/01/01/数据结构和算法/C实例/进制转换/","link":"","permalink":"http://example.com/2019/01/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/C%E5%AE%9E%E4%BE%8B/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/","excerpt":"","text":"1234567891011121314151617181920212223十进制转换为二进制**//%**和**/**的应用。**%**为模运算符，或称求余运算符，**%**两侧均应为整型数据；**/**为除法运算符，两个整数相除的结果为整数，运算的两个数中有一个数为实数，则结果是**double**型。**#include&lt;stdio.h&gt;****#include&lt;stdlib.h&gt;****void main()&#123;**** int i,j,n,m;**** int a[16]=&#123;**** 0**** &#125;;**** system(“cls”);**** printf(“**请输入一个十进制数**(0~32767):\\n”);**** scanf(“%d”,&amp;n);**** for(m=0;m&lt;15;m++)&#123;**** I=n%2;**** j=n/2;**** n=j;**** a[m]=I;**** &#125;**** for(m=15;m&gt;=0;m—)&#123;**** printf(“%d”,a[m]);**** if(m%4==0)**** printf(“ “);**** &#125;**** printf(“\\n”);****&#125;** 12345678910111213141516171819202122232425？**n**进制转换为十进制**#include&lt;stdio.h&gt;****#include&lt;string.h&gt;****void main()&#123;**** long t1;**** int i,n,t,t3;**** char a[100];**** printf(“please input a number:\\n”);**** gets(a);**** strupr(a);**** t1=0;**** printf(“**请输入进制**n(2**或**8**或**16)**：**\\n”);**** scanf(“%d”,&amp;n);**** for(I=0;i&lt;t3;i++)&#123;**** if(a[I]-‘0’&gt;=n&amp;&amp;a[I]-‘A’||a[I]-‘A’+10&gt;=n)&#123;**** printf(“**输入有误！！**”);**** exit(0);**** &#125;**** if(a[I]&gt;=‘0’&amp;&amp;a[I]&lt;=‘9’)**** t=a[I]-‘0’;**** else if(n&gt;=11&amp;&amp;(a[I]&gt;=‘A’&amp;&amp;a[I]&lt;=‘A’+n-10))**** t=a[I]-‘A’+10;**** t1=t1*n+t;**** &#125;**** printf(“**十进制形式是**%1d\\n”,t1);****&#125;**","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"C实例","slug":"C实例","permalink":"http://example.com/tags/C%E5%AE%9E%E4%BE%8B/"}]},{"title":"六种经典排序","slug":"数据结构和算法/六种经典排序","date":"2018-12-31T16:00:00.000Z","updated":"2021-03-12T03:03:58.000Z","comments":true,"path":"2019/01/01/数据结构和算法/六种经典排序/","link":"","permalink":"http://example.com/2019/01/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E5%85%AD%E7%A7%8D%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F/","excerpt":"","text":"求数组中的最大值/最小值/累加和、平均值 求用户输入的多个数的最大、最小值。。while循环 3个数由小到大排序//任意输入3个整数，编程实现对这3个整数由小到大进行排序。//本实例使用scanf(“%d%d%d”,&amp;a,&amp;b,&amp;c)从键盘中获得任意3个数。在输入数据时，在两个数据之间以一个或多个空格间隔，也可以用Enter键、Tab键，不能用逗号作为两个数据间的分隔符。若用格式输入函数*scanf(“%d,%d,%d”,&amp;a,&amp;b,&amp;c)*输入数据，两个数据之间要用“，”做间隔。 1234567891011121314151617181920212223#include&lt;stdio.h&gt;**int** main()&#123; **int** a,b,c,t; printf(“Please input a,b,c:\\n”); scanf(“%d%d%d”,&amp;a,&amp;b,&amp;c); **if**(a&gt;b)&#123; t=a; a=b; b=t; &#125; **if**(a&gt;c)&#123; t=a; a=c; c=t; &#125; **if**(b&gt;c)&#123; t=b; b=c; c=t; &#125; printf(“The order of the number is:\\n”); printf(“%d,%d,%d”,a,b,c);&#125; 数组元素逆置： 直接插入排序*//*插入排序是把一个记录插入到已排序的有序序列中，使整个序列在插入该纪录后仍然有序。插入排序中较简单的一种方法是直接插入排序，其插入位置的确定方法是将待插入的记录与有序区中的各记录自右向左依次比较其关键字值的大小。 12345678910111213141516171819202122232425262728#include&lt;stdio.h&gt;**void** insort(**int** s[],**int** n)&#123; **int** i,j; **for**(i=2;i&lt;=n;i++)&#123; s[0]=s[i]; j=i-1; **while**(s[0]&lt;s[j])&#123; s[j+1]=s[j]; j—; &#125; s[j+1]=s[0]; &#125;&#125;**void** main()&#123; **int** a[11],I; printf(“please input ten numbers:\\n”); **for**(I=1;i&lt;=10;i++) scanf(“%d”,&amp;a[I]); printf(“原始顺序:\\n”); **for**(I=1;i&lt;11;i++) printf(“%5d”,a[I]); insort(a,10); printf(“\\n 插入数据排序后顺序：\\n”); **for**(I=1;i&lt;11;i++) printf(“%5d”,a[I]); printf(“\\n”);&#125; 希尔排序//用希尔排序法对一组数据从小到大进行排序，数据分别为69，56，12，136，3，55，46，99，88，25.//希尔排序是在直接插入排序的基础上做的改进，也就是将要排序的序列按固定增量分成若干组，等距离者在同一组中，然后再在组内进行直接插入排序。这里面的固定增量从nn/2开始，以后每次缩小到原来的一半。 1234567891011121314151617181920212223242526272829#include&lt;stdio.h&gt;**void** shsort(**int** s[],**int** n)&#123; **int** i,j,d; d=n/2; **while**(d&gt;=1)&#123; **for**(I=d+1;i&lt;=n;i++)&#123; s[0]=s[i]; j=i-d; **while**((j&gt;0)&amp;&amp;(s[0]&lt;s[j]))&#123; s[j+d]=s[j]; j=j-d; &#125; s[j+d]=s[0]; &#125; d=d/2; &#125;&#125;**void** main()&#123; **int** a[11],I; printf(“please input ten numbers:\\n”); **for**(I=1;i&lt;=10;i++) scanf(“%d”,&amp;a[I]); shsort(a,10); printf(“排序后的顺序是：\\n”); **for**(I=1;i&lt;=10;i++) printf(“%5d”,a[I]); printf(“\\n”);&#125; 冒泡排序//用冒泡法对任意输入的10个数由小到大进行排序//冒泡法的基本思路是，如果要对n个数进行冒泡排序，那么要进行n-1趟比较，在第1趟比较中要进行n-1次两两比较，在第j趟中要进行n-j次两两比较。从这个基本思路中发现，趟数决定了两两比较的次数，这样就很容易将两个for循环联系起来了。 12345678910111213141516171819202122#include&lt;stdio.h&gt;**void** main()&#123; **int** i,j,t,a[11]; printf(“please input ten numbers:\\n”); **for**(I=1;i&lt;11;i++) scanf(“%d”,&amp;a[I]); **for**(I=1;i&lt;10;i++) **for**(j=1;j&lt;11;j++) **if**(a[j]&gt;a[j+1])&#123; t=a[j]; a[j]=a[j+1]; a[j+1]=t; &#125; printf(“排序后的顺序是：\\n”); **for**(I=1;i&lt;=10;i++) printf(“%5d”,a[I]); printf(“\\n”);&#125; 快速排序//用快速排序法对一组数据由小到大进行排序，数据分别为99，45，12，36，69，22，62，796，4，696//快速排序是对冒泡排序的一种改进，主要的算法思想是在待排序的n个数据中取第一个数据作为基准值，将所有记录分为3组，使第一组中各数据值均小于或等于基准值，第二组做基准值的数据，第三组中各数据值均大于或等于基准值。这便实现了第一趟分割，然后再对第一组和第三组分别重复上述方法，以此类推，直到每组中只有一个记录为止。 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;stdio.h&gt;**void** qusort(**int** s[],**int** start,**int** end)&#123; **int** i,j; I=start; j=end; s[0]=s[start]; **while**(I&lt;j)&#123; **while**(I&lt;j&amp;&amp;s[0]&lt;s[j]) j—; **if**(I&lt;j)&#123; s[I]=s[j]; I++; &#125; **while**(I&lt;j&amp;&amp;s[I]&lt;=s[0]) I++; **if**(I&lt;j)&#123; s[j]=s[I]; j—; &#125; &#125; s[I]=s[0]; **if**(start&lt;i) qusort(s,start,j-1); **if**(I&lt;end) qusort(s,j+1,end);&#125;**void** main()&#123; **int** a[11],I; printf(“please input ten numbers:\\n”); **for**(I=1;i&lt;=10;i++) scanf(“%d”,&amp;a[I]); qusort(a,1,10); printf(“排序后的顺序是：\\n”); **for**(I=1;i&lt;=10;i++) printf(“%5d”,a[I]); printf(“\\n”);&#125; 选择排序//用选择排序法对一组数据由小到大进行排序，数据分别为526，36，2，369，56，45，78，92，125，52.//选择排序的基本算法是从待排序的区间中经过选择和交换后选出最小的数值存放到a[0]中，再从剩余的未排序区间中经过选择和交换后选出最小的数值存放到a[1]中，a[1]中的数字仅大于a[0]，以此类推，即可实现排序。 123456789101112131415161718192021222324#include&lt;stdio.h&gt;**void** main()&#123; **int** i,j,t,a[11]; printf(“please input ten numbers:\\n”); **for**(I=1;i&lt;11;i++) scanf(“%d”,&amp;a[I]); **for**(I=1;i&lt;=9;i++) **for**(j=I+1;j&lt;=10;j++) **if**(a[I]&gt;a[j])&#123; t=a[I]; a[I]=a[j]; a[j]=t; &#125; printf(“排序后的顺序是：\\n”); **for**(I=1;i&lt;=10;i++) printf(“%5d”,a[I]); printf(“\\n”);&#125; [image:C7736FB2-872D-41A1-9CA3-D087519F454F-23019-0000F9CC713A9ECD/Pasted Graphic 22.png] 归并排序//用归并排序法对一组数据由小到大进行排序，数据分别为695，458，362，789，12，15，163，23，2，986.//归并是将两个或多个有序记录序列合并成一个有序序列。归并方法有多种，一次对两个有序记录序列进行归并，称为二路归并排序，也有三路归并排序及多路归并排序。本实例是二路归并排序，基本方法如下：//（1）将n个记录看成是n个长度为1的有序子表。//（2）将两两相邻的有序子表进行归并。//（3）重复执行步骤（2），直到归并成一个长度为n的有序表。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;stdio.h&gt;**void** merge(**int** r[],**int** s[],**int** x1,**int** x2,**int** x3)&#123; **int** i,j,k; I=x1; j=x2+1; k=x1; **while**((I&lt;=x2)&amp;&amp;(j&lt;=x3)) **if**(r[I]&lt;=r[j])&#123; s[k]=r[I]; I++; k++; &#125; **else**&#123; s[k]=r[j]; j++; k++; &#125; **while**(I&lt;=x2) s[k++]=r[I++]; **while**(j&lt;=x3) s[k++]=r[j++];&#125;**void** merge_sort(**int** r[],**int** s[],**int** m,**int** n)&#123; **int** p; **int** t[20]; **if**(m==n) s[m]=r[m]; **else**&#123; p=(m+n)/2; merge_sort(r,t,m,p); merge_sort(r,t,p+1,n); merge(t,s,m,p,n); &#125;&#125;**void** main()&#123; **int** a[11]; **int** I; printf(“please input ten numbers:\\n”); **for**(I=1;i&lt;=10;i++) scanf(“%d”,&amp;a[I]); merge_sort(a,a,1,10); printf(“排序后的顺序是：\\n”); **for**(I=1;i&lt;=10;i++) printf(“%5d”,a[I]); printf(“\\n”);&#125;","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"C实例","slug":"C实例","permalink":"http://example.com/tags/C%E5%AE%9E%E4%BE%8B/"}]},{"title":"三种查找方法","slug":"数据结构和算法/三种查找方法","date":"2018-12-31T16:00:00.000Z","updated":"2021-03-12T03:03:46.000Z","comments":true,"path":"2019/01/01/数据结构和算法/三种查找方法/","link":"","permalink":"http://example.com/2019/01/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E4%B8%89%E7%A7%8D%E6%9F%A5%E6%89%BE%E6%96%B9%E6%B3%95/","excerpt":"","text":"二分查找//本实例采用二分查找法查找特定关键字的元素。要求用户输入数组长度，也就是有序表的数据长度，并输入数组元素和查找的关键字。程序输出查找成功与否，以及成功时关键字在数组中的位置。例如，在有序表11，13，18，28，39，56，69，89，98，122中查找关键字为89的元素。//二分查找就是折半查找，其基本思想是：首先选取表中间位置的记录，将其关键字与给定关键字key进行比较，若相等，则查找成功；若key值比该关键字值大，则要找的元素一定在右子表中，则继续对右子表进行折半查找；若key值比该关键字值小，则要找的元素一定在左子表中，继续对左子表进行折半查找。如此递推，直到查找成功或查找失败（查找范围为0）。 123456789101112131415161718192021222324252627282930313233#include&lt;stdio.h&gt;**void** binary_search(**int** key,**int** a[],**int** n)&#123; **int** low,high,mid,count=0,count1=0; low=0; high=n-1; **while**(low&lt;high)&#123; count++; mid=(low+high)/2; **if**(key&lt;a[mid]) high=mid-1; **else** **if**(key&gt;a[mid]) low=mid+1; **else** **if**(key==a[mid])&#123; printf(“查找成功！\\n查找%d次！a[%d]=%d”,count,mid,key); count1++; **break**; &#125; &#125; **if**(count1==0) printf(“查找失败！”);&#125; **int** main(**void**)&#123; **int** i,key,a[100],n; printf(“请输入数组长度：\\n”); scanf(“%d”,&amp;n); printf(“请输入数组元素：\\n”); **for**(I=0;i&lt;n;i++) scanf(“%d”,&amp;a[i]); printf(“请输入你想查找的元素：\\n”); scanf(“%d”,&amp;key); binary_search(key,a,n); printf(“\\n”);&#125; 分块查找*//*分块查找也称为索引顺序查找，要求将待查的元素均匀的分成块，块间按大小排序，块内不排序，所以要建立一个块的最大（或最小）关键字表，成为索引表。 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;stdio.h&gt;**struct** index&#123; **int** key; **int** start; **int** end;&#125;index_table[4];**int** block_search(**int** key,**int** a[])&#123; **int** i,j; I=1; **while**(I&lt;=3&amp;&amp;key&gt;index_table[I].key) I++; **if**(I&gt;3) **return** 0; j=index_table[I].start; **while**(j&lt;=index_table[I].end&amp;&amp;a[j]!=key) j++; **if**(j&gt;index_table[I].end) j=0; **return** j;&#125;**void** main()&#123; **int** i,j=0,k,key,a[16]; printf(“请输入15个数:\\n”); **for**(I=1;i&lt;16;i++) scanf(“%d”,&amp;a[I]); **for**(I=1;i&lt;=3;i++)&#123; index_table[I].start=j+1; j=j+1; index_table[I].end=j+4; j=j+4; index_table[I].key=a[j]; &#125; printf(“请输入你想查找的元素：\\n”); scanf(“%d”,&amp;key); k=block_search(key,a); **if**(k!=0) printf(“查找成功，其位置是：%d\\n,k”); **else** printf(“查找失败！”);&#125; 哈希查找//编程实现哈希查找。要求如下：已知哈希表长度为11，哈希函数为H(key)=key%11,随机产生待散列的小于50的8个元素，同时采用线性探测仔散列的方法处理冲突。任意输入要查找的数据，无论是否找到均给出提示信息。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;stdio.h&gt;#include&lt;time.h&gt;#define Max 11#define N 8**int** hashtable[Max];**int** func(**int** value)&#123; **return** value % Max;&#125;**int** search(**int** key)&#123; **int** pos,t; pos=func(key); t=pos; **while**(hashtable[t]!=key&amp;&amp;hashtable[t]!=-1)&#123; t=(t+1)%Max; **if**(pos==t) **return** -1; &#125; **if**(hashtable[t]==-1) **return** **NULL**; **else** **return** t;&#125;**void** creathash(**int** key)&#123; **int** pos,t; pos=func(key); t=pos; **while**(hashtable[t]!=-1)&#123; t=(t+1)%Max; **if**(pos==t)&#123; printf(“哈希表已满\\n”); **return**; &#125; &#125; hashtable[t]=key;&#125;**void** main()&#123; **int** flag[50]; **int** i,j,t; **for**(I=0;i&lt;Max;i++) hashtable[I]=-1; **for**(I=0;i&lt;50;i++) flag[I]=0; srand((**unsigned** **long**)time(0)); *//*哈希函数的构造方法常用的有*5*种，分别是数字分析法、平方取中法、分段叠加、伪随机数法和余数法，其中余数法比较常用。 i=0; *//*虽然通过构造好的哈希函数可以减少冲突，但冲突是不可能完全避免的，所以就相应的产生了避免哈希冲突的常用的*4*种方法，分别是开放定址法 **while**(i!=N)&#123; *//*（包括线性探测再散列和二次探测再散列）、链地址法、再哈希法和建立公共溢出区。 t=rand()%50; *//*开放定址法中的线性探测再散列比较常用，该方法的特点是在冲突发生时，顺序查看表中的下一单元，直到找出一个空单元或查遍全表。 **if**(flag[t]==0)&#123; creathash(t); printf(“%2d:”,t); **for**(j=0;j&lt;Max;j++) printf(“(%2d)”,hashtable[j]); printf(“\\n”); flag[t]=1; I++; &#125; &#125; printf(“请输入你想查找的元素：”); scanf(“%d”,&amp;t); **if**(t&gt;0&amp;&amp;t&lt;50)&#123; I=search(t); **if**(I!=-1) printf(“查找成功！其位置是:%d\\n”,i); **else** printf(“查找失败！”); &#125; **else** printf(“输入有误！”);&#125;","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"C实例","slug":"C实例","permalink":"http://example.com/tags/C%E5%AE%9E%E4%BE%8B/"}]},{"title":"macOS的一些使用小技巧：","slug":"Apple、Linux/macOS/macOS的一些使用小技巧：","date":"2018-11-29T16:00:00.000Z","updated":"2021-03-23T07:53:12.000Z","comments":true,"path":"2018/11/30/Apple、Linux/macOS/macOS的一些使用小技巧：/","link":"","permalink":"http://example.com/2018/11/30/Apple%E3%80%81Linux/macOS/macOS%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BD%BF%E7%94%A8%E5%B0%8F%E6%8A%80%E5%B7%A7%EF%BC%9A/","excerpt":"","text":"在任意输入框中按option+shift+K组合键会显示苹果logo 文本编辑中按Fn+Delete键可向后删除内容 Finder+菜单栏中的前往+一直按住option，打开资源库 终端输入sudo spctl —master-disable命令打开【安全性与隐私】中的【任何来源】 隐藏和恢复桌面文件：隐藏桌面文件：defaults write com.apple.finder CreateDesktop -bool false;killall Finder恢复显示桌面文件：defaults write com.apple.finder CreateDesktop -bool true;killall Finder 快速调用emoji表情：control+command+空格 CheatSheet:长按command键可显示当前应用所有的快捷键 调整launchpad图标大小： 改行数：defaults write com.apple.dock springboard-rows -int 10改列数：defaults write com.apple.dock springboard-columns int 7killall Dock 恢复系统默认：defaults write com.apple.dock springboard-rows Defaultdefaults write com.apple.dock springboard-columns Defaultkillall Dock 移动文件：打开源文件夹和目标文件夹，拖拽源文件到目标文件夹拷贝文件：按住option，拖拽源文件到目标文件夹 全屏截图：command+shift+3截取部分屏幕：command+shift+4 回到桌面：command+F3","categories":[{"name":"Apple、Linux","slug":"Apple、Linux","permalink":"http://example.com/categories/Apple%E3%80%81Linux/"}],"tags":[{"name":"macOS","slug":"macOS","permalink":"http://example.com/tags/macOS/"}]},{"title":"macOS终端ssh远程连接Ubuntu server：","slug":"Apple、Linux/macOS/macOS终端ssh远程连接Ubuntu server：","date":"2018-11-28T16:00:00.000Z","updated":"2021-03-23T07:53:01.000Z","comments":true,"path":"2018/11/29/Apple、Linux/macOS/macOS终端ssh远程连接Ubuntu server：/","link":"","permalink":"http://example.com/2018/11/29/Apple%E3%80%81Linux/macOS/macOS%E7%BB%88%E7%AB%AFssh%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5Ubuntu%20server%EF%BC%9A/","excerpt":"","text":"原因： Ubuntu server虚拟机界面实在是不如Mac终端好操作 Linux下的命令与UNIX很多不一样，无法直接在macOS下学习Linux 步骤： Ubuntu系统默认安装了openssh-client，但没有安装openssh-server，先检查一下(ps -e | grep ssh) 安装openssh-server：sudo apt-get install openssh-server 如果出现sshd，代表安装成功【sudo /etc/init.d/ssh start启动服务】 ifconfig -a查看IP地址 ssh 用户名@IP地址","categories":[{"name":"Apple、Linux","slug":"Apple、Linux","permalink":"http://example.com/categories/Apple%E3%80%81Linux/"}],"tags":[{"name":"macOS","slug":"macOS","permalink":"http://example.com/tags/macOS/"}]},{"title":"shell是什么：","slug":"Apple、Linux/Ubuntu Server/shell是什么：","date":"2018-10-30T16:00:00.000Z","updated":"2021-03-23T07:52:18.000Z","comments":true,"path":"2018/10/31/Apple、Linux/Ubuntu Server/shell是什么：/","link":"","permalink":"http://example.com/2018/10/31/Apple%E3%80%81Linux/Ubuntu%20Server/shell%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9A/","excerpt":"","text":"date：显示当前系统的时间和日期 cal ：默认情况下显示当月的日历 df ：查看磁盘驱动器当前的可用空间 free ：显示可用内存 exit ：结束终端会话（或直接关闭终端窗口） （1）shell是一个接收由键盘输入的命令，并将其传递给操作系统来执行的程序 （2）当使用图形用户界面时，需要另一种叫做终端仿真器的程序与shell进行交互（KDE环境下使用的是konsole,GNOME环境下使用的是gnome-terminal,但是在桌面菜单上很可能将它们简单的统称为终端） （3）shell提示符：username@machinename,其后是当前工作目录(长度更长一些)和一个$符号；如果shell提示符的最后一个字符是#，而不是一个$符号，那么终端会话将享有超级用户特权 （4）命令历史记录：在默认情况下，大部分Linux发行版本能够存储最近输入的500个命令","categories":[{"name":"Apple、Linux","slug":"Apple、Linux","permalink":"http://example.com/categories/Apple%E3%80%81Linux/"}],"tags":[{"name":"Ubuntu Server","slug":"Ubuntu-Server","permalink":"http://example.com/tags/Ubuntu-Server/"}]},{"title":"导航、Linux系统、操作文件与目录：","slug":"Apple、Linux/Ubuntu Server/导航、Linux系统、操作文件与目录：","date":"2018-10-29T16:00:00.000Z","updated":"2021-03-23T07:50:04.000Z","comments":true,"path":"2018/10/30/Apple、Linux/Ubuntu Server/导航、Linux系统、操作文件与目录：/","link":"","permalink":"http://example.com/2018/10/30/Apple%E3%80%81Linux/Ubuntu%20Server/%E5%AF%BC%E8%88%AA%E3%80%81Linux%E7%B3%BB%E7%BB%9F%E3%80%81%E6%93%8D%E4%BD%9C%E6%96%87%E4%BB%B6%E4%B8%8E%E7%9B%AE%E5%BD%95%EF%BC%9A/","excerpt":"","text":"pwd(打印工作目录)：显示当前工作目录（第一次登录系统时或是启动终端仿真器会话时，当前工作目录被设置成主目录，每个用户账号都有一个主目录，作为普通用户操作时，这是唯一一个允许用户写文件的地方） ls：列出当前工作目录的文件和目录 通过ls命令可以查看目录内容，确定各种重要文件和目录的属性 ls 指定目录：列出指定要显示的目录 ls ~ /usr：列出用户主目录（由符号波浪线表示）和/usr目录的内容 ls -l：将输出以长格式显示 选项和参数：通常，命令后面跟有一个或多个选项，带有不同选项的命令其功能也不一样；此外，命令后面还会跟有一个或多个参数，这些参数是命令作用的对象【command -options arguments】 大部分命令使用的选项是在单个字符前加上连字符，如-l，但是很多命令，包括GNU项目里的命令，也支持在单字前加两个连字符的长选项，而且很多命令也允许多个短选项串在一起使用 ls命令包含了两个选项，l选项产生长格式输出，而t选项则表示以文件修改时间的先后将结果进行排序，加上长选项—reverse，则结果会以相反的顺序输出 ls命令的常用选项 下面的例子来自于Ubuntu系统：ls长列表字段： cd 目标工作目录的路径名：改变工作目录（即在文件系统树的位置） 路径名指的是沿着分枝到达目标目录的路由，路径名分为两种：绝对路径名和相对路径名 绝对路径名：从根目录开始，其后紧接着一个又一个文件树分支，直到到达目标目录或文件 /usr/bin:大多数系统程序都安装在这个目录里【根目录(在路径名中用前导斜杠来表示)中有一个目录是usr,该目录包含一个bin目录】 相对路径名：从工作目录开始，通常使用一些特殊符号来表示文件系统树中的相对位置（“.” ”..”）“.”代表当前工作目录“..”代表当前工作目录的父目录 我们希望把工作目录改变成/usr/bin的父目录/usr1）绝对路径名2）相对路径名 也可以把工作目录从/usr变到/usr/bin1）绝对路径名2）相对路径名 几乎在所有的情况下都可以省略“./”，因为它是隐含的，一般而言，如果没有指定路径名，则默认为工作目录 cd的一些快捷方式：1）cd：将当前工作目录改变为主目录2）cd -:将工作目录改变成先前的工作目录3）cd ~username：将工作目录改变为username的主目录 file filename：确定文件的类型 less filename：查看文本文件的内容，Q键退出less程序 less程序最常使用的键盘命令： 符号链接： 在浏览过程中，我们可能会看到带有如下条目的目录信息 该条目信息的第一个字母是l，而且看起来像是有两个文件名，这种特殊的文件叫做符号链接（又叫软链接或symlink） 假设，一个程序需要使用包含foo文件中的一个共享资源，但foo版本变化很频繁，这样，在文件名中包含版本号会是一个好主意，因此管理员或其他相关方就能够看到安装了foo的哪个版本，这就出现了一个问题，如果改变了共享资源的名称，就必须跟踪每个可能使用了该共享资源的程序，并且当安装了该资源新的版本后，都要让使用它的程序去寻找新的资源名 假设foo的安装版本是2.6，他的文件名是foo-2.6，然后创建一个符号链接foo指向foo-2.6，这意味着，当一个程序打开foo文件时，它实际上打开的是文件foo-2.6.这样一来皆大欢喜，依赖foo文件的程序能够找到它，并且也能看到实际安装的版本。当需要升级到foo-2.7时，只需将该文件添加到系统里，删除符号链接文件foo，创建一个指向新版本的符号链接即可，这不仅解决了版本升级的问题，也可以将两种版本都保存在机器里。假如foo-2.7存在一个程序错误需要切换到旧的版本，同样，只需要删除指向新版本的符号链接，重新创建指向旧版本的符号链接即可 硬链接：默认情况下，每个文件有一个硬链接，该硬链接会给文件起名字。当创建一个硬链接的时候，也为这个文件创建了一个额外的目录条目 硬链接和文件本身没有什么区别，与包含符号链接的目录列表不同，包含硬链接的目录列表没有特别的链接指示说明。当硬链接被删除时，只是删除了这个链接，但是文件本身的内容依然存在（也就是说，该空间没有释放），除非该文件的所有链接都被删除了 ln file link：创建硬链接 ln -s item link:创建符号链接，这里的item可以是文件也可以是目录 符号链接是通过创建一个特殊类型的文件来起作用的，该文件包含了指向引用文件或目录的文本指针 由于shell需要经常使用文件名，因此它提供了一些特殊字符来帮助你快速指定一组文件名，这些特殊字符称为通配符，通配符（也叫文件名替换）允许用户依据字符模式选择文件名通配符的使用使得为文件名构建复杂的筛选标准成为可能： mkdir dir1：创建单个dir1目录 mkdir dir1 dir2 dir3：创建3个目录 cp：复制文件和目录cp item1 item2：将单个文件或目录item1复制到文件或目录item2中cp item1 . :将item1复制到当前目录cp item… directory：将多个项目（文件或目录）复制进一个目录中 需要注意的是，在没有任何警告的情况下，cp命令会覆盖第一次的复制内容（命令一样的情况下） mv：文件移动和文件重命名（在这两种情况下，完成操作后，原来的文件名将不存在） mv item1 item2:将文件（或目录）item1移动（或重命名）为item2mv item… directory：将一个或多个条目从一个目录移动到另一个目录下 rm item… ：移除（删除）文件和目录 （1）与Windows相同，类UNIX操作系统（Linux）也是以称之为分层目录结构的方式来组织文件的，文件系统的第一个目录叫做根目录，它包含了文件和子目录，子目录里包含了更多的文件和子目录，依此类推 （2）在Windows系统中，每个存储设备都有一个独立的文件系统树。而在类UNIX系统中，无论多少驱动器或存储设备与计算机相连，通常只有一个文件系统树。根据系统管理员的设置，存储设备将会连接（挂载）到文件系统树的不同位置，系统管理员要负责系统的维护 （3）树通常是倒立显示的，顶部是根目录，依次向下排列的是子目录 （4）以“.”字符开头的文件名是隐藏的，这仅说明ls不会列出这些文件，除非输入ls -a,在创建用户账号时，主目录里会放置一些隐藏文件，用来配置账号信息，此外，一些应用程序也会将它们的配置文件和设置文件以隐藏文件的形式放在主目录下面 （5）与UNIX一样，在Linux中，文件名与命令是区分大小写的 （6）Linux没有文件扩展名的概念，我们可以按照自己的喜好随意给文件命名，文件的内容或用途由其他方式来决定 （7）Linux支持长文件名，但是在创建文件名的过程中，仅句号、连字符和下划线是可以使用的，文件名中不要嵌入空格，可以使用下划线 （8）在Linux系统中找到的目录： 实战演练：","categories":[{"name":"Apple、Linux","slug":"Apple、Linux","permalink":"http://example.com/categories/Apple%E3%80%81Linux/"}],"tags":[{"name":"Ubuntu Server","slug":"Ubuntu-Server","permalink":"http://example.com/tags/Ubuntu-Server/"}]},{"title":"命令的使用：","slug":"Apple、Linux/Ubuntu Server/命令的使用：","date":"2018-10-28T16:00:00.000Z","updated":"2021-03-23T07:52:07.000Z","comments":true,"path":"2018/10/29/Apple、Linux/Ubuntu Server/命令的使用：/","link":"","permalink":"http://example.com/2018/10/29/Apple%E3%80%81Linux/Ubuntu%20Server/%E5%91%BD%E4%BB%A4%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%9A/","excerpt":"","text":"type命令是一个shell内置命令，可根据指定的命令名显示shell将要执行的命令类型：type command which命令可以确定一个给定可执行文件的准确位置 which命令只适用于可执行程序，而不适用于内置命令和命令别名（真正可执行程序的替代物），试图在shell内置命令（例如cd）中使用which命令时，要么没响应，要么得到一条错误信息 bash为每一个shell内置命令提供了一个内置的帮助工具，输入help，然后输入shell内置命令的名称即可使用该帮助工具 注意：出现在命令语法描述中的方括号表示一个可选的选项，竖线符号代表的是两个互斥的选项，这种表示法说明，cd命令后可能有一个-L参数，也可能是-P参数，甚至可以跟参数dir –help选项描述了命令支持的语法和选项 大多数供命令行使用的可执行文件，提供一个称之为manual或者是man page的正式文档，该文档可以用一种称为man的特殊分页程序来查看：man program(这里的program是需要查看的命令名称) man ls: 在大多数Linux系统中，man命令调用less命令来显示手册文档 apropos: whatis程序显示匹配具体关键字的手册页的名字和一行描述 GNU项目提供了info页面来代替手册文档，info页面可通过info阅读器来显示，info页面使用超链接，这与网页结构很相似 info ls: 通过alias命令将以上命令整合成一条新的命令【给这条命令起了一个名字foo，现在foo就代表这条命令了】 unalias foo:删除别名 要查看在环境中定义的所有别名，可以使用不带参数的alias命令 在命令行定义别名还有一个小问题：当shell会话结束时，这些别名也随之消失了 命令行小技巧：通过使用分号来分隔多条命令，就可以将多条命令输入在一行之中","categories":[{"name":"Apple、Linux","slug":"Apple、Linux","permalink":"http://example.com/categories/Apple%E3%80%81Linux/"}],"tags":[{"name":"Ubuntu Server","slug":"Ubuntu-Server","permalink":"http://example.com/tags/Ubuntu-Server/"}]},{"title":"重定向和管道：","slug":"Apple、Linux/Ubuntu Server/重定向和管道：","date":"2018-10-27T16:00:00.000Z","updated":"2021-03-23T07:51:56.000Z","comments":true,"path":"2018/10/28/Apple、Linux/Ubuntu Server/重定向和管道：/","link":"","permalink":"http://example.com/2018/10/28/Apple%E3%80%81Linux/Ubuntu%20Server/%E9%87%8D%E5%AE%9A%E5%90%91%E5%92%8C%E7%AE%A1%E9%81%93%EF%BC%9A/","excerpt":"","text":"I/O是输入/输出(input/output)的缩写，I/O重定向可以把命令行的输入重定向为从文件中获取内容，也可以把命令行的输出结果重定向到文件中，如果我们将多个命令行关联起来，将形成非常强大的命令：管道 标准输出重定向：I/O重定向功能可以重新定义标准输出内容发送到哪里，使用重定向操作符“&gt;”，后面接文件名，就可以把标准输出重定向到另一个文件中，而不是显示在屏幕上，主要用于把命令的输出内容保存到一个文件中 标准错误重定向： 将标准输出和标准错误重定向到同一个文件:1）传统的方法，在旧版本的shell中使用2）在这个例子中，只使用一个标记符“&amp;&gt;”就把标准输出和标准错误都重定向到了文件中 处理不想要的输出：有时候沉默是金，命令执行后我们并不希望得到输出，而是想把这个输出丢弃，尤其是在输出错误和状态信息的情况下更为需要。系统提供了一种方法，即通过把输出重定向到一个称为/dev/null的特殊文件中来实现它，这个文件是一个称为位桶(bit bucket)的系统设备，它接受输入但是不对输入进行任何处理 标准输入重定向： cat file..：合并文件，读取一个或多个文件，并把它们复制到标准输出文件中 管道:命令从标准输入到读取数据，并将数据发送到标准输出的能力是使用了名为管道的shell特性，使用管道操作符“｜”可以把一个命令的标准输出传送到另一个命令的标准输入中 command | command【标准输出—&gt;标准输入】 通过使用该技术，可以很方便的检查任意一条生成标准输出的命令的运行结果 过滤器：管道功能经常用来对数据执行复杂的操作，也可以把多条命令合在一起构成一个管道，这种方式中用到的命令通常被称为过滤器(filter)，过滤器接受输入，按照某种方式对输入进行改变，然后再输出它 sort：假设要把/bin和/usr/bin目录下的所有可执行程序合并成一个列表，并且按照顺序排列，最后再查看这个列表 uniq：经常和sort命令结合使用，uniq可以接受来自于标准输入或者一个单一文件名参数对应的已排好序的数据列表，默认情况下，该命令删除列表中的所有重复行 wc(字数统计，word count)：用来显示文件中包含的行数、字数和字节数 grep：在文件中查找匹配文本 head/tail：打印文件的开头部分/结尾部分：head命令将输出文件的前10行，tail命令则输出文件的最后10行，可以通过-n选项来调整输出的行数 这些命令选项也可以应用在管道中： tee：读取标准输入，再把读到的内容复制到标准输出（允许数据可以继续向下传输到管道中）和一个或更多的文件中去【标准输入—&gt;标准输出】 在使用grep命令过滤管道内容之前，先使用tee命令来获取整个目录列表并输出到ls.txt文件中：","categories":[{"name":"Apple、Linux","slug":"Apple、Linux","permalink":"http://example.com/categories/Apple%E3%80%81Linux/"}],"tags":[{"name":"Ubuntu Server","slug":"Ubuntu-Server","permalink":"http://example.com/tags/Ubuntu-Server/"}]},{"title":"扩展和引用：","slug":"Apple、Linux/Ubuntu Server/扩展和引用：","date":"2018-10-26T16:00:00.000Z","updated":"2021-03-23T07:51:45.000Z","comments":true,"path":"2018/10/27/Apple、Linux/Ubuntu Server/扩展和引用：/","link":"","permalink":"http://example.com/2018/10/27/Apple%E3%80%81Linux/Ubuntu%20Server/%E6%89%A9%E5%B1%95%E5%92%8C%E5%BC%95%E7%94%A8%EF%BC%9A/","excerpt":"","text":"扩展：每次输入命令行按下Enter键时，bash都会在执行命令之前对文本进行多重处理，产生这个结果的处理过程称为扩展，有了扩展功能，在输入内容后，这些内容将在shell对其执行之前被扩展成其他内容 echo:shell内置命令，把文本参数内容打印到标准输出 路径名扩展：通过使用通配符来实现扩展的机制 波浪线扩展：如果把～用在一个单词的开头，那么它将被扩展为指定用户的主目录名，如果没有指定用户命名，则扩展为当前用户的主目录 算术扩展：shell支持通过扩展来运行算术表达式，这允许我们把shell提示符当作计算器来使用： 花括号扩展：可以按照花括号里面的模式创建多种文本字符串 参数扩展：命名为USER的变量包含你的用户名，为了触发参数扩展，并显示出USER的内容： 命令替换：可以把一个命令的输出作为一个扩展模式使用 引用： 在第一个例子中，shell会对echo命令的参数列表进行单词分割，去除多余的空白；在第二个例子中，因为$1是一个未定义的变量，所以参数扩展将把$1的值替换为空字符串 shell提供了一种称为引用（quoting）的机制，用来有选择性的避免不想要的扩展 双引号：在第一个例子中，没有加上引号的命令替换将导致命令行被识别为命令后面跟着38个参数；而在第二个例子中加了双引号，使得命令行被识别为命令后面只跟着一个参数，这个参数包含着嵌入空格和换行字符 单引号： 转义字符： 有时候我们只是想要引用单个字符，这种情况可以通过在该字符前加上反斜杠来实现，这里的反斜杠称为转义字符，转义字符经常在双引号中用来有选择性的阻止扩展： 转义字符也常用来消除文件名中某个字符的特殊含义，比如文件名中可以使用在shell中通常具有特殊含义的字符，这些字符包括“$”、“!”、“&amp;”、空格等 如果想要显示反斜杠字符，可以通过使用两个反斜杠“\\”来实现，需要注意的是，单引号中的反斜杠将失去它的特殊含义，而只被当成一个普通字符","categories":[{"name":"Apple、Linux","slug":"Apple、Linux","permalink":"http://example.com/categories/Apple%E3%80%81Linux/"}],"tags":[{"name":"Ubuntu Server","slug":"Ubuntu-Server","permalink":"http://example.com/tags/Ubuntu-Server/"}]},{"title":"高级键盘技巧：","slug":"Apple、Linux/Ubuntu Server/高级键盘技巧：","date":"2018-10-25T16:00:00.000Z","updated":"2021-03-23T07:51:34.000Z","comments":true,"path":"2018/10/26/Apple、Linux/Ubuntu Server/高级键盘技巧：/","link":"","permalink":"http://example.com/2018/10/26/Apple%E3%80%81Linux/Ubuntu%20Server/%E9%AB%98%E7%BA%A7%E9%94%AE%E7%9B%98%E6%8A%80%E5%B7%A7%EF%BC%9A/","excerpt":"","text":"光标移动： 修改文本： 剪切和粘贴文本： 自动补齐功能：在输入命令时，按Tab键将触发自动补齐功能 使用历史命令：bash会保存使用过命令的历史记录，这些命令的历史记录列表保存在用户主目录的.bash_history文件中 搜索历史命令： history | less：查看历史记录的内容列表 bash默认会保存用户最近使用过的500个命令，其中500是个默认值 找到用来列出/usr/bin目录下内容的命令： 历史记录扩展：","categories":[{"name":"Apple、Linux","slug":"Apple、Linux","permalink":"http://example.com/categories/Apple%E3%80%81Linux/"}],"tags":[{"name":"Ubuntu Server","slug":"Ubuntu-Server","permalink":"http://example.com/tags/Ubuntu-Server/"}]},{"title":"权限：","slug":"Apple、Linux/Ubuntu Server/权限：","date":"2018-10-24T16:00:00.000Z","updated":"2021-03-23T07:51:19.000Z","comments":true,"path":"2018/10/25/Apple、Linux/Ubuntu Server/权限：/","link":"","permalink":"http://example.com/2018/10/25/Apple%E3%80%81Linux/Ubuntu%20Server/%E6%9D%83%E9%99%90%EF%BC%9A/","excerpt":"","text":"传统的UNIX操作系统与那些传统的MS-DOS操作系统不同，区别在于它们不仅是多重任务处理系统，而且还是多用户系统,这意味着同一时间内可以有多个用户使用同一台计算机 id命令可以获得用户身份标识的相关信息 1）用户账户定义在文件/etc/passwd中，对于每一个用户账户，文件/etc/passwd中都定义了对应用户的用户（登录）名、uid、gid、账户的真实姓名、主目录以及登录shell信息2）用户组定义在文件/etc/group中，如果查看文件/etc/passwd和文件/etc/group的内容，可以发现除了普通用户账户信息之外，文件中还有对应于超级用户（uid为0）和其他不同种类的系统用户的账户信息3）在创建用户账户和群组时，这些文件随着文件/etc/shadow的变动而修改，文件/etc/shadow中保存了用户的密码信息 对文件和目录的访问权限是按照读访问、写访问以及执行访问来定义的： chmod：更改文件或者目录的模式（权限），只有文件所有者和超级用户才可以更改文件或者目录的模式1）八进制数字表示法：使用八进制数字来设置所期望的权限模式 通过使用3位八进制数字，我们可以分别设置文件所有者、组成员和其他所有用户的文件模式 2）符号表示法：分为三部分：更改会影响谁、要执行哪个操作、要设置哪种权限 umask命令控制着创建文件时指定给文件的默认权限，它使用八进制表示法来表示从文件模式属性中删除一个位掩码 有三种方法用来转换身份：1）注销系统并以其他用户的身份重新登录系统2）使用su命令3）使用sudo命令 在shell会话状态下，使用su命令将允许你假定为另一个用户的身份，既可以以这个用户的ID来启动一个新的shell会话，也可以以这个用户的身份来发布一个命令使用sudo命令将允许管理者创建一个称为/etc/sudoer的配置文件，并且定义一些特定的命令，这些命令只有被赋予为假定身份的特定用户才允许执行 su：以其他用户和组ID的身份来运行shell sudo：以另一个用户的身份执行命令 chown：更改文件或者目录的所有者和所属群组，需要超级用户的权限 chgrp：在更早的UNIX版本中，chown命令只能更改文件的所有者，而不能改变文件所属群组，为了达到这个目的，可以使用chgrp 实例： passwd：设置或者更改密码","categories":[{"name":"Apple、Linux","slug":"Apple、Linux","permalink":"http://example.com/categories/Apple%E3%80%81Linux/"}],"tags":[{"name":"Ubuntu Server","slug":"Ubuntu-Server","permalink":"http://example.com/tags/Ubuntu-Server/"}]},{"title":"进程：","slug":"Apple、Linux/Ubuntu Server/进程：","date":"2018-10-23T16:00:00.000Z","updated":"2021-03-23T07:51:08.000Z","comments":true,"path":"2018/10/24/Apple、Linux/Ubuntu Server/进程：/","link":"","permalink":"http://example.com/2018/10/24/Apple%E3%80%81Linux/Ubuntu%20Server/%E8%BF%9B%E7%A8%8B%EF%BC%9A/","excerpt":"","text":"现代操作系统通常都支持多重任务处理，多重任务处理是指系统通过快速切换运行中的程序来实现多任务的同时执行，Linux内核通过使用进程来管理多重任务，进程是Linux用来安排不同程序等待CPU调度的一种组织方式 进程如何工作：系统启动时，内核先把它的一些程序初始化为进程，然后运行一个称为init的程序，init程序将依次运行一系列称为脚本初始化的shell脚本(放在/etc目录下)，这些脚本将会启动所有的系统服务，其中的很多服务都是通过守护程序来实现的，而后台程序只是呆在后台做它们自己的事情，并且没有用户界面，因此，即使没有用户登录，系统也在忙于执行一些例行程序 一个程序的运行可以触发其他程序的运行，在进程系统中这种情况被表述为父进程创建子进程 内核会保存每个进程的信息以便确保任务有序进行，比如，每个进程将被分配一个称为进程ID(PID，process ID)的号码。进程ID是按递增的顺序来分配的，init进程的PID始终为1.内核也记录分配给每个进程的内存信息以及用来恢复运行的进程就绪信息。和文件系统类似，进程系统中也存在所有者、用户ID、有效用户ID等 ps命令：查看进程信息（默认情况下，ps命令输出的信息并不是很多，只是输出和当前终端会话相关的进程信息）1）TTY是teletype(电传打字机)的缩写，代表了进程的控制终端2）UNIX在这里也显示了进程的运行时间，TIME字段表示了进程消耗的CPU时间总和 添加x选项(注意这里没有前置的连字符)将告知ps命令显示所有的进程，而不需要关注它们是由哪个终端（如果有其他的情况）所控制的。TTY列中出现的“？”表示没有控制终端 这些进程状态的后面可以带其他的字符来表示不同的特殊进程特性 ps aux：将会显示属于每个用户的进程信息，使用这些选项时不带前置连字符将使得命令以“BSD模式(BSD-style)”运行。ps命令的Linux版本可以模拟多种UNIX版本中ps程序的运行方式： 虽然ps命令可以显示有关机器运行情况的很多信息，但是它提供的只是在ps命令被执行时刻机器状态的一个快照。要查看机器运行情况的动态视图，可以使用top命令 top程序将按照进程活动的顺序，以列表的形式持续更新显示系统进程的当前信息（默认每3秒更新一次），它主要用于查看系统“最高（top）”进程的运行情况，top命令显示的内容包含两个部分，顶部显示的是系统总体状态信息，下面显示的是一张按CPU活动时间排序的进程情况表 top程序可以接受许多键盘指令，其中最常用的有两个：一个是h，输入后将显示程序的帮助界面；另一个是q，用来退出top命令 主流的桌面环境都提供了用来显示类似top命令的输出信息的图形化应用程序，但是top命令优于图形化版本，这是因为top命令运行的更快，而且消耗的系统资源要少得多，毕竟，系统监控程序不应该减缓正在被监控的系统的处理速度 控制进程： 1）中断进程：在终端里按下Ctrl-C键将会中断一个程序，它意味着我们委婉的请求程序结束，许多（但不是所有）命令行程序都可以使用这种方法来实现中断 2）使进程在后台运行： 3）使进程回到前台运行： 4）停止（暂停）进程： 信号： kill命令通常用来“杀死”（终止）进程，它可以用来终止运行不正常的程序或者反过来拒绝终止的程序","categories":[{"name":"Apple、Linux","slug":"Apple、Linux","permalink":"http://example.com/categories/Apple%E3%80%81Linux/"}],"tags":[{"name":"Ubuntu Server","slug":"Ubuntu-Server","permalink":"http://example.com/tags/Ubuntu-Server/"}]},{"title":"环境：","slug":"Apple、Linux/Ubuntu Server/环境：","date":"2018-10-22T16:00:00.000Z","updated":"2021-03-23T07:50:53.000Z","comments":true,"path":"2018/10/23/Apple、Linux/Ubuntu Server/环境：/","link":"","permalink":"http://example.com/2018/10/23/Apple%E3%80%81Linux/Ubuntu%20Server/%E7%8E%AF%E5%A2%83%EF%BC%9A/","excerpt":"","text":"在shell会话调用环境期间，shell会存储大量的信息，程序使用存储在环境中的数据来确定我们的配置，尽管大多数系统程序使用配置文件来存储程序设置，但是也有一些程序会查找环境中存储的变量来调整自己的行为，用户可以使用环境来自定义shell 尽管shell在环境中存储了两种基本类型的数据，但是在bash中，这两种类型基本上没有区别。这两种数据类型分别是环境变量和shell变量。shell变量是由bash存放的少量数据，环境变量就是除此之外的所有其他变量。除变量之外，shell还存储了一些编程数据，也就是别名和shell函数 set命令会同时显示shell变量和环境变量，而printenv只会显示环境变量printenv | less: 命令printenv也能够列出特定变量的值： 在使用set命令时，如果不带选项或参数，那么只会显示shell变量、环境变量以及任何已定义的shell函数，与printenv命令不同的是，set命令的输出结果是按照字母顺序排列的set | less: 如需要查看单个变量的值，也可以使用echo命令 set命令和printenv命令都不能显示的一个环境元素是别名，要查看别名，需使用不带任何参数的alias命令 一些有趣的变量： 环境是如何建立的：用户登录系统后，bash程序就会启动并读取一系列称为启动文件的配置脚本，这些脚本定义了所有用户共享的默认环境。接下来，bash会读取更多存储在主目录下的用于定义个人环境的启动文件。这些步骤的确切顺序是由启动的shell会话类型决定的 修改环境： 文本编辑器： 使用文本编辑器配置文件：所有的文本编辑器都可以通过在命令行输入编辑器名称和需编辑的文件名称的方式启动，如果输入的文件不存在，编辑器会认为用户想要创建一个新的文件 扩展名.bak、.sav、.old和.orig是常用的标示备份文件的方法 激活修改：因为只有在启动shell会话时才会读取.bashrc，所以对.bashrc做出的修改只有在关闭shell终端会话并重启的时候才会生效。也可以使用命令强制命令bash重新读取.bashrc文件 在shell脚本和bash启动文件中，注释是以“#”开头的","categories":[{"name":"Apple、Linux","slug":"Apple、Linux","permalink":"http://example.com/categories/Apple%E3%80%81Linux/"}],"tags":[{"name":"Ubuntu Server","slug":"Ubuntu-Server","permalink":"http://example.com/tags/Ubuntu-Server/"}]},{"title":"vi的基本使用：","slug":"Apple、Linux/Ubuntu Server/vi的基本使用：","date":"2018-10-21T16:00:00.000Z","updated":"2021-03-23T07:50:40.000Z","comments":true,"path":"2018/10/22/Apple、Linux/Ubuntu Server/vi的基本使用：/","link":"","permalink":"http://example.com/2018/10/22/Apple%E3%80%81Linux/Ubuntu%20Server/vi%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%EF%BC%9A/","excerpt":"","text":"本文目录 使用vi的原因 启动、退出、保存vi vi的三种工作模式 移动光标 基本编辑 a.撤销命令 b.删除文本 c.剪切、复制和粘贴文本 d.合并行 查找和替换 a.行内搜索 b.搜索整个文件 c.全局搜索和替换 编辑多个文件 a.切换文件 b.载入更多的文件 c.文件之间的内容复制 d.插入整个文件 使用vi的原因： vi总是可用的，如果用户面前的系统没有图形界面，例如是远程服务器或者是本地系统的X配置不可用，那么vi就会成为救命的稻草。POSIX（一种UNIX系统的程序兼容标准）要求系统必须配备有vi vi是轻量级的软件，运行速度快。对很多任务来说，启动vi比在菜单中找到一个图形界面编辑器并等待几兆大小的编辑器载入要容易的多。另外，vi的设计还非常利于打字 用户不想被其他Linux和UNIX用户蔑视 启动、退出、保存vi：启动vi：vi 新文件名 退出、保存vi： 12345678910esc :w 保存文件但不退出vi :w file 将修改另外保存到file中，不退出vi（另存为）【此命令在以新名称保存文件的同时，并不更改编辑中的原文件的名称，当用户继续编辑时，编辑的还是原文件而不是新文件】 :w! 强制保存，不退出vi :wq 保存文件并退出vi :wq! 强制保存文件，并退出vi :q 不保存文件，退出vi :q! 不保存文件，强制退出vi :e! 放弃所有修改，从上次保存文件开始再编辑 命令模式下输入ZZ 保存当前文档并退出vi vi的三种工作模式： 如果用户阅读vi的说明文档，会困惑的发现命令模式被称为普通模式，而使用ex命令则被称为命令模式 移动光标（命令模式下）： l或右方向键：右移一位 h或左方向键：左移一位 j或下方向键：下移一行 k或上方向键：上移一行 数字0：至本文开头 基本编辑：在命令模式下按u键可以撤销用户多步操作 删除文本（命令模式下）： 12x：当前字符3x：当前字符和之后2个字符 剪切(d)、复制(y)和粘贴(p)文本： 12345678910111213141516171819命令d不只是删除文本，而是在剪切文本，用户每次使用d命令之后，都会复制删除的内容进缓存（类似剪贴板），然后用户就可以使用p命令将缓存中的内容粘贴到光标之后或使用P命令将内容粘贴到光标之前dd：当前行5dd：当前行和之后4行dW：当前字符到下一单词的起始d$：当前字符到当前行的末尾d0：当前字符到当前行的起始d^：当前字符到当前行下一个非空字符dG：当前行到文件末尾d20G：当前行到文件第20行yy：当前行5yy：当前行和之后4行yW：当前字符到下一单词的起始y$：当前字符到当前行的末尾Y0：当前字符到当前行的起始y^：当前字符到当前行下一个非空字符yG：当前行到文件末尾y20G：当前行到文件第20行 合并行(J)：vi在行的概念上非常严格，通常来说，将光标移动到行的末端并删除行的末尾字符并不能将此行与下一行合并 查找和替换:行内搜索：命令f在行内进行搜索，并将光标移至搜索到的下一个指定字符。比如命令fa就会将光标移动到本行下一处出现字符a的地方，在执行过一次行内搜索之后，输入分号可以使vi重复上一次搜索 搜索整个文件：命令“/”可以完成对单词或短语的搜索，当用户使用“/”命令后，一个“/”符号会出现在屏幕的底部。接下来，输入需要搜索的单词或短语，以Enter结束，光标就会移动到下一处包含被搜索字符串的地方，使用n命令可以重复此搜索 全局搜素和替换：vi使用ex命令来执行几行之内或者整个文件中的搜索和替换操作 12345678910111213141516:%s/Line/line/g :冒号用于启动一条ex命令 %确定了操作作用的范围，%简洁的代表了从文件的第一行到最后一行（还可以用1,2表示从第一行到第二行），如果不明确指出命令的作用范围，那么命令只会在当前行生效 s指定了具体的操作：替换 /Line/line搜索和替换的文本 g代指global（全局），也就是说对搜索到的每一行的每一个实例进行替换，如果g缺失，那么只替换每一行第一个符合条件的实例 在命令末尾添加c，则命令在每次替换之前都会请求用户确认::%s/Line/line/gc y：执行替换 n：跳过此次替换 a：执行此次替换和之后的所有替换 q或者ESC：停止替换 l：执行此次替换并退出替换，是last的缩写 Ctrl-E，Ctrl-Y：分别是向下滚动和向上滚动，能用于查看替换处的上下文 编辑多个文件:1vi file1 file2 file3… 打开多个文件 切换文件： 1:n下一个文件 :N上一个文件 当用户从一个文件切换到另一个的时候，vi要求用户必须先保存对当前文件做出的修改才能切换到其他文件。若要放弃对文件的修改并使vi强制切换到另一个文件，可在命令后添加感叹号！ 12:buffers 查看正在编辑的文件列表:buffer 2 切换到文件2 载入更多的文件： 1:e 文件名【使用此命令载入的文件不会响应:n或:N命令，而需要使用:buffer加文件编号来切换文件】 文件之间的内容复制：使用之前的复制粘贴命令即可 插入整个文件： 1:r text1 将text1文件内容插入到当前文件光标处","categories":[{"name":"Apple、Linux","slug":"Apple、Linux","permalink":"http://example.com/categories/Apple%E3%80%81Linux/"}],"tags":[{"name":"Ubuntu Server","slug":"Ubuntu-Server","permalink":"http://example.com/tags/Ubuntu-Server/"}]},{"title":"定制提示符","slug":"Apple、Linux/Ubuntu Server/定制提示符：","date":"2018-10-20T16:00:00.000Z","updated":"2021-03-23T07:50:28.000Z","comments":true,"path":"2018/10/21/Apple、Linux/Ubuntu Server/定制提示符：/","link":"","permalink":"http://example.com/2018/10/21/Apple%E3%80%81Linux/Ubuntu%20Server/%E5%AE%9A%E5%88%B6%E6%8F%90%E7%A4%BA%E7%AC%A6%EF%BC%9A/","excerpt":"","text":"系统的默认提示符：提示符中包含了用户名、主机名和当前的工作目录 提示符是由名为PS1（提示符字符串1）的环境变量定义的，echo命令可以帮助用户看到PS1的值 尝试设计提示符： 备份：在终端会话中，用户随时可以通过这个过程的逆操作来复原最初的提示符 如果提示符为空：那么用户不会得到任何提示 将提示符设置成最简略的内容： 在提示符中添加了一个铃声，每当系统显示提示符的时候，用户都会听到哔哔声，这在一些情况下可能会很有帮助，比如可以在一个耗时比较长的命令执行完毕时通知用户： 包括主机名和当天的时间信息： 添加颜色：字符颜色是由发送到终端仿真器的一个ANSI转义代码来控制的，该转义代码嵌入到了要显示的字符流中，控制代码不会打印到屏幕上，而是被终端解释为一条指令： 创造红色的提示符：但是此时用户输入的所有文字也变成红色了 修复这个问题： 设置文本的背景颜色，背景颜色不支持粗体属性： 文本除了正常(0)和粗体(1)属性外，还可以设置为下划线(4)、闪烁(5)和斜体(7)，为了维持好的品味，许多终端仿真器拒绝使用闪烁属性","categories":[{"name":"Apple、Linux","slug":"Apple、Linux","permalink":"http://example.com/categories/Apple%E3%80%81Linux/"}],"tags":[{"name":"Ubuntu Server","slug":"Ubuntu-Server","permalink":"http://example.com/tags/Ubuntu-Server/"}]},{"title":"软件包管理","slug":"Apple、Linux/Ubuntu Server/软件包管理","date":"2018-10-19T16:00:00.000Z","updated":"2021-03-23T07:50:15.000Z","comments":true,"path":"2018/10/20/Apple、Linux/Ubuntu Server/软件包管理/","link":"","permalink":"http://example.com/2018/10/20/Apple%E3%80%81Linux/Ubuntu%20Server/%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%AE%A1%E7%90%86/","excerpt":"","text":"决定Linux发行版本质量最重要的因素是软件包系统和支持该发行版本社区的活力软件包管理是一种在系统上安装、维护软件的方法不同的Linux发行版用的是不同的软件包系统，并且原则上适用于一种发行版的软件包与其他版本是不兼容的。多数Linux发行版采用的不外乎两种软件包技术阵营，即Debian的.deb技术和Red Hat的.rpm技术，当然也有一些特例。比如Gentoo，Slackware和Foresight等软件包系统工作方式：Linux系统所有软件均可在网上找到，并且多数是以软件包文件的形式由发行商提供，其余则以可手动安装的源代码形式存在1）软件包文件2）库3）依赖关系4）高级和低级软件包工具：软件包管理系统通常包含两类工具—执行如安装、删除软件包文件等任务的低级工具和进行元数据搜索及提供依赖性解决的高级工具尽管所有Red-Hat系列版本都使用相同的低级工具（rpm），但使用的高级工具却不尽相同常见软件包管理任务：1）在库里面查找软件包2）安装库中的软件包3）安装软件包文件中的软件包4）删除软件包5）更新库中的软件包6）更新软件包文件中的软件包7）列出已安装的软件包列表8）判断软件包是否安装9）显示已安装软件包的相关信息10）查看某具体文件由哪个软件包安装得到","categories":[{"name":"Apple、Linux","slug":"Apple、Linux","permalink":"http://example.com/categories/Apple%E3%80%81Linux/"}],"tags":[{"name":"Ubuntu Server","slug":"Ubuntu-Server","permalink":"http://example.com/tags/Ubuntu-Server/"}]},{"title":"基本概念","slug":"编程语言/C语言/基本概念","date":"2018-09-29T16:00:00.000Z","updated":"2021-03-23T07:34:59.000Z","comments":true,"path":"2018/09/30/编程语言/C语言/基本概念/","link":"","permalink":"http://example.com/2018/09/30/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/","excerpt":"","text":"C语言的发展： C语言是从B语言发展而来的，B语言是从BCPL发展而来的，BCPL是从FORTRAN发展而来的 BCPL和B都支持指针间接方式，所以C也支持了 C语言还受到了PL/I的影响，还和PDP-II的机器语言有很大关系 1973年3月，第三版的Unix上出现了C语言的编译器 1973年11月，第四版的Unix(System Four)发布了，这个版本是完全用C语言重新写的 C语言标准： 1989年ANSI发布了一个标准：ANSI C 1990年ISO接受了ANSI的标准：C89 C的标准在1995年和1999年两次更新：C95和C99 所有的当代编译器都支持C99了 环境、开发环境和IDE： 环境：就是一个软件 开发环境：用于开发程序的一个软件，就是说这个软件是用来开发程序的 IDE：集成开发环境，集成的意思是多个功能集合在一起，所以就是集多种功能于一身的用来开发程序的软件 程序的执行： 解释：借助一个程序，那个程序能试图理解你的程序，然后按照你的要求执行 编译：借助一个程序，就像一个翻译，把你的程序翻译成计算机真正能懂的语言（机器语言写的程序），然后这个机器语言写的程序就能直接执行了 解释型语言VS编译型语言：语言本无解释和编译之分，解释型语言有特殊的计算能力，编译型语言有确定的运算性能 C需要被编译才能运行，所以你需要编辑器和编译器或者IDE（集成开发环境） 现代的编程语言在语法上的差异很小，几乎都是C-like语言，语言的能力和适用领域主要是由库和传统所决定的 程序是用特殊的编程语言写出来表达如何解决问题的，不是用编程语言来和计算机交谈，而是描述要求它如何做事情的过程和方法，我们要让计算机做计算，就需要找出计算的步骤，然后用编程语言写出来；计算机做的所有的事情都叫做计算，计算的步骤就是算法","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"C语言","slug":"C语言","permalink":"http://example.com/tags/C%E8%AF%AD%E8%A8%80/"}]},{"title":"编写第一个shell脚本：","slug":"Apple、Linux/Ubuntu Server/编写第一个shell脚本","date":"2018-09-29T16:00:00.000Z","updated":"2021-03-23T07:49:53.000Z","comments":true,"path":"2018/09/30/Apple、Linux/Ubuntu Server/编写第一个shell脚本/","link":"","permalink":"http://example.com/2018/09/30/Apple%E3%80%81Linux/Ubuntu%20Server/%E7%BC%96%E5%86%99%E7%AC%AC%E4%B8%80%E4%B8%AAshell%E8%84%9A%E6%9C%AC/","excerpt":"","text":"shell脚本是一个包含一系列命令的文件，shell读取这个文件，然后执行这些命令，就好像这些命令是直接输入到命令行中一样；shell既是一个强大的命令行接口，也是一个脚本语言解释器，大多数能够在命令行中完成的工作都可以在脚本中完成，反之亦然 为了成功创建和运行一个shell脚本，我们需要做三件事：1）编写脚本：shell脚本是普通的文本文件，所以我们需要一个文本编辑器来编辑它，最好文本编辑器可以提供“语法高亮”功能，从而能够看到脚本元素彩色代码视图，“语法高亮”可以定位一些常见的错误2）使脚本可执行：系统相当严格，它不会将任何老式的文本文件当作程序，所以我们需要将脚本文件的权限设置为允许执行3）将脚本放置在shell能够发现的位置：当没有显式指定路径名时，shell会自动的寻找某些目录，来查找可执行文件，为了最大程度的方便，我们将脚本放置在这些目录下 文本行中，在“#”符号后面的所有内容会被忽略“#!”字符序列是一种特殊的结构，称之为shebang，用来告知操作系统，执行后面的脚本应该使用的解释器的名字，每一个shell脚本都应该将其作为第一行 可执行权限：对于脚本，有两种常见的权限设置，权限为755的脚本，每个人都可以执行；权限为700的脚本，只有脚本的所有人才能执行，注意，为了能够执行脚本，它必须是可读的 脚本文件的位置：为了使脚本运行，我们必须显式指定脚本文件的路径 如果没有显式指定路径，则系统在查找一个可执行程序时，需要搜索一系列目录，这就是当我们在命令行中输入ls时，系统知道要执行/bin/ls的原因。/bin目录是系统会自动搜索的一个目录。 目录列表存放在名为PATH的环境变量中，这个PATH变量包含一个由冒号分隔开的待搜索目录的列表： 如果脚本位于该列表中的任何一个目录中，问题就解决了 这两个命令一样，为了减少输入，当在命令行中输入选项时，短选项更可取，但是在编写脚本时，长选项名可以提高可读性 缩进和行连接： 脚本和命令行的一个区别是，脚本可以使用制表符来实现缩进，但在命令行中，Tab键用来激活自动补齐功能","categories":[{"name":"Apple、Linux","slug":"Apple、Linux","permalink":"http://example.com/categories/Apple%E3%80%81Linux/"}],"tags":[{"name":"Ubuntu Server","slug":"Ubuntu-Server","permalink":"http://example.com/tags/Ubuntu-Server/"}]},{"title":"macOS终端下执行第一个C程序","slug":"编程语言/C语言/macOS终端下执行第一个C程序","date":"2018-09-28T16:00:00.000Z","updated":"2021-03-23T07:32:45.000Z","comments":true,"path":"2018/09/29/编程语言/C语言/macOS终端下执行第一个C程序/","link":"","permalink":"http://example.com/2018/09/29/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80/macOS%E7%BB%88%E7%AB%AF%E4%B8%8B%E6%89%A7%E8%A1%8C%E7%AC%AC%E4%B8%80%E4%B8%AAC%E7%A8%8B%E5%BA%8F/","excerpt":"","text":"在其他操作系统中，编译，加载，运行等规则会有所不同！ 1）新建一个文件夹“C语言程序演示” 2）在终端中cd进入这个新建的文件夹 3）在新文件夹中touch hello.c建立一个后缀名为.c的源程序 4）在hello.c源文件中写第一个C语言的代码 5）通过cc hello.c命令进行编译，如果源程序没有什么错误，编译过程将顺利进行，并生成一个可执行文件a.out【cc -c 源文件名称：编译，生成.o文件，叫做目标文件，存储的是.c文件中的代码对应的二进制指令；cc 目标文件名称：连接，为.o的目标文件添加启动代码，告诉编译器，要调用的函数在什么地方】 6）然后我们输入./a.out，即可运行a.out，打印出程序结果","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"C语言","slug":"C语言","permalink":"http://example.com/tags/C%E8%AF%AD%E8%A8%80/"}]},{"title":"数据类型","slug":"编程语言/C语言/数据类型","date":"2018-09-27T16:00:00.000Z","updated":"2021-03-23T07:34:47.000Z","comments":true,"path":"2018/09/28/编程语言/C语言/数据类型/","link":"","permalink":"http://example.com/2018/09/28/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"C数据类型、格式控制符整理123456789101112131415161718192021222324252627282930313233343536373839404142434445464748C数据类型：1⃣️基本数据类型：整型：char、short、int、long、long long(C99)浮点型：float、double、long double(C99)布尔型：bool(C99)1）char：字符类型，一个字节（一个字节=八个比特），-128～+1272）short：短整型，通常为16位，两个字节，-32768～327673）int：取值范围取决于具体的机器，通常代表特定机器中整数的自然长度，通常为16位，其取值范围在-2147483648 ～ +2147483647之间，也有用32位表示的int类型4）long：长整型，四个字节，至少占32位存储单元，在某些机器上int与long类型的长度相同5）long long：八个字节6）float类型：取值范围取决于具体的机器，通常是32位，可以存储有效位数不超过7位的小数，取值范围一般在10^(-38)~10^(+38)之间7）double：双精度浮点型，64位，可以存储有效位数不超过16位的小数2⃣️构造类型：数组、结构体、枚举3⃣️指针类型4⃣️空类型：void5⃣️typedef自定义类型C格式控制符：不同类型的数据在变量中存储的形式是不一样的，所以在读取变量中的数据的时候，类型不同读取的方式也不同%hd：short%d：读取int整型，以十进制输出%o：读取int整型，以八进制输出（一个以0开始的数字字面量是8进制）%x：读取int整型，以十六进制输出（一个以0x开始的数字字面量是16进制，8进制和16进制只是如何把数字表达为字符串，与内部如何表达数字无关）%ld：long%lld：long long%hu：unsigned short%u：unsigned int%lu：unsigned long%llu：unsigned long longfloat和double类型的printf都使用%f或%e，float的scanf使用%f，double的scanf使用%lf%c：char类型，表示字符%s表示字符串%p：地址%%表示百分号（%）本身 数据类型的一些注意点 一个C语言程序，无论其大小如何，都是由函数和变量组成的，函数中包含一些语句，以指定所要执行的计算操作；变量则用于存储计算过程中使用的值。main是一个特殊的函数名，每个程序都从main函数的起点开始执行，每个程序都必须在某个位置包含一个main函数；函数之间进行数据交换的一种方法是调用函数向被调用函数提供一个值（称为参数）列表 变量的命名规则：变量名是由字母和数字组成的序列，但其第一个字符必须为字母，下划线“_”被看作是字母，通常用于命名较长的变量名，以提高其可读性。由于库例程的名字通常以下划线开头，因此变量名不要以下划线开头 变量就是内存中开辟的用来存储数据的那块空间，所以变量是用来存储数据的，我们声明一个变量，如果没有为这个变量赋值，这个变量是有值的，这个值是一个随机数、垃圾值 在同一个大括弧中不允许定义多个变量名相同的变量，不同大括弧可以 自动类型转换：当我们为变量赋值的时候，如果赋值的数据的类型和变量的类型不一致，这时候C系统会将赋值的数据的类型转换为变量的类型再赋值 如果某个算术运算符的所有操作数均为整型，则执行整型运算。但是，如果某个算术运算符有一个浮点型操作数和一个整型操作数，则在开始运算之前整型操作数将会被转换为浮点型 强制类型转换：要把一个量强制转换成另一个类型（通常是较小的类型）:(int)10.2，注意这时候的安全性，小的变量不总能表达大的量：(short)32768 强制类型转换只是从那个变量计算出了一个新的类型的值，它并不改变那个变量，无论是值还是类型都不改变 强制类型转换的优先级高于四则运算： 123double a=1.0;double b=2.0;int I=(int)a/b; 在printf函数的参数中，只能用\\n表示换行符，如果用程序的换行代替\\n，C编译器将会产生一条错误信息。printf函数永远不会自动换行，这样我们可以多次调用该函数以分阶段得到一个长的输出行。 printf函数并不是C语言本身的一部分，C语言本身并没有定义输入/输出功能。printf仅仅是标准库函数中一个有用的函数而已，这些标准库函数在C语言程序中通常都可以使用。 printf输出inf表示超过范围的浮点数，printf输出nan表示不存在的浮点数 scanf函数是一个阻塞式的函数，当CPU执行到这个函数的时候，CPU的执行就会暂停，不会继续往下执行了，并等待用户输入数据 scanf函数后面不要加\\n 如果没有特殊需要，只使用double，现代CPU能直接对double做硬件运算，性能不会比float差，在64位的机器上，数据存储的速度也不比float慢 #include&lt;stdbool.h&gt;之后就可以使用bool和true、false了 在C语言中如果我们直接写一个小数，那么这个小数的类型是double类型的，如果我们就是希望这个小数是一个float类型的，那么就在这个小数的后面加一个f/F char类型的变量中只能存储单个字符，并且这单个字符还要用单引号引起来；如果char类型的变量中存储的字符超过一个，那么它只会保存最后一个字符（char变量中可以存储一个空格，无法存储中文，因为在C语言中，一个中文占3个字节） 字符型变量是用来存储字符常量的变量。将一个字符常量存储到一个字符变量中，实际上是将该字符的ASCII码值（无符号整数）存储到内存单元中。【‘A’——65、‘a’——97、‘0’——48，为char变量赋值的时候可以直接赋值ASCII码】 所有整型都包括signed(带符号)和unsigned(无符号)两种形式，且可以表示无符号常量与十六进制字符常量； unsigned类型的数总是正值或0，如果char对象占用8位，那么unsigned char类型变量的取值范围为0～255，而signed char类型变量的取值范围则为-128～127（在采用对二的补码的机器上） 如果一个字面量常数想要表达自己是unsigned，可以在后面加U【255U】，用l或L表示long(long) unsigned的初衷并非扩展数能表达的范围，而是为了做纯二进制运算，主要是为了移位 无论是float还是double，默认都只显示小数点后6位(不足的用0补齐，多余六位的只保留六位)%.nf：表示显示小数点后n位%m.nf：如果变量整体的位数(小数点默认显示n位，无n的默认显示6位，小数点不足6位的在后面补0，大于6位的按6位计算)小于m，不足的地方就会以空格补齐（正数在前面补齐，负数在后面补齐）；如果变量整体的位数大于字符宽，那么实际有多少位就显示多少位(%0mf，不足的地方以0补齐)","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"C语言","slug":"C语言","permalink":"http://example.com/tags/C%E8%AF%AD%E8%A8%80/"}]},{"title":"scanf输入多个数据出现的问题","slug":"编程语言/C语言/scanf输入多个数据出现的问题","date":"2018-09-26T16:00:00.000Z","updated":"2021-03-23T07:32:34.000Z","comments":true,"path":"2018/09/27/编程语言/C语言/scanf输入多个数据出现的问题/","link":"","permalink":"http://example.com/2018/09/27/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80/scanf%E8%BE%93%E5%85%A5%E5%A4%9A%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"","text":"如果使用scanf函数一次输入多个数据，只能是整型和浮点型，如果有char字符型混合输入，就会出现问题： 图中可以看到：num3的值并没有打印出来，出现这种情况的原因是什么呢？？？ 在执行scanf函数的时候，会让用户输入一个数据，数据输入完毕之后，并不是将这个数据直接赋值给变量，而是先将数据存储在缓冲区，输入的任何数据都会存储在缓冲区中 在执行scanf函数的时候，会先检查缓冲区中是否有数据，如果缓冲区中没有数据，那么就会让用户从键盘输入，如果缓冲区中有数据，直接从缓冲区中将数据拿出来，不会让用户输入数据 当从缓冲区中拿数据的时候，如果要拿的数据的类型是整型或者实型，如果拿到的数据的类型是空格、回车、Tab键，就会被自动忽略，继续往下拿；如果要拿的数据是字符型，不会忽略任何数据 我们来分析下面的一段程序：程序中要求用户输入一个整型数据num1，但是这个时候我们偏偏输入两个整型数据10、20，这个时候缓冲区其实有四个数据：10、空格、20、换行，执行第一个printf后结果为10，这是我们事先预料好的；当第二个scanf执行的时候，程序根本就不会让用户输入数据，因为缓冲区中已经有整型数据20了【当从缓冲区中拿数据的时候，如果要拿的数据的类型是整型或者实型，如果拿到的数据的类型是空格、回车、Tab键，就会被自动忽略，继续往下拿】，所以最终程序会直接打印出num2=20 让我们再回头看第一个程序：为什么num3的值打印出来的结果为空？？？执行完第11行程序以后，缓冲区中的数据为10、空格、2.5、空格、a、换行；打印num1、num2的值的时候，因为是整型或者浮点型，程序会自动忽略空格和换行，所以输出结果为num1=10，num2=2.500000；但是num3是一个字符型的数据，程序并不会忽略任何的数据，最后打印出来的结果为num3= ；【这里打印出来了一个空格，并不是空】 那这个时候就有问题了，如果scanf输入多个数据中包含字符型数据时，我就是想要输出来字符型数据，该怎么做呢？？？ 解决方案：通过rewind(stdin);这行代码把缓冲区中的数据全部清空，这个时候缓冲区中没有任何数据了 写C代码时，如果遇到整型、浮点型、字符型同时出现在scanf函数中的时候，要十分注意缓冲区中数据的情况！！","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"C语言","slug":"C语言","permalink":"http://example.com/tags/C%E8%AF%AD%E8%A8%80/"}]},{"title":"运算符和表达式","slug":"编程语言/C语言/运算符和表达式","date":"2018-09-25T16:00:00.000Z","updated":"2021-03-23T07:34:36.000Z","comments":true,"path":"2018/09/26/编程语言/C语言/运算符和表达式/","link":"","permalink":"http://example.com/2018/09/26/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80/%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E8%A1%A8%E8%BE%BE%E5%BC%8F/","excerpt":"","text":"C运算符、优先级整理123456789101112131415161718192021C运算符：赋值运算符【=、+=、-=、*=、/=、%=】算术运算符【+、-、*、/、%】关系运算符【==、!=、&gt;、&gt;=、&lt;、&lt;=】自增自减运算符【++、—-】逗号运算符【,】逻辑运算符【&amp;&amp;(与)、||(或)、！】取地址运算符【&amp;】C优先级：1）（）：从左到右2）! + - ++ —：从右到左（单目的+和-）3）* / %：从左到右4）+ -：从左到右5）&lt; &lt;= &gt; &gt;=：从左到右6）== !=：从左到右7）&amp;&amp;：从左到右8）||：从左到右9）= += -= *= /= %=：从右到左 运算符和表达式的一些注意点1）逃逸字符：用来表达无法印出来的控制字符或特殊字符，它由一个反斜杠”\\”开头，后面跟上另一个字符，这两个字符合起来，组成了一个字符：printf(“请分别输入身高的英尺和英寸，”“如输入\\“5 7 \\”表示5英尺7英寸：“); \\b：回退一格\\t：到下一个表格位\\n：换行\\r：回车\\”：双引号\\’：单引号\\：反斜杠本身 转义符只能是小写字母，每个转义符只能看作一个字符 垂直制表符“\\v”和换页符“\\f”对屏幕没有任何影响，但会影响打印机执行相应的操作 在C语言程序中，通常会用转义符表示不可打印的字符 2）如果参与算术表达式的操作数的类型不一致，那么这个算术表达式的结果的类型就是范围最大的那个类型 3）m % n的结果一定是在0～（n-1）之间 4）char类型的数据可以参与算术运算，当算术表达式中的操作数是一个char数据的时候，会先将这个char数据的ASCII码取出来代替，然后再参与算术运算，实际上它是一个int类型的数据在参与运算；char数据也可以参与比较运算 5）const是一个修饰符，加在int的前面，用来给这个变量加上一个const（不变的）的属性。这个const的属性表示这个变量的值一旦初始化，就不能再修改了，如果你试图对常量做修改，把它放在赋值运算符的左边，就会被编译器发现，指出为一个错误 6）无论是前自增表达式还是后自增表达式，都是将自身的值增加1 7）sizeof是一个运算符，给出某个类型或变量在内存中所占据的字节数：sizeof(int)、sizeof(i) sizeof是静态运算符，它的结果在编译时刻就决定了，不要在sizeof的括号里做运算，这些运算不会做的 8）逻辑运算是对逻辑量进行的运算，结果只有0或1，逻辑量是关系运算或逻辑运算的结果 逻辑非！【!a，如果a是true，结果就是false，如果a是false，结果是true】逻辑与&amp;&amp;【a &amp;&amp; b，如果a和b都是true，结果就是true，否则就是false】逻辑或||【a || b，如果a和b有一个是true，结果为true，两个都是false，结果为false】 x&gt;4 &amp;&amp; x&lt;6：像4&lt;x&lt;6这样的式子，不是C能正确计算的式子，因为4&lt;x的结果是一个逻辑值(0或1) 短路：逻辑运算是自左向右进行的，如果左边的结果已经能够决定结果了，就不会做右边的计算；对于&amp;&amp;，左边是false时就不做右边了；对于||，左边是true时就不做右边了 不要把赋值，包括复合赋值组合进表达式！a==6 &amp;&amp; b==1；a==6 &amp;&amp; b+=1 9）三元表达式、条件运算符（可以部分代替if else）： 1234567count = (count&gt;20) ? count-10 : count+10;if(count &gt; 20) count = count-10;else count = count+10; 10）逗号运算符：逗号用来连接两个表达式，并以其右边的表达式的值作为它的结果。逗号的优先级是所有的运算符中最低的，所以它两边的表达式会先计算；逗号的组合关系是自左向右，所以左边的表达式会先计算，而右边的表达式的值就留下来作为逗号运算的结果for（i=0，j=10；i&lt;j；i++，j—） 逗号表达式的目的并不是想要前面表达式的结果，而只是想要前面的表达式执行，要最后一个表达式的结果","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"C语言","slug":"C语言","permalink":"http://example.com/tags/C%E8%AF%AD%E8%A8%80/"}]},{"title":"控制流","slug":"编程语言/C语言/控制流","date":"2018-09-24T16:00:00.000Z","updated":"2021-03-23T07:34:25.000Z","comments":true,"path":"2018/09/25/编程语言/C语言/控制流/","link":"","permalink":"http://example.com/2018/09/25/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80/%E6%8E%A7%E5%88%B6%E6%B5%81/","excerpt":"","text":"C选择结构、循环结构整理123456789101112131415161718192021222324252627282930313233341）if-else if-else2）switch-case：选择结构switch(表达式)&#123; case 值1: 执行代码; break; case 值2: 执行代码; break; case 值3: 执行代码; break; default: 执行代码; break;&#125;3）while循环4）do while循环【当循环体无论如何至少要执行一次的时候使用】do&#123; 循环体;&#125;while(条件表达式);5）for循环【当循环次数确定的时候，一般使用for循环；当循环次数不确定的时候，一般使用while循环】 控制流的一些注意点1）小技巧：Xcode中选中要对齐的代码：control+i，就会自动对齐 2）while循环应用场景： -循环体确定，循环次数也确定-循环体确定，循环的次数不确定，但是循环继续或者结束的条件确定-遍历指定范围的数-找出指定范围中符合特定条件的数-求累加和与平均值-找一堆数中的最大数和最小数-计数-穷举【一个一个试】 3）定义在一个大括弧中的变量，只能在这个大括弧中访问，出了大括弧，CPU立即将变量回收，无法访问到了: 123456789101112131415#include&lt;stdio.h&gt;int main(int argc,const char * argv[])&#123; int num=1; if(num &gt; 0)&#123; int age = 10; printf(&quot;age=%d\\n&quot;,age); &#125; printf(&quot;age=%d\\n&quot;,age); return 0;&#125; 我们可以自定义一个作用域来提前释放一个变量: 123456&#123; int i=1; printf(&quot;i=%d\\n&quot;,i);&#125; //这个时候，i就会在这里释放 4）无大括号else的匹配：else总是和最近的那个if匹配 5）if-else与switch-case的区别：前者从头开始遍历，后者直接跳转到符合要求处 每一个case块后面的break在语法上是可以不写的，break的意思代表立即结束整个switch-case结构，如果case块中没有break，那么就会直接穿透到下一个case中执行代码，直到遇到break才会结束switch结构，或者执行完 如果多个case块的处理逻辑是一样的，那么我们可以利用case穿透简写代码 switch后面的表达式任何类型都是可以的，除了实型 如果case块中要声明变量，那么这个case块就必须要使用大括弧 switch结构只能做等值判断，不能直接做范围判断，并且case后面的数据不能有变量 break的作用： 6）break和continue的区别： 如果在循环体中遇到了break，就会立即结束当前循环结构，但是还会继续外层循环 continue只能使用在循环体中，如果遇到了continue，会立即结束本次循环，然后回去判断循环条件【注意一下while循环体和for循环体不一样(前者可能包括i++，后者不包括)】 break和continue都只能作用于当前循环体！ 一道比较有意思的面试题： 7）while和do-while的区别：前者先判断条件后进循环体，后者先进循环体再判断条件 8）for循环中，三个表达式都可以省略，但是分号不能省略；如果第二个表达式省略，那么循环条件默认就是成立的 for循环三个表达式其实可以是任意的C语句： 9）goto：可以将CPU的执行跳转到当前函数的别的地方继续执行 当执行到goto语句的时候，CPU就会跳转到指定的标签的地方继续往下执行 goto语句也可以实现循环操作 goto可以往前跳，也可以往后跳，但是只能在当前函数中跳 取标签名下面的那一句代码不能是声明变量： 10）break和goto：","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"C语言","slug":"C语言","permalink":"http://example.com/tags/C%E8%AF%AD%E8%A8%80/"}]},{"title":"数组","slug":"编程语言/C语言/数组","date":"2018-09-23T16:00:00.000Z","updated":"2021-03-23T07:34:15.000Z","comments":true,"path":"2018/09/24/编程语言/C语言/数组/","link":"","permalink":"http://example.com/2018/09/24/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80/%E6%95%B0%E7%BB%84/","excerpt":"","text":"局部变量的回收：在大括弧执行完毕之后，定义在这个大括弧中的变量就会被系统立即回收，声明变量的时候，其实是找系统为你从高地址向低地址分配指定字节数的连续空间，当变量回收的时候，其实就是告诉系统变量占用的字节不再使用了，可以分配给别的变量了，变量所占用的字节的数据是不会清空的【垃圾值的由来】 当将全局变量声明出来以后，系统会自动的将全局变量中的数据清零 一维数组： int arr[3];，其中所有的元素具有相同的数据类型，一旦创建，不能改变大小 数组中的元素在内存中是连续依次排列的： 遍历数组： 一维数组的初始化：1）使用这种方式初始化，数组的长度就不能使用变量了，但是使用宏可以【也可以干脆直接省略数组中的长度，这样数组的长度就是由大括弧中的数据的个数来决定的】 12int len=3;int arr[len]=&#123;10,20,30&#125;; //错误 2）int arr[3]=&#123;10&#125;;这个时候数组的第0个元素的值是10，其他的元素的值被自动初始化为0，所以如果我们要将数组中的所有元素全部初始化为0，只需要在大括弧中写一个0就可以了 3）指定下标的初始化，其他的元素的值就自动初始化为0：int arr[3]=&#123;[1]=10,[2]=20&#125;; 声明一个数组，在内存中从高字节向低字节申请连续的（数组的长度*每个元素的字节数）个字节的空间 数组的元素的本质就是一个普通类型的变量，一个数组就是由多个普通类型的变量联合而成的 C语言的数组名中存储的就是数组的地址！ 数组的大小：sizeof(a)/sizeof(a[0])sizeof给出整个数组所占据的内容的大小，单位是字节；sizeof(a[0])给出数组中单个元素的大小，于是相除就得到了数组的单元个数；这样的代码，一旦修改数组中初始的数据，不需要修改遍历的代码 数组的赋值：数组变量本身不能被赋值，要把一个数组的所有元素交给另一个数组，必须采用遍历 1234for(int i=0;i&lt;length;i++)&#123; b[i]=a[i];&#125; 二维数组： 二维数组的长度一般认为是元素的个数【行*列】 二维数组的遍历：a[i][j]是一个int，表示第i行第j列上的单元 二维数组的初始化： 1）1.列数是必须给出的，行数可以由编译器来数2.每行一个{}，逗号分隔3.最后的逗号可以存在，有古老的传统 2） 12345int arr[3][4]=&#123;&#123;10&#125;,&#123;20&#125;,&#123;30&#125;&#125;;a[0][0]=10a[1][0]=20a[2][0]=30 其他元素会自动初始化为0 3）int arr[3][4]=&#123;10,20,30,40,50&#125;;按照顺序去初始化每一个元素，其他的元素的值就会被自动初始化为0 4）int arr[3][4]=&#123;[1]=&#123;10,20,30,40&#125;,[2]=&#123;50,60,70,80&#125;&#125;;给指定的行初始化，其他的元素自动初始化为0 二维数组从高地址向低地址申请了连续的（行列每一个元素占用的字节）个字节空间 二维数组在内存中仍然是一块连续的空间，并不是一个表格 求二维数组的长度的方法与一维数组一样：sizeof(arr)/sizeof(arr[0][0]); 求二维数组的行数：sizeof(arr)/sizeof(arr[0]); 求二维数组的列数：sizeof(arr[0])/sizeof(arr[0][0]); 如果函数的参数是一个一维数组，那么我们在传递的时候可以传递二维数组的某一行，二维数组的行其实是一个一维数组 二维数组也可以作为函数的参数【与一维数组类似】，但是其中形参的行数可以省略，列数不能省略，实参与形参的行数可以任意，实参的列数与形参的列数必须一致 解决方案【与一维数组稍微不同！】","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"C语言","slug":"C语言","permalink":"http://example.com/tags/C%E8%AF%AD%E8%A8%80/"}]},{"title":"函数","slug":"编程语言/C语言/函数","date":"2018-09-22T16:00:00.000Z","updated":"2021-03-23T07:34:04.000Z","comments":true,"path":"2018/09/23/编程语言/C语言/函数/","link":"","permalink":"http://example.com/2018/09/23/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80/%E5%87%BD%E6%95%B0/","excerpt":"","text":"函数：函数是一块代码，接收零个或多个参数，做一件事情，并返回零个或一个值 循环：同一段代码反复不停的执行重用/复用：有一段代码，多个地方都要执行一次，但是不是反复不停的执行 定义在函数内部的变量，我们就叫做局部变量定义在函数外部的变量，我们就叫做全局变量，直接定义在源文件下面 局部变量只能在当前函数的内部访问全局变量从定义的地方开始，后面的所有函数中都可以访问这个全局变量 声明一个局部变量，如果没有为这个局部变量赋初始值，那么这个局部变量中的值是一个垃圾值；声明一个全局变量，如果没有为这个全局变量赋初始值，那么这个全局变量的初始值为0 如果全局变量的类型是char类型，并且我们也没有初始化，那么系统就会自动的为这个char变量赋值一个‘\\0’，代表一个不可见的字符，这个字符的ASCII码就是0 CPU执行声明局部变量的那句话的时候，才会在内存中声明局部变量，当作用域结束以后，就会自动回收；程序一启动，就在内存中创建全局变量，程序结束的时候全局变量才会被回收 可以定义一个和全局变量名称相同的局部变量【不建议】 声明在函数名称后面的小括弧中的变量就叫做这个函数的参数，参数实际上就是定义在函数内部的局部变量，所以在函数的内部不能再定义一个局部变量的名称和参数的名称一样 形参：声明在函数名的小括弧中的参数实参：在调用函数的时候，实际上为形参赋的值 return关键字用在函数体中，在函数体中如果遇到了return关键字，就会立即结束这个函数的执行 函数的声明(.h)和实现(.c) 当我们的程序的函数过多的时候，就要考虑分模块开发，一个模块至少包含两个文件，.h文件专门写函数的声明，.c文件专门写函数的实现 ，其他人想要调用函数，只需要导入头文件就可以了","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"C语言","slug":"C语言","permalink":"http://example.com/tags/C%E8%AF%AD%E8%A8%80/"}]},{"title":"值传递、地址传递","slug":"编程语言/C语言/值传递、地址传递","date":"2018-09-21T16:00:00.000Z","updated":"2021-03-23T07:32:24.000Z","comments":true,"path":"2018/09/22/编程语言/C语言/值传递、地址传递/","link":"","permalink":"http://example.com/2018/09/22/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80/%E5%80%BC%E4%BC%A0%E9%80%92%E3%80%81%E5%9C%B0%E5%9D%80%E4%BC%A0%E9%80%92/","excerpt":"","text":"值传递：当函数参数的类型是int、float、double、char类型的时候，调用者传入一个实参变量，函数执行完毕之后，对实参变量的值没有影响 我们来分析下面一段代码：为啥test函数和main函数中num的值不一样呢？？ 程序执行原理： 地址传递：数组作为函数的参数时是地址传递，在传值的时候，是把实参数组名传递进来，数组名代表数组地址，所以这个时候传值传的是数组的地址，把数组的地址传递给了函数的参数，所以函数的参数也指向了实参数组【当数组作为函数的参数的时候，在函数的内部去修改这个参数数组的元素，其实修改的就是实参数组的元素】 当数组作为函数的参数的时候，那么在传递的时候，会丢失数组的长度，在函数的内部使用sizeof计算参数数组的字节数，得到的永远都是8 内部原理：如果函数的参数是一个数组，在声明这个参数的时候，并不会去真正的创建数组，而是去声明一个用来存储数组地址的指针变量，这个指针变量在内存中占据8个字节 那我们函数内部想要得到原来的数组长度该怎么办呢？？ 如果我们的函数的参数是一个数组，这个时候还必须得加一个参数，让调用者将这个数组的长度传递进来 如果我们为函数写了一个数组作为参数，其实编译器在编译的时候，已经把这个数组换成了指针【所以，以后为函数写一个数组参数的时候，不要写数组了，直接按照下图写一个指针】","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"C语言","slug":"C语言","permalink":"http://example.com/tags/C%E8%AF%AD%E8%A8%80/"}]},{"title":"指针作为函数的参数、返回值","slug":"编程语言/C语言/指针作为函数的参数、返回值","date":"2018-09-20T16:00:00.000Z","updated":"2021-03-23T07:32:14.000Z","comments":true,"path":"2018/09/21/编程语言/C语言/指针作为函数的参数、返回值/","link":"","permalink":"http://example.com/2018/09/21/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80/%E6%8C%87%E9%92%88%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0%E3%80%81%E8%BF%94%E5%9B%9E%E5%80%BC/","excerpt":"","text":"指针作为函数的参数： 当我们调用一个函数的时候，如果这个函数的参数是一个指针，那么我们就必须要为这个指针传递一个和指针类型相同的普通变量的地址，这个时候，在函数的内部去访问参数指针指向的变量的时候，其实访问的就是实参变量 下面的程序遇到了一个问题：函数内部只能返回一个数据 当函数需要返回多个数据的时候就可以使用指针作为函数的参数 解决方法：使用指针作为函数的参数，让调用者将自己的变量的地址传递到函数的内部，函数的内部通过指针就可以修改实参变量的值1）2） 指针作为函数的返回值： 可以返回局部变量的值，但是不能返回局部变量的地址 如果你就是要返回一个指针，那么你就要保证这个指针指向的空间在函数结束以后仍然存在，那么这个时候，就可以将空间申请在堆区，然后返回堆区的地址【使用完后一定要记得free】","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"C语言","slug":"C语言","permalink":"http://example.com/tags/C%E8%AF%AD%E8%A8%80/"}]},{"title":"指针","slug":"编程语言/C语言/指针","date":"2018-09-19T16:00:00.000Z","updated":"2021-03-23T07:33:53.000Z","comments":true,"path":"2018/09/20/编程语言/C语言/指针/","link":"","permalink":"http://example.com/2018/09/20/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80/%E6%8C%87%E9%92%88/","excerpt":"","text":"变量的值：存储在变量中的数据叫做变量的值变量的地址：一个变量是由一个或多个字节组成的，组成这个变量的低字节的地址，就是这个变量的地址 变量的地址就叫做指针，指针变量就是专门用来存储地址的变量，专门用来存储另外一个变量的地址，那么我们就说这个指针变量指向了另外一个变量【它自己也有一个地址】，通过指针变量可以间接的访问指针变量指向的另外一个变量 int* p1;，代表声明了一个叫做p1的指针变量，这个指针变量的类型是int，这个代表这个变量不是一个普通变量，而是一个专门用来存储地址的指针变量【只能存储int变量的地址】 指针变量初始化只能给他一个地址：int* p1=&amp;num; 使用指针间接的操作指向的变量： 1234int num = 10;int* p1=&amp;num;*p1=100; //*p1代表指向的变量，也就是num 运算符&amp;：获得变量的地址，它的操作数必须是变量:int i;printf(“%p”,&amp;i); *是一个单目运算符，用来访问指针的值所表示的地址上的变量,可以做右值也可以做左值int k=*p;*p=k+1; 指针的一些注意点： 1）【指针+1】并不是在指针地址的基础之上加一个字节的地址，而是在这个指针地址的基础之上加一个单位变量占用的字节数【这个时候p1指向的就是num1】 2）p++的意思是取出p所指的那个数据，之后再把p移到下一个位置去，的优先级虽然高，但是没有++高，常用于数组类的连续空间操作 3）int* p1;我们声明一个指针变量，如果没有为其初始化，那么这个时候这个指针变量是有值的，这个值是一个垃圾值，，这个时候，这个指针变量就有可能指向了一块随机的空间，像这样的指针我们就叫做野指针【最好给他初始化一下：int *p1=NULL;NULL值代表指针变量不指向内存中的任何地址】 4）多个指针指向同一变量： 5）指针分好多类型，但无论指针什么类型，在内存中都是占据着8个字节，指向不同类型的指针是不能直接互相赋值的，这是为了避免用错指针 6）p1指针变量中存储的是num变量的地址，也就是num变量的低字节的地址，这个时候p1指针能操作多少个字节是根据指针的类型来决定的【这就是为什么指针要分类型，还必须跟指向的普通变量的类型一致】 一级指针和多级指针： 一个指针变量中存储的是一个普通变量的地址，像这样的指针，我们就叫做一级指针一个指针变量中存储的是一个一级指针变量的地址，像这样的指针，我们就叫做二级指针 声明多级指针： 一级指针只能存储普通变量的地址，二级指针只能存储一级指针变量的地址 指针与数组： 使用指针来遍历数组：1）2）本方法中不能换成*(arr++)，数组名代表数组的地址，而数组一旦创建，数组的地址就确定了，不能改变，所以我们不能为数组名赋值，不能修改数组名的值，但是可以使用数组名的值3）此方法跟前两种不一样 中括弧的本质【数组arr[0]等价于*(arr+0)，操作数组我们虽然使用中括弧下标来操作，实际上内部仍然是使用指针来操作】：指针变量后面可以使用中括弧，在中括弧中写上下标来访问数据：p1[n]完全等价于*(p1+n) 函数参数表中的数组实际上是指针,但是可以用数组的运算符[]进行运算 数组变量是特殊的指针：1）数组变量本身表达地址，所以int a[10];int *p=a;无需用&amp;取地址，但是数组的单元表达的是变量，需要用&amp;取地址2）[]运算符可以对数组做，也可以对指针做3）*运算符可以对指针做，也可以对数组做4）数组变量是const的指针，所以不能被赋值：int a[];int * const a; 如果一个数组是用来存储指针类型的数据的话，那么这个数组就叫做存储指针的数组：int* arr[3]; 指针之间的运算：指针与指针之间只能做减法运算，不能做加乘除运算，可以做比较运算 指针与指针之间可以做减法运算，结果是一个long类型的数据，代表两个指针指向的变量之间相差多少个单位变量 如果参与减法运算的两个指针不指向同一个数组，先求出两个指针的差/每一个指针变量对应的普通变量占用的字节数 指针的比较运算： 指向函数的指针：程序在运行的时候，会将程序加载到内存，程序中的函数肯定存在于内存的代码段中，我们可以声明一个指针，存储这个函数的地址，让这个指针指向这个函数，使用指针来间接的调用函数 一个指向函数的指针，并不是任意的函数都可以指向，要求指向的函数的返回值类型和参数类型必须要与指针的描述一样函数的名称就代表这个函数的地址：【注意不要在函数名后加小括弧，如果加了小括弧，就代表指向这个函数，拿到这个函数的返回值】 如果指向的函数有参数有返回值，调用的时候有参数就传参，有返回值就接！","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"C语言","slug":"C语言","permalink":"http://example.com/tags/C%E8%AF%AD%E8%A8%80/"}]},{"title":"const修饰基本数据类型","slug":"编程语言/C语言/const修饰基本数据类型","date":"2018-09-18T16:00:00.000Z","updated":"2021-03-23T07:31:51.000Z","comments":true,"path":"2018/09/19/编程语言/C语言/const修饰基本数据类型/","link":"","permalink":"http://example.com/2018/09/19/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80/const%E4%BF%AE%E9%A5%B0%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"const int num = 10;一般情况下来说，被const修饰的变量具备一定程度上的不可变性【只能取值不能修改】 const修饰数组：const int arr[4]=&#123;10,20,30,40&#125;;，数组的元素的值不能修改,数组变量已经是const的指针了，这里的const表明数组的每个单元都是const int，所以必须通过初始化进行赋值 const修饰指针：1）2）int const * p1=&amp;num;效果同上3）int * const p1=&amp;num;p1的值不能修改，但是可以通过p1去修改p1指向的变量的值4）int const * const p1=&amp;num;既不能修改p1的值，也不能通过p1去修改p1指向的变量的值 当函数的参数是一个指针的时候，这个时候函数的内部是有可能会修改实参变量的值,所以要加一个const:","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"C语言","slug":"C语言","permalink":"http://example.com/tags/C%E8%AF%AD%E8%A8%80/"}]},{"title":"与申请字节空间有关的三个函数","slug":"编程语言/C语言/与申请字节空间有关的三个函数","date":"2018-09-17T16:00:00.000Z","updated":"2021-03-23T07:32:02.000Z","comments":true,"path":"2018/09/18/编程语言/C语言/与申请字节空间有关的三个函数/","link":"","permalink":"http://example.com/2018/09/18/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80/%E4%B8%8E%E7%94%B3%E8%AF%B7%E5%AD%97%E8%8A%82%E7%A9%BA%E9%97%B4%E6%9C%89%E5%85%B3%E7%9A%84%E4%B8%89%E4%B8%AA%E5%87%BD%E6%95%B0/","excerpt":"","text":"#include&lt;stdlib.h&gt; 向堆区申请字节空间来使用：我们在堆区申请的字节空间，如果不主动释放，那么系统是不会释放掉的，除非程序结束 1）malloc()：向堆空间申请指定连续的字节空间来使用【参数是size_t类型的，也就是unsigned long】返回值是void *，返回的是创建的空间中第一个字节的地址 2）calloc()：calloc申请的字节，申请完之后，系统会将字节中的数据清零 3）realloc()：当我们发现我们之前在堆区申请的字节空间不够用的时候，就可以使用realloc函数来为我们的字节空间扩容【如果原来的空间后面还有剩余的空间，并且足够扩容，那么直接就扩容在后面；如果原来的空间后面有剩余空间但是剩下的空间不够扩容，就重新找一块足够的空间申请，将原来的数据拷贝过来，原来的空间被自动释放】 空间由3个变成4个，扩容了一个：","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"C语言","slug":"C语言","permalink":"http://example.com/tags/C%E8%AF%AD%E8%A8%80/"}]},{"title":"结构体(struct)","slug":"编程语言/C语言/结构体(struct)","date":"2018-09-16T16:00:00.000Z","updated":"2021-03-23T07:33:39.000Z","comments":true,"path":"2018/09/17/编程语言/C语言/结构体(struct)/","link":"","permalink":"http://example.com/2018/09/17/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80/%E7%BB%93%E6%9E%84%E4%BD%93(struct)/","excerpt":"","text":"我们使用结构体仅仅是创建了一个新的数据类型而已，并没有声明变量，是在指定新的数据类型是由哪些成员组合而成 12345678struct Student&#123; char *name; int age; int score; float height;&#125;;struct Student stu; //代表声明了一个struct Student类型的变量，变量名字叫做stu，这个时候stu才是一个变量，才会在内存中申请空间 结构体初始化： 结构和数组有点像，数组用[]运算符和下标访问其成员，结构用.运算符和名字访问其成员 匿名结构体：这个结构体类型没有名称，只能在声明结构体的同时就创建变量，不能单独的声明这个结构体类型的变量 12345struct&#123; char *barnd; char *color; int price;&#125;fengshan1; 声明一个结构体变量，如果没有为这个结构体变量的成员赋值，那么成员是有值的，这个值是一个垃圾值；在声明结构体变量的同时，只要初始化一个成员，其他的成员就会被自动的初始化为0 如果结构体类型是定义在函数的内部的，那么这个结构体类型只能在这个函数的内部使用，如果我们希望这个结构体类型可以用在所有的函数中，那么就把这个结构体类型定义在函数的外面 结构体之间比较： 相同结构体类型的变量之间是可以相互赋值的【值传递】 12struct Student xiaoMing=&#123;&quot;小明&quot;,19,100&#125;;struct Student xiaoHua=xiaoMing; 结构体数组： 结构体指针：结构体变量是一个变量，struct Student xiaoMing=&#123;“小明”,18,100&#125;; xiaoMing首先是一个变量，类型是struct Student类型的，既然xiaoMing是一个变量，那么这个变量肯定是有地址的，既然有地址，那么就可以声明一个指针指向这个结构体变量 结构指针：和数组不同，结构变量的名字并不是结构变量的地址，必须使用&amp;运算符struct date *pDate=&amp;today; 结构体作为函数参数：int numberOfDays(struct date d)整个结构可以作为参数的值传入函数这时候是在函数内新建一个结构变量，并复制调用者的结构的值也可以返回一个结构这与数组完全不同 结构体作为函数的参数【值传递】： 改成指针后就是地址传递了 结构体完全可以作为函数的返回值，在返回的时候，直接将这个结构体变量的值返回即可 如果你要返回结构体变量的地址，那么就要把这个结构体变量创建在堆区：","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"C语言","slug":"C语言","permalink":"http://example.com/tags/C%E8%AF%AD%E8%A8%80/"}]},{"title":"枚举(enum)","slug":"编程语言/C语言/枚举(enum)","date":"2018-09-15T16:00:00.000Z","updated":"2021-03-23T07:31:40.000Z","comments":true,"path":"2018/09/16/编程语言/C语言/枚举(enum)/","link":"","permalink":"http://example.com/2018/09/16/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80/%E6%9E%9A%E4%B8%BE(enum)/","excerpt":"","text":"支持新创建一种数据类型，这个数据类型的变量的取值被限定，枚举值的名称都以枚举类型来开头 每一个枚举值/枚举项都有一个对应的整型的数，默认从0开始，依次的递增【实际上可以手动的赋值】，无论是什么类型的枚举变量，都是占据4个字节，枚举变量中真正存储的是枚举值所对应的整型的数 枚举类型名字通常并不真的使用，要用的是在大括号里的名字，因为它们就是常量符号，它们的类型是int，值依次从0到n 虽然枚举类型可以当作类型使用，但是实际上很少用","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"C语言","slug":"C语言","permalink":"http://example.com/tags/C%E8%AF%AD%E8%A8%80/"}]},{"title":"typedef","slug":"编程语言/C语言/typedef","date":"2018-09-14T16:00:00.000Z","updated":"2021-03-23T07:31:30.000Z","comments":true,"path":"2018/09/15/编程语言/C语言/typedef/","link":"","permalink":"http://example.com/2018/09/15/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80/typedef/","excerpt":"","text":"为一个已经存在的数据类型取一个别名【为结构体和枚举取一个别名】 size_t其实就是unsigned long C语言提供了一个叫做typedef的功能来声明一个已有的数据类型的新名字，比如 typedef int Length;","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"C语言","slug":"C语言","permalink":"http://example.com/tags/C%E8%AF%AD%E8%A8%80/"}]},{"title":"联合(union)","slug":"编程语言/C语言/联合(union)","date":"2018-09-13T16:00:00.000Z","updated":"2021-03-23T07:31:19.000Z","comments":true,"path":"2018/09/14/编程语言/C语言/联合(union)/","link":"","permalink":"http://example.com/2018/09/14/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80/%E8%81%94%E5%90%88(union)/","excerpt":"","text":"所有的成员共享一个空间同一时间只有一个成员是有效的union的大小是其最大的成员","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"C语言","slug":"C语言","permalink":"http://example.com/tags/C%E8%AF%AD%E8%A8%80/"}]},{"title":"进制","slug":"编程语言/C语言/进制","date":"2018-09-12T16:00:00.000Z","updated":"2021-03-23T07:33:26.000Z","comments":true,"path":"2018/09/13/编程语言/C语言/进制/","link":"","permalink":"http://example.com/2018/09/13/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80/%E8%BF%9B%E5%88%B6/","excerpt":"","text":"C语言可以识别的进制：1）二进制【C语言中如果要写二进制，就加一个0b的前缀】2）八进制【加一个0前缀】3）十进制4）十六进制【加一个0x前缀】 %d：将整型变量中的数据以十进制的形式输出来%o：将整型变量中的数据以八进制的形式输出来%x：将整型变量中的数据以十六进制的形式输出来 数码：指的是这个数据的每一位数字数位：数码在这个数中的位置，从右到左依次递增，从0开始基数：就是进制位权：数码*（基数的数位次方） 进制转换： 1）十进制转换为二进制(除2取余法)：将这个数除以2，直到商为0，然后将余数倒序 【十进制转换为八进制/十六进制类似】 2）二进制转换为十进制(加权法)：将这个二进制的每个数码的位权相加【八进制/十六进制转换为十进制类似】 3）二进制转换为八进制(三合一)：将这个二进制从低位到高位每三个分成一组，高位不够补0，将每一组转换为十进制，将每一组的十进制连起来（二进制转换为十六进制类似） 4）八进制转换为二进制(一拆三)（十六进制转换为二进制类似） 5）八进制—&gt;十六进制；八—&gt;二—&gt;十六 6）十六进制—&gt;八进制：十六—&gt;二—&gt;八 内存中的数据存储单元是由一个一个的二进制位组成的，每一个二进制位只能存储0或者1；把内存中的八个二进制位分为一组，叫做一个字节，作为存储数据的最小基本单元 如果要往内存中存储数据的话，就至少要使用一个字节，这时候一个字节最多可以表示256种数据 123456单位换算：1字节(byte)=8bit1KB=1024byte1MB=1024KB1GB=1024MB1TB=1024GB 我们在声明变量的时候，并不是去开辟一块空间，而是向系统在内存中申请一块指定字节数的连续的字节空间 char——1个字节int——4个字节float—4个字节double—8个字节 sizeof：计算常量、变量在当前系统上内存中占用的字节数【sizeof(数据类型)、sizeof(变量名)、sizeof(常量) 】 char类型的变量在内存中占据一个字节，char类型的常量在内存中占据四个字节 变量在内存中占据的字节数，会因为系统版本、编译器的不同而发生变化 原码、反码、补码都是二进制，只不过是二进制的不同表现形式，数据是以补码的二进制存储的 int类型的变量，在内存中占据4个字节，32位，为了可以表示正负性，使用最高位来表示正负，最高位为0，表示正，最高位为1，表示负，所以用来表示数据的只有31位，2^31，最小值为-2147483648，最大值为2147483647 原码：最高位表示符号位，剩下的位数是这个数的绝对值的二进制 反码：正数的反码就是其原码，负数的反码就是在其原码的基础之上，符号位不变，其他位取反 补码：正数的补码就是其原码，负数的补码就是在其反码的基础上+1 为什么数据要以补码的形式存储呢？因为计算机中只有加法没有减法，为了更加低成本的计算出结果，所以使用补码来存储数据 位运算指的是一个二进制数据的每一位来参与运算，前提是这个数必须是一个二进制 注意：1）参与位运算的二进制数据必须是补码形式2）位运算的结果也是二进制的补码形式 1）按位与(&amp;)：参与按位与的两个二进制数，如果都为1，那么结果就为1，只要有一位为0，那么结果就为0【3 &amp; 2 = 2】 任何数按位与1的结果是这个数的最低位，偶数的最低位一定是0，奇数的最低位一定是1，所以如果要判断这个数是奇数还是偶数，只要用这个数按位与1就可以了，如果结果为1，那么就是奇数，如果结果为0，那么就是偶数 2）按位或(|)：参与按位或的二进制数据，只要有一位是1，那么结果就为1，只有当两位都是0的时候结果才为0 3）按位取反(~)：单目运算符，将这个二进制数的每一位取反 4）按位异或(^)：参与按位异或的二进制的位，相同为0，不同为1 交换两个变量的值可以用异或运算 5）按位左移(&lt;&lt;)：参与按位左移运算的二进制数据，向左移动指定的位数，低位不够补0，高位溢出丢弃【左移运算有可能会改变其正负性；将一个数左移n位，相当于将这个数乘以2的n次方】 6）按位右移(&gt;&gt;)：参与按位右移运算的二进制数据，向右移动指定的位数，低位溢出丢弃，高位补符号位【右移运算不会改变其正负性；将一个数右移n位，相当于将这个数除以2的n次方】 变量的存储： 变量占用的字节空间一定是连续的，内存中存储数据的最小基本单位是字节，每个字节都有一个独一无二的内存地址，是一个十六进制的数 在为变量分配字节空间的时候，是从高地址向低地址分配的 存储在变量中的数据是以数据的二进制补码形式存储进去的【低位存储在低字节，高位存储在高字节】 变量的地址： 是组成这个变量的低字节的地址，使用&amp;取地址可以取出变量的地址 %p：取地址 声明变量就会占用内存空间，实际上程序在运行的时候，并不是说只有我们的代码才会声明变量，系统自己也会在内存中申请空间存储数据 short int：在内存中占据两个字节【最高位表示符号位，2^15，所以最小值：-32768，最大值：32767】【%hd来输出，%d可能会有问题】 long short：在32位系统下占4个字节，在64位占8个字节【%ld来输出】 long long int：在32位和64位下都占据8个字节【%lld来输出】 unsigned int，2^32，最高位不用来表示符号位了，所以最小值为0【%u来输出】 unsigned short int【%hu来输出】 字符数据在内存中存储的是这个字符所对应的ASCII码的二进制补码【实际上就是一个整数，可以用%d输出】 char变量是一个有符号的，最高位表示符号位 %c读取的时候，先从变量中读取出存储在变量中的整数，然后再去ASCII码表中去查找这个整数对应的字符，再显示这个字符","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"C语言","slug":"C语言","permalink":"http://example.com/tags/C%E8%AF%AD%E8%A8%80/"}]},{"title":"字符串","slug":"编程语言/C语言/字符串","date":"2018-09-11T16:00:00.000Z","updated":"2021-03-23T07:33:16.000Z","comments":true,"path":"2018/09/12/编程语言/C语言/字符串/","link":"","permalink":"http://example.com/2018/09/12/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80/%E5%AD%97%E7%AC%A6%E4%B8%B2/","excerpt":"","text":"字符串数据在C中的存储方式：内存中的五大区域： 栈：是专门用来存储局部变量的，所有的局部变量都是声明在栈区域中 堆：允许程序员手动的从堆申请指定字节数的空间来使用 BSS段：是用来存储未初始化的全局变量和静态变量，声明一个全局变量，如果我们没有初始化，在程序运行最开始的时候，这个全局变量是没有初始化的，存储在BSS段【程序运行后系统就自动的初始化为0，并把初始化后的全局变量存储在数据段中】 数据段/常量区：用来存储已经初始化的全局变量、静态变量和常量数据 代码段：用来存储程序的代码/指令 字符串数据在C语言中有两种存储方式： 使用字符数组来存储：将字符串数据的每一个字符存储到字符数组中，并追加一个’\\0’代表存储结束char name[]=“jack”; 使用字符指针来存储字符串数据：直接将一个字符串数据初始化给一个字符指针char* name =“jack”; 1）当它们都是局部变量的时候： 字符数组是申请在栈区，字符串的每一个字符存储在这个字符数组的每一个元素中；指针变量是声明在栈区的，字符串数据是以字符数组的形式存储在常量区的，指针变量中存储的是字符串在常量区的地址 2）当它们作为全局变量的时候： 字符数组是存储在常量区的，字符串的每一个字符存储在这个字符数组的每一个元素中；指针变量也是存储在常量区的，字符串数据是以字符数组的形式存储在常量区的，指针变量中存储的是字符串在常量区的地址 3）以字符数组的形式存储字符串数据，不管是全局的还是局部的，都可以使用下标去修改字符数组中的每一个元素；以字符指针的形式存储字符串数据，不管是全局的还是局部的，都不能通过指针去修改指向的字符串数据 当我们以字符指针的形式要将字符串数据存储到常量区的时候，并不是直接将字符串存储到常量区，而是先检查常量区中是否有相同内容的字符串，如果有直接将这个字符串的地址拿过来返回，如果没有，才会将这个字符串数据存储在常量区中 当我们重新为字符指针初始化一个字符串的时候，并不是修改原来的字符串，而是重新的创建了一个字符串，把这个新的字符串的地址赋值给它 几个比较容易混的点： 这样是可以的，但是不是把“jack”改成了“rose”，而是重新创建了一个“rose”，把“rose”的地址赋值给namechar *name = &quot;jack&quot;;name = &quot;rose&quot;; 这样是不行的，name是数组名，代表数组的地址，不能为数组名赋值char name[]=&quot;jack&quot;;name = &quot;rose&quot;; 这样做是可以的，直接修改数组的元素name[0]=&#39;r&#39;;name[1]=&#39;o&#39;;name[2]=&#39;s&#39;;name[3]=&#39;e&#39;;name[4]=&#39;\\0&#39;; 统计字符串中某一个字符出现的次数： 使用字符指针数组来存储多个字符串数据：这是一个一维数组，每一个元素的类型是char指针：char* names[4] = &#123;&quot;jack&quot;,&quot;rose&quot;,&quot;lily&quot;,&quot;lilei&quot;&#125;; 在声明字符数组的同时，如果初始化了部分元素，那么其他的字符会被初始化为’\\0’，‘\\0’是一个字符，是一个不可见的字符，打印出来啥都没有，这个字符的ASCII码是0 在C语言中字符串数据必须要用双引号引起来 C语言中存储字符串数据：将字符串数据的每一个字符存储到字符数组中，并在后面追加一个’\\0’代表字符串存储完毕 最根本的方式存储字符串：char name[5]=&#123;‘j’,’a’,’c’,’k’,’\\0’&#125;; char name[]=&#123;“jack”&#125;;系统会自动的将这个字符串中的每一个字符存储到字符数组中，并自动的追加一个’\\0’ 最常用的方式：char name[]=“jack”; 如果我们使用字符数组存储字符串数据的时候，没有指定这个字符数组的长度，那么这个时候这个字符数组的长度为字符串长度+1 我们在使用字符数组存储字符串数据的时候，最好不要指定长度了 如果在声明一个字符数组的同时我们就初始化一个字符数据给这个数组，那么这个时候是可以用中文的【这个字符数组的长度为7，因为一个中文占3个字节】 使用格式控制符%s就可以输出存储在字符数组中的字符串数据【%s从给定的数组的地址开始，一个字节一个字节的输出，直到遇到’\\0’为止】 无需&amp; 使用scanf函数：1）如果用户输入的字符串数据在给定的字符数组中存储不下的时候，就会运行报错2）用户在输入字符串的时候，如果输入了空格，就会认为输入结束 不能使用sizeof去计算字符数组的长度来得到字符串的长度，因为有可能字符串数据存储在字符数组中只占了一部分空间解决方法： 字符串常量：“Hello”会被编译器变成一个字符数组放在某处，这个数组的长度是6，结尾还有表示结束的0两个相邻的字符串常量会被自动连接起来 C语言的字符串是以字符数组的形态存在的，不能用运算符对字符串做运算，通过数组的方式可以遍历字符串，唯一特殊的地方是字符串字面量可以用来初始化字符数组 char *s=“Hello,world!”;s是一个指针，初始化为指向一个字符串常量，由于这个常量所在的地方，所以实际上s是const char *s，但是由于历史的原因，编译器接受不带const的写法，但是试图对s所指的字符串做写入会导致严重的后果如果需要修改字符串，应该用数组：char s[]=“Hello,world!”;数组：这个字符串在这里，作为本地变量空间自动被回收指针：这个字符串不知道在哪里，处理参数，动态分配空间 如果要构造一个字符串，用数组如果要处理一个字符串，用指针 在%和s之间的数字表示最多允许读入的字符的数量，这个数字应该比数组的大小小一 stdio.h文件：puts()函数：用来输出字符串的【优点是输出完毕之后自动换行，缺点是只能输出字符串，也不能使用占位符】 fputs()函数：将字符串数据输出到指定的流中【标准输出流：控制台；文件流：磁盘上的文件】输出到标准输出流中：将字符串存储到文件中：1）要先声明一个文件指针，指向磁盘上的文件【fopen函数可以创建一个指向文件的指针】2）使用fputs()函数将字符串写入到指定的文件流中3）写完之后一定要记得使用fclose()函数将这个文件关闭 gets()函数：从控制台接收用户输入一个字符串数据【优点是当用户输入的数据包含空格的时候，会连空格一起接收；缺点是和scanf函数一样不安全，当用来存储字符串的数据的字符数组的长度不够的时候，程序就会崩溃】 fgets()函数：从指定的流中读取字符串，这个流可以是标准输入流：控制台，也可以是文件流1）从标准输入流中读取数据解决方案：2）从文件流中读取数据 string.h头文件：strlen,strcmp,strcpy,strcat,strchr,strstrstrlen:size_t strlen(const char *s);返回s的字符串长度（不包括结尾的0） strcmp:int strcmp(const char *s1,const char *s2);比较两个字符串，返回：0: s1==s21: s1&gt;s2-1: s1&lt;s2int strncmp(const char *s1,const char *s2,size_t n);只比较前几个字符 strcpy:【存储字符串1的字符数组长度不够，无法存储字符串2，这个时候运行就会崩溃】char *strcpy(char *restrict dst,const char *restrict src);把src的字符串拷贝到dst，restrict表明src和dst不重叠返回dst,为了能链起代码来 复制一个字符串：char *dst=(char *)malloc(strlen(src)+1);strcpy(dst,src);把name2拷贝到name1: strcat:【接的时候会把第一个字符串后的’\\0’干掉】char *strcat(char *restrict s1,const char *restrict s2);把s2拷贝到s1的后面，接成一个长的字符串返回s1s1必须具有足够的空间 strcpy,strcat不安全！！ 安全版本：char *strncpy(char *restrict dst,const char *restrict src,size_t n);char *strncat(char *restrict s1,const char *restrict s2,size_t n); 字符串中找字符：char *strchr(const char *s,int c);char *strrchr(const char *s,int c);返回NULL表示没有找到 字符串中找字符串：char *strstr(const char *s1,const char *s2);char *strcasestr(const char *s1,const char *s2);","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"C语言","slug":"C语言","permalink":"http://example.com/tags/C%E8%AF%AD%E8%A8%80/"}]},{"title":"预处理指令","slug":"编程语言/C语言/预处理指令","date":"2018-09-10T16:00:00.000Z","updated":"2021-03-23T07:33:05.000Z","comments":true,"path":"2018/09/11/编程语言/C语言/预处理指令/","link":"","permalink":"http://example.com/2018/09/11/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80/%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4/","excerpt":"","text":"C语言的代码主要分为两类：1）C代码2）预处理代码：以#开头的代码 预处理指令的分类：1）文件包含指令：#include2）宏定义：#define【可以将一段C代码定义为一个标识，使用这个标识就可以使用这段代码】3）条件编译指令：#if【只编译指定的C代码为二进制指令】 预处理指令的特点：1）都是以#开头2）预处理指令的后面没有分号 文件包含指令：文件包含指令作用：可以将指定的文件的内容拷贝到写指令的地方#include”文件路径”#include&lt;文件路径&gt; 绝对路径：路径从根目录开始相对路径：相对于当前这个文件夹的路径，和当前文件路径相同的部分删除【一般把导入文件放到和main.c相同的文件夹下】 #include”文件路径”和#include&lt;文件路径&gt;的寻找指定文件的方式不一样：1）前者先去当前源文件所在的目录中查找这个文件，如果有直接包含，如果没有再去系统自带的编译器目录中查找，如果有直接包含，如果没有报错2）后者直接去编译器目录中查找，如果有包含，没有报错 宏定义：它是一个预处理指令，所以它在编译之前执行，可以将一段C代码定义为一个标识，使用这个标识就可以使用这段代码 宏的原理：在预编译的时候，就会执行源文件中的预处理指令，会将C代码中使用宏名的地方替换为宏值【任意的C代码】，将C代码中的宏名替换为宏值的过程叫做宏替换/宏代换 在定义宏的时候不会去检查语法，只有当完成了宏替换的时候，才会去检查替换以后是否符合语法规范 如果宏值是一个表达式，那么宏值并不是这个表达式的结果，而是这个表达式本身 如果宏值中包括一个变量名，那么在使用这个宏之前必须要保证这个变量已经存在 【默认情况下，宏从定义的地方一直到文件结束都可以使用，#undef 宏名可以让指定的宏提前失效】#define N 10 只能在中间使用这个宏，#undef N下面宏失效 #undef N 字符串中如果出现了宏名，系统不会认为这是一个宏，而是认为是字符串的一部分 如果宏后面跟了分号，那么就会把分号作为宏值的一部分 我们在定义宏的时候，宏名是可以带参数的，在这个宏值中可以直接使用这个参数，如果使用的宏有参数，那么就必须要在使用它的时候为这个宏的参数传值 宏不是函数，所以宏的参数不需要加类型说明符 为带参数的宏传值的时候，是本色传递，如果传递一个变量，并不是传递这个变量的值 条件编译指令：默认的情况下，所有的C代码都会被编译为二进制代码，条件编译指令可以让编译器只编译指定部分的代码 在预编译的时候，如果条件成立，就会将其中的C代码编译成二进制指令，如果条件不成立，就不会将其中的C代码编译成二进制指令【条件只能是宏，不能是变量】 If语句无论如何全部都要被编译为二进制指令，条件编译指令只会将符合条件的C代码编译为二进制指令 如果定义了指定的宏，就编译其中的代码 无论一个文件被#include多少次，只希望它最终只会被包含一次 static和extern：C语言中的关键字，用来修饰变量和函数 如果局部变量被static修饰，这个变量就叫做静态变量，静态变量不再存储在栈区域，而是存储在常量区，当函数执行完之后，这个静态变量不会被回收，后面再去执行这个函数的时候，声明静态变量的这句话就不会再执行了，直接略过，直接使用这个静态变量的值【静态变量只有一份】 extern不能修饰局部变量 当我们分模块开发的时候，如果要在模块中声明全局变量，全局变量的声明要写在.h文件中，全局变量的实现要写在.c文件中【如果将全局变量定义在模块中，这个全局变量就必须要使用static或者extern修饰】 如果定义在模块中的全局变量使用extern修饰，这个模块中的全局变量就可以跨模块访问；使用static修饰，这个模块中的全局变量就只能在当前模块中访问 如果函数被extern修饰，那么这个函数可以跨模块调用；如果函数被static修饰，那么这个函数只能在当前模块中调用，无法跨模块调用 如果函数没有写static或者extern，那么这个函数默认就是extern","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"C语言","slug":"C语言","permalink":"http://example.com/tags/C%E8%AF%AD%E8%A8%80/"}]}],"categories":[{"name":"Apple、Linux","slug":"Apple、Linux","permalink":"http://example.com/categories/Apple%E3%80%81Linux/"},{"name":"代码仓库","slug":"代码仓库","permalink":"http://example.com/categories/%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93/"},{"name":"iOS开发-项目","slug":"iOS开发-项目","permalink":"http://example.com/categories/iOS%E5%BC%80%E5%8F%91-%E9%A1%B9%E7%9B%AE/"},{"name":"硬件基础","slug":"硬件基础","permalink":"http://example.com/categories/%E7%A1%AC%E4%BB%B6%E5%9F%BA%E7%A1%80/"},{"name":"数据库系统原理","slug":"数据库系统原理","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"},{"name":"操作系统原理","slug":"操作系统原理","permalink":"http://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"},{"name":"计算机网络原理","slug":"计算机网络原理","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"},{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"},{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"macOS","slug":"macOS","permalink":"http://example.com/tags/macOS/"},{"name":"iOS-功能demo","slug":"iOS-功能demo","permalink":"http://example.com/tags/iOS-%E5%8A%9F%E8%83%BDdemo/"},{"name":"UI","slug":"UI","permalink":"http://example.com/tags/UI/"},{"name":"多线程实战","slug":"多线程实战","permalink":"http://example.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%9E%E6%88%98/"},{"name":"《汇编语言(第4版)》","slug":"《汇编语言-第4版-》","permalink":"http://example.com/tags/%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E7%AC%AC4%E7%89%88-%E3%80%8B/"},{"name":"《MySQL必知必会》","slug":"《MySQL必知必会》","permalink":"http://example.com/tags/%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B/"},{"name":"操作系统原理","slug":"操作系统原理","permalink":"http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"},{"name":"计算机网络原理","slug":"计算机网络原理","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"},{"name":"数据结构、算法笔记","slug":"数据结构、算法笔记","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"Swift","slug":"Swift","permalink":"http://example.com/tags/Swift/"},{"name":"Objective-C","slug":"Objective-C","permalink":"http://example.com/tags/Objective-C/"},{"name":"C++语言","slug":"C-语言","permalink":"http://example.com/tags/C-%E8%AF%AD%E8%A8%80/"},{"name":"C实例","slug":"C实例","permalink":"http://example.com/tags/C%E5%AE%9E%E4%BE%8B/"},{"name":"Ubuntu Server","slug":"Ubuntu-Server","permalink":"http://example.com/tags/Ubuntu-Server/"},{"name":"C语言","slug":"C语言","permalink":"http://example.com/tags/C%E8%AF%AD%E8%A8%80/"}]}