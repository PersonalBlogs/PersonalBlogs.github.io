<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>基础知识</title>
    <url>/2020/10/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80(%E7%AC%AC4%E7%89%88)%E3%80%8B/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<p>——————————————————<br>1.1.机器语言<br>1.2.汇编语言的产生<br>1.3.汇编语言的组成<br>1.4.存储器<br>1.5.指令和数据<br>1.6.存储单元<br>1.7.CPU对存储器的读写<br>1.8.地址总线<br>1.9.数据总线<br>1.10.控制总线<br>1.11.内存地址空间(概述)<br>1.12.主板<br>1.13.接口卡<br>1.14.各类存储器芯片<br>1.15.内存地址空间<br>——————————————————</p>
<p>汇编语言是直接在硬件之上工作的编程语言，首先要了解硬件系统的结构，才能有效的应用汇编语言对其编程</p>
<p>机器语言是机器指令的集合，机器指令展开来讲就是一台机器可以正确执行的命令，电子计算机的机器指令是一列二进制数字，计算机将之转变为一列高低电平，以使计算机的电子器件受到驱动，进行运算</p>
<p>CPU是一种微处理器，每一种微处理器，由于硬件设计和内部结构的不同，就需要不同的电平脉冲来控制，使他工作，所以每一种微处理器都有自己的机器指令集，也就是机器语言<br>————————</p>
<p>汇编语言的主体是汇编指令</p>
<p>汇编指令和机器指令的差别在于指令的表示方法上，汇编指令是机器指令便于记忆的书写格式，汇编指令是机器指令的助记符</p>
<p>寄存器，简单的讲是CPU中可以存储数据的器件，一个CPU中有多个寄存器，AX是其中一个寄存器的代号，BX是另一个寄存器的代号<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gor8lthws7j30bl02xaai.jpg"><br>————————</p>
<p>汇编语言由以下三类组成：<br>1）汇编指令（机器码的助记符，有对应的机器码）<br>2）伪指令（没有对应的机器码，由编译器执行，计算机并不执行）<br>3）其他符号如+-*/（由编译器识别，没有对应的机器码）</p>
<p>汇编语言的核心是汇编指令，它决定了汇编语言的特性<br>————————</p>
<p>CPU是计算机的核心部件，它控制着整个计算机的运作并进行运算，要想让一个CPU工作，就必须向它提供指令和数据，指令和数据在存储器中存放，也就是平时所说的内存</p>
<p>在一台PC机中内存的作用仅次于CPU，离开了内存，性能再好的CPU也无法工作，磁盘不同于内存，磁盘上的数据或程序如果不读到内存中，就无法被CPU使用<br>————————</p>
<p>指令和数据是应用上的概念，在内存或磁盘上，指令和数据没有任何区别，都是二进制信息<br>————————</p>
<p>存储器被划分为若干个存储单元，每个存储单元从0开始顺序编号【电子计算机的最小信息单位是bit（比特），也就是一个二进制位，8个bit组成一个Byte（字节），微型机存储器的存储单位可以存储一个Byte】<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gor8mb0lbkj30ga09s79g.jpg"><br>—————————</p>
<p>CPU要想进行数据的读写，必须和外部器件（芯片）进行三类信息的交互：<br>1）地址信息：存储单元的地址<br>2）控制信息：器件的选择，读或写命令<br>3）数据信息：读或写的数据</p>
<p>每一个CPU芯片都有许多管脚，这些管脚和总线相连，也可以说，这些管脚引出总线，一个CPU可以引出三种总线的宽度标志着这个CPU的不同方面的性能：<br>地址总线的宽度决定了CPU的寻址能力<br>数据总线的宽度决定了CPU与其他器件进行数据传送时的一次数据传送量<br>控制总线的宽度决定了CPU对系统中其他器件的控制能力</p>
<p>电子计算机能处理、传输的信息都是电信号，电信号当然要用导线传送，在计算机中专门有连接CPU和其他芯片的导线，通常称为总线<br>物理上：一根根导线的集合<br>逻辑上划分为：<br>1）地址总线：CPU是通过地址总线来指定存储单元的，地址总线上能传送多少个不同的信息，CPU就可以对多少个存储单元进行寻址</p>
<p>一个CPU有N根地址总线，则可以说这个CPU的地址总线的宽度为N，这样的CPU最多可以寻找2的N次方个内存单元</p>
<p>2）数据总线：CPU与内存或其他器件之间的数据传送是通过数据总线来进行的，数据总线的宽度决定了CPU和外界的数据传送速度</p>
<p>8088CPU的数据总线宽度为8，8086CPU的数据总线宽度为16</p>
<p>3）控制总线：CPU对外部器件的控制是通过控制总线来进行的，在这里控制总线是个总称，控制总线是一些不同控制线的集合，有多少根控制总线，就意味着CPU提供了对外部器件的多少种控制，所以，控制总线的宽度决定了CPU对外部器件的控制能力</p>
<p>要让一个计算机或微处理器工作，应向它输入能够驱动它进行工作的电平信号（机器码）<br>——————————</p>
<p>一个CPU的地址线宽度为10，那么可以寻址1024个内存单元，这1024个可寻到的内存单元就构成了这个CPU的内存地址空间<br>——————————</p>
<p>在每一台PC机中，都有一个主板，主板上有核心器件和一些主要器件，这些器件通过总线（地址总线、数据总线、控制总线）相连，这些器件有CPU、存储器、外围芯片组、扩展插槽等，扩展插槽上一般插有RAM内存条和各类接口卡<br>——————————</p>
<p>计算机系统中，所有可用程序控制其互作的设备，必须受到CPU的控制，CPU对外部设备不能直接控制，如显示器、音箱、打印机等，直接控制这些设备进行工作的是插在扩展插槽上的接口卡，扩展插槽通过总线和CPU相连，所以接口卡也通过总线同CPU相连<br>——————————</p>
<p>各类存储器芯片：<br>1）从读写属性上看分为两类：随机存储器（RAM）和只读存储器（ROM），随机存储器可读可写，但必须带电存储，关机后存储的内容丢失；只读存储器只能读取不能写入，关机后其中的内容不丢失<br>2）从功能和连接上分类：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gor8mt9rgpj30bl05mjta.jpg"></p>
<p>这些存储器在物理上是独立的器件：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gor8n32ur5j30fm0cqwgj.jpg"></p>
<p>但是它们在以下两点上相同：<br>1）都和CPU的总线相连<br>2）CPU对它们进行读或写的时候都通过控制线发出内存读写命令<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gor8nmj07vj30fm0cigpr.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gor8nvqh13j30fm06on1b.jpg"></p>
<p>不同的计算机系统的内存地址空间分配情况是不同的<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gor8o3v5oqj30cx0coq4l.jpg"></p>
<p>内存地址空间的大小受CPU地址总线宽度的限制</p>
<p>对CPU来讲，系统中的所有存储器中的存储单元都处于一个统一的逻辑存储器中，它的容量受CPU寻址能力的限制，这个逻辑存储器即是我们所说的内存地址空间<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gor8oeidamj30c402gaax.jpg"></p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>《汇编语言(第4版)》</tag>
      </tags>
  </entry>
  <entry>
    <title>BX和loop指令</title>
    <url>/2020/10/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80(%E7%AC%AC4%E7%89%88)%E3%80%8B/%5BBX%5D%E5%92%8Cloop%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<p>——————————————————————————<br>5.1.[BX]<br>5.2.Loop指令<br>5.3.在Debug中跟踪用loop指令实现的循环程序<br>5.4.Debug和汇编编译器masm对指令的不同处理<br>5.5.loop和[bx]的联合应用<br>5.6.段前缀<br>5.7.一段安全的空间<br>5.8.段前缀的使用<br>——————————————————————————</p>
<p>要完整的描述一个内存单元，需要两种信息：内存单元的地址、内存单元的长度（类型）</p>
<p>用[0]表示一个内存单元时，0表示单元的偏移地址，段地址默认在ds中，单元的长度（类型）可以由具体指令中的其他操作对象（比如说寄存器）指出</p>
<p>[bx]同样也表示一个内存单元，它的偏移地址在bx中</p>
<p>loop：循环</p>
<p>用一个描述性的符号“（）”来表示一个寄存器或一个内存单元中的内容，（）中的内存单元的地址为物理地址</p>
<p>（）中的元素可以有3种类型：寄存器名、段寄存器名、内存单元的物理地址（一个20位数据）<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gor9pszkg6j309a015aa8.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gor9q2v7itj30c9090mz9.jpg"></p>
<p>约定符号idata表示常量<br>——————————————————</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gor9qhyixyj30cl0az3zx.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gor9qqfny7j30ch0hiq5j.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gor9qydnulj30ch087ta6.jpg"></p>
<p>———————————————</p>
<p>loop指令的格式是：loop 标号<br>CPU执行loop指令的时候，要进行两步操作：(cx)=(cx)-1、判断cx中的值，不为零则转至标号处执行程序，如果为零则向下执行【通常，我们用loop指令来实现循环功能，cx中存放循环次数】</p>
<p>assume cs:code<br>code segment<br>    mov ax,2<br>    mov cx,11<br>s:<br>    add ax,ax<br>    loop s</p>
<pre><code>mov ax,4c00h
int 21h</code></pre>
<p>code ends<br>end<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gor9rb1gsqj30ch07zmyk.jpg"></p>
<p>1）在cx中存放循环次数<br>2）loop指令中的标号所标识地址要在前面<br>3）要循环执行的程序段，要写在标号和loop指令的中间<br>——————————————</p>
<p>在Debug中跟踪用loop指令实现的循环程序：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gor9rkgjpaj30cm0aa75q.jpg"></p>
<p>1）标号s前的指令我们已经确定在逻辑上完全正确，不想再一步一步跟踪了（g IP，直接跳转到IP值处）<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gor9rucjibj30ht09ldgb.jpg"></p>
<p>2）循环也不想再一步一步跟踪了（遇到loop，直接p）<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gor9s38jfwj30ht0bqmy5.jpg"></p>
<p>———————————————————</p>
<p>Debug和汇编编译器masm对指令的不同处理：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gor9sdhx36j30b109tq4i.jpg"></p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>《汇编语言(第4版)》</tag>
      </tags>
  </entry>
  <entry>
    <title>实验1、查看CPU和内存，用机器指令和汇编指令编程</title>
    <url>/2020/10/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80(%E7%AC%AC4%E7%89%88)%E3%80%8B/%E5%AE%9E%E9%AA%8C1%E3%80%81%E6%9F%A5%E7%9C%8BCPU%E5%92%8C%E5%86%85%E5%AD%98%EF%BC%8C%E7%94%A8%E6%9C%BA%E5%99%A8%E6%8C%87%E4%BB%A4%E5%92%8C%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<p>Debug是DOS、Windows都提供的实模式（8086方式）程序的调试工具，使用它可以查看CPU各种寄存器的内容、内存的情况和在机器码级跟踪程序的运行</p>
<p>Debug功能：<br>1）R：查看、改变CPU寄存器的内容<br>2）D：查看内存中的内容<br>3）E：改写内存中的内容<br>4）U：将内存中的机器指令翻译成汇编指令<br>5）T：执行一条机器指令<br>6）A：以汇编指令的格式在内存中写入一条机器指令<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gor9276jodj30hs0bstb3.jpg"></p>
<p>1）使用R命令查看、修改CPU中各个寄存器的内容：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gor92hm5baj30hu05et8y.jpg"></p>
<p>2）用Debug的D命令查看内存中的内容<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gor92q99vmj30hu04i0sv.jpg"></p>
<p>a.中间是从指定地址开始的128个内存单元的内容，用十六进制的格式输出，每行的输出从16的整数倍的地址开始，最多输出16个单元的内容<br>b.左边是每行的起始地址<br>c.右边是每个内存单元中的数据对应的可显示的ASCII码字符<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gor930ucdxj30hu04ymxb.jpg"></p>
<p>直接使用D命令，将列出Debug预设的地址处的内容<br>在使用“d 段地址：偏移地址”之后，接着使用D命令，可列出后续的内容<br>也可以指定D命令的查看范围：“d 段地址：起始偏移地址 结尾偏移地址”<br>只想查看内存单元10000H中的内容：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gor93ch6c2j30hu0163yg.jpg"></p>
<p>3）用Debug的E命令改写内存中的内容<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gor93qxd7bj30hu02swej.jpg"></p>
<p>也可以采用提问的方式一个一个的改写内存中的内容：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gor9420rjyj30hu03c74c.jpg"></p>
<p>可以用E命令向内存中写入字符、字符串<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gor94c34y2j30hu02qgln.jpg"></p>
<p>4）用E命令向内存中写入机器码，用U命令查看内存中机器码的含义，用T命令执行内存中的机器码</p>
<p>向内存中写入机器码：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gor94lge2hj303z02hglo.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gor94yujp2j30hu00x748.jpg"></p>
<p>查看写入的或内存中原有的机器码所对应的汇编指令：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gor95a2d9vj30bv07fweq.jpg"></p>
<p>U命令的显示输出分为3部分：每一条机器指令的地址、机器指令、机器指令所对应的汇编指令</p>
<p>T命令可以执行一条或多条指令，简单的使用T命令，可以执行CS：IP指向的指令<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gor95j1161j30ht04ft8w.jpg"></p>
<p>若要用T命令控制CPU执行我们写到1000:0的指令，必须先让CS：IP指向1000:0<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gor95rhjc9j30ht04mwel.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gor9610yqlj30ht0773yu.jpg"></p>
<p>5）用Debug的A命令以汇编指令的形式在内存中写入机器指令<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gor96bstguj30ht051dfy.jpg"></p>
<p>简单的使用A命令，可以从一个预设的地址开始输入指令</p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>《汇编语言(第4版)》</tag>
      </tags>
  </entry>
  <entry>
    <title>寄存器(CPU工作原理)</title>
    <url>/2020/10/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80(%E7%AC%AC4%E7%89%88)%E3%80%8B/%E5%AF%84%E5%AD%98%E5%99%A8(CPU%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86)/</url>
    <content><![CDATA[<p>—————————————————<br>2.1.通用寄存器<br>2.2.字在寄存器中的存储<br>2.3.几条汇编指令<br>2.4.物理地址<br>2.5.16位结构的CPU<br>2.6.8086CPU给出物理地址的方法<br>2.7.“段地址*16+偏移地址=物理地址”的本质含义<br>2.8.段的概念<br>2.9.段寄存器<br>2.10.CS和IP<br>2.11.修改CS、IP的指令<br>2.12.代码段<br>—————————————————</p>
<p>一个典型的CPU由运算器、控制器、寄存器(CPU工作原理)等器件组成，这些器件靠内部总线相连</p>
<p>内部总线实现CPU内部各个器件之间的联系，外部总线实现CPU和主板上其他器件的联系</p>
<p>在CPU中：<br>1）运算器进行信息处理<br>2）寄存器进行信息存储<br>3）控制器控制各种器件进行工作<br>4）内部总线连接各种器件，在他们之间进行数据的传送</p>
<p>对于一个汇编程序员来说，CPU中的主要部件是寄存器，寄存器是CPU中程序员可以用指令读写的部件，程序员通过改变各种寄存器中的内容来实现对CPU的控制</p>
<p>8086CPU有14个寄存器，它们的名称为：<br>AX，BX，CX，DX，<br>SI，DI，SP，BP，<br>CS，IP，<br>SS，DS，ES，PSW</p>
<p>8086CPU所有的寄存器都是16位的，可以存放两个字节，AX、BX、CX、DX通常用来存放一般性数据被称为通用寄存器<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gor8shcygwj30e903sdg9.jpg"></p>
<p>一个16位寄存器可以存储一个16位的数据，所能存储的数据的最大值为2^16-1</p>
<p>8086上一代CPU中的寄存器都是8位的，为保证兼容性，这四个通用寄存器都可以分为两个独立的8位寄存器使用<br>AX可以分为AH和AL<br>BX可以分为BH和BL<br>CX可以分为CH和CL<br>DX可以分为DH和DL<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gor8ss5p1mj30g605fwfz.jpg"><br>—————————</p>
<p>出于对兼容性的考虑，8086CPU可以一次性处理以下两种尺寸的数据：<br>1）字节：记为byte，一个字节由8个bit组成，可以存在8位寄存器中<br>2）字：记为word，一个字由两个字节组成，这两个字节分别称为这个字的高位字节和低位字节<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gor8t4abvtj306802hgls.jpg"></p>
<p>为了区分不同的进制，在十六进制表示的数据的后面加H，在二进制表示的数据的后面加B<br>—————————</p>
<p>在写一条汇编指令或一个寄存器的名称时不区分大小写：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gor8tjwbmyj30ch03pt9m.jpg"><br>—————————</p>
<p>CPU访问内存单元时，要给出内存单元的地址，所有的内存单元构成的存储空间是一个一维的线性空间，每一个内存单元在这个空间中都有唯一的地址，我们将这个唯一的地址称为物理地址</p>
<p>CPU通过地址总线送入存储器的，必须是一个内存单元的物理地址。在CPU向地址总线上发出物理地址之前，必须要在内部先形成这个物理地址，不同的CPU可以有不同的形成物理地址的方式<br>—————————</p>
<p>概括来讲，16位结构描述了一个CPU具有下面几方面的结构特性：<br>1）运算器一次最多可以处理16位的数据<br>2）寄存器的最大宽度为16位<br>3）寄存器和运算器之间的通路为16位<br>—————————</p>
<p>8086CPU给出物理地址的方法：</p>
<p>8086CPU有20位地址总线，又是16位结构，采用一种在内部用两个16位地址合成的方法来形成一个20位的物理地址<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gor8u1db7lj30aa06ydgo.jpg"></p>
<p>当8086CPU要读写内存时：<br>1）CPU中的相关部件提供两个16位的地址，一个称为段地址，另一个称为偏移地址<br>2）段地址和偏移地址通过内部总线送入一个称为地址加法器的部件<br>3）地址加法器将两个16位地址合成为一个20位的物理地址<br>4）地址加法器通过内部总线将20位物理地址送入输入输出控制电路<br>5）输入输出控制电路将20位物理地址送上地址总线<br>6）20位物理地址被地址总线传送到存储器<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gor8ubj36tj30cj06y403.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gor8ukaiukj30bz08h42f.jpg"></p>
<p>——————————</p>
<p>“段地址<em>16+偏移地址=物理地址”的本质含义是：CPU在访问内存时，用一个基础地址（段地址</em>16）和一个相对于基础地址的偏移地址相加，给出内存单元的物理地址<br>——————————</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gor8uth09bj30au066aar.jpg"><br>在编程时可以根据需要，将若干地址连续的内存单元看作一个段，用段地址<em>16定位段的起始地址（基础地址），用偏移地址定位段中的内存单元<br>1）段地址</em>16必然是16的倍数，所以一个段的起始地址也一定是16的倍数<br>2）偏移地址为16位，16位地址的寻址能力为64KB，所以一个段的长度最大为64KB<br>——————————</p>
<p>段地址在8086CPU的段寄存器中存放，8086CPU有4个段寄存器：CS，DS，SS，ES<br>——————————</p>
<p>CS和IP是8086CPU中两个最关键的寄存器，它们指示了CPU当前要读取指令的地址，CS为代码段寄存器，IP为指令指针寄存器</p>
<p>在8086PC机中，任意时刻，设CS中的内容为M，IP中的内容为N，8086CPU将从内存M*16+N单元开始，读取一条指令并执行<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gor8w0hau0j30c409hju7.jpg"></p>
<p>8086CPU读取、执行一条指令的过程：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gor8w92jsrj30c405kq4e.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gor8wgrgaxj30c405kmym.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gor8woipllj30c405kgmz.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gor8wvqrskj30c405k75o.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gor8x2wtnpj30c405fabk.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gor8x9k43hj30c405f0u6.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gor8xguwhdj30c406f0uf.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gor8xntv5ij30c405edh6.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gor8xvhssgj30c405vq4c.jpg"></p>
<p>1）从CS：IP指向的内存单元读取指令，读取的指令进入指令缓冲器<br>2）IP=IP+所读取指令的长度，从而指向下一条指令<br>3）执行指令，转到步骤1），重复这个过程<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gor8y47ydgj30c401jwey.jpg"></p>
<p>CPU将CS：IP指向的内存单元中的内容看作指令<br>—————————</p>
<p>程序员可以通过改变CS、IP中的内容来控制CPU执行目标指令</p>
<p>8086CPU大部分寄存器的值，都可以用mov指令来改变，mov指令被称为传送指令，但是mov指令不能用于设置CS、IP的值；能够改变CS、IP的内容的指令被统称为转移指令（jmp指令）<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gor8yjgr77j30c402z0tg.jpg"></p>
<p>若想仅修改IP的内容，可用形如“jmp 某一合法寄存器”的指令完成：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gor8yskyiej30c40383z6.jpg"></p>
<p>——————————<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gor8z1g7l7j30cm087gnz.jpg"></p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>《汇编语言(第4版)》</tag>
      </tags>
  </entry>
  <entry>
    <title>寄存器(内存访问)</title>
    <url>/2020/10/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80(%E7%AC%AC4%E7%89%88)%E3%80%8B/%E5%AF%84%E5%AD%98%E5%99%A8(%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE)/</url>
    <content><![CDATA[<p>寄存器(内存访问)：</p>
<p>——————————————————<br>3.1.内存中字的存储<br>3.2.DS和[address]<br>3.3.字的传送<br>3.4.mov、add、sub指令<br>3.5.数据段<br>3.6.栈<br>3.7.CPU提供的栈机制<br>3.8.栈顶超界的问题<br>3.9.push、pop指令<br>3.10.栈段<br>——————————————————</p>
<p>CPU中，用16位寄存器来存储一个字，高8位存放高位字节，低八位存放低位字节。<br>在内存中存储时，由于内存单元是字节单位（一个单元存放一个字节），则一个字要用两个地址连续的内存单元来存放，这个字的低位字节存放在低地址单元中，高位字节存放在高地址单元中</p>
<p>将起始地址为N的字单元简称为N地址字单元</p>
<p>任何两个地址连续的内存单元，N号单元和N+1号单元，可以将它们看成两个内存单元，也可看成一个地址为N的字单元中的高位字节单元和低位字节单元<br>——————————</p>
<p>CPU要读写一个内存单元的时候，必须先给出这个内存单元的地址，在8086PC中，内存地址由段地址和偏移地址组成，8086CPU中有一个DS寄存器，通常用来存放要访问数据的段地址</p>
<p>可以使用mov指令将一个内存单元中的内容送入一个寄存器中：mov 寄存器名，内存单元地址</p>
<p>“[…]”表示一个内存单元，“[…]”中的0表示内存单元的偏移地址，指令执行时，8086CPU自动取ds中的数据为内存单元的段地址<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gor98a6bwhj302m01kq2x.jpg"></p>
<p>8086CPU不支持将数据直接送入段寄存器的操作，ds是一个段寄存器，所以mov ds,1000H这条指令是非法的<br>——————————</p>
<p>8086CPU是16位结构，有16根数据线，所以可以一次性传送16位的数据，也就是说可以一次性传送一个字，只要在mov指令中给出16位的寄存器就可以进行16位数据的传送了<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gor98kuzmmj307t01kwem.jpg"></p>
<p>——————————</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gor98wn3cvj307t03aq3m.jpg"><br>mov 寄存器，段寄存器<br>mov 内存单元，段寄存器<br>mov 段寄存器，内存单元<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gor998bpukj30b604laaw.jpg"></p>
<p>mov、add、sub是具有两个操作对象的指令，jmp是具有一个操作对象的指令<br>——————————</p>
<p>我们可以将一组长度为N（N&lt;=64KB）、地址连续、起始地址为16的倍数的内存单元当作专门存储数据的内存空间，从而定义了一个数据段<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gor99h7y8sj30a30690tn.jpg"></p>
<p>——————————</p>
<p>栈是一种具有特殊的访问方式的存储空间，最后进入这个空间的数据，最先出去，栈的这种操作规则被称为：LIFO（Last In First Out，后进先出）<br>——————————</p>
<p>8086CPU提供相关的指令来以栈的方式访问内存空间，这意味着，在基于8086CPU编程的时候，可以将一段内存当作栈来使用：PUSH（入栈）和POP（出栈），8086CPU的入栈和出栈操作都是以字为单位进行的<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gor99yjbm6j30cc0gmjuw.jpg"></p>
<p>CS、IP中存放着当前指令的段地址和偏移地址<br>8086CPU中，有两个寄存器，段寄存器SS和寄存器SP，栈顶的段地址存放在SS中，偏移地址存放在SP中，任意时刻，SS：SP指向栈顶元素，push指令和pop指令执行时，CPU从SS和SP中得到栈顶的地址<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gor9abl3l9j30cc09ljtr.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gor9al29e1j30cc03cdgg.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gor9atrxmhj30cc082gno.jpg"></p>
<p>——————————————</p>
<p>当栈满的时候再使用push指令入栈，或栈空的时候再使用pop指令出栈，都将发生栈顶越界问题<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gor9b37og1j30cc041dh2.jpg"></p>
<p>——————————————</p>
<p>push和pop指令是可以在寄存器和内存之间传送数据的</p>
<p>栈空间也是内存空间的一部分，它只是一段可以以一种特殊的方式进行访问的内存空间<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gor9bchdn9j307l01w0sx.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gor9brc7egj30co06iwg1.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gor9bzm36nj30c4029aad.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gor9c7itqnj30cd0el76p.jpg"></p>
<p>注意：push、pop等栈操作指令，修改的只是SP，也就是说，栈顶的变化范围最大为0～FFFFH</p>
<p>提供SS、SP指示栈顶，改变SP后写内存的入栈指令，读内存后改变SP的出栈指令，这就是8086CPU提供的栈操作机制<br>—————————————————</p>
<p>在编程时，可以根据需要，将一组内存单元定义为一个段，我们可以将长度为N（N&lt;=64KB）的一组地址连续、起始地址为16的倍数的内存单元，当作栈空间来用，从而定义了一个栈段<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gor9ckqxadj30by06u0vx.jpg"></p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>《汇编语言(第4版)》</tag>
      </tags>
  </entry>
  <entry>
    <title>第一个程序</title>
    <url>/2020/10/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80(%E7%AC%AC4%E7%89%88)%E3%80%8B/%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8F/</url>
    <content><![CDATA[<p>———————————————————<br>4.1.一个源程序从写出到执行的过程<br>4.2.源程序<br>4.3.编辑源程序<br>4.4.编译<br>4.5.连接<br>4.6：1.exe的执行<br>4.7.谁将可执行文件中的程序装载进入内存并使它运行？<br>4.8.程序执行过程的跟踪<br>———————————————————</p>
<p>1）编写汇编源程序：使用文本编辑器，用汇编语言编写汇编源程序，这一步工作的结果是产生了一个存储源程序的文本文件<br>2）对源程序进行编译连接：使用汇编语言编译程序对源程序文件中的源程序进行编译，产生目标文件；再用连接程序对目标文件进行连接，生成可在操作系统中直接运行的可执行文件</p>
<p>可执行文件包含两部分内容：程序（从源程序中的汇编指令翻译过来的机器码）和数据（源程序中定义的数据）、相关的描述信息（比如程序有多大、要占用多少内存空间）</p>
<p>这一步工作的结果，产生了一个可在操作系统中运行的可执行文件</p>
<p>3）执行可执行文件中的程序，在操作系统中，执行可执行文件中的程序，操作系统依照可执行文件中的描述信息，将可执行文件中的机器码和数据加载入内存，并进行相关的初始化（比如设置CS：IP指向第一条要执行的指令），然后由CPU执行程序<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gor9iigj9yj30670aqq3q.jpg"><br>———————————————</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gor9irqdw3j30670640sz.jpg"><br>1）伪指令：在汇编语言源程序中，包含两种指令，一种是汇编指令，一种是伪指令。汇编指令是有对应的机器码的指令，可以被编译为机器指令，最终为CPU所执行。而伪指令没有对应的机器指令，最终不被CPU所执行，伪指令是由编译器来执行的指令，编译器根据伪指令来进行相关的编译工作</p>
<p>segment和ends是一对成对使用的伪指令，功能是定义一个段<br>end是一个汇编程序的结束标记，标记整个程序的结束<br>assume假设某一段寄存器和程序中的某一个用segment…ends定义的段相关联<br>2）源程序中的“程序”<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gor9j41kahj30bh06vgmu.jpg"></p>
<p>3）标号：一个标号指代了一个地址，比如codesg在segment的前面，作为一个段的名称，这个段的名称最终将被编译、连接程序处理为一个段的段地址<br>4）程序的结构<br>5）程序返回：一个程序结束后，将CPU的控制权交还给使它得以运行的程序，称这个过程为程序返回<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gor9jdcrjsj30cv03674y.jpg"></p>
<p>6）语法错误和逻辑错误<br>程序在编译时被编译器发现的错误是语法错误<br>在源程序编译后，在运行时发生的错误是逻辑错误，语法错误容易发现，也容易解决，而逻辑错误通常不容易被发现<br>——————————————</p>
<p>编辑源程序：</p>
<p>可以用任意的文本编辑器来编辑源程序，只要最终将其存储为纯文本文件即可<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gor9jpk741j30hr0brdgo.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gor9jyhfazj30hr0brt9d.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gor9k6ml35j30hu0brmy2.jpg"></p>
<p>———————————————</p>
<p>编译：<br>在编译过程中，我们提供了一个输入，即源程序文件，最多可以得到3个输出：目标文件（.obj）、列表文件（.lst）、交叉引用文件（.crf），这3个输出文件中，目标文件是我们最终要得到的结果，而另外两个只是中间结果<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gor9khvb94j30hr06s3yq.jpg"></p>
<p>———————————————</p>
<p>连接：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gor9kr11m2j30hr05l0sw.jpg"><br>连接的作用：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gor9kz6alvj30ce04hwg7.jpg"></p>
<p>最终生成3个文件：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gor9l7tndej305p02kaa2.jpg"><br>————————————————</p>
<p>1.exe的执行：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gor9lgim9oj30hu011zk7.jpg"><br>————————————————</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gor9lo749pj30by081adv.jpg"><br>在DOS中直接执行1.exe时，是正在运行的command，将1.exe中的程序加载入内存，command设置CPU的CS：IP指向程序的第一条指令（即程序的入口），从而使程序得以运行，程序运行结束后，返回到command中，CPU继续运行command<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gor9lz4scxj30bz022q3u.jpg"></p>
<p>————————————————</p>
<p>程序执行过程的跟踪（Debug）：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gor9masapnj30c302j750.jpg"></p>
<p>为了观察程序的运行过程，可以使用Debug，Debug可以将程序加载入内存，设置CS：IP指向程序的入口，但Debug并不放弃对CPU的控制</p>
<p>CX中存放的是程序的长度，1.exe中程序的机器码共有15个字节<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gor9mmcsm7j30hu02tt8s.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gor9mv2tlaj30cg0gvdkj.jpg"></p>
<p>DS的值为075A，则PSP的地址为075A：0，程序的地址为076A：0（即075A+10:0）</p>
<p>源程序中的指令是mov ax,0123H，在Debug中记为mov ax,0123，这是因为Debug默认所有数据都用十六进制表示</p>
<p>可以用U命令看一下其他指令：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gor9n62hfrj30bz07laac.jpg"></p>
<p>T命令单步执行程序中的每一条指令：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gor9neti40j30ht0bpgmm.jpg"></p>
<p>到了int 21，我们要用P命令执行：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gor9np1chlj30ht044mx9.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gor9nwyahtj30cw044q3w.jpg"></p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>《汇编语言(第4版)》</tag>
      </tags>
  </entry>
  <entry>
    <title>实验2、用机器指令和汇编指令编程</title>
    <url>/2020/10/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80(%E7%AC%AC4%E7%89%88)%E3%80%8B/%E5%AE%9E%E9%AA%8C2%E3%80%81%E7%94%A8%E6%9C%BA%E5%99%A8%E6%8C%87%E4%BB%A4%E5%92%8C%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gor9e689j1j30cu02sgmf.jpg"></p>
<p>1）D命令也提供了一种符合CPU机理的格式：“d 段寄存器：偏移地址”，以段寄存器中的数据为段地址SA，列出从SA：偏移地址开始的内存区间中的数据</p>
<p>查看从ds:0开始的内存区间中的内容：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gor9eill0wj30hu05vglw.jpg"></p>
<p>查看当前代码段和栈段中的内容：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gor9euy7ksj30hu08hwey.jpg"></p>
<p>2）在E、A、U命令中使用段寄存器<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gor9f5ib8yj30cc042t9h.jpg"></p>
<p>3）在Debug中，用A命令写一段程序</p>
<p>在用T命令执行mov ss,ax的时候，它的下一条指令mov sp,10也紧接着执行了<br>不单是mov ss,ax，对于如mov ss,bx    mov ss,[0]    pop ss等指令都会发生这种情况，这些指令的共性是都是修改栈段寄存器SS的指令</p>
<p>Debug的T命令在执行修改寄存器SS的指令时，下一条指令也紧接着被执行<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gor9gigxwbj30ht0apmxl.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gor9grbausj30ht07674n.jpg"></p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>《汇编语言(第4版)》</tag>
      </tags>
  </entry>
  <entry>
    <title>死锁</title>
    <url>/2020/10/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%AD%BB%E9%94%81/</url>
    <content><![CDATA[<h2 id="死锁的概念"><a href="#死锁的概念" class="headerlink" title="死锁的概念"></a>死锁的概念</h2><h3 id="什么是死锁"><a href="#什么是死锁" class="headerlink" title="什么是死锁"></a>什么是死锁</h3><p>在并发环境下，各进程因竞争资源而造成的一种互相等待对方手里的资源，导致各进程都阻塞，都无法向前推进的现象，就是“死锁”。发生死锁后若无外力干涉，这些进程都将无法向前推进</p>
<h3 id="进程死锁、饥饿、死循环的区别"><a href="#进程死锁、饥饿、死循环的区别" class="headerlink" title="进程死锁、饥饿、死循环的区别"></a>进程死锁、饥饿、死循环的区别</h3><p>死锁：各进程互相等待对方手里的资源，导致各进程都阻塞，无法向前推进的现象</p>
<p>饥饿：由于长期得不到想要的资源，某进程无法向前推进的现象</p>
<p>死循环：某进程执行过程中一直跳不出某个循环的现象。有时是因为程序逻辑bug导致的，有时是程序员故意设计的</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gr8ab7hbu2j30um09wqhn.jpg"></p>
<h3 id="死锁产生的必要条件"><a href="#死锁产生的必要条件" class="headerlink" title="死锁产生的必要条件"></a>死锁产生的必要条件</h3><p>产生死锁必须同时满足以下四个条件，只要有其中任一条件不成立，死锁就不会发生</p>
<ol>
<li>互斥条件：只有对必须互斥使用的资源的争抢才会导致死锁（如哲学家的筷子、打印机设备等），像内存、扬声器这种可以同时让多个进程使用的资源是不会导致死锁的</li>
<li>不剥夺条件：进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放</li>
<li>请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放</li>
<li>循环等待条件：存在一种进程资源的循环等待链，链中的每一个进程已获得的资源同时被下一个进程所请求</li>
</ol>
<p>注意：发生死锁时一定有循环等待，但是发生循环等待时未必死锁（循环等待是死锁的必要不充分条件）</p>
<h3 id="什么时候会发生死锁"><a href="#什么时候会发生死锁" class="headerlink" title="什么时候会发生死锁"></a>什么时候会发生死锁</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gr8awftx2wj30v009eq98.jpg"></p>
<h3 id="死锁的处理策略"><a href="#死锁的处理策略" class="headerlink" title="死锁的处理策略"></a>死锁的处理策略</h3><ol>
<li>预防死锁（静态策略，不允许死锁发生）：破坏死锁产生的四个必要条件中的一个或几个</li>
<li>避免死锁（动态策略，不允许死锁发生）：用某种方法防止系统进入不安全状态，从而避免死锁（银行家算法）</li>
<li>死锁的检测和解除：允许死锁的发生，不过操作系统会负责检测出死锁的发生，然后采取某种措施解除死锁</li>
</ol>
<h2 id="死锁的处理策略：预防死锁"><a href="#死锁的处理策略：预防死锁" class="headerlink" title="死锁的处理策略：预防死锁"></a>死锁的处理策略：预防死锁</h2><h3 id="破坏互斥条件"><a href="#破坏互斥条件" class="headerlink" title="破坏互斥条件"></a>破坏互斥条件</h3><p>互斥条件：只有对必须互斥使用的资源的争抢才会导致死锁</p>
<p>如果把只能互斥使用的资源改造为允许共享使用，则系统不会进入死锁状态。比如SPOOLing技术，操作系统可以采用SPOOLing技术把独占设备在逻辑上改造成共享设备</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gr8bfc9kmjj30w409a7dt.jpg"></p>
<p>该策略的缺点：并不是所有的资源都可以改造成可共享使用的资源。并且为了系统安全，很多地方还必须保护这种互斥性，因此，很多时候都无法破坏互斥条件</p>
<h3 id="破坏不剥夺条件"><a href="#破坏不剥夺条件" class="headerlink" title="破坏不剥夺条件"></a>破坏不剥夺条件</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gr8bmnf2jzj30u80dyguv.jpg"></p>
<h3 id="破坏请求和保持条件"><a href="#破坏请求和保持条件" class="headerlink" title="破坏请求和保持条件"></a>破坏请求和保持条件</h3><p>C类进程可能会饥饿：</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gr8bqg4rw0j30u80f848h.jpg"></p>
<h3 id="破坏循环等待条件"><a href="#破坏循环等待条件" class="headerlink" title="破坏循环等待条件"></a>破坏循环等待条件</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gr8by5l8fgj30u80f8wri.jpg"></p>
<h2 id="死锁的处理策略：避免死锁（银行家算法）"><a href="#死锁的处理策略：避免死锁（银行家算法）" class="headerlink" title="死锁的处理策略：避免死锁（银行家算法）"></a>死锁的处理策略：避免死锁（银行家算法）</h2><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gr8parwlp6j317o0u044r.jpg"></p>
<h3 id="什么是安全序列"><a href="#什么是安全序列" class="headerlink" title="什么是安全序列"></a>什么是安全序列</h3><p>所谓安全序列，就是指如果系统按照这种序列分配资源，则每个进程都能顺利完成。只要能找出一个安全序列，系统就是安全状态。当然，安全序列可能有多个</p>
<h3 id="什么是系统的不安全状态，与死锁有何联系"><a href="#什么是系统的不安全状态，与死锁有何联系" class="headerlink" title="什么是系统的不安全状态，与死锁有何联系"></a>什么是系统的不安全状态，与死锁有何联系</h3><p>如果分配了资源之后，系统中找不出任何一个安全序列，系统就进入了不安全状态。这就意味着之后可能所有进程都无法顺利的执行下去。当然，如果有进程提前归还了一些资源，那系统也有可能重新回到安全状态，不过我们在分配资源之前总是要考虑到最坏的情况</p>
<p>❗️如果系统处于安全状态，就一定不会发生死锁。如果系统进入不安全状态，就可能发生死锁（处于不安全状态未必就是发生了死锁，但发生死锁时一定是在不安全状态）</p>
<p>因此可以在资源分配之前预先判断这次分配是否会导致系统进入不安全状态，以此决定是否答应资源分配请求。这也是“银行家算法”的核心思想</p>
<h3 id="如何避免系统进入不安全状态：银行家算法"><a href="#如何避免系统进入不安全状态：银行家算法" class="headerlink" title="如何避免系统进入不安全状态：银行家算法"></a>如何避免系统进入不安全状态：银行家算法</h3><p>银行家算法是荷兰学者Dijkstra为银行系统设计的，以确保银行在发放现金贷款时，不会发生不能满足所有客户需要的情况。后来该算法被用在操作系统中，用于避免死锁</p>
<p>核心思想：在进程提出资源申请时，先预判此次分配是否会导致系统进入不安全状态。如果会进入不安全状态，就暂时不答应这次请求，让该进程先阻塞等待</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gr8pj7rqk2j30u20d6h3u.jpg"></p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gr8q8jsq4uj31fa0pctcg.jpg"></p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gr8q9heabjj30w60hse6k.jpg"></p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gr8qd9199tj30tw0e8qbd.jpg"></p>
<h2 id="死锁的处理策略：死锁的检测和解除"><a href="#死锁的处理策略：死锁的检测和解除" class="headerlink" title="死锁的处理策略：死锁的检测和解除"></a>死锁的处理策略：死锁的检测和解除</h2><h3 id="死锁的检测"><a href="#死锁的检测" class="headerlink" title="死锁的检测"></a>死锁的检测</h3><p>用于检测系统状态，以确定系统中是否发生了死锁</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gr8qxiw5ruj30vq0ge4a3.jpg"></p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gr8r22pqtlj30ve0bo47j.jpg"></p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gr8r91zqqgj30tk0fudpe.jpg"></p>
<p>最终还连着边的那些进程就是处于死锁状态的进程：</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gr8r5kf6blj30dy09276k.jpg"></p>
<p>![image-20210606190618200](/Users/liaojialong/Library/Application Support/typora-user-images/image-20210606190618200.png)</p>
<h3 id="死锁的解除"><a href="#死锁的解除" class="headerlink" title="死锁的解除"></a>死锁的解除</h3><p>当认定系统中已经发生了死锁，利用该算法可将系统从死锁状态中解脱出来</p>
<p>一旦检测出死锁的发生，就应该立即解除死锁</p>
<p>❗️并不是系统中所有的进程都是死锁状态，用死锁检测算法化简资源分配图后，还连着边的那些进程就是死锁进程</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gr8rhj7dj2j60tk06kwkr02.jpg"></p>
<p>如何决定先剥夺哪个进程的资源或先对谁动手？</p>
<ol>
<li>根据进程优先级（先动手优先级低的）</li>
<li>根据进程已执行多长时间</li>
<li>根据进程还要多久能完成</li>
<li>根据进程已经使用了多少资源（先动手使用资源多的，这样很容易把更多死锁进程解除出来）</li>
<li>根据进程是交互式的还是批处理式的（优先动手批处理式的，交互式的是跟用户打交道）</li>
</ol>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>操作系统原理</tag>
      </tags>
  </entry>
  <entry>
    <title>进程通信</title>
    <url>/2020/10/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/</url>
    <content><![CDATA[<h2 id="什么是进程通信"><a href="#什么是进程通信" class="headerlink" title="什么是进程通信"></a>什么是进程通信</h2><p>顾名思义，进程通信就是指进程之间的信息交换</p>
<p>进程是分配系统资源的单位（包括内存地址空间），因此各进程拥有的内存地址空间相互独立，为了保证安全，一个进程不能直接访问另一个进程的地址空间，但是进程之间的信息交换又是必须实现的。为了保证进程间的安全通信，操作系统提供了一些方法</p>
<h2 id="共享存储"><a href="#共享存储" class="headerlink" title="共享存储"></a>共享存储</h2><h3 id="基于数据结构的共享、基于存储区的共享"><a href="#基于数据结构的共享、基于存储区的共享" class="headerlink" title="基于数据结构的共享、基于存储区的共享"></a>基于数据结构的共享、基于存储区的共享</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gr3y1yuhssj30wa0eek1i.jpg"></p>
<h2 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h2><p>进程间的数据交换以结构化的消息为单位，进程通过操作系统提供的“发送消息/接收消息”两个原语进行数据交换</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gr3yl5ld92j30g005owht.jpg"></p>
<h3 id="直接通信方式"><a href="#直接通信方式" class="headerlink" title="直接通信方式"></a>直接通信方式</h3><p>发送进程要发送的消息直接挂到接收进程的消息缓冲队列上（通过发送消息/接收消息原语）</p>
<h3 id="间接通信方式"><a href="#间接通信方式" class="headerlink" title="间接通信方式"></a>间接通信方式</h3><p>消息要先发送到中间实体（信箱）中，因此也称“信箱通信方式”（计网中的电子邮件系统）</p>
<h2 id="管道通信"><a href="#管道通信" class="headerlink" title="管道通信"></a>管道通信</h2><p>“管道”是指用于连接读写进程的一个共享文件，又名pipe文件。其实就是在内存中开辟一个大小固定的缓冲区</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gr3y9wdumfj30sa060goi.jpg"></p>
<ul>
<li>管道只能采用半双工通信，某一时间段内只能实现单向的传输。如果要实现双向同时通信，则需要设置两个管道</li>
<li>各进程要互斥的访问管道</li>
<li>数据以字符流的形式写入管道，当管道写满时，写进程的write()系统调用将被阻塞，等待读进程将数据取走。当读进程将数据全部取走后，管道变空，此时读进程的read()系统调用将被阻塞</li>
<li>如果没写满，就不允许读。如果没读空，就不允许写</li>
<li>数据一旦被读出，就从管道中被抛弃，这就意味着读进程最多只能有一个，否则可能会有读错数据的情况</li>
</ul>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>操作系统原理</tag>
      </tags>
  </entry>
  <entry>
    <title>SHOW语句HELP SHOW</title>
    <url>/2020/10/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B/SHOW%E8%AF%AD%E5%8F%A5HELP%20SHOW/</url>
    <content><![CDATA[<p>SHOW语句【HELP SHOW;】：</p>
<p>可使用的数据库名：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gort3y5xv0j308l04oglt.jpg"></p>
<p>USE选择数据库（必须先使用USE打开数据库，才能读取其中的数据）</p>
<p>SHOW TABLES；返回当前选择的数据库内可用表的列表<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gort49cdbcj30dn0hiq44.jpg"></p>
<p>SHOW COLUMNS FROM…….【DESCRIBE…..】（从某个表中查找）<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gort4k3h1oj30ge0dawga.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gort4ti7vdj30eu0b93zh.jpg"></p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>《MySQL必知必会》</tag>
      </tags>
  </entry>
  <entry>
    <title>使用存储过程</title>
    <url>/2020/10/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B/%E4%BD%BF%E7%94%A8%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<p>使用存储过程</p>
<p>存储过程简单来说，就是为以后的使用而保存的一条或多条MySQL语句的集合。可将其视为批文件，虽然它们的作用不仅限于批处理<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorwwtjskzj30c20eiteh.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorwx1tyugj30c20670vn.jpg"></p>
<p>1）执行存储过程：<br>MySQL称存储过程的执行为调用，因此MySQL执行存储过程的语句为CALL，CALL接受存储过程的名字以及需要传递给它的任意参数<br>CALL productpricing(@pricelow,<br>                                    @pricehigh,<br>                                    @priceaverage);</p>
<p>2）创建存储过程<br>CREATE PROCEDURE productpricing()<br>BEGIN<br>     SELECT Avg(prod_price) AS priceaverage<br>     FROM products;<br>END;<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorwxb4n6qj30bb0ar10l.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorwxpz7mqj30bb02t40i.jpg"><br>3)使用存储过程：<br>CALL productpricing();<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorwxyajenj302c01k3yk.jpg"></p>
<p>4）删除存储过程：<br>DROP PROCEDURE productpricing;<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorwy82yv0j30ba023400.jpg"></p>
<p>变量：内存中一个特定的位置，用来临时存储数据<br>变量名：所有MySQL变量都必须以@开始</p>
<p>5)每个参数必须具有指定的类型，这里使用十进制值，关键字OUT指出相应的参数用来从存储过程传出一个值（返回给调用者）；MySQL支持IN（传递给存储过程）、OUT（从存储过程传出）和INOUT（对存储过程传入和传出）类型的参数<br>CREATE PROCEDURE productpricing(<br>     OUT pl DECIMAL(8,2),<br>     OUT ph DECIMAL(8,2),<br>     OUT pa DECIMAL(8,2)<br>)<br>BEGIN<br>     SELECT Min(prod_price)<br>     INTO pl<br>     FROM products;<br>     SELECT Max(prod_price)<br>     INTO ph<br>     FROM products;<br>     SELECT Avg(prod_price)<br>     INTO pa<br>     FROM products;<br>END;</p>
<p>CALL productpricing(@pricelow,<br>                                    @pricehigh,<br>                                    @priceaverage);<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorwyj99pgj30b403540r.jpg"><br>为了获得3个值，可使用：<br>SELECT @pricehigh,@pricelow, @priceaverage;<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorwyqi83qj306b01hdg2.jpg"></p>
<p>6)<br>CREATE PROCEDURE ordertotal(<br>     IN onumber INT,<br>     OUT ototal DECIMAL(8,2)<br>)<br>BEGIN<br>   SELECT Sum(item_price*quantity)<br>   FROM orderitems;<br>   WHERE order_num=onumber<br>   INTO ototal;<br>END;</p>
<p>CALL ordertotal(20005,@total);</p>
<p>SELECT @total;</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorwz1ickmj301d01ht8p.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorwz8cyl4j30bl0ezjut.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorwzf6ygvj30bl01w74f.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorwzlzcnyj30bl0foteu.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorwzurosaj30bl0ajwji.jpg"></p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>《MySQL必知必会》</tag>
      </tags>
  </entry>
  <entry>
    <title>使用子查询</title>
    <url>/2020/10/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B/%E4%BD%BF%E7%94%A8%E5%AD%90%E6%9F%A5%E8%AF%A2/</url>
    <content><![CDATA[<p>使用子查询</p>
<p>查询：任何SQL语句都是查询，但此术语一般指SELECT语句</p>
<p>1）列出订购物品TNT2的所有客户：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorukyg8fej309301xt9b.jpg"></p>
<p>法1:<br>SELECT order_num<br>FROM orderitems<br>WHERE prod_id=’TNT2’;<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorul67nzpj301w01ujrf.jpg"></p>
<p>SELECT cust_id<br>FROM orders<br>WHERE order_num IN(20005,20007);<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goruleb7r9j301l01u3yj.jpg"></p>
<p>SELECT custname,custcontact<br>FROM customers<br>WHERE cust_id IN(10001,10004);<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorulm5ilnj304v01v0sy.jpg"></p>
<p>法2:(在SELECT语句中，子查询总是从内向外处理)<br>SELECT custname,custcontact<br>FROM customers<br>WHERE custid IN(SELECT custid<br>                                FROM orders<br>                                WHERE ordernum IN(SELECT ordernum<br>                                                                      FROM orderitems<br>                                                                      WHERE prod_id=’TNT2’));<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorulw15rfj304v01v0sy.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorum75192j30b801v75m.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorumdxayuj30b906rjvl.jpg"></p>
<p>法3:<br>SELECT custname,custcontact<br>FROM customers,orders,orderitems<br>WHERE customers.custid=orders.custid<br>   AND orderitems..ordernum=orders.ordernum<br>   AND prod_id=’TNT2’;<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goruml1my3j304v01v0sy.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorumuiofmj30b80340uy.jpg"></p>
<p>2)显示customers表中每个客户的订单总数<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorun2nb6vj30b9015dg7.jpg"><br>SELECT custname,custstate,<br>               (SELECT COUNT(*)<br>                FROM orders<br>                WHERE orders.custid=customers.custid) AS orders<br>FROM customers<br>ORDER BY cust_name;<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorunb3wduj305y02wgm0.jpg"></p>
<p>相关子查询：涉及外部查询的子查询<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorunjmhcjj30bs0ba422.jpg"></p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>《MySQL必知必会》</tag>
      </tags>
  </entry>
  <entry>
    <title>使用数据处理函数</title>
    <url>/2020/10/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B/%E4%BD%BF%E7%94%A8%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>使用数据处理函数</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goru6ay4lpj30b506j794.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goru6idywcj30b501nt94.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goru6p4zahj30b5042q49.jpg"></p>
<p>1）文本处理函数Upper()<br>SELECT vendname,Upper(vendname) AS vendnameupcase<br>FROM vendors<br>ORDER BY vend_name;<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goru6x1hgbj305h039aal.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goru753j8fj308403u3za.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goru7cb4a0j308402kmxn.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goru7jgpk6j30bh02qgmv.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goru7uz31wj30bh0bddjf.jpg"></p>
<p>2)日期和时间处理函数<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goru82yiqgj30bh09lacf.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goru8ah6a8j30b302iabx.jpg"></p>
<p>SELECT custid,ordernum<br>FROM orders<br>WHERE order_date=‘2005-09-01’;<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goru8jfzvtj303d01ijrh.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goru8ur7cfj30br06xjuf.jpg"><br>SELECT custid,ordernum<br>FROM orders<br>WHERE Date(order_date)=‘2005-09-01’;<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goru93pk7ij30b603vwh9.jpg"></p>
<p>检索出2005年9月下的所有订单<br>法1:<br>SELECT custid,ordernum<br>FROM orders<br>WHERE Date(order_date) BETWEEN ‘2005-09-01’ AND ‘2005-09-30’;<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goru9bxlpnj303e027mxc.jpg"></p>
<p>法2:<br>SELECT custid,ordernum<br>FROM orders<br>WHERE Year(orderdate)=2005 AND Month(orderdate)=9;<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goru9jol11j30b5022myj.jpg"></p>
<p>3)数值处理函数<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goru9qw82uj308005ndgt.jpg"></p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>《MySQL必知必会》</tag>
      </tags>
  </entry>
  <entry>
    <title>使用游标</title>
    <url>/2020/10/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B/%E4%BD%BF%E7%94%A8%E6%B8%B8%E6%A0%87/</url>
    <content><![CDATA[<p>使用游标</p>
<p>有时，需要在检索出来的行中前进或后退一行或多行。这就是使用游标的原因。游标是一个存储在MySQL服务器上的数据库查询，它不是一条SELECT语句，而是被该语句检索出来的结果集。在存储了游标之后，应用程序可以根据需要滚动或浏览其中的数据；游标主要用于交互式应用，其中用户需要滚动屏幕上的数据，并对数据进行浏览或做出更改</p>
<p>不像多数DBMS，MySQL游标只能用于存储过程（和函数）<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorx3hzpwkj30bw04wabw.jpg"></p>
<p>1）创建游标【存储过程处理完成后，游标就消失（因为它局限于存储过程）】<br>游标用DECLARE语句创建，DECLARE命名游标，并定义相应的SELECT语句，根据需要带WHERE和其他子句<br>CREATE PROCEDURE processorders()<br>BEGIN<br>     DECLARE ordernumbers CURSOR<br>     FOR<br>     SELECT order_num FROM orders;<br>END;</p>
<p>2）打开和关闭游标<br>OPEN ordernumbers;</p>
<p>CLOSE ordernumbers;</p>
<p>在一个游标关闭后，如果没有重新打开，则不能使用它。但是，使用声明过的游标不需要再次声明，用OPEN语句打开它就可以了，如果你不明确关闭游标，MySQL将会在到达END语句时自动关闭它</p>
<p>这个存储过程声明、打开和关闭一个游标，但对检索出来的数据什么也没做<br>CREATE PROCEDURE processorders()<br>BEGIN<br>     DECLARE ordernumbers CURSOR<br>     FOR<br>     SELECT order_num FROM orders;</p>
<pre><code> OPEN ordernumbers;

 CLOSE ordernumbers;</code></pre>
<p>END;</p>
<p>3）使用游标数据：在一个游标被打开后，可以使用FETCH语句分别访问它的每一行。FETCH指定检索什么数据（所需的列），检索出来的数据存储在什么地方。它还向前移动游标中的内部行指针，使下一条FETCH语句检索下一行（不重复读取同一行）</p>
<p>从游标中检索单个行（第一行）：<br>CREATE PROCEDURE processorders()<br>BEGIN</p>
<pre><code> DECLARE o INT;

 DECLARE ordernumbers CURSOR
 FOR
 SELECT order_num FROM orders;

 OPEN ordernumbers;

 FETCH ordernumbers INTO o;

 CLOSE ordernumbers;</code></pre>
<p>END;</p>
<p>循环检索数据，从第一行到最后一行：【如果一切正常，你可以在循环内放入任意需要的处理（在FETCH语句之后，循环结束之前）】<br>CREATE PROCEDURE processorders()<br>BEGIN</p>
<pre><code> DECLARE done BOOLEAN DEFAULT 0;
 DECLARE o INT;

 DECLARE ordernumbers CURSOR
 FOR
 SELECT order_num FROM orders;

 DECLARE CONTINUE HANDLER FOR SQLSTATE ’02000’ SET done=1;

 OPEN ordernumbers;

 REPEAT

 FETCH ordernumbers INTO o;

 UNTIL done END REPEAT;

 CLOSE ordernumbers;</code></pre>
<p>END;<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorx3yvddsj30bw067tbi.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorx45veh1j30bg02idhn.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorx4ckm50j30bg02p764.jpg"></p>
<p>CREATE PROCEDURE processorders()<br>BEGIN</p>
<pre><code> DECLARE done BOOLEAN DEFAULT 0;
 DECLARE o INT;
 DECLARE t DECIMAL(8,2);

 DECLARE ordernumbers CURSOR
 FOR
 SELECT order_num FROM orders;

 DECLARE CONTINUE HANDLER FOR SQLSTATE ’02000’ SET done=1;

 CREATE TABLE IF NOT EXISTS ordertotals
         (order_num INT,total DECIMAL(8,2));

 OPEN ordernumbers;

 REPEAT

      FETCH ordernumbers INTO o;

      CALL ordertotal(o,l,t);

      INSERT INTO ordertotals(order_num,total)
      VALUES(o,t);

 UNTIL done END REPEAT;

 CLOSE ordernumbers;</code></pre>
<p>END;</p>
<p>SELECT *<br>FROM ordertotals;<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorx4pbq42j303g0310t1.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorx4wiosoj30bx03n0ug.jpg"></p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>《MySQL必知必会》</tag>
      </tags>
  </entry>
  <entry>
    <title>使用视图</title>
    <url>/2020/10/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B/%E4%BD%BF%E7%94%A8%E8%A7%86%E5%9B%BE/</url>
    <content><![CDATA[<p>使用视图</p>
<p>视图是虚拟的表，与包含数据的表不一样，视图只包含使用时动态检索数据的查询</p>
<p>SELECT custname,custcontact<br>FROM customers,orders,orderitems<br>WHERE customers.custid=orders.custid<br>     AND orderitems.ordernum=orders.ordernum<br>     AND prod_id=’TNT2’;</p>
<p>现在，假如可以把整个查询包装成一个名为productcustomers的虚拟表，则可以如下轻松地检索出相同的数据：<br>SELECT custname,custcontact<br>FROM productcustomers<br>WHERE prod_id=’TNT2’;<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorwsap1tbj30bt01pt9d.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorwslo79tj30bt0dy44n.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorwssjvutj30bt08gwha.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorwszim7yj30bt05iwgf.jpg"></p>
<p>1）<br>CREATE VIEW productcustomers AS<br>SELECT custname,custcontact,prod_id<br>FROM customers,orders,orderitems<br>WHERE customers.custid=orders.custid<br>   AND orderitems.ordernum=orders.ordernum;</p>
<p>为检索订购了产品TNT2的客户：<br>SELECT custname,custcontact<br>FROM productcustomers<br>WHERE prod_id=’TNT2’;<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorwt8av55j304u01tdg1.jpg"></p>
<p>可以看出，视图极大的简化了复杂SQL语句的使用，利用视图，可一次性编写基础的SQL，然后根据需要多次使用<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorwtgi1k8j30b7033wgk.jpg"></p>
<p>2）<br>SELECT Concat(RTrim(vendname)，‘ （’，RTrim(vendcountry)，‘）’）AS vend_title<br>FROM vendors<br>ORDER BY vend_name;<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorwtp24azj303z03at93.jpg"></p>
<p>CREATE VIEW vendorlocations AS<br>SELECT Concat(RTrim(vendname)，‘ （’，RTrim(vendcountry)，‘）’）AS vend_title<br>FROM vendors<br>ORDER BY vend_name;</p>
<p>SELECT *<br>FROM vendorlocations;<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorwtxskgrj303z03aq3b.jpg"></p>
<p>3)<br>CREATE VIEW customeremaillist AS<br>SELECT custid,custname,cust_email<br>FROM customers<br>WHERE cust_email IS NOT NULL;</p>
<p>SELECT *<br>FROM customeremaillist;<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorwu5zx20j307e0280t8.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorwufd723j30b401xgmw.jpg"></p>
<p>4)<br>SELECT prod_id,<br>              quantity,<br>              item_price,<br>              quantity*itemprice AS expandedprice<br>FROM orderitems<br>WHERE order_num=20005;<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorwumtgq4j307r02i3yz.jpg"></p>
<p>CREATE VIEW orderitemsexpanded AS<br>SELECT prod_id,<br>              quantity,<br>              item_price,<br>              quantity*itemprice AS expandedprice<br>FROM orderitems;</p>
<p>SELECT *<br>FROM orderitemsexpanded<br>WHERE order_num=20005;<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorwuxuy21j309i02kjs1.jpg"></p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorwv6q1svj30bu08twhc.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorwvecw9wj30bu070juj.jpg"></p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>《MySQL必知必会》</tag>
      </tags>
  </entry>
  <entry>
    <title>使用触发器</title>
    <url>/2020/10/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B/%E4%BD%BF%E7%94%A8%E8%A7%A6%E5%8F%91%E5%99%A8/</url>
    <content><![CDATA[<p>使用触发器</p>
<p>触发器是MySQL响应以下任意语句而自动执行的一条MySQL语句（或位于BEGIN和END语句之间的一组语句）：<br>                 DELETE;<br>                 INSERT;<br>                 UPDATE;<br>其他MySQL语句不支持触发器</p>
<p>在创建触发器时，需要给出4条信息：<br>1）唯一的触发器名<br>2）触发器关联的表<br>3）触发器应该响应的活动（DELETE、INSERT、UPDATE）<br>4）触发器何时执行（处理之前或之后）<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorx7ksl98j30cq04341u.jpg"></p>
<p>1）创建触发器<br>CREATE TRIGGER newproduct AFTER INSERT ON products<br>FOR EACH ROW SELECT ‘Product added’;<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorx80epvrj30db04oq5e.jpg"></p>
<p>只有表才支持触发器，视图不支持（临时表也不支持）；触发器按每个表每个事件每次的定义，每个表每个事件每次只允许一个触发器，因此每个表最多支持6个触发器（每条INSERT、UPDATE、DELETE的之前和之后）。单一触发器不能与多个事件或多个表关联，所以，如果你需要一个对INSERT和UPDATE操作执行的触发器，则应该定义两个触发器。<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorx8byu9ej30cs02bmz1.jpg"></p>
<p>2）删除触发器<br>DROP TRIGGER newproduct;<br>触发器不能更新或覆盖，为了修改一个触发器，必须先删除它，然后再重新创建</p>
<p>3）使用触发器<br>（1）INSERT触发器<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorx8l7mumj30d905ognh.jpg"><br>CREATE TRIGGER neworder AFTER INSERT ON orders<br>FOR EACH ROW SELECT NEW.order_num;<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorx8xpv7oj30d904340m.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorx95mnoxj30d908wq6k.jpg"></p>
<p>(2)DELETE触发器</p>
<p>【原书缺页？？？？】</p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>《MySQL必知必会》</tag>
      </tags>
  </entry>
  <entry>
    <title>全文本搜索</title>
    <url>/2020/10/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B/%E5%85%A8%E6%96%87%E6%9C%AC%E6%90%9C%E7%B4%A2/</url>
    <content><![CDATA[<p>全文本搜索</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorv0yqxudj30b5049q5z.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorv16gkm7j30b501s0t8.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorv1daeb2j30b506t41e.jpg"></p>
<p>1）CREATE TABLE语句接受FULLTEXT子句，它给出被索引列的一个逗号分隔的列表<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorv1kbfizj30bm0d2wk5.jpg"></p>
<p>2）在索引之后，使用两个函数Match()和Against()执行全文本搜索，其中Match()指定被搜索的列，Against()指定要使用的搜索表达式；传递给Match()的值必须与FULLTEXT()定义中的相同，如果指定多个列，则必须列出它们（而且次序正确）<br>SELECT note_text<br>FROM productnotes<br>WHERE Match(note_text) Against(‘rabbit’);<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorv1sf6apj309k02imxu.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorv20qlwhj30b501lab3.jpg"></p>
<p>3）这条SELECT语句同样检索出两行，但次序不同（虽然并不总是出现这种情况）<br>SELECT note_text<br>FROM productnotes<br>WHERE note_text LIKE ‘%rabbit%’;<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorv26z6f1j309i02jjs2.jpg"></p>
<p>上述两条SELECT语句都不包含ORDER BY子句，后者以不特别有用的顺序返回数据。前者返回以文本匹配的良好程度排序的数据。两个行都包含词rabbit，但包含词rabbit作为第3个词的行的等级比作为第20个词的行高</p>
<p>4）演示排序如何工作<br>SELECT note_text，<br>      Match(note_text) Against(‘rabbit’) AS rank<br>FROM productnotes<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorv2ga8h8j30ad0bmjv5.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorv2nmx7tj30ad04smyl.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorv2uzbkmj30bm0610ve.jpg"></p>
<p>如果指定多个搜索项，则包含多数匹配词的那些行将具有比包含较少词（或仅有一个匹配）的那些行高的等级值</p>
<p>5)<br>查询扩展用来设法放宽所返回的全文本搜索结果的范围<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorv3317xtj30bm061mz7.jpg"><br>SELECT note_text<br>FROM productnotes<br>WHERE Match(note_text) Against(‘anvils’);<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorv3atxkhj30a90243z1.jpg"></p>
<p>表中的行越多（这些行中的文本就越多，使用查询扩展返回的结果越好）<br>SELECT note_text<br>FROM productnotes<br>WHERE Match(note_text) Against(‘anvils’ WITH QUERY EXPANSION);<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorv3igwblj30a90700v3.jpg"></p>
<p>6）布尔文本搜索，以布尔方式，可以提供关于如下内容的细节：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorv3u8pq3j30at03ht9l.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorv42eipxj30b802l763.jpg"><br>SELECT note_text<br>FROM productnotes<br>WHERE Match(note_text) Against(‘heavy’ IN BOOLEAN MODE);<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorv4awfkuj30bo07in0s.jpg"></p>
<p>匹配包含heavy但不包含任意以rope开始的词的行：<br>SELECT note_text<br>FROM productnotes<br>WHERE Match(note_text) Against(‘heavy -rope*’ IN BOOLEAN MODE);<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorv4jqhqyj30aa026dge.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorv4rq4y2j30af0510tz.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorv5184c6j30bv0cg0wg.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorv58urzqj30bv02wt9r.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorv5hkdsxj30bv0a7aez.jpg"></p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>《MySQL必知必会》</tag>
      </tags>
  </entry>
  <entry>
    <title>全球化和本地化</title>
    <url>/2020/10/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B/%E5%85%A8%E7%90%83%E5%8C%96%E5%92%8C%E6%9C%AC%E5%9C%B0%E5%8C%96/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>《MySQL必知必会》</tag>
      </tags>
  </entry>
  <entry>
    <title>创建计算字段</title>
    <url>/2020/10/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B/%E5%88%9B%E5%BB%BA%E8%AE%A1%E7%AE%97%E5%AD%97%E6%AE%B5/</url>
    <content><![CDATA[<p>创建计算字段</p>
<p>计算字段并不实际存在于数据库表中，计算字段是运行时在SELECT语句内创建的</p>
<p>字段：基本上与列的意思相同，经常互换使用，不过数据库列一般称为列，而术语字段通常用在计算字段的连接上</p>
<p>只有数据库知道SELECT语句中哪些列是实际的表列，哪些列是计算字段。从客户机（如应用程序）的角度来看，计算字段的数据是以与其他列的数据相同的方式返回的<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gortz4hy7dj30b703576m.jpg"></p>
<p>拼接：将值联结到一起构成单个值</p>
<p>1）<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goru3500nmj30b6024myn.jpg"><br>SELECT Concat(vendname，‘ （’，vendcountry，‘）’）<br>FROM vendors<br>ORDER BY vend_name;<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goru3e6rfnj306s03cjrx.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goru3kvotqj30bi05mjt3.jpg"></p>
<p>RTrim()函数去掉值右边的所有空格，通过使用RTrim()，各个列都进行了整理<br>SELECT Concat(RTrim(vendname)，‘ （’，RTrim(vendcountry)，‘）’）<br>FROM vendors<br>ORDER BY vend_name;<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goru3sjk96j30b7023q4d.jpg"></p>
<p>2）别名是一个字段或值的替换名，别名用AS关键字赋予<br>SELECT Concat(RTrim(vendname)，‘ （’，RTrim(vendcountry)，‘）’）AS vend_title<br>FROM vendors<br>ORDER BY vend_name;<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goru41cau8j304203bt93.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goru47rf4jj30b7022gn3.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goru4djupzj30b701iab5.jpg"></p>
<p>3)检索订单号20005中的所有物品<br>SELECT prodid,quantity,itemprice<br>FROM orderitems<br>WHERE order_num=20005;<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goru4l975mj305802maae.jpg"></p>
<p>item_price列包含订单中每项物品的单价，如下汇总物品的价格（单价乘以订购数量）<br>SELECT prod_id,<br>              quantity,<br>              item_price,<br>              quantity*itemprice AS expandedprice<br>FROM orderitems<br>WHERE order_num=20005;<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goru4tqhgsj307r02i3yz.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goru50n0mwj307r038glv.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goru56chxej30b903lju1.jpg"></p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>《MySQL必知必会》</tag>
      </tags>
  </entry>
  <entry>
    <title>分组数据</title>
    <url>/2020/10/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B/%E5%88%86%E7%BB%84%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<p>分组数据</p>
<p>分组允许把数据分为多个逻辑组，以便能对每个组进行聚集计算</p>
<p>1）<br>SELECT  vendid,COUNT(*) AS numprods<br>FROM products<br>GROUP BY vend_id;<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorugtm69rj303d02k0sw.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goruh1m7d3j30b702vjth.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goruh9lb27j30b008077o.jpg"></p>
<p>2)WHERE过滤行，HAVING过滤分组<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goruhi2u4dj30b702mq4r.jpg"><br>SELECT  cust_id,COUNT(<em>) AS orders<br>FROM orders<br>GROUP BY cust_id<br>HAVING COUNT(</em>) &gt;=2;<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goruhqovxej302z01ijrg.jpg"></p>
<p>这里WHERE子句不起作用，因为过滤是基于分组聚集值而不是特定行值的<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goruhzwdz2j30b7026myt.jpg"></p>
<p>3）列出具有2个（含）以上、价格为10（含）以上的产品的供应商<br>SELECT  vendid,COUNT(<em>) AS numprods<br>FROM products<br>WHERE prod_price &gt;=10<br>GROUP BY vend_id<br>HAVING COUNT(</em>) &gt;=2;<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorui89ypjj303c01tglp.jpg"></p>
<p>SELECT  vendid,COUNT(<em>) AS numprods<br>FROM products<br>GROUP BY vend_id<br>HAVING COUNT(</em>) &gt;=2;<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goruifzm3pj303c02kt8v.jpg"></p>
<p>4）<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goruiou8d2j30az0310tq.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goruiwahh3j30b7022dha.jpg"><br>检索总计订单价格大于等于50的订单号和总计订单价格<br>SELECT ordernum,SUM(quantity<em>itemprice) AS ordertotal<br>FROM orderitems<br>GROUP BY order_num<br>HAVING SUM(quantity</em>item_price) &gt;= 50;<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goruj4enuij303w02l0t0.jpg"></p>
<p>按总计订单价格排序输出：<br>SELECT ordernum,SUM(quantity<em>itemprice) AS ordertotal<br>FROM orderitems<br>GROUP BY order_num<br>HAVING SUM(quantity</em>item_price) &gt;= 50<br>ORDER BY ordertotal;<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorujdwe2tj303w02lwer.jpg"></p>
<p>5）<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorujldl9kj30a602iq3m.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorujrvqxej30a602awf1.jpg"></p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>《MySQL必知必会》</tag>
      </tags>
  </entry>
  <entry>
    <title>创建高级联结、自联结、自然联结、外部联结</title>
    <url>/2020/10/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B/%E5%88%9B%E5%BB%BA%E9%AB%98%E7%BA%A7%E8%81%94%E7%BB%93%E3%80%81%E8%87%AA%E8%81%94%E7%BB%93%E3%80%81%E8%87%AA%E7%84%B6%E8%81%94%E7%BB%93%E3%80%81%E5%A4%96%E9%83%A8%E8%81%94%E7%BB%93/</url>
    <content><![CDATA[<p>创建高级联结【自联结、自然联结、外部联结】</p>
<p>别名除了用于列名和计算字段外，SQL还允许给表名起别名，这样做有两个主要理由：<br>1）缩短SQL语句<br>2）允许在单条SELECT语句中多次使用相同的表</p>
<p>1）表别名不仅能用于WHERE子句，它还可以用于SELECT的列表、ORDER BY子句以及语句的其他部分，表别名只在查询执行中使用，与列别名不一样，表别名不返回到客户机<br>SELECT custname,custcontact<br>FROM customers AS c,orders AS o,orderitems AS oi<br>WHERE c.custid=o.custid<br>      AND oi.ordernum=o.ordernum<br>      AND prod_id=’TNT2’;</p>
<p>2）自联结<br>首先找到生产ID为DTNTR的物品的供应商，然后找出这个供应商生产的其他物品<br>SELECT prodid,prodname<br>FROM products<br>WHERE vendid =(SELECT vendid<br>                                FROM products<br>                                WHERE prod_id=‘DTNTR’);<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorutohlegj304403mjrs.jpg"></p>
<p>SELECT p1.prodid,p1.prodname<br>FROM products AS p1,products AS p2<br>WHERE p1.vendid=p2.vendid<br>    AND p2.prod_id=‘DTNTR’;<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goruu2ml4bj304403mdg8.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goruua9u4xj30br09bjwa.jpg"></p>
<p>3)无论何时对表进行联结，应该至少有一个列出现在不止一个表中（被联结的列），标准的联结返回所有数据，甚至相同的列多次出现。自然联结排除多次出现，使每个列只返回一次<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goruuhpe5zj30br07876z.jpg"></p>
<p>4）联结包含了那些在相关表中没有关联行的行，这种类型的联结称为外部联结</p>
<p>检索所有客户及其订单（内部联结）<br>SELECT customers.custid,orders.ordernum<br>FROM customers INNER JOIN orders<br>   ON customers.custid=orders.custid;</p>
<p>为了检索所有客户，包括那些没有订单的客户（外部联结）：<br>SELECT customers.custid,orders.ordernum<br>FROM customers LEFT OUTER JOIN orders<br>   ON customers.custid=orders.custid;<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goruupdyqtj303d03a74l.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goruv1k1huj30bn0a7jwq.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goruv9ietej30b801gmy4.jpg"></p>
<p>5)检索所有客户及每个客户所下的订单数<br>SELECT customers.cust_name,<br>               customers.cust_id,<br>               COUNT(orders.ordernum) AS numord<br>FROM customers INNER JOIN orders<br>   ON customers.custid=orders.custid<br>GROUP BY customers.cust_id;<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goruvi4uihj305j02kgly.jpg"></p>
<p>6)<br>SELECT customers.cust_name,<br>               customers.cust_id,<br>               COUNT(orders.ordernum) AS numord<br>FROM customers LEFT OUTER JOIN orders<br>   ON customers.custid=orders.custid<br>GROUP BY customers.cust_id;<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goruvq5jggj305l01uglt.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goruvx2i46j305l01jaa8.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goruw3shg3j30bm06fjtn.jpg"></p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>《MySQL必知必会》</tag>
      </tags>
  </entry>
  <entry>
    <title>排序检索数据</title>
    <url>/2020/10/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B/%E6%8E%92%E5%BA%8F%E6%A3%80%E7%B4%A2%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<p>排序检索数据</p>
<p>子句：SQL语句由子句构成，有些子句是必须的，而有的是可选的。一个子句通常由一个关键字和所提供的数据组成。</p>
<p>1）指示MySQL对列以字母顺序排序<br>SELECT 列名<br>FROM 表名<br>ORDER BY 列名;</p>
<p>2）先按价格，再按名称排序：<br>SELECT prodid,prodprice,prod_name<br>FROM products<br>ORDER BY prodprice,prodname;<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gort918kmfj305z0670tw.jpg"></p>
<p>3）按价格以降序排序<br>SELECT prodid,prodprice,prod_name<br>FROM products<br>ORDER BY prod_price DESC;<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gort9a9f5aj305z0673zo.jpg"></p>
<p>4）先按价格以降序排序，再对产品名排序<br>SELECT prodid,prodprice,prod_name<br>FROM products<br>ORDER BY prodprice DESC,prodname;<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gort9jou7zj3064021aae.jpg"><br>DESC关键字只应用到直接位于其前面的列名，在上例中，只对prodprice列指定DESC，对prodname列不指定。因此，prodprice列以降序排序，而prodname列（在每个价格内）仍然按标准的升序排序</p>
<p>5）prod_price DESC保证行是按照由最昂贵到最便宜检索的，而LIMIT 1告诉MySQL仅返回一行<br>SELECT prod_price<br>FROM products<br>ORDER BY prod_price DESC<br>LIMIT 1;<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gort9vbhnrj302001hwei.jpg"></p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>《MySQL必知必会》</tag>
      </tags>
  </entry>
  <entry>
    <title>改善性能</title>
    <url>/2020/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B/%E6%94%B9%E5%96%84%E6%80%A7%E8%83%BD/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>《MySQL必知必会》</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库基本术语</title>
    <url>/2020/10/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E6%9C%AF%E8%AF%AD/</url>
    <content><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gort1gucs5j30m705e43y.jpg"></p>
<p>数据库：保存有组织的数据的容器（通常是一个文件或一组文件）</p>
<p>表：某种特定类型数据的结构化清单，数据库中的每个表都有一个名字，用来标识自己，此名字是唯一的，这表示数据库中没有其他表具有相同的名字【虽然在相同数据库中不能两次使用相同的表名，但在不同数据库中却可以使用相同的表名】</p>
<p>模式：关于数据库和表的布局及特性的信息</p>
<p>列：表中的一个字段，所有表都是由一个或多个列组成的</p>
<p>数据类型：所容许的数据的类型，每个表列都有相应的数据类型，它限制（或容许）该列中存储的数据</p>
<p>行：表中的一个记录</p>
<p>主键：一列（或一组列），其值能够唯一区分表中每个行</p>
<p>表中的任何列都可以作为主键，只要他满足以下条件：<br>1）任意两行都不具有相同的主键值<br>2）每个行都必须具有一个主键值（主键列不允许NULL值）</p>
<p>ps aux | grep mysql</p>
<p>/usr/local/mysql/bin/mysql -u root -p<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gort1r34ntj30dm03tabl.jpg"></p>
<p>关键字：作为MySQL语言组成部分的一个保留字，绝不要用关键字命名一个表或列</p>
<p>SQL语句不区分大小写！！</p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>《MySQL必知必会》</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库维护</title>
    <url>/2020/10/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BB%B4%E6%8A%A4/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>《MySQL必知必会》</tag>
      </tags>
  </entry>
  <entry>
    <title>数据过滤</title>
    <url>/2020/10/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B/%E6%95%B0%E6%8D%AE%E8%BF%87%E6%BB%A4/</url>
    <content><![CDATA[<p>数据过滤</p>
<p>操作符：用来联结或改变WHERE子句中的子句的关键字，也称为逻辑操作符</p>
<p>1）AND:用在WHERE子句中的关键字，用来指示检索满足所有给定条件的行<br>SELECT prodid,prodname,prod_price<br>FROM products<br>WHERE vendid=1003 AND prodprice&lt;=10;<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gortdqrq6dj306402zjrw.jpg"></p>
<p>2)OR：用来表示检索匹配任一给定条件的行<br>SELECT prodname,prodprice<br>FROM products<br>WHERE vendid=1002 OR vendid=1003;<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gortdy8cwwj304k04edgd.jpg"></p>
<p>3）<br>SELECT prodname,prodprice<br>FROM products<br>WHERE vendid=1002 OR vendid=1003 AND prod_price&gt;=10;<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorte6be0aj304k03cgm0.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorted4pwej30bo03z0uo.jpg"></p>
<p>SELECT prodname,prodprice<br>FROM products<br>WHERE (vendid=1002 OR vendid=1003) AND prod_price&gt;=10;<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorteko0dsj304n02lmxh.jpg"></p>
<p>4)IN WHERE子句中用来指定要匹配值的清单的关键字，功能与OR相当<br>SELECT prodname,prodprice<br>FROM products<br>WHERE vend_id IN(1002,1003)<br>ORDER BY prod_name;<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gortevao5yj304m04fq3h.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gortf1wwppj30aq03a75q.jpg"></p>
<p>5）NOT WHERE子句中用来否定后跟条件的关键字<br>SELECT prodname,prodprice<br>FROM products<br>WHERE vend_id NOT IN(1002,1003)<br>ORDER BY prod_name;<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gortf9n2m6j304c02w0t3.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gortfgap23j30ba021abh.jpg"></p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>《MySQL必知必会》</tag>
      </tags>
  </entry>
  <entry>
    <title>插入数据</title>
    <url>/2020/10/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B/%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<p>插入数据</p>
<p>INSERT是用来插入（或添加）行到数据库表的【INSERT语句一般不会产生输出】<br>插入可以用几种方式使用：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorwj7dds6j304x02hglv.jpg"></p>
<p>1）插入完整的行<br>INSERT INTO Customers<br>VALUES(NULL,<br>               ‘Pep E.LaPew’,<br>               ‘100 Main Street’,<br>               ‘Los Angeles’,<br>               ‘CA’,<br>               ‘90046’,<br>               ‘USA’,<br>               NULL,<br>               NULL);<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorwjftpo2j30bp07jn0v.jpg"></p>
<p>INSERT INTO Customers(cust_name,<br>         cust_address,<br>         cust_city,<br>         cust_state,<br>         cust_zip,<br>         cust_country,<br>         cust_contact,<br>         cust_email)<br>VALUES(‘Pep E.LaPew’,<br>               ‘100 Main Street’,<br>               ‘Los Angeles’,<br>               ‘CA’,<br>               ‘90046’,<br>               ‘USA’,<br>               NULL,<br>               NULL);<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorwjud82hj30bq04gacb.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorwk29g09j30b502hjt5.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorwka1hpsj30b70d4wms.jpg"></p>
<p>2)插入多个行<br>INSERT INTO Customers(cust_name,<br>         cust_address,<br>         cust_city,<br>         cust_state,<br>         cust_zip,<br>         cust_country)<br>VALUES(‘Pep E.LaPew’,<br>               ‘100 Main Street’,<br>               ‘Los Angeles’,<br>               ‘CA’,<br>               ‘90046’,<br>               ‘USA’);<br>INSERT INTO Customers(cust_name,<br>         cust_address,<br>         cust_city,<br>         cust_state,<br>         cust_zip,<br>         cust_country)<br>VALUES(‘M.Martian’,<br>               ’42 Galaxy Way’,<br>               ’New York’,<br>               ‘NY’,<br>               ’11213’,<br>               ‘USA’);</p>
<p>只要每条INSERT语句中的列名（和次序）相同，可以如下组合各语句：<br>INSERT INTO Customers(cust_name,<br>         cust_address,<br>         cust_city,<br>         cust_state,<br>         cust_zip,<br>         cust_country)<br>VALUES(<br>               ‘Pep E.LaPew’,<br>               ‘100 Main Street’,<br>               ‘Los Angeles’,<br>               ‘CA’,<br>               ‘90046’,<br>               ‘USA’<br>              )，<br>              (<br>               ‘M.Martian’,<br>               ’42 Galaxy Way’,<br>               ’New York’,<br>               ‘NY’,<br>               ’11213’,<br>               ‘USA’<br>               );<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorwkm47q6j30b7022ta4.jpg"></p>
<p>3）插入检索出的数据<br>INSERT INTO Customers(cust_id,<br>         cust_contact,<br>         cust_email,<br>         cust_name,<br>         cust_address,<br>         cust_city,<br>         cust_state,<br>         cust_zip,<br>         cust_country)<br>SELECT cust_id,<br>         cust_contact,<br>         cust_email,<br>         cust_name,<br>         cust_address,<br>         cust_city,<br>         cust_state,<br>         cust_zip,<br>         cust_country<br>FROM custnew;<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorwkxfdpej30bj05q0v4.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorwl5nalvj30b704a77c.jpg"></p>
<p>INSERT SELECT中SELECT语句可包含WHERE子句以过滤插入的数据</p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>《MySQL必知必会》</tag>
      </tags>
  </entry>
  <entry>
    <title>安全管理</title>
    <url>/2020/10/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B/%E5%AE%89%E5%85%A8%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>《MySQL必知必会》</tag>
      </tags>
  </entry>
  <entry>
    <title>创建和操纵表</title>
    <url>/2020/10/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B/%E5%88%9B%E5%BB%BA%E5%92%8C%E6%93%8D%E7%BA%B5%E8%A1%A8/</url>
    <content><![CDATA[<p>创建和操纵表</p>
<p>一般有两种创建表的方法：<br>1）使用具有交互式创建和管理表的工具<br>2）表也可以直接用MySQL语句操纵</p>
<p>值得注意的是，在使用交互式工具时，实际上使用的是MySQL语句，但是这些语句不是用户编写的，界面工具会自动生成并执行相应的MySQL语句（更改现有表时也是这样）</p>
<p>为利用CREATE TABLE创建表，必须给出下列信息：<br>1）新表的名字，在关键字CREATE TABLE之后给出<br>2）表列的名字和定义，用逗号分隔</p>
<p>1）表的主键可以在创建表时用PRIMARY KEY关键字指定，为创建由多个列组成的主键，应该以逗号分隔的列表给出各列名；主键为其值唯一标识表中每个行的列，主键中只能使用不允许NULL值的列，允许NULL值的列不能作为唯一标识<br>CREATE TABLE customers<br>(<br>     custid              int                NOT NULL AUTOINCREMENT,<br>     cust_name        char(50)     NOT NULL,<br>     cust_address    char(50)     NULL,<br>     cust_city           char(50)     NULL,<br>     cust_state         char(5)       NULL,<br>     cust_zip             char(10)     NULL,<br>     cust_country     char(50)     NULL,<br>     cust_contact     char(50)     NULL,<br>     cust_email         char(255)   NULL,<br>     PRIMARY KEY (cust_id)<br>)ENGINE-InnoDB;</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorwon1sojj30b4044jub.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorwoulrokj30b402lwgb.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorwp2xsdhj30b402l40a.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorwp9p6ubj30b402l761.jpg"></p>
<p>AUTOINCREMENT告诉MySQL，本列每当增加一行时自动增量。每次执行一个INSERT操作时，MySQL自动对该列增量（从而才有这个关键字AUTOINCREMENT），给该列赋予下一个可用的值。这样给每个行分配一个唯一的custid，从而可以用作主键值；每个表只允许一个AUTOINCREMENT列，而且它必须被索引（如通过使它成为主键）<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorwpk2xfbj30b40bjjz3.jpg"></p>
<p>2）如果在插入行时没有给出值，MySQL允许指定此时使用的默认值。默认值用CREATE TABLE语句的列定义中的DEFAULT关键字指定<br>CREATE TABLE orderitems<br>(<br>     order_num        int                     NOT NULL,<br>     order_item        int                     NOT NULL,<br>     prod_id             char(10)           NOT NULL,<br>     quantity            int                     NOT NULL DEFAULT 1,<br>     item_price        decimal(8,2)    NOT NULL,<br>     PRIMARY KEY(ordernum,orderitem)<br>)ENGINE-InnoDB;<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorwptvtivj30b404d40w.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorwq1d6f2j30bw07ndis.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorwq88t37j30bw0f0wlh.jpg"></p>
<p>3)更新表<br>为了使用ALTER TABLE更改表结构，必须给出下面的信息：<br>1）在ALTER TABLE之后给出要更改的表名（该表必须存在，否则将出错）<br>2）所做更改的列表</p>
<p>ALTER TABLE vendors<br>ADD vend_phone CHAR(20);</p>
<p>删除刚刚添加的列：<br>ALTER TABLE Vendors<br>DROP COLUMN vend_phone;<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorwqhn92kj30bw08l76r.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorwqphxx2j30bw01ldg7.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorwqwbdwtj30bw07e0wg.jpg"></p>
<p>4)删除表：删除整个表而不是其内容，删除表没有确认，也不能撤销，执行这条语句将永久删除该表</p>
<p>DROP TABLE customers2;</p>
<p>5)重命名表</p>
<p>RENAME TABLE customers2 TO customers,<br>                            backup_vendors TO vendors;</p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>《MySQL必知必会》</tag>
      </tags>
  </entry>
  <entry>
    <title>更新和删除数据</title>
    <url>/2020/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B/%E6%9B%B4%E6%96%B0%E5%92%8C%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<p>更新和删除数据</p>
<p>1）为了更新（修改）表中的数据，可使用UPDATE语句，可采用两种方式使用UPDATE：<br>更新表中特定行；<br>更新表中所有行；</p>
<p>UPDATE语句的组成：<br>1）要更新的表<br>2）列名和它们的新值<br>3）确定要更新行的过滤条件</p>
<p>UPDATE customers<br>SET cust_email=‘ <a href="mailto:&#101;&#x6c;&#109;&#x65;&#x72;&#x40;&#102;&#x75;&#100;&#x64;&#46;&#99;&#111;&#x6d;">&#101;&#x6c;&#109;&#x65;&#x72;&#x40;&#102;&#x75;&#100;&#x64;&#46;&#99;&#111;&#x6d;</a> ’<br>WHERE cust_id=10005;</p>
<p>UPDATE customers<br>SET cust_name=’The Fudds’,<br>        cust_email=‘ <a href="mailto:&#101;&#x6c;&#x6d;&#x65;&#x72;&#64;&#x66;&#x75;&#100;&#x64;&#46;&#99;&#111;&#109;">&#101;&#x6c;&#x6d;&#x65;&#x72;&#64;&#x66;&#x75;&#100;&#x64;&#46;&#99;&#111;&#109;</a> ’<br>WHERE cust_id=10005;<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorwmjgrtzj30b705mjv7.jpg"></p>
<p>为了删除某个列的值，可设置它为NULL（假定表定义允许NULL值）<br>UPDATE customers<br>SET cust_email=NULL<br>WHERE cust_id=10005;</p>
<p>2）为了从一个表中删除（去掉）数据，可使用DELETE语句<br>从表中删除特定的行<br>从表中删除所有行</p>
<p>DELETE FROM customers<br>WHERE cust_id =10006;<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorwmsze4qj30b604rtbq.jpg"></p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorwn2z6fvj30bs0c9jx3.jpg"></p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>《MySQL必知必会》</tag>
      </tags>
  </entry>
  <entry>
    <title>检索数据SELECT语句</title>
    <url>/2020/10/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B/%E6%A3%80%E7%B4%A2%E6%95%B0%E6%8D%AESELECT%E8%AF%AD%E5%8F%A5/</url>
    <content><![CDATA[<p>检索数据【SELECT语句】：</p>
<p>检索单个列：</p>
<p>从db表中检索一个名为Host的列：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gort6c7xeij306303a74d.jpg"><br>从db表中检索多个列：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gort6kg84nj30ab03pglt.jpg"><br>从db表中检索所有列：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gort6tsbinj30ev0d4dgj.jpg"></p>
<p>检索不同的行？？<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gort72pvf9j30ai0dljtw.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gort79ppwjj30ai059myt.jpg"></p>
<p>限制结果：<br>LIMIT 1；【指示MySQL返回不多于1行】<br>LIMIT 1，2；【第一个数为开始位置，第二个数为要检索的行数】<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gort7jl4ayj308b0a6aal.jpg"><br>1）所以，带一个值的LIMIT总是从第一行开始，给出的数为返回的行数。带两个值的LIMIT可以指定从行号为第一个值的位置开始<br>2）检索出来的第一行为行0而不是行1，因此，LIMIT 1，1将检索出第二行而不是第一行<br>3）LIMIT中指定要检索的行数为检索的最大行数，如果没有足够的行（例如，给出LIMIT 10，5，但只有13行），MySQL将只返回它能返回的那么多行</p>
<p>使用完全限定的表名：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gort7w68sij308b03w0sv.jpg"></p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>《MySQL必知必会》</tag>
      </tags>
  </entry>
  <entry>
    <title>汇总数据</title>
    <url>/2020/10/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B/%E6%B1%87%E6%80%BB%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<p>汇总数据</p>
<p>聚集函数：运行在行组上，计算和返回单个值的函数<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorub8jfypj3080045wf3.jpg"></p>
<p>1）AVG()函数：AVG()通过对表中行数计算并计算特定列值之和，求得该列的平均值。AVG()可用来返回所有列的平均值，也可以用来返回特定列或行的平均值</p>
<p>返回products表中所有产品的平均价格<br>SELECT AVG(prodprice) AS avgprice<br>FROM products;<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorubgpm52j301v01kaa3.jpg"></p>
<p>返回特定供应商所提供产品的平均价格<br>SELECT AVG(prodprice) AS avgprice<br>FROM products<br>WHERE vend_id =1003;<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorubopzzmj301v01kaa3.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorubwhuxfj30b603kgnu.jpg"></p>
<p>2)COUNT()函数<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goruc4a991j30bm04b3zr.jpg"></p>
<p>返回customers表中客户的总数：<br>SELECT COUNT(*) AS num_cust<br>FROM customers;<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorucbxi9yj301r01l3yi.jpg"></p>
<p>只对具有电子邮件地址的客户计数<br>SELECT COUNT(custemail) AS numcust<br>FROM customers;<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goruclrzijj301r01ldfu.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goructfdt3j30b601p3zn.jpg"></p>
<p>3)MAX()函数：要求指定列名<br>SELECT MAX(prodprice) AS maxprice<br>FROM products;<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorud22nwpj301x01gjre.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorud9vrdwj30b803zwgv.jpg"></p>
<p>4)MIN()函数：要求指定列名<br>SELECT MIN(prodprice) AS minprice<br>FROM products;<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorudhl35tj301u01haa2.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorudpylkmj30b8044jtz.jpg"></p>
<p>5)SUM()函数：用来返回指定列值的和（总计）</p>
<p>检索所订购物品的总数（所有quantity值之和）<br>SELECT SUM(quantity) AS items_ordered<br>FROM orderitems<br>WHERE order_num=20005;<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorudypxc9j302g01lq2z.jpg"></p>
<p>合计每项物品的items_price<em>quantity，得到总的订单金额<br>SELECT SUM(itemprice</em>quantity) AS totalprice<br>FROM orderitems<br>WHERE order_num=20005;<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorue994hlj302701idfv.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorueib4iij30b802vgnf.jpg"></p>
<p>6)聚集不同值<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorueq3r3qj30ba042jt8.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goruexsptij30ba06r40f.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goruf5cszrj30ba056adj.jpg"></p>
<p>7）组合聚集函数<br>SELECT COUNT(*) AS num_items,<br>               MIN(prodprice) AS pricemin,<br>               MAX(prodprice) AS pricemax,<br>               AVG(prodprice) AS priceavg<br>FROM products;<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorufd6iwpj307b01gmxf.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorufl6iwxj30b501z75o.jpg"></p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>《MySQL必知必会》</tag>
      </tags>
  </entry>
  <entry>
    <title>用正则表达式进行搜索</title>
    <url>/2020/10/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B/%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BF%9B%E8%A1%8C%E6%90%9C%E7%B4%A2/</url>
    <content><![CDATA[<p>用正则表达式进行搜索</p>
<p>正则表达式是用来匹配文本的特殊的串（字符集合），正则表达式的作用是匹配文本，将一个模式（正则表达式）与一个文本串进行比较<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gortjue6zgj30b90230u8.jpg"></p>
<p>1）检索列prod_name包含文本1000的所有行<br>SELECT prod_name<br>FROM products<br>WHERE prod_name REGEXP ‘1000’<br>ORDER BY prod_name;<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gortk1veqij302b01hgln.jpg"></p>
<p>2）<br>SELECT prod_name<br>FROM products<br>WHERE prod_name REGEXP ‘.000’<br>ORDER BY prod_name;<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gortkdlt9pj302b01t3yl.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gortkm1ewmj30b609kn40.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gortkuaajej30b601gab0.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gortl0jw5kj30b602ndhp.jpg"></p>
<p>3）|为正则表达式的OR操作符，它表示匹配其中之一，使用|从功能上类似于在SELECT语句中使用OR语句，多个OR条件可并入单个正则表达式<br>SELECT prod_name<br>FROM products<br>WHERE prod_name REGEXP ‘1000|2000’<br>ORDER BY prod_name;<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gortl89espj302b01s3yl.jpg"></p>
<p>4）[123]定义一组字符，它的意思是匹配1或者2或者3，因此，1 ton 和2 ton都匹配且返回（没有 3 ton）,[123] Ton为[1|2|3] Ton的缩写<br>SELECT prod_name<br>FROM products<br>WHERE prod_name REGEXP ‘[123] Ton’<br>ORDER BY prod_name;<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gortlh9hn8j302601y0st.jpg"></p>
<p>MySQL假定你的意思是‘1’或‘2’或‘3 ton’，除非你把字符｜括在一个集合中，否则它将应用于整个串<br>SELECT prod_name<br>FROM products<br>WHERE prod_name REGEXP ‘1|2|3 Ton’<br>ORDER BY prod_name;<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gortlp996wj302d02yweo.jpg"></p>
<p>[^123]匹配除这些字符外的任何东西</p>
<p>5）<br>SELECT prod_name<br>FROM products<br>WHERE prod_name REGEXP ‘[1-5] Ton’<br>ORDER BY prod_name;<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gortm4jsr9j302d02bmxa.jpg"></p>
<p>6）.匹配任意字符，因此每个行都被检索出来<br>SELECT vend_name<br>FROM vendors<br>WHERE vend_name REGEXP ‘.’<br>ORDER BY vend_name;<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gortmeuft6j302n03c74i.jpg"></p>
<p>为了匹配特殊字符，必须用\为前导。\-表示查找-，\.表示查找.<br>SELECT vend_name<br>FROM vendors<br>WHERE vend_name REGEXP ‘\.’<br>ORDER BY vend_name;<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gortmy5lwij302e01ijrf.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gortoggjl3j309y04hdgj.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gortpdzf5sj30b903tdi7.jpg"></p>
<p>7)<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gortrj2c90j30bp08y774.jpg"></p>
<p>8)<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gortugmffnj30bw089416.jpg"><br>SELECT prod_name<br>FROM products<br>WHERE prod_name REGEXP ‘\([0-9] sticks?\)’<br>ORDER BY prod_name;<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gortuypklpj302n01wwel.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gortv8r75kj30bk02it9s.jpg"></p>
<p>SELECT prod_name<br>FROM products<br>WHERE prod_name REGEXP ‘:digit:{4}’<br>ORDER BY prod_name;<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gortvhksbej302c01xq31.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gortvpgndlj30bl04sjt0.jpg"></p>
<p>9)<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gortvyaf7uj307z03m3yx.jpg"><br>SELECT prod_name<br>FROM products<br>WHERE prod_name REGEXP ‘^[0-9\.]’<br>ORDER BY prod_name;<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gortw7jexzj302c029aa6.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gortwgb8m3j30bj01sq3k.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gortwr6d1hj30bc04i0vr.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gortx446h0j30bb03wmzu.jpg"></p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>《MySQL必知必会》</tag>
      </tags>
  </entry>
  <entry>
    <title>用通配符进行过滤</title>
    <url>/2020/10/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B/%E7%94%A8%E9%80%9A%E9%85%8D%E7%AC%A6%E8%BF%9B%E8%A1%8C%E8%BF%87%E6%BB%A4/</url>
    <content><![CDATA[<p>用通配符进行过滤</p>
<p>通配符：用来匹配值的一部分的特殊字符<br>搜索模式：由字面值、通配符或两者组合构成的搜索条件<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gortgmkz1rj30b602kjta.jpg"></p>
<p>1）%表示任何字符出现的任意次数，下列找出所有以词jet起头的产品，%告诉MySQL接受jet之后的任意字符，不管它有多少字符<br>SELECT prodid,prodname<br>FROM products<br>WHERE prod_name LIKE ‘jet%’;<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gortgvd90lj303u01tt8w.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorth29b7gj30b701kjsf.jpg"></p>
<p>2）搜索模式’%anvil%’表示匹配任何位置包含文本anvil的值，而不论它之前或之后出现什么字符<br>SELECT prodid,prodname<br>FROM products<br>WHERE prod_name LIKE ‘%anvil%’;<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorth9wyc0j303r0270sy.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorthi0f4ej30b606in1g.jpg"></p>
<p>3）下划线只匹配单个字符而不是多个字符<br>SELECT prodid,prodname<br>FROM products<br>WHERE prodname LIKE ‘ ton anvil’;<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorthpptr1j303o01vaa8.jpg"></p>
<p>SELECT prodid,prodname<br>FROM products<br>WHERE prod_name LIKE ‘% ton anvil’;<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorthxwb0kj303s025mxd.jpg"><br>与%能匹配0个字符不一样，_总是匹配一个字符，不能多也不能少<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorti5qgb0j30bv06440v.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gortic92ltj30bl024t91.jpg"></p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>《MySQL必知必会》</tag>
      </tags>
  </entry>
  <entry>
    <title>管理事务处理</title>
    <url>/2020/10/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B/%E7%AE%A1%E7%90%86%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<p>管理事务处理</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorxalt67nj30cs04vq71.jpg"></p>
<p>事务处理可以用来维护数据库的完整性，它保证成批的MySQL操作要么完全执行，要么完全不执行</p>
<p>事务处理是一种机制，用来管理必须成批执行的MySQL操作，以保证数据库不包含不完整的操作结果，利用事务处理，可以保证一组操作不会中途停止，它们或者作为整体执行，或者完全不执行（除非明确指示），如果没有发生错误，整组语句提交给（写到）数据库表。如果发生错误，则进行回退（撤销）以恢复数据库到某个已知且安全的状态<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorxatr9omj30dg06876c.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorxb1qcl4j30dg0cj41g.jpg"></p>
<p>事务：指一组SQL语句<br>回退：指撤销指定SQL语句的过程<br>提交：指将未存储的SQL语句结果写入数据库表<br>保留点：指事务处理中设置的临时占位符，你可以对它发布回退（与回退整个事务处理不同）</p>
<p>1）START TRANSACTION标识事务的开始</p>
<p>2）MySQL的ROLLBACK命令用来回退（撤销）MySQL语句：<br>SELECT * FROM ordertotals;<br>START TRANSACTION;<br>DELETE FROM ordertotals;<br>SELECT * FROM ordertotals;<br>ROLLBACK;<br>SELECT * FROM ordertotals;<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorxbcn65zj30dg08wwjg.jpg"></p>
<p>3)一般的MySQL语句都是直接针对数据库表执行和编写的，这就是所谓的隐含提交，即提交（写或保存）操作是自动进行的；但是，在事务处理块中，提交不会隐含的进行。为进行明确的提交，使用COMMIT语句<br>START TRANSACTION;<br>DELETE FROM orderitems WHERE order_num=20010;<br>DELETE FROM orders WHERE order_num=20010;<br>COMMIT;<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorxbll0v0j30dg03ign9.jpg"></p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorxbtebtmj30cr01ogmw.jpg"></p>
<p>使用保留点：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorxc0363yj30dc05lacf.jpg"><br>这些占位符称为保留点</p>
<p>创建占位符：<br>SAVEPOINT deletel;</p>
<p>每个保留点都取标识它的唯一名字，以便在回退时，MySQL知道要回退到何处。为了回退到本例给出的保留点，可如下进行：<br>ROLLBACK TO deletel;<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorxcakymdj30cr05f78a.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorxctcr4mj30dl083788.jpg"></p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>《MySQL必知必会》</tag>
      </tags>
  </entry>
  <entry>
    <title>组合查询</title>
    <url>/2020/10/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B/%E7%BB%84%E5%90%88%E6%9F%A5%E8%AF%A2/</url>
    <content><![CDATA[<p>组合查询</p>
<p>MySQL也允许执行多个查询（多条SELECT语句），并将结果作为单个查询结果集返回，这些组合查询通常称为并或复合查询<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goruxgf6b0j308c024mxq.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goruxo5c5ej30b803q770.jpg"></p>
<p>1）假如需要价格小于等于5的所有物品的一个列表，而且还想包括供应商1001和1002生产的所有物品（不考虑价格）</p>
<p>法1:<br>SELECT vendid,prodid,prod_price<br>FROM products<br>WHERE prod_price&lt;=5;<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goruxvg9ysj304z02jmxg.jpg"></p>
<p>SELECT vendid,prodid,prod_price<br>FROM products<br>WHERE vend_id IN(1001,1002);<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goruy2pzt4j304z02y74o.jpg"></p>
<p>法2:<br>SELECT vendid,prodid,prod_price<br>FROM products<br>WHERE prod_price&lt;=5;<br>UNION<br>SELECT vendid,prodid,prod_price<br>FROM products<br>WHERE vend_id IN(1001,1002);<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goruyafa8rj304z044aan.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goruyi3nujj30bt042jss.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goruypdlemj30bt02ht9l.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goruyw3s4nj30bt02oq3z.jpg"></p>
<p>UNION从查询结果集中自动去除了重复的行，这是UNION的默认行为，但是如果需要，可以改变它，事实上，如果想返回所有匹配行，可使用UNION ALL而不是UNION<br>SELECT vendid,prodid,prod_price<br>FROM products<br>WHERE prod_price&lt;=5;<br>UNION ALL<br>SELECT vendid,prodid,prod_price<br>FROM products<br>WHERE vend_id IN(1001,1002);<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goruz3ehsaj304y04fdgg.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goruzasm6aj30b602jmyy.jpg"></p>
<p>2）SELECT语句的输出用ORDER BY子句排序。在用UNION组合查询时，只能使用一条ORDER BY子句，它必须出现在最后一条SELECT语句之后。对于结果集，不存在用一种方式排序一部分，而又用另一种方式排序另一部分的情况。因此不允许使用多条ORDER BY子句<br>SELECT vendid,prodid,prod_price<br>FROM products<br>WHERE prod_price&lt;=5;<br>UNION<br>SELECT vendid,prodid,prod_price<br>FROM products<br>WHERE vend_id IN(1001,1002)<br>ORDER BY vendid,prodprice;<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goruzia4m6j304z044jry.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goruzo6qhej30b501zq4a.jpg"></p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>《MySQL必知必会》</tag>
      </tags>
  </entry>
  <entry>
    <title>联结表、内部联结或等值联结</title>
    <url>/2020/10/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B/%E8%81%94%E7%BB%93%E8%A1%A8%E3%80%81%E5%86%85%E9%83%A8%E8%81%94%E7%BB%93%E6%88%96%E7%AD%89%E5%80%BC%E8%81%94%E7%BB%93/</url>
    <content><![CDATA[<p>联结表【内部联结或等值联结】</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorupddvpbj30bs05i762.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorupl3ey2j30bs0hk45s.jpg"></p>
<p>联结是一种机制，用来在一条SELECT语句中关联表，使用特殊的语法，可以联结多个表返回一组输出，联结在运行时关联表中正确的行<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorupv39x6j30b706lq7s.jpg"></p>
<p>1）<br>SELECT vendname,prodname,prod_price<br>FROM vendors,products<br>WHERE vendors.vendid=products.vendid<br>ORDER BY vendname,prodname;<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goruq4vmywj306p01taac.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goruqcanemj306p04pgmk.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goruqjjij8j30b701zdh8.jpg"></p>
<p>笛卡尔积：由没有联结条件的表关系返回的结果为笛卡尔积，检索出的行的数目将是第一个表中的行数乘以第二个表中的行数<br>SELECT vendname,prodname,prod_price<br>FROM vendors,products<br>ORDER BY vendname,prodname;<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goruqqkynyj30760c1ju2.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goruqye64rj30760hen1d.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorur7bbicj307602xt9c.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorurf2qndj30bh06qjvh.jpg"></p>
<p>2）<br>SELECT vendname,prodname,prod_price<br>FROM vendors INNER JOIN products<br>ON vendors.vendid=products.vendid;<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorurn499nj30bc02g409.jpg"></p>
<p>3)<br>SELECT prodname,vendname,prod_price,quantity<br>FROM orderitems,products,vendors<br>WHERE products.vendid=vendors.vendid<br>   AND orderitems.prodid=products.prodid<br>   AND order_num=20005;<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goruruabf9j308g02igm6.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorus28tl7j30bf023jsx.jpg"></p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>《MySQL必知必会》</tag>
      </tags>
  </entry>
  <entry>
    <title>过滤数据</title>
    <url>/2020/10/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B/%E8%BF%87%E6%BB%A4%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<p>过滤数据</p>
<p>1）只返回prod_price值为2.50的行<br>SELECT prodname,prodprice<br>FROM products<br>WHERE prod_price=2.50;<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gortb74hxbj304h01y0sy.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gortbdgfqkj30b701y3zv.jpg"></p>
<p>2）<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gortbjxonjj308i05nwf2.jpg"></p>
<p>3）MySQL在执行匹配时默认不区分大小写，所以fuses与Fuses匹配<br>SELECT prodname,prodprice<br>FROM products<br>WHERE prod_name=‘fuses’;【注意单引号】<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gortbtr4awj303t01jglq.jpg"></p>
<p>4）<br>SELECT prodname,prodprice<br>FROM products<br>WHERE prod_price&lt;10;<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gortc1kroej304h03oaai.jpg"></p>
<p>5)列出不是由供应商1003制造的所有产品<br>SELECT vendid,prodname<br>FROM products<br>WHERE vend_id&lt;&gt;1003;<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gortc91h1jj303v03nwex.jpg"></p>
<p>6）检索价格在5美元和10美元之间的所有产品<br>SELECT prodname,prodprice<br>FROM products<br>WHERE prod_price BETWEEN 5 AND 10;<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gortcgfxiyj304j02vdg6.jpg"></p>
<p>7）NULL：无值，它与字段包含0、空字符串或仅仅包含空格不同<br>这条语句返回没有价格（空prod_price字段，不是价格为0）的所有产品<br>SELECT prod_name<br>FROM products<br>WHERE prod_price IS NULL;</p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>《MySQL必知必会》</tag>
      </tags>
  </entry>
  <entry>
    <title>5层参考模型</title>
    <url>/2020/08/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/5%E5%B1%82%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<p>5层参考模型：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosdi35si1j31ps0neh2v.jpg"></p>
<p>5层参考模型的数据封装与解封装：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosdie2kd5j31ps0mqdxt.jpg"></p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>计算机网络原理</tag>
      </tags>
  </entry>
  <entry>
    <title>ARP协议</title>
    <url>/2020/07/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/ARP%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<p>ARP协议：</p>
<p>发送数据的过程：<br>1）从主机1—&gt;主机3<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosjxkzb84j312n0frgtr.jpg"><br>2）从主机1—&gt;主机5<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosjxsi66wj312w0gidos.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosjxzyw0dj312k0g7wn2.jpg"></p>
<p>由于在实际网络的链路上传送数据帧时，最终必须使用MAC地址</p>
<p>ARP协议：完成主机或路由器IP地址到MAC地址的映射（解决下一跳走哪的问题）</p>
<p>ARP协议使用过程：检查ARP高速缓存，有对应表项则写入MAC帧，没有则用目的MAC地址为FF-FF-FF-FF-FF-FF的帧封装并广播ARP请求分组，同一局域网中所有主机都能收到该请求。目的主机收到请求后就会向源主机单播一个ARP响应分组，源主机收到后将此映射写入ARP缓存（10～20min更新一次）</p>
<p>ARP协议的4种典型情况（ARP协议自动进行）：<br>1）主机A发给本网络上的主机B：用ARP找到主机B的硬件地址<br>2）主机A发给另一网络上的主机B：用ARP找到本网络上一个路由器（网关）的硬件地址<br>3）路由器发给本网络的主机A：用ARP找到主机A的硬件地址<br>4）路由器发给另一网络的主机B：用ARP找到本网络上的一个路由器的硬件地址</p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>计算机网络原理</tag>
      </tags>
  </entry>
  <entry>
    <title>ALOHA协议</title>
    <url>/2020/08/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/ALOHA%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<p>ALOHA协议：</p>
<p>1）纯ALOHA协议：不监听信道，不按时间槽发送，随机重发【想发就发】<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goseghu845j311q0em0z0.jpg"></p>
<p>2）时隙ALOHA协议：把时间分成若干个相同的时间片，所有用户在时间片开始时刻同步接入网络信道，若发生冲突，则必须等到下一个时间片开始时刻再发送【控制想发就发的随意性】<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosegr4c4ej30u208pdi4.jpg"></p>
<p>纯ALOHA协议比时隙ALOHA吞吐量更低，效率更低<br>纯ALOHA想发就发，时隙ALOHA只有在时间片段开始时才能发</p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>计算机网络原理</tag>
      </tags>
  </entry>
  <entry>
    <title>7层OSI参考模型</title>
    <url>/2020/08/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/7%E5%B1%82OSI%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<p>7层OSI参考模型：</p>
<p>为了支持异构网络系统的互联互通，国际标准化组织ISO于1984年提出开放系统互连（OSI）参考模型<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosdf621cnj30zb0jak0i.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosdfhtxqmj31580u07wh.jpg"></p>
<p>应用层：用户与网络的界面，所有能和用户交互产生网络流量的程序【文件传输(FTP)、电子邮件(SMTP)、万维网(HTTP)】</p>
<p>表示层：用于处理在两个通信系统中交换信息的表示方式（语法和语义）【功能：数据格式变换、数据加密解密、数据压缩和恢复】【主要协议：JPEG、ASCII】</p>
<p>会话层：向表示层实体/用户进程提供建立连接并在连接上有序的传输数据，这是会话，也是建立同步(SYN)【功能：建立、管理、终止会话；使用校验点可使会话在通信失效时从校验点/同步点继续恢复通信，实现数据同步，适用于传输大文件】【主要协议：ADSP、ASP】</p>
<p>传输层：负责主机中两个进程的通信，即端到端的通信，传输单位是报文段或用户数据段【功能：可靠传输、不可靠传输；差错控制；流量控制；复用分用(复用：多个应用层进程可同时使用下面运输层的服务；分用：运输层把收到的信息分别交付给上面应用层中相应的进程)】【主要协议：TCP、UDP】</p>
<p>网络层：主要任务是把分组从源端传到目的端，为分组交换网上的不同主机提供通信服务，网络层传输单位是数据报【功能：路由选择、最佳路径；流量控制；差错控制；拥塞控制(若所有结点都来不及接受分组，而要丢弃大量分组的话，网络就处于拥塞状态。因此要采取一定措施，缓解这种拥塞)】【主要协议：IP、IPX、ICMP、IGMP、ARP、RARP、OSPF】</p>
<p>数据链路层：主要任务是把网络层传下来的数据报组装成帧，数据链路层/链路层的传输单位是帧【功能：成帧(定义帧的开始和结束)；差错控制(帧错+位错)；流量控制；访问(接入)控制(控制对信道的访问)】【主要协议：SDLC、HDLC、PPP、STP】</p>
<p>物理层：主要任务是在物理媒体上实现比特流的透明传输，物理层传输单位是比特(透明传输：指不管所传数据是什么样的比特组合，都应当能够在链路上传送)【功能：定义接口特性；定义传输模式(单工、半双工、双工)；定义传输速率；比特同步；比特编码】【主要协议：Rj45、802.3】</p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>计算机网络原理</tag>
      </tags>
  </entry>
  <entry>
    <title>4层TCP/IP参考模型</title>
    <url>/2020/08/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/4%E5%B1%82TCP:IP%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<p>4层TCP/IP参考模型：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosdgrtb77j31fj0j814m.jpg"></p>
<p>OSI参考模型与TCP/IP参考模型：</p>
<p>相同点：<br>1）都分层<br>2）基于独立的协议栈的概念<br>3）可以实现异构网络互联</p>
<p>不同点：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosdh3m5lmj31ps0n3e0c.jpg"></p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>计算机网络原理</tag>
      </tags>
  </entry>
  <entry>
    <title>BGP协议</title>
    <url>/2020/07/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/BGP%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<p>BGP协议：</p>
<p>1）和谁交换：与其他AS的邻站BGP发言人交换信息<br>2）交换什么：交换的网络可达性的信息，即要到达某个网络所要经过的一系列AS<br>3）多久交换：发生变化时更新有变化的部分<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosknk14ohj30rp0b745d.jpg"></p>
<p>BGP协议交换信息的过程：BGP所交换的网络可达性的信息就是要到达某个网络所要经过的一系列AS，当BGP发言人互相交换了网络可达性的信息后，各BGP发言人就根据所采用的策略从收到的路由信息中找出到达各AS的较好路由<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosknt7c0qj310q0frjzo.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosko15hwsj30y10h3wn0.jpg"></p>
<p>BGP协议报文格式：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goskob3jaaj312m0gadoj.jpg"></p>
<p>BGP协议特点：<br>1）BGP支持CIDR，因此BGP的路由表也就应当包括目的网络前缀、下一跳路由器，以及到达该目的网络所要经过的各个自治系统序列<br>2）在BGP刚刚运行时，BGP的邻站是交换整个的BGP路由表，但以后只需要在发生变化时更新有变化的部分，这样做对节省网络带宽和减少路由器的处理开销都有好处</p>
<p>BGP-4的四种报文：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goskomnp20j30wn06kn1h.jpg"></p>
<p>三种路由协议比较：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goskoxtkrxj311w06wgq4.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goskp5u6ctj311p0blgrw.jpg"></p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>计算机网络原理</tag>
      </tags>
  </entry>
  <entry>
    <title>CSMA-CA协议</title>
    <url>/2020/08/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/CSMA-CA%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<p>CSMA-CA协议：</p>
<p>载波监听多点接入/碰撞避免CSMA/CA</p>
<p>为什么有了CSMA-CD后还要有CSMA-CA：CSMA-CA多用于无线局域网，无线局域网无法做到360度全面检测碰撞、隐蔽站(当A和C都检测不到信号，认为信道空闲时，同时像终端B发送数据帧，就会导致冲突)</p>
<p>CSMA-CA协议工作原理：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goseyqx7iqj310h0c8doe.jpg"></p>
<p>CSMA-CD与CSMA-CA：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goseyywzz6j310d0ac46u.jpg"></p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>计算机网络原理</tag>
      </tags>
  </entry>
  <entry>
    <title>CSMA-CD协议</title>
    <url>/2020/08/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/CSMA-CD%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<p>CSMA-CD协议：</p>
<p>载波监听多点接入/碰撞检测CSMA/CD</p>
<p>CS：载波监听，每一个站在发送数据之前以及发送数据时都要检测一下总线上是否有其他计算机在发送数据</p>
<p>MA：多点接入，表示许多计算机以多点接入的方式连接在一根总线上（总线型网络）</p>
<p>CD：碰撞检测（冲突检测），“边发送边监听”，适配器边发送数据边检测信道上信号电压的变化情况，以便判断自己在发送数据时其他站是否也在发送数据（半双工网络）</p>
<p>先听后发为什么还会冲突：因为电磁波在总线上总是以有限的速率传播的</p>
<p>传播时延对载波监听的影响：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosejiwuzaj313d0i5wpx.jpg"></p>
<p>如何确定碰撞后的重传时机：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosejs3s7jj31150fkqez.jpg"></p>
<p>最小帧长问题：A站发了一个很短的帧，但发生了碰撞，不过帧在发送完毕后才检测到发生碰撞，没法停止发送，因为已经发完了。。。<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosek8exnrj30fw08n401.jpg"></p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>计算机网络原理</tag>
      </tags>
  </entry>
  <entry>
    <title>CSMA协议</title>
    <url>/2020/08/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/CSMA%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<p>CSMA协议：</p>
<p>载波监听多路访问协议CSMA</p>
<p>CS：载波监听，每一个站在发送数据之前要检测一下总线上是否有其他计算机在发送数据【当几个站同时在总线上发送数据时，总线上的信号电压摆动值将会增大(互相叠加)，当一个站检测到的信号电压摆动值超过一定门限值时，就认为总线上至少有两个站同时在发送数据，表明产生了碰撞，即发生了冲突】</p>
<p>MA：多点接入，表示许多计算机以多点接入的方式连接在一根总线上</p>
<p>协议思想：发送帧之前，监听信道</p>
<p>监听结果：<br>1）信道空闲：发送完整帧【1-坚持CSMA、非坚持CSMA、p-坚持CSMA】<br>2）信道忙：推迟发送</p>
<p>1-坚持CSMA：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosehvypu9j312b0a1gs6.jpg"></p>
<p>非坚持CSMA：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosei4q9m8j30vq08mwjx.jpg"></p>
<p>p-坚持CSMA：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goseick36fj30w30b9jyd.jpg"></p>
<p>有没有什么办法可以减少资源浪费，一冲突就能发现呢？？</p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>计算机网络原理</tag>
      </tags>
  </entry>
  <entry>
    <title>IPv4地址</title>
    <url>/2020/07/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/IPv4%E5%9C%B0%E5%9D%80/</url>
    <content><![CDATA[<p>IPv4地址：</p>
<p>IP编址的历史阶段：<br>1）分类的IP地址<br>2）子网的划分<br>3）构成超网（无分类编址方法）</p>
<p>——————————————————</p>
<p>分类的IP地址：</p>
<p>IP地址：全世界唯一的32位/4字节标识符，标识路由器主机的接口【&lt;网络号&gt;&lt;主机号&gt;】</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosjorjhnyj30ge02vmxf.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosjp1yyanj30v80ejwj8.jpg"></p>
<p>特殊IP地址：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosjpb7m25j31000htth6.jpg"></p>
<p>私有IP地址：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosjpjgbiaj30r109s767.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosjpr56nqj312r058goh.jpg"></p>
<p>——————————————</p>
<p>路由器对目的地址是私有IP地址的数据报一律不进行转发</p>
<p>网络地址转换NAT：在专用网连接到因特网的路由器上安装NAT软件，安装了NAT软件的路由器叫NAT路由器，它至少有一个有效的外部全球IP地址<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosjq1osg4j311k0ff482.jpg"></p>
<p>—————————————</p>
<p>子网划分和子网掩码：</p>
<p>分类的IP地址的弱点：<br>1）IP地址空间的利用率有时很低<br>2）两级IP地址不够灵活</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosjqxnqvhj30ge08qgmv.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosjr64e9zj311w0i3n62.jpg"></p>
<p>子网掩码（相与：相同为1，不同为0）：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosjrfbgijj30wn0giahe.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosjrmkrr0j30ii0dbtaj.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosjsj4jiuj30ge0jvmzz.jpg"></p>
<p>使用子网时分组的转发：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosjsxfyj7j313y0hugvy.jpg"></p>
<p>———————————————</p>
<p>无分类编址CIDR：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosjtng9xsj30ge0idtby.jpg"></p>
<p>构成超网：将多个子网聚合成一个较大的子网，叫做构成超网，或路由聚合</p>
<p>方法：将网络前缀缩短<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosjtzkt3ej30sc0b70xd.jpg"></p>
<p>最长前缀匹配：使用CIDR时，查找路由表可能得到几个匹配结果，应选择具有最长网络前缀的路由，前缀越长，地址块越小，路由越具体<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosjurtsp9j30ge0dhabz.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosjveu82qj30ge08mwgf.jpg"></p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>计算机网络原理</tag>
      </tags>
  </entry>
  <entry>
    <title>ICMP协议</title>
    <url>/2020/07/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/ICMP%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<p>ICMP协议：</p>
<p>TCP/IP协议栈：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosk0m22eoj30jt0dwacj.jpg"><br>ICMP协议：为了更有效的转发IP数据报和提高交付成功的机会</p>
<p>网际控制报文协议ICMP：ICMP协议支持主机或路由器：差错（或异常）报告、网络探询，发送特定ICMP报文【ICMP差错报文、ICMP询问报文】<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosk0v92k8j30rc0cvag4.jpg"></p>
<p>ICMP差错报告报文：<br>1）终点不可达：当路由器或主机不能交付数据报时就向源点发送终点不可达报文【无法交付】<br>2）源点抑制：当路由器或主机由于拥塞而丢弃数据报时，就向源点发送源点抑制报文，使源点知道应当把数据报的发送速率放慢【拥塞丢数据】<br>3）时间超过：当路由器收到生存时间TTL=0的数据报时，除丢弃该数据报外，还要向源点发送时间超过报文。当终点在预先规定的时间内不能收到一个数据报的全部数据报片时，就把已收到的数据报片都丢弃，并向源点发送时间超过报文【TTL=0】<br>4）参数问题：当路由器或目的主机收到的数据报的首部中有的字段的值不正确时，就丢弃该数据报，并向源点发送参数问题报文【首部字段有问题】<br>5）改变路由（重定向）：路由器把改变路由报文发送给主机，让主机知道下次应将数据报发送给另外的路由器（可通过更好的路由）【值得更好的路由】</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosk15speuj30uf0cn7b8.jpg"></p>
<p>不应发送ICMP差错报文的情况：<br>1）对ICMP差错报告报文不再发送ICMP差错报告报文<br>2）对第一个分片的数据报片的所有后续数据报片都不发送ICMP差错报告报文<br>3）对具有组播地址的数据报都不发送ICMP差错报告报文【广播是一对全部；组播是一对多，有选择性的】<br>4）对具有特殊地址（如127.0.0.0或0.0.0.0）的数据报不发送ICMP差错报告报文</p>
<p>ICMP询问报文：<br>1）回送请求和回答报文：主机或路由器向特定目的主机发出的询问，收到此报文的主机必须给源主机或路由器发送ICMP回送回答报文【测试目的站是否可达以及了解其相关状态】<br>2）时间戳请求和回答报文：请某个主机或路由器回答当前的日期和时间【用来进行时钟同步和测量时间】<br>3）掩码地址请求和回答报文<br>4）路由器询问和通告报文</p>
<p>ICMP的应用：<br>1）PING：测试两个主机之间的连通性，使用了ICMP回送请求和回答报文<br>2）Traceroute：跟踪一个分组从源点到终点的路径，使用了ICMP时间超过差错报告报文</p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>计算机网络原理</tag>
      </tags>
  </entry>
  <entry>
    <title>IPv6</title>
    <url>/2020/07/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/IPv6/</url>
    <content><![CDATA[<p>IPv6：</p>
<p>为什么有IPv6：<br>1）32位IPv4地址空间已分配殆尽，CIDR、NAT治标不治本；IPv6从根本上解决了地址耗尽问题<br>2）改进首部格式<br>3）快速处理/转发数据报<br>4）支持QoS<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosk2n3kkqj30dl04vtah.jpg"></p>
<p>IPv6数据报格式：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosk335ivej30w108mgpv.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosk3tyn6fj30ge0g477h.jpg"></p>
<p>IPv6和IPv4：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosk46kdd4j311h0din68.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosk4tj6pmj30ge0btwg6.jpg"></p>
<p>IPv6基本地址类型：<br>1）单播：一对一通信，可做源地址+目的地址<br>2）多播：一对多通信，可做目的地址<br>3）任播：一对多中的一个通信，可做目的地址</p>
<p>IPv6向IPv4过渡的策略：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosk7socfpj311c0gi49p.jpg"></p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>计算机网络原理</tag>
      </tags>
  </entry>
  <entry>
    <title>IP数据报格式</title>
    <url>/2020/07/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/IP%E6%95%B0%E6%8D%AE%E6%8A%A5%E6%A0%BC%E5%BC%8F/</url>
    <content><![CDATA[<p>IP数据报格式：</p>
<p>TCP/IP协议栈：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosjjtwyb4j30jt0dwacj.jpg"></p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosjkm3qhmj30ge0d3mz3.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosjl4k421j30ge0bfad4.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosjljkpd2j30ge09mdht.jpg"></p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>计算机网络原理</tag>
      </tags>
  </entry>
  <entry>
    <title>IP数据报分片</title>
    <url>/2020/07/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/IP%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%88%86%E7%89%87/</url>
    <content><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosjmx9f9hj30ge09hjse.jpg"></p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>计算机网络原理</tag>
      </tags>
  </entry>
  <entry>
    <title>IP组播</title>
    <url>/2020/07/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/IP%E7%BB%84%E6%92%AD/</url>
    <content><![CDATA[<p>IP组播：</p>
<p>IP数据报的三种传输方式：<br>1）单播：单播用于发送数据包到单个目的地，且每发送一份单播报文都使用一个单播IP地址作为目的地址，是一种点对点传输方式<br>2）广播：广播是指发送数据包到同一广播域或子网内的所有设备的一种数据传输方式，是一种点对多点传输方式<br>3）组播(多播)：当网络中的某些用户需要特定数据时，组播数据发送者仅发送一次数据，借助组播路由协议为组播数据包建立组播分发树，被传递的数据到达距离用户端尽可能近的节点后才开始复制和分发，是一种点对多点传输方式<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goskqgqy1qj311e0hy47c.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goskqpmzprj31050huqc9.jpg"></p>
<p>IP组播地址：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goskqy50fij31220hxn7l.jpg"></p>
<p>硬件组播：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goskrjgwlvj31260gln81.jpg"></p>
<p>——————————————————</p>
<p>网际组管理协议IGMP：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosktfog4vj30z60hh7dv.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosktoaowlj30yp0ed42i.jpg"></p>
<p>IGMP工作的两个阶段：<br>1）某主机要加入组播组时，该主机向组播组的组播地址发送一个IGMP报文，声明自己要成为该组的成员；本地组播路由器收到IGMP报文后，要利用组播路由选择协议把这组成员关系发给因特网上的其他组播路由器<br>2）本地组播路由器周期性探寻本地局域网上的主机，以便知道这些主机是否还是组播组的成员；只要有一个主机对某个组响应，那么组播路由器就认为这个组是活跃的，如果经过几次探寻后没有一个主机响应，组播路由器就认为本网络上没有此组播组的主机，因此就不再把这组的成员关系发给其他的组播路由器</p>
<p>组播路由器知道的成员关系只是所连接的局域网中有无组播组的成员</p>
<p>组播路由选择协议目的是找出以源主机为根节点的组播转发树</p>
<p>构造树可以避免在路由器之间兜圈子</p>
<p>对不同的多播组对应于不同的多播转发树；同一个多播组，对不同的源点也会有不同的多播转发树<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosku2ty5yj30kx0dlaa9.jpg"></p>
<p>组播路由选择协议常使用的三种算法：<br>1）基于链路状态的路由选择<br>2）基于距离-向量的路由选择<br>3）协议无关的组播（稀疏/密集）</p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>计算机网络原理</tag>
      </tags>
  </entry>
  <entry>
    <title>DHCP协议</title>
    <url>/2020/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/DHCP%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<p>DHCP协议：</p>
<p>主机如何获得IP地址：<br>1）静态配置：IP地址、子网掩码、默认网关<br>2）动态配置：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosjz6ggh1j30bx07j0tw.jpg"></p>
<p>DHCP协议：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosjzfcv7gj313r0hlgwe.jpg"></p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>计算机网络原理</tag>
      </tags>
  </entry>
  <entry>
    <title>OSPF协议与链路状态算法</title>
    <url>/2020/07/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/OSPF%E5%8D%8F%E8%AE%AE%E4%B8%8E%E9%93%BE%E8%B7%AF%E7%8A%B6%E6%80%81%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>OSPF协议与链路状态算法：</p>
<p>开放最短路径优先OSPF协议：“开放”标明OSPF协议不是受某一家厂商控制，而是公开发表的；“最短路径优先”是因为使用了Dijkstra提出的最短路径算法SPF</p>
<p>OSPF最主要的特征就是使用分布式的链路状态协议<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goskl422gaj313t0av45t.jpg"></p>
<p>链路状态路由算法：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goskldmgksj312w0eo125.jpg"></p>
<p>OSPF的区域：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosklm1mbwj30zb0guk4j.jpg"></p>
<p>OSPF分组：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goskm3y2fhj30zu0a80te.jpg"></p>
<p>OSPF其他特点：<br>1）每隔30min，要刷新一次数据库中的链路状态<br>2）由于一个路由器的链路状态只涉及到与相连路由器的连通状态，因而与整个互联网的规模并无直接关系，因此当互联网规模很大时，OSPF协议要比距离向量协议RIP好很多<br>3）OSPF不存在坏消息传的慢的问题，它的收敛速度很快</p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>计算机网络原理</tag>
      </tags>
  </entry>
  <entry>
    <title>PPP协议和HDLC协议</title>
    <url>/2020/08/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/PPP%E5%8D%8F%E8%AE%AE%E5%92%8CHDLC%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<p>PPP协议和HDLC协议：</p>
<p>广域网：WAN，通常跨接很大的物理范围，所覆盖的范围从几十公里到几千公里，它能连接多个城市或国家，或横跨几个洲并能提供远距离通信，形成国际性的远程网络</p>
<p>广域网的通信子网主要使用分组交换技术，广域网的通信子网可以利用公用分组交换网、卫星通信网和无线分组交换网，它将分布在不同地区的局域网或计算机系统互连起来，达到资源共享的目的，如因特网（Internet）是世界范围内最大的广域网<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosfetx8q2j30w70bf0wl.jpg"></p>
<p>————————————</p>
<p>点对点协议PPP是目前使用最广泛的数据链路层协议，用户使用拨号电话接入因特网时一般都使用PPP协议</p>
<p>PPP协议只支持全双工链路</p>
<p>PPP协议应满足的要求：<br>1）简单：对于链路层的帧，无需纠错，无需序号，无需流量控制<br>2）封装成帧：帧定界符<br>3）透明传输：与帧定界符一样比特组合的数据应该如何处理：异步线路用字节填充，同步线路用比特填充<br>4）多种网络层协议：封装的IP数据报可以采用多种协议<br>5）多种类型链路：串行/并行，同步/异步，电/光<br>6）差错检测：错就丢弃<br>7）检测连接状态：链路是否正常工作<br>8）最大传送单元：数据部分最大长度MTU<br>9）网络层地址协商：知道通信双方的网络层地址<br>10）数据压缩协商</p>
<p>PPP协议无需满足的要求：<br>1）纠错<br>2）流量控制<br>3）序号<br>4）支持多点线路</p>
<p>PPP协议的三个组成部分：<br>1）一个将IP数据报封装到串行链路（同步串行/异步串行）的方法<br>2）链路控制协议LCP：建立并维护数据链路连接（身份验证）<br>3）网络控制协议NCP：PPP可支持多种网络层协议，每个不同的网络层协议都要一个相应的NCP来配置，为网络层协议建立和配置逻辑连接</p>
<p>PPP协议的状态图：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosff6jyuoj30nu0fjaex.jpg"></p>
<p>PPP协议的帧格式：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosffl3cllj30vo0ebagh.jpg"></p>
<p>———————————</p>
<p>HDLC协议：高级数据链路控制，是一个在同步网上传输数据、面向比特的数据链路层协议，它是由国际标准化组织ISO根据IBM公司的SDLC协议扩展开发而成的</p>
<p>数据报文可透明传输，用于实现透明传输的“0比特插入法”易于硬件实现</p>
<p>采用全双工通信</p>
<p>所有帧采用CRC检验，对信息帧进行顺序编号，可防止漏收或重份，传输可靠性高</p>
<p>HDLC的站：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosfg2jsnuj30z30be0zl.jpg"></p>
<p>HDLC的帧格式：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosfgf2mnzj30za0czn4h.jpg"></p>
<p>PPP协议和HDLC协议：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosfgrg2hej30rx0hqn43.jpg"></p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>计算机网络原理</tag>
      </tags>
  </entry>
  <entry>
    <title>UDP协议</title>
    <url>/2020/07/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/UDP%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<p>UDP协议：</p>
<p>用户数据报协议UDP只在IP数据报服务之上增加了很少功能，即复用分用和差错检测功能</p>
<p>UDP的主要特点：<br>1）UDP是无连接的，减少开销和发送数据之前的时延<br>2）UDP使用最大努力交付，即不保证可靠交付<br>3）UDP是面向报文的，适合一次性传输少量数据的网络应用<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosl2ei7slj30y908gjv1.jpg"><br>4）UDP无拥塞控制，适合很多实时应用<br>5）UDP首部开销小，8B，TCP 20B</p>
<p>UDP首部格式：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosl2npjmtj31290ds0xq.jpg"></p>
<p>UDP校验：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosl2z4lywj310q0cxq85.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosl37bx9rj31040hik28.jpg"></p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>计算机网络原理</tag>
      </tags>
  </entry>
  <entry>
    <title>RIP协议与距离向量算法</title>
    <url>/2020/07/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/RIP%E5%8D%8F%E8%AE%AE%E4%B8%8E%E8%B7%9D%E7%A6%BB%E5%90%91%E9%87%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>RIP协议与距离向量算法：</p>
<p>RIP是一种分布式的基于距离向量的路由选择协议，是因特网的协议标准，最大优点是简单</p>
<p>RIP协议要求网络中每一个路由器都维护从它自己到其他每一个目的网络的唯一最佳距离记录（即一组距离）</p>
<p>距离：通常为“跳数”，即从源端口到目的端口所经过的路由器个数，经过一个路由器跳数+1。特别的，从一路由器到直接连接的网络距离为1，RIP允许一条路由最多只能包含15个路由器，因此距离为16表示网络不可达</p>
<p>RIP协议只适用于小互联网<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goskeju1aij30zx0aljw4.jpg"></p>
<p>RIP协议：<br>1）仅和相邻路由器交换信息<br>2）路由器交换的信息是自己的路由表<br>3）每30s交换一次路由信息，然后路由器根据新信息更新路由表，若超过180s没收到邻居路由器的通告，则判定邻居没了，并更新自己路由表；路由器刚开始工作时，只知道直接连接的网络的距离（距离为1），接着每一个路由器也只和数目非常有限的相邻路由器交换并更新路由信息；经过若干次更新后，所有路由器最终都会知道到达本自治系统任何一个网络的最短距离和下一跳路由器的地址，即“收敛”</p>
<p>距离向量算法：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosket395yj312i0hl48f.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goskfejgkdj30fx0giad3.jpg"></p>
<p>RIP协议的报文格式：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goskftp5wwj313d0hlal5.jpg"></p>
<p>RIP的特点：当网络出现故障时，要经过比较长的时间（例如数分钟）才能将此信息传送到所有的路由，“慢收敛”<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goskge7cmpj30gj0cttb9.jpg"></p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>计算机网络原理</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP协议</title>
    <url>/2020/07/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/TCP%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<p>TCP协议：</p>
<p>——————————————</p>
<p>TCP协议特点和TCP报文段格式<br>TCP连接管理<br>TCP可靠传输<br>TCP流量控制<br>TCP拥塞控制</p>
<p>——————————————</p>
<p>TCP协议的特点：<br>1）TCP是面向连接（虚连接）的传输层协议<br>2）每一条TCP连接只能有两个端点，每一条TCP连接只能是点对点的<br>3）TCP提供可靠交付的服务，无差错、不丢失、不重复、按序到达【可靠有序，不丢不重】<br>4）TCP提供全双工通信：【发送缓存：准备发送的数据、已发送但尚未收到确认的数据；接收缓存：按序到达但尚未被接受应用程序读取的数据、不按序到达的数据】<br>5）TCP面向字节流：TCP把应用程序交下来的数据看成仅仅是一连串的无结构的字节流【流：流入到进程或从进程流出的字节序列】<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosl4s29f9j31280ef7a5.jpg"></p>
<p>TCP报文段首部格式：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosl58chpsj30gj0e1myz.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosl5wz7mrj30gj07mdi6.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosl6h81urj30gj0hhq87.jpg"><br>——————————————————</p>
<p>TCP连接管理：</p>
<p>TCP连接传输三个阶段：<br>1）连接建立<br>2）数据传送<br>3）连接释放</p>
<p>TCP连接的建立采用客户服务器方式，主动发起连接建立的应用进程叫做客户，而被动等待连接建立的应用进程叫服务器</p>
<p>TCP的连接建立(三次握手)：假设运行在一台主机（客户）上的一个进程想与另一台主机（服务器）上的一个进程建立一条连接，客户应用进程首先通知客户TCP，它想建立一个与服务器上某个进程之间的连接，客户中的TCP会用以下步骤与服务器中的TCP建立一条TCP连接：【seq：序号，ack：确认号】<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosl6snr8fj312r0dhq9j.jpg"></p>
<p>SYN洪泛攻击：【解决办法：SYN cookie】<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosl70q24oj30ul07244c.jpg"></p>
<p>TCP的连接释放(四次挥手)：参与一条TCP连接的两个进程中的任何一个都能终止该连接，连接结束后，主机中的“资源”（缓存和变量）将被释放<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosl79qn5tj313o0fpwn7.jpg"></p>
<p>————————————————</p>
<p>TCP可靠传输：</p>
<p>网络层：提供尽最大努力交付，不可靠传输<br>传输层：使用TCP实现可靠传输【如果使用UDP协议，则在应用层实现可靠传输】</p>
<p>可靠：保证接收方进程从缓存区读出的字节流与发送方发出的字节流是完全一样的</p>
<p>TCP实现可靠传输的机制：<br>1）校验：与UDP校验一样，增加伪首部<br>2）序号<br>3）确认：TCP默认使用累计确认<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosl8h724mj312n0ein4h.jpg"><br>4）重传：确认重传不分家，TCP的发送方在规定的时间内没有收到确认就要重传已发送的报文段【超时重传，TCP采用自适应算法，动态改变重传时间RTTs(加权平均往返时间)】</p>
<p>等太久了怎么办？？？<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosl8q47l9j30v10a7445.jpg"></p>
<p>—————————————————</p>
<p>TCP流量控制：让发送方慢点，要让接收方来得及接收</p>
<p>TCP利用滑动窗口机制实现流量控制</p>
<p>在通信过程中，接收方根据自己接收缓存的大小，动态的调整发送方的发送窗口大小，即接收窗口rwnd（接收方设置确认报文段的窗口字段来将rwnd通知给发送方），发送方的发送窗口取接收窗口rwnd和拥塞窗口cwnd的最小值【接收窗口：接收方根据接受缓存设置的值，并告知给发送方，反映接收方容量；拥塞窗口：发送方根据自己估算的网络拥塞程度而设置的窗口值，反映网络当前容量】<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosl92k8sdj31310gndr9.jpg"></p>
<p>这个时候假设B给A发了一个非零的rwnd，但是在路上丢失了，主机A在等着B发送非零窗口，主机B在等着A的确认消息，两者相互等待，造成死锁</p>
<p>解决方法：<br>1）TCP为每一个连接设有一个持续计时器，只要TCP连接的一方收到对方的零窗口通知，就启动持续计时器<br>2）若持续计时器设置的时间到期，就发送一个零窗口探测报文段，接收方收到探测报文段时给出现在的窗口值<br>3）若窗口仍然是0，那么发送方就重新设置持续计时器</p>
<p>————————————————</p>
<p>TCP拥塞控制：防止过多的数据注入到网络中【全局性】</p>
<p>出现拥塞的条件：对资源需求的总和&gt;可用资源【网络中有许多资源同时呈现供应不足—&gt;网络性能变坏—&gt;网络吞吐量将随输入负荷增大而下降】</p>
<p>拥塞控制四种算法：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosl9hagnxj30oh054dhr.jpg"><br>1）慢开始、拥塞避免<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosl9ovga8j31260efqae.jpg"><br>2）快重传、快恢复<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosl9yhkk7j310e0cpn4t.jpg"></p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>计算机网络原理</tag>
      </tags>
  </entry>
  <entry>
    <title>万维网和HTTP协议</title>
    <url>/2020/07/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E4%B8%87%E7%BB%B4%E7%BD%91%E5%92%8CHTTP%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<p>万维网和HTTP协议：</p>
<p>万维网WWW（World Wide Web）是一个大规模的、联机式的信息储藏所/资料空间，是无数个网络站点和网页的集合<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosljzzgmlj30gj0650tm.jpg"><br>用户通过点击超链接（<a href="http://www.baidu.com)获取资源,这些资源通过超文本传输协议http传送给使用者/">http://www.baidu.com）获取资源，这些资源通过超文本传输协议HTTP传送给使用者</a></p>
<p>万维网以客户/服务器方式工作，用户使用的浏览器就是万维网客户程序，万维网文档所驻留的主机运行服务器程序</p>
<p>万维网使用超文本标记语言HTML，使得万维网页面设计者可以很方便的从一个界面的链接转到另一个界面，并能够在自己的屏幕上显示出来</p>
<p>———————————————————</p>
<p>超文本传输协议HTTP：HTTP协议定义了浏览器（万维网客户进程）怎样向万维网服务器请求万维网文档，以及服务器怎样把文档传送给浏览器<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goslkbzmu3j312g0fkthb.jpg"></p>
<p>HTTP协议的特点：<br>1）HTTP协议是无状态的【但是在实际工作中，一些万维网站点常常希望能够识别用户（淘宝、Cookie），Cookie是存储在用户主机中的文本文件，记录一段时间内某用户（使用识别码识别，如“123456”）的访问记录、提供个性化服务】<br>2）HTTP采用TCP作为运输层协议，但HTTP协议本身是无连接的（通信双方在交换HTTP报文之前不需要先建立HTTP连接）</p>
<p>HTTP的连接方式：<br>1）持久连接(Keep-alive)：非流水线、流水线<br>2）非持久连接(Close)<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goslklh1zpj30xe0fkjw3.jpg"></p>
<p>HTTP报文结构：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goslkun779j31080gjtfy.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosll4jdn4j312a0i2akf.jpg"></p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>计算机网络原理</tag>
      </tags>
  </entry>
  <entry>
    <title>以太网</title>
    <url>/2020/08/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E4%BB%A5%E5%A4%AA%E7%BD%91/</url>
    <content><![CDATA[<p>以太网：</p>
<p>以太网(Ethernet)指的是由Xerox公司创建并由Xerox、Intel和DEC公司联合开发的基带总线局域网规范，是当今现有局域网采用的最通用的通信协议标准。以太网使用CSMA/CD技术</p>
<p>以太网在局域网各种技术中占统治性地位：<br>1）造价低廉(以太网网卡不到一百块)<br>2）是应用最广泛的局域网技术<br>3）比令牌环网、ATM网便宜，简单<br>4）满足网络速率要求：10Mb/s～10Gb/s</p>
<p>以太网两个标准：<br>1）DIX Ethernet V2:第一个局域网产品（以太网）规约<br>2）IEEE 802.3:IEEE 802委员会802.3工作组制定的第一个IEEE的以太网标准（帧格式有一点改动）</p>
<p>以太网提供无连接、不可靠的服务：<br>1）无连接：发送方和接收方之间无“握手过程”<br>2）不可靠：不对发送方的数据帧编号，接收方不向发送方进行确认，差错帧直接丢弃，差错纠正由高层负责</p>
<p>以太网只实现无差错接收，不实现可靠传输</p>
<p>以太网传输介质与拓扑结构的发展：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosf5yxwrfj30vk0eytfb.jpg"></p>
<p>10BASE-T以太网：10BASE-T是传送基带信号的双绞线以太网，T表示采用双绞线，现10BASE-T采用的是无屏蔽双绞线（UTP），传输速率是10Mb/s<br>1）物理上采用星型拓扑，逻辑上总线型，每段双绞线最长为100m<br>2）采用曼彻斯特编码<br>3）采用CSMA/CD介质访问控制</p>
<p>适配器与MAC地址：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosfaf879wj311b0cjjzs.jpg"></p>
<p>以太网MAC帧：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosfas36i2j30y70eowlv.jpg"></p>
<p>高速以太网：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosfb2r4s5j30uz0fn469.jpg"></p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>计算机网络原理</tag>
      </tags>
  </entry>
  <entry>
    <title>信道划分介质访问控制</title>
    <url>/2020/08/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E4%BF%A1%E9%81%93%E5%88%92%E5%88%86%E4%BB%8B%E8%B4%A8%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<p>信道划分介质访问控制：</p>
<p>传输数据使用的两种链路：<br>1）点对点链路：两个相邻节点通过一个链路相连，没有第三者。【应用：PPP协议，常用于广域网】<br>2）广播式链路：所有主机共享通信介质【应用：早期的总线以太网、无线局域网。常用于局域网】【典型拓扑结构：总线型、星型(逻辑总线型)】</p>
<p>介质访问控制：采取一定的措施，使得两对节点之间的通信不会发生相互干扰的现象<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosed7uczbj30gl08ctb5.jpg"><br>信道划分介质访问控制：将使用介质的每个设备与来自同一信道上的其他设备的通信隔离开，把时域和频域资源合理的分配给网络上的设备<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosedhfmlyj31250fsn65.jpg"></p>
<p>1）频分多路复用FDM<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosedrja3nj311j0dbtfk.jpg"></p>
<p>2）时分多路复用TDM<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosedzx8s1j31100d4tfj.jpg"></p>
<p>3）改进的时分复用—统计时分复用STDM<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goseea5voxj313h0fp7cg.jpg"></p>
<p>4）波分多路复用WDM：波分多路复用就是光的频分多路复用，在一根光纤中传输多种不同波长（频率）的光信号，由于波长（频率）不同，所以各路光信号互不干扰，最后再用波长分解复用器将各路波长分解出来<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goseejjw8pj30o008gtap.jpg"></p>
<p>5）码分多路复用CDM：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosef2iaq9j30gl0gngoy.jpg"></p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>计算机网络原理</tag>
      </tags>
  </entry>
  <entry>
    <title>分层结构、协议、接口、服务</title>
    <url>/2020/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E5%88%86%E5%B1%82%E7%BB%93%E6%9E%84%E3%80%81%E5%8D%8F%E8%AE%AE%E3%80%81%E6%8E%A5%E5%8F%A3%E3%80%81%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<p>分层结构、协议、接口、服务：</p>
<p>发送文件前要完成的工作：<br>1）发起通信的计算机必须将数据通信的通路进行激活<br>2）要告诉网络如何识别目的主机<br>3）发起通信的计算机要查明目的主机是否开机，并且与网络连接正常<br>4）发起通信的计算机要弄清楚，对方计算机中文件管理程序是否已经做好准备工作<br>5）确保差错和意外可以解决</p>
<p>分层的基本原则：<br>1）各层之间相互独立，每层只实现一种相对独立的功能<br>2）每层之间界面自然清晰，易于理解，相互交流尽可能少<br>3）结构上可分割开，每层都采用最合适的技术来实现<br>4）保持下层对上层的独立性，上层单向使用下层提供的服务<br>5）整个分层结构应该能促进标准化工作<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosde45ld4j31ps0qvh9t.jpg"></p>
<p>1）网络体系结构是从功能上描述计算机网络结构<br>2）计算机网络体系结构简称网络体系结构，是分层结构<br>3）每层遵循某个/些网络协议以完成本层功能<br>4）计算机网络体系结构是计算机网络的各层及其协议的集合<br>5）第n层在向n+1层提供服务时，此服务不仅包含第n层本身的功能，还包含由下层服务提供的功能<br>6）仅仅在相邻层间有接口，且所提供服务的具体实现细节对上一层完全屏蔽<br>7）体系结构是抽象的，而实现是指能运行的一些软件和硬件</p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>计算机网络原理</tag>
      </tags>
  </entry>
  <entry>
    <title>传输层概述</title>
    <url>/2020/07/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E4%BC%A0%E8%BE%93%E5%B1%82%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<p>传输层概述：</p>
<p>传输层：只有主机才有的层次，为应用层提供通信服务，使用网络层的服务</p>
<p>传输层的功能：<br>1）传输层提供进程和进程之间的逻辑通信，网络层提供主机之间的逻辑通信<br>2）复用和分用<br>3）传输层对收到的报文进行差错检测<br>4）传输层的两种协议</p>
<p>1）面向连接的传输控制协议TCP：传送数据之前必须建立连接，数据传送结束后要释放连接，不提供广播或多播服务，由于TCP要提供可靠的面向连接的传输服务，因此不可避免增加了许多开销：确认、流量控制、计时器及连接管理等【可靠，面向连接，时延大，适用于大文件】<br>2）无连接的用户数据报协议UDP：传送数据前不需要建立连接，收到UDP报文后也不需要给出任何确认【不可靠，无连接，时延小，适用于小文件】</p>
<p>传输层的寻址与端口：</p>
<p>复用：应用层所有的应用进程都可以通过传输层再传输到网络层<br>分用：传输层从网络层收到数据后交付指明的应用进程</p>
<p>端口是传输层的SAP，标识主机中的应用进程【逻辑端口/软件端口】</p>
<p>端口号只有本地意义，在因特网中不同计算机的相同端口是没有联系的</p>
<p>端口号长度为16bit，能表示65536个不同的端口号<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosl1f13e7j30gj09f404.jpg"><br>在网络中采用发送方和接收方的套接字组合来识别端点，套接字唯一标识了网络中的一个主机和它上面的一个进程</p>
<p>套接字Socket=（主机IP地址，端口号）</p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>计算机网络原理</tag>
      </tags>
  </entry>
  <entry>
    <title>奈式准则和香农定理</title>
    <url>/2020/08/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E5%A5%88%E5%BC%8F%E5%87%86%E5%88%99%E5%92%8C%E9%A6%99%E5%86%9C%E5%AE%9A%E7%90%86/</url>
    <content><![CDATA[<p>奈式准则和香农定理：</p>
<p>失真：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosdnj0jstj31ps0nv4hk.jpg"></p>
<p>失真的一种现象：码间串扰（接收端收到的信号波形失去了码元之间清晰界限的现象）<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosdnroynrj31d40ifwq8.jpg"></p>
<p>奈式准则（奈奎斯特定理）：在理想低通（无噪声，带宽受限）条件下，为了避免码间串扰，极限码元传输速率为2W Baud，W是信道带宽，单位是Hz【只有在这两个公式这带宽才用Hz】</p>
<p>理想低通信道下的极限数据传输率=2Wlog2V（b/s）</p>
<p>1）在任何信道中，码元传输的速率是有上限的，若传输速率超过此上限，就会出现严重的码间串扰问题，使接收端对码元的完全正确识别成为不可能<br>2）信道的频带越宽（即能通过的信号高频分量越多），就可以用更高的速率进行码元的有效传输<br>3）奈式准则给出了码元传输速率的限制，但并没有对信息传输速率给出限制<br>4）由于码元的传输速率受奈式准则的制约，所以要提高数据的传输速率，就必须设法使每个码元能携带更多个比特的信息量，这就需要采用多元制的调制方法</p>
<p>香农定理：</p>
<p>噪声存在于所有的电子设备和通信信道中，由于噪声随机产生，它的瞬时值有时会很大，因此噪声会使接收端对码元的判决产生错误。但是噪声的影响是相对的，若信号较强，那么噪声影响相对较小。因此信噪比就很重要</p>
<p>信噪比=信号的平均功率/噪声的平均功率，常记为S/N，并用分贝（dB）作为度量单位，即：<br>信噪比（dB）=10log10(S/N)【注意题目中有没有dB这个单位】</p>
<p>香农定理：在带宽受限且有噪声的信道中，为了不产生误差，信息的数据传输速率有上限值</p>
<p>信道的极限数据传输速率=Wlog2(1+S/N)(b/s)</p>
<p>1）信道的带宽或信道中的信噪比越大，则信息的极限传输速率就越高<br>2）对一定的传输带宽和一定的信噪比，信息传输速率的上限就确定了<br>3）只要信息的传输速率低于信道的极限传输速率，就一定能找到某种方法来实现无差错的传输<br>4）香农定理得出的为极限信息传输速率，实际信道能达到的传输速率要比它低不少<br>5）从香农定理可以看出，若信道带宽W或信噪比S/N没有上限（不可能），那么信道的极限信息传输速率也就没有上限</p>
<p>取最小值：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosdnzxwyoj31c00aun3z.jpg"></p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>计算机网络原理</tag>
      </tags>
  </entry>
  <entry>
    <title>域名解析系统DNS</title>
    <url>/2020/07/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E7%B3%BB%E7%BB%9FDNS/</url>
    <content><![CDATA[<p>域名解析系统DNS：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosldjprthj30gj09q404.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosldrldmej30l60f3di2.jpg"></p>
<p>———————————————————</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosle7lj4tj30gj0dz77g.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosletw8dlj312i0fjgtr.jpg"></p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>计算机网络原理</tag>
      </tags>
  </entry>
  <entry>
    <title>封装成帧和透明传输</title>
    <url>/2020/08/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E5%B0%81%E8%A3%85%E6%88%90%E5%B8%A7%E5%92%8C%E9%80%8F%E6%98%8E%E4%BC%A0%E8%BE%93/</url>
    <content><![CDATA[<p>封装成帧和透明传输：</p>
<p>封装成帧就是在一段数据的前后部分添加首部和尾部，这样就构成了一个帧。接收端在收到物理层上交的比特流后，就能根据首部和尾部的标记，从收到的比特流中识别帧的开始和结束</p>
<p>首部和尾部包含许多的控制信息，他们的一个重要作用：帧定界（确定帧的界限）</p>
<p>帧同步：接收方应当能从接收到的二进制比特流中区分出帧的起始和终止</p>
<p>组帧的四种方法：字符计数法、字符（节）填充法、零比特填充法、违规编码法<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosdyi6kj4j31710ein3z.jpg"></p>
<p>透明传输是指不管所传数据是什么样的比特组合，都应当能够在链路上传送。因此，链路层就“看不见”有什么妨碍数据传输的东西</p>
<p>当所传数据中的比特组合恰巧与某一个控制信息完全一样时，就必须采取适当的措施，使收方不会将这样的数据误认为是某种控制信息。这样才能保证数据链路层的传输是透明的</p>
<p>字符计数法：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosdyr3a3gj31cz0ion6z.jpg"></p>
<p>字符填充法：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosdz15fjjj31ju0mu4gz.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosdzbjxu4j31ps0pl4f1.jpg"></p>
<p>零比特填充法：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosdzkpa2tj31ps0nv1cl.jpg"></p>
<p>违规编码法：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosdzxw0oaj31ps0hen58.jpg"></p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>计算机网络原理</tag>
      </tags>
  </entry>
  <entry>
    <title>局域网基本概念和体系结构</title>
    <url>/2020/08/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E5%B1%80%E5%9F%9F%E7%BD%91%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<p>局域网基本概念和体系结构：</p>
<p>局域网：简称LAN，是指在某一区域内由多台计算机互联成的计算机组，使用广播信道</p>
<p>特点：<br>1）覆盖的地理范围较小，只在一个相对独立的局部范围内联，如一座或集中的建筑群内<br>2）使用专门铺设的传输介质（双绞线、同轴电缆）进行联网，数据传输速率高（10Mb/s～10Gb/s）<br>3）通信延迟时间短，误码率低，可靠性较高<br>4）各站为平等关系，共享传输信道<br>5）多采用分布式控制和广播式通信，能进行广播和组播</p>
<p>决定局域网的主要要素为：网络拓扑、传输介质、介质访问控制方法</p>
<p>局域网拓扑结构：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosf30a7sjj30y90hfwp9.jpg"></p>
<p>局域网传输介质：<br>1）有线局域网：双绞线、同轴电缆、光纤<br>2）无线局域网：电磁波</p>
<p>局域网介质访问控制方法：<br>1）CSMA-CD：常用于总线型局域网，也用于树型网络<br>2）令牌总线：常用于总线型局域网，也用于树型网络；它是把总线型或树型网络中的各个工作站按一定的顺序如按接口地址大小排列形成一个逻辑环，只有令牌持有者才能控制总线，才有发送信息的权力<br>3）令牌环：用于环形局域网，如令牌环网</p>
<p>局域网的分类：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosf3e1dc4j310l0c0n6j.jpg"></p>
<p>IEEE 802标准：<br>1）IEEE 802.3:以太网<br>2）IEEE 802.5:令牌环网<br>3）IEEE 802.8:光纤<br>4）IEEE 802.11:无线局域网</p>
<p>MAC子层和LLC子层：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosf3ur1grj313m0f2121.jpg"></p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>计算机网络原理</tag>
      </tags>
  </entry>
  <entry>
    <title>差错控制</title>
    <url>/2020/08/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E5%B7%AE%E9%94%99%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<p>差错控制：</p>
<p>概括来说，传输中的差错都是由于噪声引起的</p>
<p>1）全局性：由于线路本身电气特性所产生的随机噪声(热噪声)，是信道固有的，随机存在的【解决办法：提高信噪比来减少或避免干扰(对传感器下手)】<br>2）局部性：外界特定的短暂原因所造成的冲击噪声，是产生差错的主要原因【解决办法：通常利用编码技术来解决】<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gose16ypnlj30si0bln27.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gose1hmfxyj31ps0rk1kx.jpg"></p>
<p>检错编码：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gose2vycf6j30g40je42w.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gose3c457gj30g404vjs6.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gose3l5w7fj30ht031di9.jpg"><br>纠错编码：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gose49qtlgj30g40ba76f.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gose4uvg1zj30gb09e764.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gose5bcklzj30gb0a140k.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gose5psn7dj30gb0e340u.jpg"></p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>计算机网络原理</tag>
      </tags>
  </entry>
  <entry>
    <title>数据通信基础知识</title>
    <url>/2020/08/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<p>数据通信基础知识：</p>
<p>典型的数据通信模型：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosdke837oj31ps0j8k94.jpg"></p>
<p>通信的目的是传送消息</p>
<p>数据：传送信息的实体，通常是有意义的符号序列</p>
<p>信号：数据的电气/电磁的表现，是数据在传输过程中的存在形式【数字信号：代表消息的参数取值是离散的；模拟信号：代表消息的参数取值是连续的】</p>
<p>信源：产生和发送数据的源头</p>
<p>信宿：接收数据的终点</p>
<p>信道：信号的传输媒介，一般用来表示向某一个方向传送信息的介质，因此一条通信线路往往包含一条发送信道和一条接收信道【按传输信号分：模拟信道(传送模拟信号)、数字信道(传送数字信号)；按传输介质分：无线信道、有线信道】</p>
<p>三种通信方式：<br>1）单工通信：只有一个方向的通信而没有反方向的交互，仅需要一条信道<br>2）半双工通信：通信的双方都可以发送或接收信息，但任何一方都不能同时发送和接收，需要两条信道<br>3）全双工通信：通信双方可以同时发送和接收信息，也需要两条信道</p>
<p>两种数据传输方式：<br>1）串形传输：速度慢，费用低，适合远距离<br>2）并行传输：速度快，费用高，适合近距离，用于计算机内部数据传输</p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>计算机网络原理</tag>
      </tags>
  </entry>
  <entry>
    <title>数据链路层基本概念</title>
    <url>/2020/08/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<p>数据链路层基本概念：</p>
<p>结点：主机、路由器</p>
<p>链路：网络中两个结点之间的物理通道，链路的传输介质主要有双绞线、光纤和微波，分为有线链路、无线链路</p>
<p>数据链路：网络中两个结点之间的逻辑通道，把实现控制数据传输协议的硬件和软件加到链路上就构成了数据链路</p>
<p>帧：链路层的协议数据单元，封装网络层数据报</p>
<p>数据链路层负责通过一条链路从一个结点向另一个物理链路直接相连的相邻结点传送数据报<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosdx3ehuoj30lk0iwq7z.jpg"></p>
<p>数据链路层功能概述：数据链路层在物理层提供服务的基础上向网络层提供服务，其最基本的服务是将源自网络层来的数据可靠的传输到相邻节点的目标机网络层。其主要作用是加强物理层传输原始比特流的功能，将物理层提供的可能出错的物理连接改造成为逻辑上无差错的数据链路，使之对网络层表现为一条无差错的链路</p>
<p>1）为网络层提供服务：无确认无连接服务【通信质量好，有线传输链路】、有确认无连接服务、有确认面向连接服务【有连接一定有确认】【通信质量差的无线传输链路】<br>2）链路管理，即连接的建立、维持、释放（用于面向连接的服务）<br>3）组帧<br>4）流量控制<br>5）差错控制（帧错/位错）</p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>计算机网络原理</tag>
      </tags>
  </entry>
  <entry>
    <title>文件传输协议FTP</title>
    <url>/2020/07/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AEFTP/</url>
    <content><![CDATA[<p>文件传输协议FTP：</p>
<p>文件传送协议：<br>1）文件传送协议FTP(File Transfer Protocol)：提供不同种类主机系统（硬、软件体系等都可以不同）之间的文件传输能力【拷贝：上传、下载】<br>2）简单文件传送协议TFTP</p>
<p>FTP服务器和用户端：<br>1）FTP是基于客户/服务器（C/S）的协议<br>2）用户通过一个客户机程序连接至在远程计算机上运行的服务器程序<br>3）依照FTP协议提供服务，进行文件传送的计算机就是FTP服务器<br>4）连接FTP服务器，遵循FTP协议与服务器传送文件的电脑就是FTP客户端</p>
<p>FTP工作原理：<br>1）登陆：FTP地址、用户名、密码<br>匿名登陆：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goslfplvsdj30pl060gq5.jpg"><br>2）FTP使用TCP实现可靠传输<br>【FTP服务器进程：一个主进程、n个从属进程】【控制进程和数据传送进程都属于从属进程】<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goslfxnqelj313m0angra.jpg"></p>
<p>FTP传输模式：<br>1）文本模式：ASCII模式，以文本序列传输数据<br>2）二进制模式：Binary模式，以二进制序列传输数据</p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>计算机网络原理</tag>
      </tags>
  </entry>
  <entry>
    <title>时延、时延带宽积、往返时间RTT、利用率</title>
    <url>/2020/08/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E6%97%B6%E5%BB%B6%E3%80%81%E6%97%B6%E5%BB%B6%E5%B8%A6%E5%AE%BD%E7%A7%AF%E3%80%81%E5%BE%80%E8%BF%94%E6%97%B6%E9%97%B4RTT%E3%80%81%E5%88%A9%E7%94%A8%E7%8E%87/</url>
    <content><![CDATA[<p>时延、时延带宽积、往返时间RTT、利用率</p>
<p>时延：指数据（报文/分组/比特流）从网络（或链路）的一端传送到另一端所需的时间，也叫延迟或迟延，单位是s</p>
<p>1）发送时延（传输时延）：从发送分组的第一个比特算起，到该分组的最后一个比特发送完毕所需的时间【计算公式：数据长度/信道带宽（发送速率）】<br>2）传播时延：取决于电磁波传播速度和链路长度【公式：信道长度/电磁波在信道上的传播速率】<br>3）排队时延：等待输出/入链路可用<br>4）处理时延：检错、找出口</p>
<p>高速链路只是提高了信道带宽，减小了发送时延，但是传播时延和传播速率是不变的</p>
<p>时延带宽积（bit）：传播时延（s）*带宽（b/s），又称为以比特为单位的链路长度，即“某段链路现在有多少比特”</p>
<p>往返时延RTT：从发送方发送数据开始，到发送方收到接收方的确认（接收方收到数据后立即发送确认），总共经过的时延；RTT越大，在收到确认之前，可以发送的数据越多</p>
<p>RTT包括：往返传播时延=传播时延*2、末端处理时间【不包括发送时延】</p>
<p>利用率：信道利用率【有数据通过时间/有+无数据通过时间】、网络利用率（信道利用率加权平均值）<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosdcy4qalj30ie0c80um.jpg"></p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>计算机网络原理</tag>
      </tags>
  </entry>
  <entry>
    <title>标准化</title>
    <url>/2020/08/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E6%A0%87%E5%87%86%E5%8C%96/</url>
    <content><![CDATA[<p>标准化：</p>
<p>要实现不同厂商的硬、软件之间相互连通，必须遵守统一的标准</p>
<p>标准的分类：<br>1）法定标准（由权威机构制定的正式的、合法的标准：OSI）<br>2）事实标准（某些公司的产品在竞争中占据了主流，时间长了，这些产品中的协议和技术就成了标准：TCP/IP）</p>
<p>RFC（Request For Comments）：因特网标准的形式</p>
<p>RFC要上升为因特网正式标准的四个阶段：<br>1）因特网草案：这个阶段还不是RFC文档<br>2）建议标准：从这个阶段开始成为RFC文档<br>3）因特网标准</p>
<p>标准化工作的相关组织：<br>1）国际标准化组织ISO：OSI参考模型、HDLC协议<br>2）国际电信联盟ITU：制定通信规则<br>3）国际电气电子工程师协会IEEE：学术机构、IEEE802系列标准、5G<br>4）Internet工程任务组IETF：负责因特网相关标准的制定</p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>计算机网络原理</tag>
      </tags>
  </entry>
  <entry>
    <title>无线局域网</title>
    <url>/2020/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E6%97%A0%E7%BA%BF%E5%B1%80%E5%9F%9F%E7%BD%91/</url>
    <content><![CDATA[<p>无线局域网：</p>
<p>IEEE 802.11是无线局域网通用的标准，它是由IEEE所定义的无线网络通信的标准<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosfcl3h58j30g809wjsr.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosfd20e2vj30x90bbn1j.jpg"></p>
<p>无线局域网的分类：<br>1）有固定基础设施无线局域网<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosfdc9eckj31100hfal4.jpg"><br>2）无固定基础设施无线局域网的自组织网络<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosfdkrx77j312w0f80xm.jpg"></p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>计算机网络原理</tag>
      </tags>
  </entry>
  <entry>
    <title>概念、功能、组成、分类</title>
    <url>/2020/08/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E6%A6%82%E5%BF%B5%E3%80%81%E5%8A%9F%E8%83%BD%E3%80%81%E7%BB%84%E6%88%90%E3%80%81%E5%88%86%E7%B1%BB/</url>
    <content><![CDATA[<p>概念、功能、组成、分类：</p>
<p>计算机网络：是一个将分散的、具有独立功能的计算机系统，通过通信设备与线路连接起来，由功能完善的软件实现资源共享和信息传递的系统</p>
<p>计算机网络是互连的【互联互通、通信链路】、自治的【无主从关系】计算机集合</p>
<p>计算机网络的功能：<br>1）数据通信（连通性）<br>2）资源共享（硬件、软件、数据）<br>3）分布式处理：多台计算机各自承担同一工作任务的不同部分（Hadoop平台）<br>4）提高可靠性<br>5）负载均衡（各计算机之间更亲密）</p>
<p>计算机网络的组成：<br>1）按组成部分分类：硬件、软件、协议<br>2）按工作方式分类：边缘部分（用户直接使用：C/S方式、P2P方式）、核心部分（为边缘部分服务）<br>3）按功能组成分类：通信子网（实现数据通信）、资源子网（实现资源共享/数据处理）<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosd9rga3qj30xg0gath7.jpg"></p>
<p>计算机网络的分类：<br>1）按分布范围分：广域网（WAN、使用交换技术）、城域网（MAN）、局域网（LAN、使用广播技术）、个人区域网（PAN）<br>2）按使用者分：公用网、专用网<br>3）按交换技术分：电路交换、报文交换、分组交换<br>4）按拓扑结构分：总线型、星型、环型、网状型（常用于广域网）<br>5）按传输技术分：广播式网络（共享公共通信信道）、点对点网络（使用分组存储转发和路由选择机制）</p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>计算机网络原理</tag>
      </tags>
  </entry>
  <entry>
    <title>流量控制与可靠传输机制</title>
    <url>/2020/08/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E4%B8%8E%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>流量控制与可靠传输机制：</p>
<p>数据链路层的流量控制：较高的发送速度和较低的接收能力的不匹配，会造成传输出错，因此流量控制也是数据链路层的一项重要工作</p>
<p>数据链路层的流量控制是点对点的，而传输层的流量控制是端到端的</p>
<p>数据链路层流量控制的手段：接收方收不下就不回复确认<br>传输层流量控制的手段：接收端给发送端一个窗口公告</p>
<p>流量控制的方法：<br>1）停止-等待协议：每发送完一个帧就停止发送，等待对方的确认，在收到确认后再发送下一个帧<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gose7dgvq7j30f70c2abu.jpg"><br>2）滑动窗口协议：后退N帧协议(GBN)、选择重传协议(SR)<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gose7lkb7hj30m309kn0s.jpg"></p>
<p>停止-等待协议：发送窗口大小=1，接收窗口大小=1<br>后退N帧协议(GBN)：发送窗口大小&gt;1，接收窗口大小=1<br>选择重传协议(SR)：发送窗口大小&gt;1，接收窗口大小&gt;1</p>
<p>可靠传输、流量控制、滑动窗口：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gose7tibf8j30p408on08.jpg"></p>
<p>————————————</p>
<p>停止等待协议：</p>
<p>为什么要有停止等待协议：除了比特出差错，底层信道还会出现丢包问题，为了实现流量控制【丢包：物理线路故障、设备故障、病毒攻击、路由信息错误等原因，会导致数据包的丢失】</p>
<p>研究停止等待协议的前提：<br>1）虽然现在常用全双工通信方式，但为了讨论问题方便，仅考虑一方发送数据（发送方），一方接收数据（接收方）<br>2）因为是在讨论可靠传输的原理，所以并不考虑数据是在哪一个层次上传送的</p>
<p>停止等待协议的几种应用情况：<br>1）无差错情况<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gose82wz9vj30ro0h5442.jpg"><br>2）有差错情况<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gose8bu6k7j31480gxjzn.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gose8jewbqj30so0gq7aa.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gose8rsaukj30rt0gqaf2.jpg"></p>
<p>停止等待协议的性能分析：简单、信道利用率太低<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gose90ohdvj30zw0ec78y.jpg"></p>
<p>信道利用率：发送方在一个发送周期内，有效的发送数据所需要的时间占整个发送周期的比率</p>
<p>信道利用率=(L/C)/T<br>L：T内发送L比特数据<br>C：发送方数据传输率<br>T；发送周期，从开始发送数据，到收到第一个确认帧为止</p>
<p>信道吞吐率：信道利用率*发送方的发送速率</p>
<p>停止等待协议的弊端：</p>
<p>流水线技术：必须增加序号范围、发送方需要缓存多个分组<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gose9cgzfpj30f50h5gpw.jpg"></p>
<p>—————————————</p>
<p>后退N帧协议(GBN)：</p>
<p>后退N帧协议中的滑动窗口：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gose9nxmbfj30mk0gb7a2.jpg"></p>
<p>GBN发送方必须响应的三件事：<br>1）上层的调用：上层要发送数据时，发送方先检查发送窗口是否已满，如果未满，则产生一个帧并将其发送；如果窗口已满，发送方只需将数据返回给上层，暗示上层窗口已满。上层等一会再发送（实际实现中，发送方可以缓存这些数据，窗口不满时再发送帧）<br>2）收到了一个ACK：GBN协议中，对n号帧的确认采用累计确认的方式，标明接收方已经收到n号帧和它之前的全部帧<br>3）超时事件：协议的名字为后退N帧/回退N帧，来源于出现丢失和时延过长帧时发送方的行为。就像在停等协议中一样，定时器将再次用于恢复数据帧或确认帧的丢失，如果出现超时，发送方重传所有已发送但未被确认的帧</p>
<p>GBN接收方要做的事：<br>1）如果正确收到n号帧，并且按序，那么接收方为n帧发送一个ACK，并将该帧中的数据部分交付给上层<br>2）其余情况都丢弃帧，并为最近按序接收的帧重新发送ACK，接收方无需缓存任何失序帧，只需要维护一个信息：expectedseqnum（下一个按序接收的帧序号）【接收方只按序接收帧，不按序无情丢弃】【确认序列号最大的，按序到达的帧】<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goseacfu9xj30gb0fhdji.jpg"><br>滑动窗口长度：若采用n个比特对帧编号，那么发送窗口的尺寸WT应满足：1&lt;=WT&lt;=2^n-1，因为发送窗口尺寸过大，就会使得接收方无法区别新帧和旧帧</p>
<p>GBN协议性能分析：<br>1）因连续发送数据帧而提高了信道利用率<br>2）在重传时必须把原来已经正确传送的数据帧重传，使得传送效率降低</p>
<p>—————————————</p>
<p>选择重传协议(SR)：</p>
<p>解决GBN的弊端：可不可以只重传出错的帧？设置单个确认，同时加大接收窗口，设置接收缓存，缓存乱序到达的帧</p>
<p>选择重传协议中的滑动窗口：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goseanqvpaj30t10i0dh2.jpg"></p>
<p>SR发送方必须要响应的三件事：<br>1）上层的调用：从上层收到数据后，SR发送方检查下一个可用于该帧的序号，如果序号位于发送窗口内，则发送数据帧，否则就像GBN一样，要么将数据缓存，要么返回给上层之后再传输<br>2）收到了一个ACK：如果收到ACK，假如该帧序号在窗口内，则SR发送方将那个被确认的帧标记为已接收。如果该帧序号是窗口的下界（最左边第一个窗口对应的序号），则窗口向前移动到具有最小序号的未确认帧处，如果窗口移动了并且有序号在窗口内的未发送帧，则发送这些帧<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goseay44m7j30ku03mjre.jpg"><br>3）超时事件：每个帧都有自己的定时器，一个超时事件发生后只重传一个帧【只重传出错帧】</p>
<p>SR接收方要做的事：窗口内的帧来者不拒<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goseb7f1rfj30qv0e33zp.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosebm7sfsj30gb0gywjj.jpg"><br>滑动窗口的长度：发送窗口最好等于接收窗口（大了会溢出，小了没意义）【WTmax=WRmax=2^(n-1)】</p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>计算机网络原理</tag>
      </tags>
  </entry>
  <entry>
    <title>物理层传输介质</title>
    <url>/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E7%89%A9%E7%90%86%E5%B1%82%E4%BC%A0%E8%BE%93%E4%BB%8B%E8%B4%A8/</url>
    <content><![CDATA[<p>物理层传输介质：</p>
<p>传输介质也称传输媒体/传输媒介，它就是数据传输系统中在发送设备和接收设备之间的物理通路</p>
<p>传输媒体并不是物理层，传输媒体在物理层的下面，因为物理层是体系结构的第一层，因此有时称传输媒体为0层。在传输媒体中传输的是信号但传输媒体并不知道所传输的信号代表什么意思，但物理层规定了电气特性，因此能够识别所传送的比特流</p>
<p>传输介质：<br>1）导向性传输介质：电磁波被导向沿着固体媒介(铜线/光纤)传播<br>2）非导向性传输介质：自由空间，介质可以是空气、真空、海水等</p>
<p>导向性传输介质:</p>
<p>1）双绞线<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosdsq56vtj31ps0qr1kx.jpg"><br>2）同轴电缆<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosdtiluftj31ps0mwqtr.jpg"><br>3）光纤<br>特点：传输损耗小，中继距离长，对远距离传输特别经济；抗雷电和电磁干扰性能好；无串音干扰，保密性好，也不易被窃听或截取数据；体积小，重量轻<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosdtxshenj31ps0m8kgz.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosdu5ddnpj31ps0rrx0w.jpg"></p>
<p>非导向性传输介质：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosdudhtnmj31ps0rzqps.jpg"></p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>计算机网络原理</tag>
      </tags>
  </entry>
  <entry>
    <title>物理层基本概念</title>
    <url>/2020/08/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E7%89%A9%E7%90%86%E5%B1%82%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<p>物理层基本概念：</p>
<p>物理层解决如何在连接各种计算机的传输媒体上传输数据比特流，而不是指具体的传输媒体</p>
<p>物理层主要任务：确定与传输媒体接口有关的一些特性(定义标准)<br>1）机械特性：定义物理连接的特性，规定物理连接时所采用的规格、接口形状、引线数目、引脚数量和排列情况<br>2）电气特性：规定传输二进制位时，线路上信号的电压范围、阻抗匹配、传输速率和距离限制等<br>3）功能特性：指明某条线上出现的某一电平表示何种意义，接口部件的信号线的用途<br>4）规程特性：（过程特性）定义各条物理线路的工作规程和时序关系</p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>计算机网络原理</tag>
      </tags>
  </entry>
  <entry>
    <title>电子邮件</title>
    <url>/2020/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6/</url>
    <content><![CDATA[<p>电子邮件：</p>
<p>组成结构：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goslh070tyj311h0gmwmg.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goslh7l4ydj30rl096dk6.jpg"></p>
<p>——————————————————</p>
<p>简单邮件传送协议SMTP【使用TCP连接、端口号为25、C/S】【MIME】：<br>1）SMTP规定了在两个相互通信的SMTP进程之间应如何交换信息<br>2）负责发送邮件的SMTP进程就是SMTP客户，负责接收邮件的进程就是SMTP服务器<br>3）SMTP规定了14条命令（几个字母）和21种应答信息（三位数字代码+简单文字说明）</p>
<p>SMTP通信三个阶段：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goslhjzjt4j312c0han8b.jpg"></p>
<p>SMTP的缺点：<br>1）SMTP不能传送可执行文件或者其他二进制对象<br>2）SMTP仅限于传送7位ASCII码，不能传送其他非英语国家的文字<br>3）SMTP服务器会拒绝超过一定长度的邮件<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goslhsinqaj30qi0bsmxr.jpg"></p>
<p>———————————————————</p>
<p>邮局协议POP3【TCP连接、端口号为110、C/S】:<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosli5lqolj30rl096dk6.jpg"><br>POP3工作方式：下载并保留(在服务器)、下载并删除</p>
<p>—————————————————</p>
<p>网际报文存取协议IMAP：<br>1）IMAP协议比POP协议复杂，当用户Pc上的IMAP客户程序打开IMAP服务器的邮箱时，用户可以看到邮箱的首部，若用户需要打开某个邮件，该邮件才上传到用户的计算机上<br>2）IMAP可以让用户在不同的地方使用不同的计算机随时上网阅读处理邮件，还允许只读取邮件中的某一个部分（先看正文，有WI-FI的时候再下载附件）</p>
<p>————————————————</p>
<p>基于万维网的电子邮件（方便）：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goslihx6byj30rq09rjs6.jpg"></p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>计算机网络原理</tag>
      </tags>
  </entry>
  <entry>
    <title>物理层设备</title>
    <url>/2020/08/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E7%89%A9%E7%90%86%E5%B1%82%E8%AE%BE%E5%A4%87/</url>
    <content><![CDATA[<p>物理层设备：</p>
<p>————————————————</p>
<p>中继器：</p>
<p>诞生原因：由于存在损耗，在线路上传输的信号功率会逐渐衰减，衰减到一定程度时将造成信号失真，因此会导致接收错误</p>
<p>中继器的功能：对信号进行再生和还原，对衰减的信号进行放大，保持与原数据相同，以增加信号传输的距离，延长网络的长度【再生数字信号】</p>
<p>中继器的两端：<br>1）两端的网络部分是网段，而不是子网，适用于完全相同的两类网络的互连，且两个网段速率要相同<br>2）中继器只将任何电缆段上的数据发送到另一段电缆上，它仅作用于信号的电气部分，并不管数据中是否有错误数据或不适于网段的数据<br>3）两端可连相同媒体，也可连不同媒体<br>4）中继器两端的网段一定要是同一个协议（中继器不会存储转发）</p>
<p>5-4-3规则：网络标准中都对信号的延迟范围作了具体的规定，因而中继器只能在规定的范围内进行，否则会网络故障<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosdving1gj30xb07rtaj.jpg"></p>
<p>—————————————————</p>
<p>集线器（多口中继器）：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosdvsk536j31ps0mtql6.jpg"></p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>计算机网络原理</tag>
      </tags>
  </entry>
  <entry>
    <title>电路交换、报文交换、分组交换</title>
    <url>/2020/07/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E7%94%B5%E8%B7%AF%E4%BA%A4%E6%8D%A2%E3%80%81%E6%8A%A5%E6%96%87%E4%BA%A4%E6%8D%A2%E3%80%81%E5%88%86%E7%BB%84%E4%BA%A4%E6%8D%A2/</url>
    <content><![CDATA[<p>电路交换、报文交换、分组交换：</p>
<p>如何使数据通过网络核心(路由器)从源主机到目的主机？——数据交换</p>
<p>为什么要数据交换：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosjekpeo8j312a0fcn56.jpg"></p>
<p>数据交换方式：<br>1）电路交换<br>2）报文交换<br>3）分组交换：数据报方式、虚电路方式</p>
<p>—————————————</p>
<p>电路交换：电话网络(多路复用)</p>
<p>电路交换的阶段：<br>1）建立连接（呼叫/电路建立）<br>2）通信<br>3）释放连接（拆除电路）</p>
<p>特点：独占资源</p>
<p>优点：通信时延小、有序传输、没有冲突、实时性强</p>
<p>缺点：建立连接时间长、线路独占，使用效率低、灵活性差、无差错控制能力</p>
<p>—————————————</p>
<p>报文交换：</p>
<p>报文：源应用发送的信息整体<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosjeyl2ofj30xy063773.jpg"></p>
<p>优点：<br>1）无需建立连接<br>2）存储转发，动态分配线路<br>3）线路可靠性较高<br>4）线路利用率较高<br>5）多目标服务</p>
<p>缺点：<br>1）有存储转发时延<br>2）报文大小不定，需要网络节点有较大缓存空间</p>
<p>—————————————</p>
<p>分组交换：</p>
<p>分组：把大的数据块分割成小的数据块<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosjfnqa67j30wt064q56.jpg"></p>
<p>优点：<br>1）无需建立连接<br>2）存储转发，动态分配线路<br>3）线路可靠性较高<br>4）线路利用率较高<br>5）相对于报文交换，存储管理更容易</p>
<p>缺点：<br>1）有存储转发时延<br>2）需要传输额外的信息量<br>3）乱序到目的主机时，要对分组排序重组</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosjfztu79j31330ge46c.jpg"></p>
<p>————————————————</p>
<p>数据报方式为网络层提供无连接服务【无连接服务：不事先为分组的传输确定传输路径，每个分组独立确定传输路径，不同分组传输路径可能不同】【每个分组携带源和目的地址】【路由器根据分组的目的地址转发分组：基于路由协议/算法构建转发表；检索转发表；每个分组独立选路】<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosjgapxlfj30qe0c678k.jpg"></p>
<p>虚电路方式为网络层提供连接服务【连接服务：首先为分组的传输确定传输路径(建立连接)，然后沿该路径(连接)传输系列分组，系列分组传输路径相同，传输结束后拆除连接】</p>
<p>虚电路将数据报方式和电路交换方式结合，以发挥两者优点</p>
<p>虚电路：一条源主机到目的主机类似于电路的路径（逻辑连接），路径上所有的结点都要维持这条虚电路的建立，都维持一张虚电路表，每一项纪录了一个打开的虚电路信息</p>
<p>通信过程：<br>1）建立连接（虚电路建立）：每个分组携带虚电路号，而非目的地址，源主机发送“呼叫请求”分组并收到“呼叫应答”分组后才算建立连接<br>2）数据传输（全双工通信）<br>3）释放连接（虚电路释放）：源主机发送“释放请求”分组以拆除虚电路</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosjh0y8ioj310c0e8wm8.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosjhnh4wuj30g806y3z8.jpg"></p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>计算机网络原理</tag>
      </tags>
  </entry>
  <entry>
    <title>码元、波特、速率、带宽</title>
    <url>/2020/08/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E7%A0%81%E5%85%83%E3%80%81%E6%B3%A2%E7%89%B9%E3%80%81%E9%80%9F%E7%8E%87%E3%80%81%E5%B8%A6%E5%AE%BD/</url>
    <content><![CDATA[<p>码元、波特、速率、带宽：</p>
<p>码元是指用一个固定时长的信号波形（数字脉冲），代表不同离散数值的基本波形，是数字通信中数字信号的计量单位，这个时长内的信号称为k进制码元，而该时长称为码元宽度，当码元的离散状态有M个时（M大于2），此时码元为M进制码元；一码元可以携带多个比特的信息量，例如在使用二进制编码时，只有两种不同的码元，一种代表0状态，另一种代表1状态<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosdlpv68vj317d0u0th6.jpg"></p>
<p>速率也叫数据率，是指数据的传输速率（注意区分传播速率），表示单位时间内传输的数据量，可以用码元传输速率和信息传输速率表示</p>
<p>码元传输速率：别名码元速率、波形速率、调制速率、符号速率等，它表示单位时间内数字通信系统所传输的码元个数（也可称为脉冲个数或信号变化的次数），单位是波特（Baud），1波特表示数字通信系统每秒传输一个码元，这里的码元可以是多进制的，也可以是二进制的，但码元速率与进制数无关【1s传输多少个码元】</p>
<p>信息传输速率：别名信息速率、比特率等，表示单位时间内数字通信系统传输的二进制码元个数（即比特数），单位是比特/秒（b/s）【1s传输多少个比特】</p>
<p>关系：若一个码元携带n bit的信息量，则M Baud的码元传输速率所对应的信息传输速率为M*n bit/s<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosdlyuv2ej319e0rcgrv.jpg"></p>
<p>带宽：表示在单位时间内从网络中的某一点到另一点所能通过的“最高数据率”，常用来表示网络的通信线路所能传输数据的能力，单位是b/s<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosdmcuo66j31h90j6nik.jpg"></p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>计算机网络原理</tag>
      </tags>
  </entry>
  <entry>
    <title>编码与调制</title>
    <url>/2020/08/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E7%BC%96%E7%A0%81%E4%B8%8E%E8%B0%83%E5%88%B6/</url>
    <content><![CDATA[<p>编码与调制：</p>
<p>信道：信号的传输媒介，一般用来表示向某一个方向传送信息的介质，因此一条通信线路往往包含一条发送信道和一条接收信道【按传输信号分：模拟信道(传送模拟信号)、数字信道(传送数字信号)；按传输介质分：无线信道、有线信道】</p>
<p>信道上传送的信号：<br>1）基带信号：将数字信号1和0直接用两种不同的电压表示，再送到数字信道上去传输（基带传输）【来自信源的信号，像计算机输出的代表各种文字或图像文件的数据信号都属于基带信号，基带信号就是发出的直接表达了要传输的信息的信号，比如我们说话的声波就是基带信号】<br>2）宽带信号：将基带信号进行调制后形成的频分复用模拟信号，再传送到模拟信道上去传输（宽带传输）【把基带信号经过载波调制后，把信号的频率范围搬移到较高的频段以便在信道中传输（即仅在一段频率范围内能够通过信道】</p>
<p>在传输距离较近时，计算机网络采用基带传输方式（近距离衰减小，从而信号内容不易发生变化）<br>在传输距离较远时，计算机网络采用宽带传输方式（远距离衰减大，即使信号变化大也能最后过滤出来基带信号）</p>
<p>编码与调制：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosdpem4rij318e06fwjy.jpg"></p>
<p>数字数据编码为数字信号：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosdpta6p6j30v80u0x0u.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosdq31no7j30yc0l0drf.jpg"></p>
<p>数字数据调制为模拟信号：数字数据调制技术在发送端将数字信号转换为模拟信号，而在接收端将模拟信号还原为数字信号，分别对应于调制解调器的调制和解调过程<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosdqh7ymrj31ps0osk9d.jpg"></p>
<p>模拟数据编码为数字信号：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosdqvipoij31ps0rv4qp.jpg"></p>
<p>模拟数据调制为模拟信号：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosdr3ewsnj31h00k5k0o.jpg"></p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>计算机网络原理</tag>
      </tags>
  </entry>
  <entry>
    <title>移动IP</title>
    <url>/2020/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E7%A7%BB%E5%8A%A8IP/</url>
    <content><![CDATA[<p>移动IP：</p>
<p>移动IP技术是移动结点（计算机/服务器等）以固定的网络IP地址，实现跨越不同网段的漫游功能，并保证了基于网络IP的网络权限在漫游过程中不发生任何改变</p>
<p>移动结点：具有永久IP地址的移动设备</p>
<p>归属代理（本地代理）：一个移动结点拥有的旧“居所”称为归属网络，在归属网络中代表移动结点执行移动管理功能的实体叫做归属代理</p>
<p>外部代理（外地代理）：在外部网络中帮助移动结点完成移动管理功能的实体称为外部代理</p>
<p>永久地址（归属地址/主地址）：移动站点在归属网络中的原始地址</p>
<p>转交地址（辅地址）：移动站点在外部网络使用的临时地址</p>
<p>移动IP通信过程：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goskx1ae0gj312t0i075z.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goskxa6ok2j30ls09s76v.jpg"></p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>计算机网络原理</tag>
      </tags>
  </entry>
  <entry>
    <title>网络层功能概述</title>
    <url>/2020/08/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E7%BD%91%E7%BB%9C%E5%B1%82%E5%8A%9F%E8%83%BD%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<p>网络层功能概述：</p>
<p>网络层主要任务是把分组从源端传到目的端，为分组交换网上的不同主机提供通信服务</p>
<p>网络层传输单位是数据报</p>
<p>功能：<br>1）路由选择与分组转发(最佳路径)<br>2）异构网络互联<br>3）拥塞控制：若所有结点都来不及接受分组，而要丢弃大量分组的话，网络就处于拥塞状态，因此要采取一定措施，缓解这种拥塞【开环控制(静)、闭环控制(动)】</p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>计算机网络原理</tag>
      </tags>
  </entry>
  <entry>
    <title>网络应用模型</title>
    <url>/2020/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<p>网络应用模型：</p>
<p>应用层对应用程序的通信提供服务</p>
<p>应用层的功能：<br>1）文件传输、访问和管理<br>2）电子邮件<br>3）虚拟终端<br>4）查询服务和远程作业登录</p>
<p>应用层的重要协议：<br>1）FTP、TFTP<br>2）SMTP、POP3、IMAP<br>3）HTTP</p>
<p>网络应用模型：<br>1）客户/服务器模型（Client/Server）<br>2）P2P模型（Peer-to-Peer）</p>
<p>—————————</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goslaudnb2j30hl0avq55.jpg"><br>服务器：提供计算服务的设备【永久提供服务、永久性访问地址/域名】</p>
<p>客户机：请求计算服务的主机<br>1）与服务器通信，使用服务器提供的服务<br>2）间歇性接入网络<br>3）可能使用动态IP地址<br>4）不与其他客户机直接通信</p>
<p>应用：Web、文件传输FTP、远程登录、电子邮件</p>
<p>—————————</p>
<p>P2P模型：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goslbb0yz9j30fd0da76v.jpg"><br>1）不存在永远在线的服务器<br>2）每个主机既可以提供服务，也可以请求服务<br>3）任意端系统/节点之间可以直接通讯<br>4）节点间歇性接入网络<br>5）节点可能改变IP地址<br>6）可扩展性好<br>7）网络健壮性强</p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>计算机网络原理</tag>
      </tags>
  </entry>
  <entry>
    <title>路由算法与路由协议概述</title>
    <url>/2020/07/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%B7%AF%E7%94%B1%E7%AE%97%E6%B3%95%E4%B8%8E%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<p>路由算法与路由协议概述：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goskagiafzj30xz0eqwk0.jpg"></p>
<p>路由算法的分类：<br>1）静态路由算法（非自适应路由算法）：管理员手工配置路由信息【简便、可靠，在负荷稳定、拓扑变化不大的网络中运行效果很好，广泛用于高度安全性的军事网络和较小的商业网络】【路由更新慢，不适用大型网络】<br>2）动态路由算法（自适应路由算法）：路由期间彼此交换信息，按照路由算法优化出路由表项【路由更新快，适用大型网络，及时响应链路费用或网络拓扑变化】【算法复杂，增加网络负担】</p>
<p>动态路由算法：<br>1）全局性：链路状态路由算法：OSPF协议，所有路由器掌握完整的网络拓扑和链路费用信息<br>2）分散性：距离向量路由算法：RIP协议，路由器只掌握物理相连的邻居及链路费用</p>
<p>分层次的路由选择协议：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goskaw333ij31180ft75k.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goskbc2n1wj30ru071q68.jpg"></p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>计算机网络原理</tag>
      </tags>
  </entry>
  <entry>
    <title>轮询访问介质访问控制</title>
    <url>/2020/08/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%BD%AE%E8%AF%A2%E8%AE%BF%E9%97%AE%E4%BB%8B%E8%B4%A8%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<p>轮询访问介质访问控制：</p>
<p>介质访问控制：<br>1）信道划分介质访问控制协议：基于多路复用技术划分资源；网络负载重的时候共享信道效率高，且公平；网络负载轻的时候共享信道效率低<br>2）随机访问MAC协议：用户根据意愿随机发送信息，发送信息时可独占信道带宽；网络负载重时产生冲突开销；网络负载轻时共享信道效率高，单个结点可利用信道全部带宽<br>3）轮询访问MAC协议：既要不产生冲突，又要发送时占全部带宽</p>
<p>轮询协议：主结点轮流邀请从属结点发送数据【问题：轮询开销、等待延迟、单点故障】</p>
<p>令牌传递协议：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosf1eqfjsj312n0e2n4l.jpg"></p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>计算机网络原理</tag>
      </tags>
  </entry>
  <entry>
    <title>网络层设备</title>
    <url>/2020/07/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E7%BD%91%E7%BB%9C%E5%B1%82%E8%AE%BE%E5%A4%87/</url>
    <content><![CDATA[<p>网络层设备：</p>
<p>路由器：是一种具有多个输入端口和多个输出端口的专用计算机，其任务是转发分组<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goskywrn1hj313i0fanbp.jpg"></p>
<p>输入端口对线路上收到的分组的处理：输入端口中的查找和转发功能在路由器的交换功能中是最重要的<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goskz5jngmj30q50afn2b.jpg"></p>
<p>输出端口将交换结构传送来的分组发送到线路：若路由器处理分组的速率赶不上分组进入队列的速率，则队列的存储空间最终必定减少到零，这就使后面再进入队列的分组由于没有存储空间而只能被丢弃【路由器中的输入或输出队列产生溢出是造成分组丢失的重要原因】<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goskzeo53aj30rr0al79b.jpg"></p>
<p>三层设备的区别：<br>1）集线器：不能互联两个物理层不同的网段<br>2）网桥：可以互联两个物理层和链路层不同的网段<br>3）路由器：可以互联两个不同网络层协议的网段<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goskzmwe8vj30mb0ao3yr.jpg"></p>
<p>路由表与路由转发：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goskzuvm2yj30wh0flq9x.jpg"></p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>计算机网络原理</tag>
      </tags>
  </entry>
  <entry>
    <title>速率、带宽、吞吐量</title>
    <url>/2020/08/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E9%80%9F%E7%8E%87%E3%80%81%E5%B8%A6%E5%AE%BD%E3%80%81%E5%90%9E%E5%90%90%E9%87%8F/</url>
    <content><![CDATA[<p>速率、带宽、吞吐量：</p>
<p>速率：即数据率、数据传输率、比特率，连接在计算机网络上的主机在数字信道上传送数据位数的速率（b/s、kb/s、Mb/s、Gb/s、Tb/s）<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosdbsjhmbj31cu09x0zr.jpg"></p>
<p>带宽：原本指某个信号具有的频带宽度，即最高频率与最低频率之差，单位是赫兹（Hz）；计算机网络中，带宽用来表示网络的通信线路传送数据的能力，通常是指单位时间内从网络中的某一点到另一点所能通过的最高数据率（b/s、kb/s、Mb/s、Gb/s、Tb/s），网络设备所支持的最高速度</p>
<p>吞吐量：表示在单位时间内通过某个网络（或信道、接口）的数据量（b/s、kb/s、Mb/s、Gb/s、Tb/s），吞吐量受网络的带宽或网络的额定速率的限制</p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>计算机网络原理</tag>
      </tags>
  </entry>
  <entry>
    <title>链路层设备</title>
    <url>/2020/08/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E9%93%BE%E8%B7%AF%E5%B1%82%E8%AE%BE%E5%A4%87/</url>
    <content><![CDATA[<p>链路层设备：</p>
<p>以太网物理上采用星型拓扑，逻辑上总线型，每段双绞线最长为100m</p>
<p>物理层扩展以太网：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosfigxuluj30yt0fhq8t.jpg"></p>
<p>链路层扩展以太网（网桥、交换机）：</p>
<p>1）网桥<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosfisg9atj311x0fa47z.jpg"></p>
<p>网桥分类：<br>1）透明网桥<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosfj2stnij31030fnwn0.jpg"><br>2）源路由网桥：在发送帧时，把详细的最佳路由信息（路由最少/时间最短）放在帧的首部中【方法：源站以广播方式向欲通信的目的站发送一个发现帧，选择其中最佳的路由线路】</p>
<p>2）多接口网桥—以太网交换机<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosfjdetqqj30sz0drwlf.jpg"></p>
<p>以太网交换机的两种交换方式：<br>1）直通式交换机：查完目的地址(6B)就立刻转发；延迟小，可靠性低，无法支持具有不同速率的端口的交换<br>2）存储转发式交换机：将帧放入高速缓存，并检查是否正确，正确则转发，错误则丢弃；延迟大，可靠性高，可以支持具有不同速率的端口的交换</p>
<p>冲突域和广播域：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosfjo9bmbj31220emwmn.jpg"></p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>计算机网络原理</tag>
      </tags>
  </entry>
  <entry>
    <title>C++中的引用：</title>
    <url>/2019/06/23/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/C++/C++%E4%B8%AD%E7%9A%84%E5%BC%95%E7%94%A8%EF%BC%9A/</url>
    <content><![CDATA[<hr>
<p>作用：给变量起别名<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glwf0uwff2j30e10deq40.jpg"></p>
<p>引用注意事项：<br>1）引用必须初始化<br>2）引用在初始化后，不可以改变<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glwf12tkd6j30e30dsmyh.jpg"></p>
<p>引用做函数参数：函数传参时，可以利用引用的技术让形参修饰实参，可以简化指针修改实参<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glwf1ay5anj30fu0ul78l.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glwf1hxdjgj30cu06tq3j.jpg"></p>
<p>引用做函数返回值：不要返回局部变量引用；函数的调用可以作为左值<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glwf1p4dcjj30lf0j0jug.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glwf1waev4j30qz063js2.jpg"></p>
<p>引用的本质：在C++内部实现是一个指针常量<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glwf235twfj30qz0fttb0.jpg"></p>
<p>常量引用：常量引用主要用来修饰形参，防止误操作，在函数形参列表中，可以加const修饰形参，防止形参改变实参<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glwf2aaw26j30qz0ft40g.jpg"></p>
]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++对象模型和this指针：</title>
    <url>/2019/06/19/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/C++/C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E5%92%8Cthis%E6%8C%87%E9%92%88%EF%BC%9A/</url>
    <content><![CDATA[<hr>
<p>——————成员变量和成员函数分开存储：</p>
<p>在C++中，类内的成员变量和成员函数分开存储</p>
<p>只有非静态成员变量才属于类的对象上<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glwf92weytj30mg0jbq5x.jpg"></p>
<p>—————————this指针：</p>
<p>每一个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码，那么这一块代码是如何区分哪个对象调用自己的呢？</p>
<p>C++通过提供特殊的对象指针，this指针，解决上述问题，this指针指向被调用的成员函数所属的对象</p>
<p>This指针是隐含每一个非静态成员函数内的一种指针，不需要定义，直接使用即可</p>
<p>This指针的用途：<br>1）当形参和成员变量同名时，可用this指针来区分<br>2）在类的非静态成员函数中返回对象本身，可使用return *this；<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glwf9a7upvj30mg0jb41f.jpg"></p>
<p>———————————空指针访问成员函数：</p>
<p>C++中空指针也是可以调用成员函数的，但是也要注意有没有用到this指针</p>
<p>如果用到this指针，需要加以判断保证代码的健壮性<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glwf9i6gh7j30mu0jb76s.jpg"></p>
<p>——————————const修饰成员函数：</p>
<p>常函数：成员函数后加const后我们称这个函数为常函数；常函数内不可以修改成员属性；成员属性声明时加关键字mutable后，在常函数中依然可以修改</p>
<p>常对象：声明对象前加const称该对象为常对象，常对象只能调用常函数<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glwf9oy6mhj30mu0ot420.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glwf9vpitfj307v01v3ym.jpg"></p>
]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++基础：</title>
    <url>/2019/06/30/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/C++/C++%E5%9F%BA%E7%A1%80%EF%BC%9A/</url>
    <content><![CDATA[<hr>
<p>常量：用于记录程序中不可更改的数据</p>
<p>C++定义常量的两种方式：<br>1）#define 常量名 常量值<br>2）const修饰的变量</p>
<p>利用sizeof关键字可以统计数据类型所占内存的大小【sizeof（数据类型/变量）】</p>
<p>字符型变量并不是把字符本身放到内存中存储，而是将对应的ASCII编码放入到存储单元【a-97，A-65】</p>
<p>水平制表符\t：可以整齐的输出数据，水平制表符与前面的字符永远占据八个空格</p>
<p>反斜杠：\</p>
<p>两种风格字符串：<br>1）C风格字符串：char 变量名[] = “字符串值”<br>2）C++风格字符串：string 变量名 = “字符串值”【使用这种风格字符串时要包含一个头文件#include <string>】</p>
<p>Cin数据的输入<br>Cout数据的输出</p>
<p>Bool类型非零即真</p>
<p>算术运算符【+(正号)、-(负号)、+、-、<em>、/、%、++、- -】<br>赋值运算符【=、+=、-=、</em>=、/=、%=】<br>比较运算符【==、！=、&lt;、&gt;、&lt;=、&gt;=】<br>逻辑运算符【！非、&amp;&amp;与、||或】</p>
<p>前置递增先对变量进行++，再计算表达式<br>后置递增先计算表达式，后对变量进行++</p>
<p>程序流程结构：顺序结构、选择结构【if语句、三目运算符、switch语句】、循环结构【while、do  while、for】</p>
<p>跳转语句：break、continue、goto</p>
<p>Break出现在switch条件语句中，作用是终止case并跳出switch，出现在循环语句中，作用是跳出当前的循环语句，出现在嵌套循环中，跳出最近的内层循环语句</p>
<p>Continue在循环语句中跳过本次循环中余下尚未执行的语句，继续执行下一次循环【可以筛选条件，奇数输出，偶数不输出】</p>
<p>Goto语句：无条件的跳转语句</p>
<p>三目运算符：表达式1？表达式2:表达式3</p>
<p>在C++中三目运算符返回的是变量，可以继续赋值</p>
<p>Switch语句中的表达式类型只能是整型或者字符型</p>
<p>系统生成随机数：rand()%100，会生成0～99的随机数【伪随机数】</p>
<p>添加随机数种子，利用当前系统时间生成随机数，防止每次随机数都一样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;ctime&gt;</span><br><span class="line">srand((unsigned int)time(NULL));</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>函数模板：</title>
    <url>/2019/06/12/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/C++/%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%EF%BC%9A/</url>
    <content><![CDATA[<hr>
<p>模板就是建立通用的模具，大大提高复用性</p>
<p>模板的特点：模板不可以直接使用，它只是一个框架；模板的通用并不是万能的</p>
<p>———————————————函数模板：</p>
<p>C++另一种编程思想称为泛型编程，主要利用的技术就是模板</p>
<p>C++提供两种模板机制：函数模板和类模板</p>
<p>函数模板的作用：建立一个通用函数，其函数返回值类型和形参类型可以不具体制定，用一个虚拟的类型来代表<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glwfp03dz6j30cz0jewgr.jpg"></p>
<p>函数模板注意事项：<br>1）自动类型推导，必须推导出一致的数据类型T才可以使用<br>2）模板必须要确定出T的数据类型，才可以使用<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glwfp6w888j30ce0brgmr.jpg"></p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glwfpd3x09j30gb0t50x2.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glwfpkhy0ej30ce01ljrh.jpg"></p>
<p>普通函数与函数模板的区别：<br>1）普通函数调用时可以发生自动类型转换（隐式类型转换）<br>2）函数模板调用时，如果利用自动类型推导，不会发生隐式类型转换；如果利用显式指定类型的方式，可以发生隐式类型转换</p>
<p>建议使用显示指定类型的方式，调用函数模板，因为可以自己确定通用类型T</p>
<p>普通函数与函数模板的调用规则：<br>1）如果函数模板和普通函数都可以实现，优先调用普通函数<br>2）可以通过空模板参数列表来强制调用函数模板<br>3）函数模板也可以发生重载<br>4）如果函数模板可以产生更好的匹配，优先调用函数模板<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glwfpql1y3j30nc0gmtb5.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glwfpwvalpj30ce01lglo.jpg"></p>
<p>模板的局限性：模板的通用性并不是万能的<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glwfq2vig6j30q209bwgj.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glwfq8w0vbj30v9096wh4.jpg"></p>
<p>因此C++为了解决这种问题，提供模板的重载，可以为这些特定的类型提供具体化的模板<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glwfqenxnvj30ij0soadu.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glwfql68fyj30ce01lwej.jpg"></p>
]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++文件操作：</title>
    <url>/2019/06/14/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/C++/C++%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%EF%BC%9A/</url>
    <content><![CDATA[<hr>
<p>程序运行时产生的数据都属于临时数据，程序一旦运行结束都会被释放，通过文件可以将数据持久化</p>
<p>C++中对文件操作需要包含头文件<fstream></p>
<p>文件类型分为两种：<br>1）文本文件：文件以文本的ASCII码形式存储在计算机中<br>2）二进制文件：文件以文本的二进制形式存储在计算机中，用户一般不能直接读懂它们</p>
<p>操作文件的三大类：<br>1）ofstream：写操作<br>2）ifstream：读操作<br>3）fstream：读写操作</p>
<p>文本文件：</p>
<p>写文件的步骤：<br>1）包含头文件：#include<fstream><br>2）创建流对象：ofstream ofs;<br>3）打开文件：ofs.open(“文件路径”,打开方式);<br>4）写数据：ofs&lt;&lt;“写入的数据”;<br>5）关闭文件：ofs.close();</p>
<p>文件打开方式【文件打开方式可以配合使用，利用|操作符】：<br>1）ios::in        为读文件而打开文件<br>2）ios::out     为写文件而打开文件<br>3）ios::ate     初始位置：文件尾<br>4）ios::app    追加方式写文件<br>5）ios::trunc  如果文件存在先删除，再创建<br>6）iOS::binary  二进制方式<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glwfm0am8yj30ia0c6dhe.jpg"></p>
<p>读文件的步骤：<br>1）包含头文件：#include<fstream><br>2）创建流对象：ifstream ifs;<br>3）打开文件并判断文件是否打开成功：ifs.open(“文件路径”,打开方式);<br>4）读数据：四种方式读取<br>5）关闭文件：ifs.close();<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glwfm96dkdj30ke0q577p.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glwfmfzd6xj30h202cglr.jpg"></p>
<p>二进制文件：以二进制的方式对文件进行读写操作，打开方式要指定为ios::binary</p>
<p>二进制方式写文件主要利用流对象调用成员函数write<br>函数原型：ostream&amp; write(const char * buffer,int len);<br>参数解释：字符指针buffer指向内存中的一段存储空间，len是读写的字节数<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glwfmn0pr8j30j10et0uf.jpg"></p>
<p>二进制方式读文件主要利用流对象调用成员函数read<br>函数原型：istream&amp; read(char *buffer,int len);<br>参数解释：字符指针buffer指向内存中的一段存储空间，len是读写的字节数<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glwfmtmxxsj30j10jemzg.jpg"></p>
]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>函数高级：</title>
    <url>/2019/06/22/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/C++/%E5%87%BD%E6%95%B0%E9%AB%98%E7%BA%A7%EF%BC%9A/</url>
    <content><![CDATA[<hr>
<p>函数默认参数：在C++中，函数的形参列表中的形参是可以有默认值的<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glwf2zheqwj30ke0dpabv.jpg"></p>
<p>函数占位参数：C++中函数的形参列表里可以有占位参数，用来做占位，调用函数时必须填补该位置<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glwf37i58cj30hi09rq3x.jpg"></p>
<p>函数重载：函数名可以相同，提高复用性</p>
<p>函数重载满足条件：<br>1）同一个作用域下<br>2）函数名称相同<br>3）函数参数类型不同或者个数不同或者顺序不同</p>
<p>注意：函数的返回值不可以作为重载的条件<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glwf3etpelj30hj0bct9o.jpg"></p>
<p>函数重载的注意事项：<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glwf3mo4i9j30gq0kfgoi.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glwf3tos4lj30hj025glt.jpg"></p>
]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>友元：</title>
    <url>/2019/06/18/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/C++/%E5%8F%8B%E5%85%83%EF%BC%9A/</url>
    <content><![CDATA[<hr>
<p>在程序里，有些私有属性也想让类外特殊的一些函数或者类进行访问，就需要用到友元的技术</p>
<p>友元的目的就是让一个函数或者类访问另一个类中的私有成员，友元的关键字为friend</p>
<p>友元的三种实现：<br>1）全局函数做友元<br>2）类做友元<br>3）成员函数做友元</p>
<p>全局函数做友元：<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glwfao4s65j30kw0k1mzz.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glwfav93vaj307v01vdfy.jpg"></p>
<p>友元类（类做友元）：<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glwfb1nwqjj30je0qeadj.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glwfb7w54qj307v01vwem.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glwfbe60cvj30j00j4n01.jpg"></p>
<p>成员函数做友元【为啥顺序不能变？？】：<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glwfbl7rcej30ko0von1h.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glwfbse9jgj30fe02k74l.jpg"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">**using** **namespace** std;</span><br><span class="line"></span><br><span class="line">**class** Building;</span><br><span class="line"></span><br><span class="line">**class** goodGay&#123;</span><br><span class="line">    </span><br><span class="line">**public**:</span><br><span class="line">    </span><br><span class="line">    Building *building;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;可访问Building中的私有成员</span><br><span class="line">    **void** visit();</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;不可访问Building中的私有成员</span><br><span class="line">    **void** visit1();</span><br><span class="line">    </span><br><span class="line">    goodGay();</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">**class** Building</span><br><span class="line">&#123;</span><br><span class="line">    **friend** **void** goodGay::visit();&#x2F;&#x2F;表示goodGay类中的成员函数visit()作为本类的好朋友</span><br><span class="line">    </span><br><span class="line">**public**:</span><br><span class="line">    </span><br><span class="line">    Building()&#123;</span><br><span class="line">        SittingRoom &#x3D; “客厅”;</span><br><span class="line">        BedRoom &#x3D; “卧室”;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">**public**:</span><br><span class="line">    string SittingRoom;</span><br><span class="line">    </span><br><span class="line">**private**:</span><br><span class="line">    string BedRoom;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">goodGay::goodGay()</span><br><span class="line">&#123;</span><br><span class="line">    building &#x3D; **new** Building;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">**void** goodGay::visit()</span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;“visit函数正在访问：”&lt;&lt;building-&gt;SittingRoom&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;“visit函数正在访问：”&lt;&lt;building-&gt;BedRoom&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">**void** goodGay::visit1()</span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;“visit2函数正在访问：”&lt;&lt;building-&gt;SittingRoom&lt;&lt;endl;</span><br><span class="line">    &#x2F;&#x2F;cout&lt;&lt;“visit函数正在访问：”&lt;&lt;building-&gt;BedRoom&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">**int** main()</span><br><span class="line">&#123;</span><br><span class="line">    goodGay gg;</span><br><span class="line">    gg.visit();</span><br><span class="line">    gg.visit1();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>多态：</title>
    <url>/2019/06/15/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/C++/%E5%A4%9A%E6%80%81%EF%BC%9A/</url>
    <content><![CDATA[<hr>
<p>多态是C++面向对象三大特性之一</p>
<p>多态分为两类：<br>1）静态多态：函数重载和运算符重载属于静态多态，复用函数名<br>2）动态多态：派生类和虚函数实现运行时多态</p>
<p>静态多态和动态多态的区别：<br>1）静态多态的函数地址早绑定，编译阶段确定函数地址<br>2）动态多态的函数地址晚绑定，运行阶段确定函数地址<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glwfjeqhc7j30l50o2wi6.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glwfjmkiwbj30df01z0st.jpg"></p>
<p>多态的底层原理：<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glwfjthhbpj30n90q042l.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glwfk02il6j30df01zq32.jpg"></p>
<p>分别利用普通写法和多态技术，设计实现两个操作数进行运算的计算器类：</p>
<p>多态的优点：代码组织结构清晰、可读性强、利于前期和后期的扩展以及维护<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glwfk8x4hfj30ku1kztgz.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glwfkg0659j30df02uq32.jpg"></p>
<p>纯虚函数和抽象类：在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容，因此可以将虚函数改为纯虚函数，当类中有了纯虚函数，这个类也称为抽象类</p>
<p>抽象类特点：<br>1）无法实例化对象<br>2）子类必须重写抽象类中的纯虚函数，否则也属于抽象类<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glwfkmuqnij30je0m9go6.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glwfku0kk3j30df02u0sw.jpg"></p>
<p>虚析构和纯虚析构：</p>
<p>多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码</p>
<p>解决方式：将父类中的析构函数改为虚析构或者纯虚析构</p>
<p>虚析构和纯虚析构共性：<br>1）可以解决父类指针释放子类对象<br>2）都需要有具体的函数实现</p>
<p>虚析构和纯虚析构的区别：如果是纯虚析构，该类属于抽象类，无法实例化对象<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glwfl0lls5j30kx10cjwj.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glwfl89z45j30df03dq3d.jpg"></p>
]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>封装：</title>
    <url>/2019/06/21/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/C++/%E5%B0%81%E8%A3%85%EF%BC%9A/</url>
    <content><![CDATA[<hr>
<p>C++面向对象的三大特征：封装、继承、多态</p>
<p>C++认为万事万物皆为对象，对象上有其属性和行为</p>
<p>封装的意义：<br>1）将属性和行为作为一个整体，表现生活中的事物<br>2）将属性和行为加以权限控制【public：公共权限(类内可以访问，类外可以访问)、protected：保护权限(类内可以访问，类外不可以访问)、private：私有权限(类内可以访问，类外不可以访问)】<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glwf4k6q82j30k70j0wh5.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glwf4rl4gbj30hj00xaa2.jpg"></p>
<p>Struct和class的区别（都可以表示一个类）：<br>1）struct默认权限为公共<br>2）class默认权限为私有</p>
<p>将成员属性设置为私有的优点：<br>1）可以自己控制读写权限【提供一个public接口让外界访问】<br>2）对于写权限，我们可以检测数据的有效性<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glwf50rd05j30fr0pwgot.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glwf57kazjj30hj01x3ym.jpg"></p>
]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++运算符重载：</title>
    <url>/2019/06/17/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/C++/C++%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%EF%BC%9A/</url>
    <content><![CDATA[<hr>
<p>运算符重载：对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型</p>
<p>加号运算符重载：实现两个自定义数据类型相加的计算【对于内置的数据类型的表达式的运算符是不可能改变的；不要滥用运算符重载】<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glwfcl18rxj30mt101n2t.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glwfcslrrij30fe02kmxc.jpg"></p>
<p>左移运算符重载：可以输出自定义数据类型<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glwfd0w3paj30fy0jwq5k.jpg"></p>
<p>递增运算符重载：通过重载递增运算符，实现自己的整型数据<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glwfd825xnj30is0wndki.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glwfdf91ztj30e702pdfw.jpg"></p>
<p>赋值运算符重载：</p>
<p>C++编译器至少给一个类添加4个函数：<br>1）默认构造函数（无参，函数体为空）<br>2）默认析构函数（无参，函数体为空）<br>3）默认拷贝构造函数，对属性进行值拷贝<br>4）赋值运算符operator=，对属性进行值拷贝</p>
<p>如果类中有属性指向堆区，做赋值操作时也会出现深浅拷贝问题<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glwfdm6b31j30l10sdwie.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glwfdsxtw4j30e702p74i.jpg"></p>
<p>关系运算符重载：重载关系运算符，可以让两个自定义类型对象进行对比操作<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glwfe2izalj30kx0tf0wg.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glwfe8hjcqj30e702p0sx.jpg"></p>
<p>函数调用运算符()重载：由于重载后使用的方式非常像函数的调用，因此称为仿函数；仿函数没有固定的写法，非常灵活<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glwfej56i2j30ke0pxdjd.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glwfeok31vj30e702pt8u.jpg"></p>
]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>数组：</title>
    <url>/2019/06/29/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/C++/%E6%95%B0%E7%BB%84%EF%BC%9A/</url>
    <content><![CDATA[<hr>
<p>一维数组的定义方式：<br>1）数据类型  数组名[数组长度];<br>2）数据类型  数组名[数组长度]={值1，值2…};<br>3）数据类型  数组名[]={值1，值2…};</p>
<p>如果在初始化数据的时候，没有全部填写完，会用0来填补剩余数据</p>
<p>一维数组名称的用途：<br>1）可以统计整个数组在内存中的长度<br>2）可以获取数组在内存中的首地址：cout&lt;&lt;arr&lt;&lt;endl；<br>cout&lt;&lt;&amp;arr[0]&lt;&lt;endl;</p>
<p>数组名是一个常量，不可以进行赋值操作</p>
<p>二维数组定义方式：<br>1）数据类型  数组名[行数][列数]；<br>2）数据类型  数组名[行数][列数]=｛｛数据1，数据2｝，｛数据3，数据4｝｝；<br>3）数据类型  数组名[行数][列数]=｛数据1，数据2，数据3，数据4｝；<br>4）数据类型  数组名[][列数]={数据1，数据2，数据3，数据4};<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glweus9q48j30rk0sj7d5.jpg"></p>
]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>函数：</title>
    <url>/2019/06/28/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/C++/%E5%87%BD%E6%95%B0%EF%BC%9A/</url>
    <content><![CDATA[<hr>
<p>值传递的时候，形参发生任何的改变，都不会影响实参</p>
<p>地址传递：利用指针作为函数的参数，可以修改实参的值</p>
<p>函数的声明可以写多次，但是定义只能有一次</p>
<p>函数的分文件编写：<br>1）创建后缀名为.h的头文件，在头文件中写函数的声明<br>2）创建后缀名为.cpp的源文件，在源文件中写函数的定义</p>
]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>对象的初始化和清理：</title>
    <url>/2019/06/20/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/C++/%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E6%B8%85%E7%90%86%EF%BC%9A/</url>
    <content><![CDATA[<hr>
<p>—————1、构造函数和析构函数：</p>
<p>C++中的面向对象来源于生活，每个对象也都会有初始设置以及对象销毁前的清理数据的设置</p>
<p>构造函数和析构函数：对象的初始化和清理是两个非常重要的安全问题，一个对象或者变量没有初始状态，对其使用后果是未知的，同样的使用完一个对象或变量没有及时清理，也会造成一定的安全问题；C++利用了构造函数和析构函数解决上述问题，这两个函数将会被编译器自动调用，完成对象初始化和清理工作；</p>
<p>对象的初始化和清理工作是编译器强制要我们做的事情，因此如果我们不提供构造和析构，编译器会提供；但是编译器提供的构造函数和析构函数是空实现</p>
<p>构造函数：主要作用于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用<br>析构函数：主要作用在对象销毁前系统自动调用，执行一些清理工作</p>
<p>构造函数语法：类名(){}<br>1）构造函数没有返回值也不写void<br>2）函数名称与类名相同<br>3）构造函数可以有参数，因此可以发生重载<br>4）程序在调用对象时会自动调用构造，无须手动调用，而且只会调用一次</p>
<p>析构函数语法：～类名(){}<br>1）析构函数没有返回值也不写void<br>2）函数名称与类名相同，在名称前加上符号～<br>3）析构函数不可以有参数，因此不可以发生重载<br>4）程序在对象销毁前会自动调用析构，无须手动调用，而且只会调用一次<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glwf5w62rwj30ng0ja77a.jpg"></p>
<p>——————————2、构造函数的分类及调用：</p>
<p>两种分类方式：<br>1）按参数分类：有参构造和无参构造<br>2）按类型分类：普通构造和拷贝构造</p>
<p>三种调用方式：括号法、显示法、隐式转换法<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glwf69o0y8j30si10tahi.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glwf6eitw1j30ng0bg76h.jpg"></p>
<p>——————3、拷贝构造函数调用时机：</p>
<p>C++中拷贝构造函数调用时机通常有三种情况：<br>1）使用一个已经创建完毕的对象来初始化一个新对象<br>2）值传递的方式给函数参数传值<br>3）以值方式返回局部对象<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glwf6ly3kzj30ma0yqaeu.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glwf6sxmzfj30cm038t8y.jpg"><br>—————————4、构造函数调用规则：</p>
<p>默认情况下，C++编译器至少给一个类添加三个函数：<br>1）默认构造函数（无参，函数体为空）<br>2）默认析构函数（无参，函数体为空）<br>3）默认拷贝构造函数，对属性进行值拷贝</p>
<p>构造函数调用规则：<br>1）如果用户定义有参构造函数，C++不再提供默认无参构造函数，但是会提供默认拷贝构造<br>2）如果用户定义拷贝构造函数，C++不会再提供其他构造函数</p>
<p>—————————5、深拷贝与浅拷贝</p>
<p>浅拷贝：简单的赋值拷贝操作<br>深拷贝：在堆区重新申请空间，进行拷贝操作<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glwf6zji4uj30na0xgagk.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glwf77h74qj30fp03q0tc.jpg"><br>—————————6、初始化列表：</p>
<p>C++提供了初始化列表语法，用来初始化属性<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glwf7dnq68j30fp0jzac3.jpg"></p>
<p>———————————7、类对象作为类成员</p>
<p>C++类中的成员可以是另一个类的对象，我们称该成员为对象成员<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glwf7kcayoj309p03et8w.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glwf7qliq9j30ma0nyadf.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glwf7xfr3fj309p03eaag.jpg"></p>
<p>————8、静态成员</p>
<p>静态成员就是在成员变量和成员函数前加上关键字static，称为静态成员</p>
<p>静态成员分为：<br>1）静态成员变量：所有对象共享同一份数据，在编译阶段分配内存，类内声明，类外初始化<br>2）静态成员函数：所有对象共享同一个函数，静态成员函数只能访问静态成员变量<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glwf8483bqj30hj0kb40y.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glwf8cyj27j30hj0jsgo8.jpg"></p>
]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>指针：</title>
    <url>/2019/06/27/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/C++/%E6%8C%87%E9%92%88%EF%BC%9A/</url>
    <content><![CDATA[<hr>
<p>指针前加一个<em>代表解引用，找到指针指向的内存中的数据【</em>p】</p>
<p>不管是什么数据类型，在32位操作系统上指针是占据4个字节空间大小，在64位操作系统上占据8个字节空间大小</p>
<p>int *p =NULL；<br>空指针：指针变量指向内存中编号为0的空间，用来初始化指针变量，空指针指向的内存是不可以访问的【0～255之间的内存编号是系统占用的，因此不可以访问】</p>
<p>野指针：指针变量指向非法的内存空间</p>
<p>空指针和野指针都不是我们申请的空间，因此不要访问</p>
<p>Const修饰指针的三种情况：<br>1）const修饰指针：常量指针【const int *p=&amp;a；指针的指向可以修改，但是指针指向的值不可以修改）<br>2）const修饰常量：指针常量【int * const p=&amp;a；指针的指向不可以改，指针指向的值可以改】<br>3）const既修饰指针又修饰常量【const int * const p=&amp;a；指针的指向和指针指向的值都不可以改】</p>
]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>通讯录管理系统：</title>
    <url>/2019/06/25/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/C++/%E9%80%9A%E8%AE%AF%E5%BD%95%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%EF%BC%9A/</url>
    <content><![CDATA[<hr>
<p>系统需求：<br>1）添加联系人：向通讯录中添加新人，信息包括（姓名、性别、年龄、联系电话、家庭住址），最多记录1000人<br>2）显示联系人：显示通讯录中所有联系人的信息<br>3）删除联系人：按照姓名进行删除指定联系人<br>4）查找联系人：按照姓名查看指定联系人信息<br>5）修改联系人：按照姓名重新修改指定联系人<br>6）清空联系人：清空通讯录中所有信息<br>7）退出通讯录：退出当前使用的通讯录</p>
<p>———————————<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glweyb64ijj30k653e7wh.jpg"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;  main.cpp</span><br><span class="line">&#x2F;&#x2F;  通讯录管理系统</span><br><span class="line">&#x2F;&#x2F;  Created by 廖家龙 on 2020&#x2F;10&#x2F;8.</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> </span><br><span class="line">本系统需要改进的点：姓名和地址显示不出中文</span><br><span class="line"> </span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line"></span><br><span class="line">#define MAX 1000    &#x2F;&#x2F;通讯录存储的最大人数</span><br><span class="line"></span><br><span class="line">**using** **namespace** std;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;1-显示菜单界面</span><br><span class="line">**void** showMenu()&#123;</span><br><span class="line">    cout&lt;&lt;“************************”&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;“*****  1、添加联系人  *****”&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;“*****  2、显示联系人  *****”&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;“*****  3、删除联系人  *****”&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;“*****  4、查找联系人  *****”&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;“*****  5、修改联系人  *****”&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;“*****  6、清空联系人  *****”&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;“*****  0、退出通讯录  *****”&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;“************************”&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;3-联系人结构体</span><br><span class="line">**struct** Person&#123;</span><br><span class="line">    string m_Name;        &#x2F;&#x2F;姓名</span><br><span class="line">    **int** m_Sex;            &#x2F;&#x2F;性别：1、男  2、女</span><br><span class="line">    **int** m_Age;            &#x2F;&#x2F;年龄</span><br><span class="line">    string m_Phone;       &#x2F;&#x2F;电话</span><br><span class="line">    string m_Addr;        &#x2F;&#x2F;住址</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;3-通讯录结构体</span><br><span class="line">**struct** Addressbooks&#123;</span><br><span class="line">    **struct** Person personArray[MAX];   &#x2F;&#x2F;通讯录中保存的联系人数组</span><br><span class="line">    **int** m_Size;                       &#x2F;&#x2F;通讯录中人员个数</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;3-添加联系人</span><br><span class="line">**void** addPerson(Addressbooks *abs)&#123;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;判断通讯录是否已满，如果满了就不再添加</span><br><span class="line">    **if**(abs-&gt;m_Size &#x3D;&#x3D; MAX)&#123;</span><br><span class="line">        Cout&lt;&lt;“通讯录已满，无法添加！”&lt;&lt;endl;</span><br><span class="line">        **return**;</span><br><span class="line">    &#125;</span><br><span class="line">    **else**&#123;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;添加具体的联系人</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;姓名</span><br><span class="line">        string name;</span><br><span class="line">        cout&lt;&lt;“请输入姓名：”&lt;&lt;endl;</span><br><span class="line">        cin&gt;&gt;name;</span><br><span class="line">        abs-&gt;personArray[abs-&gt;m_Size].m_Name&#x3D;name;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;性别</span><br><span class="line">        cout&lt;&lt;“请输入性别：(1—男、2—女)”&lt;&lt;endl;</span><br><span class="line">        **int** sex&#x3D;0;</span><br><span class="line">        </span><br><span class="line">        **while**(**true**)&#123;</span><br><span class="line">            &#x2F;&#x2F;如果输入的是1或者2，可以退出循环，因为输入的是正确的值；如果输入有误，重新输入</span><br><span class="line">            cin&gt;&gt;sex;</span><br><span class="line">            **if**(sex &#x3D;&#x3D; 1 || sex &#x3D;&#x3D; 2)&#123;</span><br><span class="line">                abs-&gt;personArray[abs-&gt;m_Size].m_Sex&#x3D;sex;</span><br><span class="line">                **break**;</span><br><span class="line">            &#125;</span><br><span class="line">            Cout&lt;&lt;“输入有误，请重新输入！”&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;年龄</span><br><span class="line">        cout&lt;&lt;“请输入年龄：(0~200)”&lt;&lt;endl;</span><br><span class="line">        **int** age&#x3D;0;</span><br><span class="line">        </span><br><span class="line">        **while**(**true**)&#123;</span><br><span class="line">            cin&gt;&gt;age;</span><br><span class="line">            **if**(age &gt;&#x3D; 0 &amp;&amp; age &lt;&#x3D; 200)&#123;</span><br><span class="line">                abs-&gt;personArray[abs-&gt;m_Size].m_Age&#x3D;age;</span><br><span class="line">                **break**;</span><br><span class="line">            &#125;</span><br><span class="line">            Cout&lt;&lt;“输入有误，请重新输入！”&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;电话</span><br><span class="line">        cout&lt;&lt;“请输入联系电话：”&lt;&lt;endl;</span><br><span class="line">        string phone;</span><br><span class="line">        cin&gt;&gt;phone;</span><br><span class="line">        abs-&gt;personArray[abs-&gt;m_Size].m_Phone&#x3D;phone;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;住址</span><br><span class="line">        cout&lt;&lt;“请输入家庭住址：”&lt;&lt;endl;</span><br><span class="line">        string address;</span><br><span class="line">        cin&gt;&gt;address;</span><br><span class="line">        abs-&gt;personArray[abs-&gt;m_Size].m_Addr&#x3D;address;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;更新通讯录的人数</span><br><span class="line">        abs-&gt;m_Size++;</span><br><span class="line">        </span><br><span class="line">        cout&lt;&lt;“添加成功！”&lt;&lt;endl;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;system(“pause”);  &#x2F;&#x2F;请按任意键继续</span><br><span class="line">        &#x2F;&#x2F;system(“cls”);    &#x2F;&#x2F;清屏操作</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;4-显示所有联系人</span><br><span class="line">**void** showPerson(Addressbooks *abs)&#123;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;判断通讯录中人数是否为0.如果为0，提示记录为空；如果不为0，显示记录的联系人信息</span><br><span class="line">    **if**(abs-&gt;m_Size &#x3D;&#x3D; 0)&#123;</span><br><span class="line">        cout&lt;&lt;“当前记录为空！”&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    **else**&#123;</span><br><span class="line">        **for**(**int** I&#x3D;0;i&lt;abs-&gt;m_Size;i++)&#123;</span><br><span class="line">            cout&lt;&lt;“姓名：”&lt;&lt;abs-&gt;personArray[I].m_Name&lt;&lt;“\t”;</span><br><span class="line">            cout&lt;&lt;“性别：”&lt;&lt;(abs-&gt;personArray[I].m_Sex &#x3D;&#x3D; 1 ? “男”: “女”)&lt;&lt;“\t”;</span><br><span class="line">            cout&lt;&lt;“年龄：”&lt;&lt;abs-&gt;personArray[I].m_Age&lt;&lt;“\t”;</span><br><span class="line">            cout&lt;&lt;“电话：”&lt;&lt;abs-&gt;personArray[I].m_Phone&lt;&lt;“\t”;</span><br><span class="line">            cout&lt;&lt;“住址：”&lt;&lt;abs-&gt;personArray[I].m_Addr&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;system(“pause”);  &#x2F;&#x2F;请按任意键继续</span><br><span class="line">    &#x2F;&#x2F;system(“cls”);    &#x2F;&#x2F;清屏操作</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;5-检测联系人是否存在，如果存在返回联系人所在数组中的具体位置，不存在返回-1</span><br><span class="line">**int** isExist(Addressbooks *abs,string name)&#123;</span><br><span class="line">    </span><br><span class="line">    **for**(**int** I&#x3D;0;i&lt;abs-&gt;m_Size;i++)&#123;</span><br><span class="line">        &#x2F;&#x2F;找到用户输入的姓名了</span><br><span class="line">        **if**(abs-&gt;personArray[I].m_Name &#x3D;&#x3D; name)&#123;</span><br><span class="line">            **return** I;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    **return** -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;5-删除指定的联系人</span><br><span class="line">**void** deletePerson(Addressbooks *abs)&#123;</span><br><span class="line">    </span><br><span class="line">    Cout&lt;&lt;“请输入您要删除的联系人：”&lt;&lt;endl;</span><br><span class="line">    string name;</span><br><span class="line">    cin&gt;&gt;name;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;ret &#x3D;&#x3D; -1 未查到；ret !&#x3D; -1 已查到</span><br><span class="line">    **int** ret &#x3D;isExist(abs,name);</span><br><span class="line">    </span><br><span class="line">    **if**(ret !&#x3D; -1)&#123;</span><br><span class="line">        &#x2F;&#x2F;查找到此人，要进行删除操作</span><br><span class="line">        **for**(**int** I&#x3D;ret;i&lt;abs-&gt;m_Size;i++)&#123;</span><br><span class="line">            &#x2F;&#x2F;数据前移</span><br><span class="line">            abs-&gt;personArray[I]&#x3D;abs-&gt;personArray[I+1];</span><br><span class="line">        &#125;</span><br><span class="line">        Abs-&gt;m_Size—;    &#x2F;&#x2F;更新通讯录中的人员数</span><br><span class="line">        cout&lt;&lt;“删除成功！”&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    **else**&#123;</span><br><span class="line">        cout&lt;&lt;“查无此人！”&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;system(“pause”);  &#x2F;&#x2F;请按任意键继续</span><br><span class="line">    &#x2F;&#x2F;system(“cls”);    &#x2F;&#x2F;清屏操作</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;6-查找指定联系人的信息</span><br><span class="line">**void** findPerson(Addressbooks *abs)&#123;</span><br><span class="line">    </span><br><span class="line">    Cout&lt;&lt;“请输入您要查找的联系人：”&lt;&lt;endl;</span><br><span class="line">    string name;</span><br><span class="line">    cin&gt;&gt;name;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;判断指定的联系人是否在通讯录中</span><br><span class="line">    **int** ret&#x3D;isExist(abs, name);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;找到联系人</span><br><span class="line">    **if**(ret !&#x3D; -1)&#123;</span><br><span class="line">        cout&lt;&lt;“姓名：”&lt;&lt;abs-&gt;personArray[ret].m_Name&lt;&lt;“\t”;</span><br><span class="line">        cout&lt;&lt;“性别：”&lt;&lt;(abs-&gt;personArray[ret].m_Sex &#x3D;&#x3D; 1 ? “男”: “女”)&lt;&lt;“\t”;</span><br><span class="line">        cout&lt;&lt;“年龄：”&lt;&lt;abs-&gt;personArray[ret].m_Age&lt;&lt;“\t”;</span><br><span class="line">        cout&lt;&lt;“电话：”&lt;&lt;abs-&gt;personArray[ret].m_Phone&lt;&lt;“\t”;</span><br><span class="line">        cout&lt;&lt;“住址：”&lt;&lt;abs-&gt;personArray[ret].m_Addr&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;未找到联系人</span><br><span class="line">    **else**&#123;</span><br><span class="line">        cout&lt;&lt;“查无此人！”&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;system(“pause”);  &#x2F;&#x2F;请按任意键继续</span><br><span class="line">    &#x2F;&#x2F;system(“cls”);    &#x2F;&#x2F;清屏操作</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;7-修改指定联系人的信息</span><br><span class="line">**void** modifyPerson(Addressbooks *abs)&#123;</span><br><span class="line">    </span><br><span class="line">    Cout&lt;&lt;“请输入您要修改的联系人：”&lt;&lt;endl;</span><br><span class="line">    string name;</span><br><span class="line">    cin&gt;&gt;name;</span><br><span class="line">    </span><br><span class="line">    **int** ret &#x3D; isExist(abs, name);</span><br><span class="line">    </span><br><span class="line">    **if**(ret !&#x3D; -1)&#123;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;姓名</span><br><span class="line">        string name;</span><br><span class="line">        cout&lt;&lt;“请输入姓名：”&lt;&lt;endl;</span><br><span class="line">        cin&gt;&gt;name;</span><br><span class="line">        abs-&gt;personArray[ret].m_Name&#x3D;name;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;性别</span><br><span class="line">        cout&lt;&lt;“请输入性别：(1—男、2—女)”&lt;&lt;endl;</span><br><span class="line">        **int** sex&#x3D;0;</span><br><span class="line">        </span><br><span class="line">        **while**(**true**)&#123;</span><br><span class="line">            cin&gt;&gt;sex;</span><br><span class="line">            **if**(sex &#x3D;&#x3D; 1 || sex &#x3D;&#x3D; 2)&#123;</span><br><span class="line">                abs-&gt;personArray[ret].m_Sex&#x3D;sex;</span><br><span class="line">                **break**;</span><br><span class="line">            &#125;</span><br><span class="line">            Cout&lt;&lt;“输入有误，请重新输入！”&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;年龄</span><br><span class="line">        cout&lt;&lt;“请输入年龄：(0~200)”&lt;&lt;endl;</span><br><span class="line">        **int** age&#x3D;0;</span><br><span class="line">        </span><br><span class="line">        **while**(**true**)&#123;</span><br><span class="line">            cin&gt;&gt;age;</span><br><span class="line">            **if**(age &gt;&#x3D; 0 &amp;&amp; age &lt;&#x3D; 200)&#123;</span><br><span class="line">                abs-&gt;personArray[ret].m_Age&#x3D;age;</span><br><span class="line">                **break**;</span><br><span class="line">            &#125;</span><br><span class="line">            Cout&lt;&lt;“输入有误，请重新输入！”&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;电话</span><br><span class="line">        cout&lt;&lt;“请输入联系电话：”&lt;&lt;endl;</span><br><span class="line">        string phone;</span><br><span class="line">        cin&gt;&gt;phone;</span><br><span class="line">        abs-&gt;personArray[ret].m_Phone&#x3D;phone;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;地址</span><br><span class="line">        cout&lt;&lt;“请输入家庭住址：”&lt;&lt;endl;</span><br><span class="line">        string address;</span><br><span class="line">        cin&gt;&gt;address;</span><br><span class="line">        abs-&gt;personArray[ret].m_Addr&#x3D;address;</span><br><span class="line">        </span><br><span class="line">        cout&lt;&lt;“修改成功！”&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    **else**&#123;</span><br><span class="line">        cout&lt;&lt;“查无此人！”&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;system(“pause”);  &#x2F;&#x2F;请按任意键继续</span><br><span class="line">    &#x2F;&#x2F;system(“cls”);    &#x2F;&#x2F;清屏操作</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;8-清空所有联系人</span><br><span class="line">&#x2F;&#x2F;将通讯录所有联系人信息清除掉，只要将通讯录记录的联系人数量置于0，做逻辑清空即可</span><br><span class="line">**void** cleanPerson(Addressbooks *abs)&#123;</span><br><span class="line">    abs-&gt;m_Size&#x3D;0;</span><br><span class="line">    cout&lt;&lt;“通讯录已清空！”&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;system(“pause”);  &#x2F;&#x2F;请按任意键继续</span><br><span class="line">    &#x2F;&#x2F;system(“cls”);    &#x2F;&#x2F;清屏操作</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">**int** main(**int** argc, **const** **char** * argv[]) &#123;</span><br><span class="line">    &#x2F;&#x2F; insert code here…</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;创建用户选择输入的变量</span><br><span class="line">    **int** select&#x3D;0;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;3-创建通讯录结构体变量</span><br><span class="line">    Addressbooks abs;</span><br><span class="line">    &#x2F;&#x2F;3-初始化通讯录中当前人员个数</span><br><span class="line">    abs.m_Size&#x3D;0;</span><br><span class="line">    </span><br><span class="line">    **while**(**true**)&#123;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;1-调用显示菜单界面的函数</span><br><span class="line">        showMenu();</span><br><span class="line">        </span><br><span class="line">        cin&gt;&gt;select;</span><br><span class="line">        </span><br><span class="line">        **switch**(select)&#123;</span><br><span class="line">                </span><br><span class="line">            &#x2F;&#x2F;添加联系人</span><br><span class="line">            **case** 1:</span><br><span class="line">                addPerson(&amp;abs);  &#x2F;&#x2F;利用地址传递，可以修饰实参</span><br><span class="line">                **break**;</span><br><span class="line">                </span><br><span class="line">            &#x2F;&#x2F;显示联系人</span><br><span class="line">            **case** 2:</span><br><span class="line">                showPerson(&amp;abs);</span><br><span class="line">                **break**;</span><br><span class="line">                </span><br><span class="line">            &#x2F;&#x2F;删除联系人</span><br><span class="line">            **case** 3:</span><br><span class="line">                </span><br><span class="line">                &#x2F;*</span><br><span class="line">                 </span><br><span class="line">                 &#x2F;&#x2F;case中如果代码很长会报错，这个时候可以加一个大括号，代表一个代码段</span><br><span class="line">                 &#123;</span><br><span class="line">                 Cout&lt;&lt;“请输入要删除联系人的姓名：”&lt;&lt;endl;</span><br><span class="line">                 string name;</span><br><span class="line">                 cin&gt;&gt;name;</span><br><span class="line">                 </span><br><span class="line">                 if(isExist(&amp;abs, name) &#x3D;&#x3D; -1)&#123;</span><br><span class="line">                 Cout&lt;&lt;“查无此人！”;</span><br><span class="line">                 &#125;</span><br><span class="line">                 else&#123;</span><br><span class="line">                 Cout&lt;&lt;“找到此人！”;</span><br><span class="line">                 &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">                 </span><br><span class="line">                 *&#x2F;</span><br><span class="line">                </span><br><span class="line">                deletePerson(&amp;abs);</span><br><span class="line">                **break**;</span><br><span class="line">                </span><br><span class="line">            &#x2F;&#x2F;查找联系人</span><br><span class="line">            **case** 4:</span><br><span class="line">                findPerson(&amp;abs);</span><br><span class="line">                **break**;</span><br><span class="line">                </span><br><span class="line">            &#x2F;&#x2F;修改联系人</span><br><span class="line">            **case** 5:</span><br><span class="line">                modifyPerson(&amp;abs);</span><br><span class="line">                **break**;</span><br><span class="line">                </span><br><span class="line">            &#x2F;&#x2F;清空联系人</span><br><span class="line">            **case** 6:</span><br><span class="line">                cleanPerson(&amp;abs);</span><br><span class="line">                **break**;</span><br><span class="line">                </span><br><span class="line">            &#x2F;&#x2F;2-退出通讯录</span><br><span class="line">            **case** 0:</span><br><span class="line">                cout&lt;&lt;“欢迎下次使用”&lt;&lt;endl;</span><br><span class="line">                &#x2F;&#x2F;system(“pause”);</span><br><span class="line">                **return** 0;</span><br><span class="line">                **break**;</span><br><span class="line">                </span><br><span class="line">            **default**:</span><br><span class="line">                **break**;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;system(“pause”);</span><br><span class="line">    </span><br><span class="line">    **return** 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>程序的内存分区模型：</title>
    <url>/2019/06/24/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/C++/%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA%E6%A8%A1%E5%9E%8B%EF%BC%9A/</url>
    <content><![CDATA[<hr>
<p>C++程序在执行时，将内存大方向划分为4个区域<br>1）代码区：存放函数体的二进制代码，由操作系统进行管理<br>2）全局区：存放全局变量和静态变量以及常量【静态变量：static int s_a=10;】【常量分为字符串常量和const修饰的全局变量】<br>3）栈区：由编译器自动分配释放，存放函数的参数值，局部变量和const修饰的局部变量等<br>4）堆区：由程序员分配和释放，若程序不释放，程序结束时由操作系统回收</p>
<p>内存四区的意义：不同区域存放的数据，赋予不同的生命周期，给我们更大的灵活编程</p>
<p>程序运行前：在程序编译后，生成了exe可执行程序，未执行该程序前分为两个区域：<br>1）代码区：存放CPU执行的机器指令；代码区是共享的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可；代码区是只读的，使其只读的原因是防止程序意外的修改了它的指令<br>2）全局区：全局变量和静态变量存放在此；全局区还包含了常量区，字符串常量和其他常量也存放在此；该区域的数据在程序结束后由操作系统释放</p>
<p>程序运行后：<br>1）栈区：由编译器自动分配释放，存放函数的参数值，局部变量等；不要返回局部变量的地址，栈区开辟的数据由编译器自动释放</p>
<p>第一次可以打印正确的数字，是因为编译器做了保留；第二次这个数据就不再保留了：<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glwezd5rooj30s70ee0ua.jpg"><br>2）堆区：在C++中主要利用new在堆区开辟内存，释放利用操作符delete【利用new创建的数据，会返回该数据对应的类型的指针】<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glweznbhmpj30ed0bwq3u.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glwezuqgqjj30p80fyabi.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glwf02rx3qj30gm0gj402.jpg"></p>
<p>在堆区创建数组：int * arr = new int[10];<br>释放堆区数组：delete[] arr;</p>
]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>继承：</title>
    <url>/2019/06/16/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/C++/%E7%BB%A7%E6%89%BF%EF%BC%9A/</url>
    <content><![CDATA[<hr>
<p>继承是面向对象三大特性之一</p>
<p>定义某些类时，下级别的成员除了拥有上一级的共性，还有自己的特性，这个时候我们就可以考虑利用继承的技术，减少重复代码<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glwfg9czzxj30hx125wjm.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glwfgfbr0rj30e707pdgu.jpg"></p>
<p>继承方式：公共继承、保护继承、私有继承<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glwfglvd97j30hn0cwjud.jpg"></p>
<p>继承中的对象模型：<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glwfgse4qoj30dz0isdhm.jpg"></p>
<p>继承中的构造和析构顺序：子类继承父类后，当创建子类对象，也会调用父类的构造函数；先构造父类，再构造子类，析构的顺序与构造的顺序相反<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glwfgzbqddj30ii0k9ac5.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glwfh6ivubj30dz02nq38.jpg"></p>
<p>继承同名成员处理方式：</p>
<p>当子类与父类出现同名的成员，如何通过子类对象访问到子类或者父类中同名的数据呢？<br>1）访问子类同名成员，直接访问即可<br>2）访问父类同名成员，需要加作用域<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glwfhdadvij30n80yxgq3.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glwfhk4mgpj30dz033q3a.jpg"></p>
<p>继承同名静态成员处理方式：静态成员和非静态成员出现同名，处理方式一致；访问子类同名成员，直接访问即可；访问父类同名成员，需要加作用域<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glwfhr4rmzj30nb11hgrf.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glwfhzmn2lj30dz072759.jpg"></p>
<p>多继承：C++允许一个类继承多个类，多继承可能会引发父类中有同名成员出现，需要加作用域区分；C++实际开发中不建议用多继承<br>class Son:public Base1,public Base2</p>
<p>菱形继承：两个派生类继承同一个基类，又有某个类同时继承着两个派生类，这种继承被称为菱形继承，或者钻石继承</p>
<p>出现的问题：<br>1）羊继承了动物的数据，驼同样继承了动物的数据，当羊驼使用数据时，就会产生二义性<br>2）羊驼继承自动物的数据继承了两份，但是这份数据我们只需要一份就可以<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glwfi72uyrj30iw0mctc0.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glwfidoddzj30df01z74f.jpg"></p>
]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>结构体：</title>
    <url>/2019/06/26/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/C++/%E7%BB%93%E6%9E%84%E4%BD%93%EF%BC%9A/</url>
    <content><![CDATA[<hr>
<p>结构体属于用户自定义的数据类型，允许用户存储不同的数据类型</p>
<p>在结构体中可以定义另一个结构体作为成员</p>
<p>值传递传参的时候会耗费大量的内存空间，用地址传递可以减少内存空间，而且不会复制新的副本出来</p>
<p>结构体中用const来防止误操作：<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glwewrbsehj30xr0rxq9y.jpg"></p>
<p>—————————————<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glwewyvfprj30t20p1q7b.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glwex98ncxj308403i0sy.jpg"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct Hero&#123;</span><br><span class="line">	string name;</span><br><span class="line">	int age;</span><br><span class="line">	string sex;</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F;冒泡排序</span><br><span class="line">void bubbleSort(struct Hero heroArray[],int len)&#123;</span><br><span class="line">	for(int i&#x3D;0;i&lt;len-1;i++)&#123;</span><br><span class="line">		for(int j&#x3D;0;j&lt;len-1-i;j++)&#123;</span><br><span class="line">			if(heroArray[j].age&gt;heroArray[j+1].age)&#123;</span><br><span class="line">				struct Hero temp&#x3D;heroArray[j];</span><br><span class="line">				heroArray[j]&#x3D;heroArray[j+1];</span><br><span class="line">				heroArray[j+1]&#x3D;temp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void printHero(struct Hero heroArray[],int len)&#123;</span><br><span class="line">	for(int i&#x3D;0;i&lt;len;i++)&#123;</span><br><span class="line">		cout&lt;&lt;“姓名： “&lt;&lt;heroArray[I].name&lt;&lt;“年龄： “&lt;&lt;heroArray[I].age&lt;&lt;“性别：”&lt;&lt;heroArray[I].sex&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[]) &#123;</span><br><span class="line">	</span><br><span class="line">	struct Hero heroArray[5]&#x3D;&#123;</span><br><span class="line">		&#123;“刘备”,23,”男”&#125;,</span><br><span class="line">		&#123;“关羽”,22,”男”&#125;,</span><br><span class="line">		&#123;“张飞”,20,”男”&#125;,</span><br><span class="line">		&#123;“赵云”,21,”男”&#125;,</span><br><span class="line">		&#123;“貂蝉”,19,”女”&#125;,</span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line">	int len&#x3D;sizeof(heroArray)&#x2F;sizeof(heroArray[0]);</span><br><span class="line">	</span><br><span class="line">	bubbleSort(heroArray,len);</span><br><span class="line">	</span><br><span class="line">	printHero(heroArray,len);</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>class和循环retain</title>
    <url>/2019/08/14/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/Objective-C/@class%E5%92%8C%E5%BE%AA%E7%8E%AFretain/</url>
    <content><![CDATA[<hr>
<p>当两个类相互包含的时候：Person.h中包含Book.h，而Book.h中又包含Person.h，这个时候就会出现循环引用的问题，就会造成无限递归，而导致无法编译通过</p>
<p>解决方案：<br>.h头文件：<br>其中一边不要使用#import引入对方的头文件，而是使用@class 类名；来标注这是一个类，这样子就可以在不引入对方头文件的情况下告诉编译器这是一个类【@class Book;（有分号）】<br>.m头文件：<br>在.m文件中再<code># import</code>对方的头文件就可以使用了【#import “Book.h”】(其实不引入也可以，只是会有警告)</p>
<p>@class与@import的区别：<br>1）#import是将指定的文件的内容拷贝到写指令的地方<br>2）@class并不会拷贝任何内容，只是告诉编译器这是一个类，这样编译器在编译的时候才可以知道这是一个类</p>
<p>当两个对象相互引用的时候（A对象的属性是B对象，B对象的属性是A对象），这个时候，如果两边都使用retain，那么就会发生内存泄露<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly467uxfuj30db09zdid.jpg"></p>
<p>解决方案：一端使用retain，另外一端使用assign，使用assign的那一端在dealloc中不再需要release了<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly46gdexrj307s04fq40.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly46nkjtpj305606amyc.jpg"></p>
<p>注意：这里有一个很特别的点<br>[p1 read];要放在[b1 release];之前，否则会出现僵尸对象<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly46ummt7j307n0883zv.jpg"></p>
]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title>property</title>
    <url>/2019/08/29/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/Objective-C/@property/</url>
    <content><![CDATA[<hr>
<p>写一个类：<br>1）要先为类写属性<br>2）再声明属性的getter和setter<br>3）再实现getter和setter</p>
<p>@property</p>
<p>作用：自动生成getter、setter方法的声明，因为是生成方法的声明，所以应该写在@interface类的声明之中</p>
<p>语法：@property 数据类型 名称；<code>@property int age;</code></p>
<p>原理：<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly3uk8pkvj30c4049764.jpg"></p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly3urj5vpj30gr059juq.jpg"></p>
]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title>类模板：</title>
    <url>/2019/06/11/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/C++/%E7%B1%BB%E6%A8%A1%E6%9D%BF%EF%BC%9A/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>property参数</title>
    <url>/2019/08/15/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/Objective-C/@property%E5%8F%82%E6%95%B0/</url>
    <content><![CDATA[<hr>
<p>1）@property可以带参数的：@property(参数1，参数2，参数3…..)  数据类型 名称;</p>
<p>@property的四组参数：<br>1）与多线程相关的两个参数：atomic（默认值）、nonatomic<br>2）与生成的setter方法的实现相关的参数：assign（默认值）、retain<br>3）与生成只读、读写相关的参数：readonly、readwrite（默认值）<br>4）与生成的getter、setter方法名字相关的参数：getter、setter</p>
<p>使用参数注意：<br>1）同一组参数只能使用一个（getter、setter可以同时使用）<br>2）参数的顺序可以随意（一般默认顺序就好）</p>
<p>Atomic：如果写atomic，这个时候生成的setter方法的代码就会被加上一把线程安全锁；特点：安全但效率低下<br>Nonatomic：如果写nonatomic，这个时候生成的setter方法的代码就不会加线程安全锁；特点：不安全但效率高</p>
<p>建议：要效率，选择使用nonatomic</p>
<p>Assign：生成的setter方法的实现就是直接赋值<br>Retain：生成的setter方法的实现就是标准的MRC内存管理代码，也就是先判断新旧对象是否为同一个对象，如果不是则release旧的，retain新的</p>
<p>当属性的类型是OC对象类型的时候，那么就使用retain<br>当属性的类型是非OC对象的时候，使用assign</p>
<p>千万注意：retain参数只是生成标准的setter方法为标准的MRC内存管理代码，不会自动的在dealloc中生成release的代码，所以，我们还要自己手动的在dealloc中release</p>
<p>readwrite：代表同时生成getter、setter<br>readonly：只会生成getter，不会生成setter</p>
<p>默认情况下，@property生成的getter、setter方法的名字都是最标准的名字，其实我们可以通过参数来指定@property生成的方法的名字</p>
<p>getter=getter方法名字，用来指定@property生成的getter方法的名字<br>setter=setter方法名字，用来指定@property生成的setter方法的名字（注意，setter方法是带参数的，所以要加一个冒号！！）<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly45ayietj30b206ewf4.jpg"></p>
<p>如果使用getter、setter修改了生成的方法的名字，在使用点语法的时候，编译器会转换成调用修改后的名字的代码<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly45n8047j302o014wel.jpg"></p>
<p>一般情况下不要去改名字：<br>1）无论什么情况都不要改setter方法的名字，因为默认情况下生成的名字就已经是最标准的了<br>2）什么时候修改getter方法的名字：当属性的类型是一个BOOL类型的时候，就修改这个getter的名字以is开头提高代码的阅读性</p>
]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title>property增强（Xcode4.4之后）</title>
    <url>/2019/08/27/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/Objective-C/@property%E5%A2%9E%E5%BC%BA%EF%BC%88Xcode4.4%E4%B9%8B%E5%90%8E%EF%BC%89/</url>
    <content><![CDATA[<hr>
<p>只需要写一个@property，编译器就会自动的<br>1）生成私有属性<br>2）生成getter、setter的声明<br>3）生成getter、setter的实现<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly3wfia8pj307j03vaav.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly3wm8ffrj30he04dwh7.jpg"></p>
<p>使用注意：<br>1）@property的类型一定要和属性的类型一致，名称要和属性的名称一致，只是去掉下划线<br>2）也可以批量声明相同类型的@property<br>3）@property生成的方法实现没有做任何的逻辑验证<br>setter：直接赋值<br>getter：直接返回<br>所以我么可以重写setter来自定义验证逻辑，如果重写了setter还会自动生成getter，如果重写了getter还会自动生成setter；如果同时重写setter和getter，那么就不会自动生成私有属性了，那么就自己定义一个私有属性就可以了<br>4）如果你想为类写一个属性，并且为这个属性封装setter和getter，一个@property就搞定<br>5）父类的@property一样可以被子类继承，@property生成的属性是私有的，在子类的内部无法直接访问生成的私有属性，但是可以通过setter和getter来访问<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly3wsxxq1j305m04dt9c.jpg"></p>
]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title>property另外两个参数：</title>
    <url>/2019/08/09/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/Objective-C/@property%E5%8F%A6%E5%A4%96%E4%B8%A4%E4%B8%AA%E5%8F%82%E6%95%B0%EF%BC%9A/</url>
    <content><![CDATA[<hr>
<p>在ARC的机制下，@property参数不能使用retain，因为retain代表生成的setter方法是MRC的标准内存管理代码</p>
<p>ARC机制下关注的重点：当一个类的属性是一个OC对象的时候，这个属性应该声明为强类型的还是弱类型的，很明显应该声明为强类型的<br>【人未死车已报废】<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly49rp7k7j307i05lwfd.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly49yxjnzj307i04gaax.jpg"></p>
<p>如何控制@property生成的私有属性是一个强类型的还是一个弱类型的？<br>使用参数：strong（默认值）和weak<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly4a5pjxxj30700173yw.jpg"></p>
<p>使用建议：<br>1）在ARC机制下，如果属性的类型是OC对象类型的，绝大多数场景下使用strong<br>2）在ARC机制下，如果属性的类型不是OC对象类型的，使用assign<br>3）strong和weak都是应用在属性的类型是OC对象的时候</p>
]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title>synthesize</title>
    <url>/2019/08/28/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/Objective-C/@synthesize/</url>
    <content><![CDATA[<hr>
<p>作用：自动生成getter、setter方法的实现，所以应该写在类的实现之中</p>
<p>语法：<code>@synthesize @property名称;</code><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly3vbvx6cj307005975d.jpg"></p>
<p>@synthesize做的事情：<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly3vjw8cij307008ign5.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly3vqcbuyj30es03u76r.jpg"></p>
<p>问题：<br>希望@synthesize不要去自动生成私有属性了，getter和setter的实现中操作我们已经写好的属性就可以了</p>
<p>语法：@synthesize @property名称 = 已经存在的属性名;【@synthesize age=_age;】<br>1）不会再去生成私有属性<br>2）直接生成setter和getter的实现<br>Setter的实现：把参数的值直接赋值给指定的属性，是没有做任何逻辑验证的<br>Getter的实现：直接返回指定的属性的值<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly3vxa8p7j305y058q3o.jpg"></p>
<p>如果setter或者getter有自己的逻辑验证，那么就自己在类的实现中重写就可以了</p>
<p>批量声明：<br>1）如果多个@property的类型一致，可以批量声明</p>
<p><code>@property float height,weight;</code></p>
<p>2）@synthesize也可以批量声明（类型不一致也可以）</p>
<p><code>@synthesize name = _name,age = _age,weight = _weight,height = _height;</code></p>
]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title>required与optional</title>
    <url>/2019/07/24/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/Objective-C/@required%E4%B8%8E@optional/</url>
    <content><![CDATA[<hr>
<p>当一个类遵守了一份协议，这个类只是拥有了这个协议中的方法的声明而已，没有实现，所以这个类还应该实现协议中的方法；如果类不实现协议中的方法，其实也不会报错，编译器只是会报警告；但是当创建对象，来调用这个没有实现的协议中的方法的时候，就会报错</p>
<p>这两个修饰符是专门用来修饰协议中的方法的<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly4pvf6jmj306l04udgl.jpg"></p>
<p>在协议中，如果方法的声明被@required修饰，那么遵守这个协议的类必须要实现这个方法，否则编译器会发出警告；<br>如果方法的声明被@optional修饰，那么遵守这个协议的类如果不实现这个方法，编译器也不会发出警告</p>
<p>这两个关键字的主要作用：在于程序员沟通，告诉遵守协议的类，哪些方法是必须要实现的（@required必须实现，@optional可实现可不实现），因为这些方法我会调用</p>
<p>默认的是：@required</p>
]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title>ARC机制下的循环引用：</title>
    <url>/2019/08/08/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/Objective-C/ARC%E6%9C%BA%E5%88%B6%E4%B8%8B%E7%9A%84%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%EF%BC%9A/</url>
    <content><![CDATA[<hr>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly4arxn6oj30dp09gdhw.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly4ay7aqoj307906gjsi.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly4b4emkpj307903laav.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly4ba4dckj304k049gm3.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly4bg8lkuj307903laat.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly4bnl581j304k0490t7.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly4buhqd3j30df095q59.jpg"></p>
<p>在ARC机制下，当两个对象相互引用的时候，如果两边都使用strong，那么就会出现内存泄漏，解决方案：一端使用strong，一端使用weak</p>
]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title>Description方法</title>
    <url>/2019/09/04/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/Objective-C/Description%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<hr>
<p>%p打印的是指针变量的值<br>%@打印的是指针指向的对象</p>
<p>如果我们使用%@打印一个对象，发现输出的格式：<code>&lt;对象所属的类名：对象的地址&gt;</code></p>
<p>当我们使用%@打印一个对象的时候，NSLog函数的底层实现：<br>1）调用传入的对象的Description方法<br>2）拿到这个方法的返回值，这个返回值是一个字符串<br>3）将这个字符串输出</p>
<p>Description方法是定义在NSObject类之中的，所以每一个OC对象都有这个方法，这个方法在NSObject类中的实现是这样的：返回的字符串格式   <code>@“&lt;对象所属的类名：对象的地址&gt;”</code></p>
<p>如果使用%@打印一个对象的时候，你希望这个对象打印的格式是我们自己自定义的，那么就可以重写Description方法</p>
]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title>ARC下的单个对象的内存管理：</title>
    <url>/2019/08/10/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/Objective-C/ARC%E4%B8%8B%E7%9A%84%E5%8D%95%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%9A/</url>
    <content><![CDATA[<hr>
<p>1）当指向对象的所有的强指针被回收的时候，对象就会被立即回收<br>2）当所有指向对象的强指针赋值为nil的时候，对象就会被立即回收</p>
<p>注意：不能创建对象用一个弱指针存储这个对象的指针，这样的话，刚创建出来的对象，就没有任何强指针指向，创建出来就被回收<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly48zujqsj309504rdh8.jpg"></p>
<p>在ARC机制下，当对象被回收的时候，原来指向这个对象的弱指针会被自动设置为nil<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly4988ujuj309w09a401.jpg"></p>
]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title>ARC机制概述</title>
    <url>/2019/08/11/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/Objective-C/ARC%E6%9C%BA%E5%88%B6%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<hr>
<p>Automatic Reference Counting，自动引用计数，即ARC，系统自动的帮助我们去计算对象的引用计数器的值</p>
<p>在程序中使用ARC非常简单，只需要向往常那样编写代码，只不过永远不要写retain，release，autorelease这三个关键字就好，永远不要手动的调用dealloc【在dealloc方法中不要调用父类dealloc】，这是ARC最基本的原则，当ARC开启时，编译器就会自动的在合适的地方插入retain，release，autorelease代码，编译器自动为对象做引用计数</p>
<p>ARC机制下，对象何时被释放：<br>本质：对象的引用计数器为0的时候，自动释放<br>表象：只要没有强指针指向这个对象，这个对象就会立即回收</p>
<p>强指针与弱指针：</p>
<p>强指针：默认情况下，我们声明一个指针，这个指针就是一个强指针，我们也可以用__strong(两个下划线)来显示的声明这是一个强指针</p>
<p>弱指针：使用__weak标识的指针就叫做弱指针</p>
<p>无论是强指针还是弱指针都是指针，都可以用来存储地址，这一点没有任何区别，都可以通过这个指针访问对象的成员；唯一的区别就是在ARC模式下，它们用来作为回收对象的基准：如果一个对象没有任何强类型的指针指向这个对象的时候，对象就会被立即释放</p>
]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title>MRC、ARC兼容与转换：</title>
    <url>/2019/08/07/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/Objective-C/MRC%E3%80%81ARC%E5%85%BC%E5%AE%B9%E4%B8%8E%E8%BD%AC%E6%8D%A2%EF%BC%9A/</url>
    <content><![CDATA[<hr>
<p>兼容：<br>如果程序使用的是ARC机制开发的，但是其中某个类使用的是MRC，这个时候双击使用MRC的那个文件输入命令：-fno-obj-arc<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly4cda0y1j30rn0a73ze.jpg"></p>
<p>MRC转换为ARC：Edit——&gt;Convert——&gt;To Objective-C ARC…</p>
]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title>NSArray与字符串的两个方法：</title>
    <url>/2019/07/08/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/Objective-C/NSArray%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%96%B9%E6%B3%95%EF%BC%9A/</url>
    <content><![CDATA[<hr>
<p>1）将数组中的元素连接起来组成一个新的字符串<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly58163gyj309u05ydgx.jpg"><br>2）将字符串以指定的分隔符分成一个数组，每一部分就是数组的一个元素<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly58729jaj309u07zq5x.jpg"></p>
]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title>NSArray：</title>
    <url>/2019/07/09/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/Objective-C/NSArray%EF%BC%9A/</url>
    <content><![CDATA[<hr>
<p>是Foundation框架中的一个类，这个类的对象是来存储多个数据的，具备数组的功能，所以NSArray是OC中的数组<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly54r5m1kj30bk029q3z.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly54y4dt3j30am02sjsl.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly554f48oj309n04n75b.jpg"><br>最常用的创建数组的方式：【只能存储OC对象】<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly55biuvaj30f906jdha.jpg"><br>简写方式：<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly55i1ayhj308n05gab6.jpg"></p>
<p>取出对应的元素的值：<br>1）<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly55ou6yzj3085073gna.jpg"><br>2）<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly55v4cuuj308505u0u3.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly561562gj30ax02b0tp.jpg"></p>
<p>NSArray数组的其他常用方法：<br>1）得到数组中元素的个数<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly568u6knj309r05utae.jpg"><br>2）判断数组中是否包含指定的元素<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly56fpr1qj309r08qtav.jpg"><br>3）查找指定的元素在NSArray数组中第一次出现的下标<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly56mqmepj30bc01pdgl.jpg"></p>
<p>NSArray数组的遍历：<br>1）使用for循环<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly56ua7zxj30bc06vdii.jpg"><br>2）声明在for()中的变量叫做迭代变量【执行原理：将数组中的第一个元素的值赋值给迭代变量，执行循环体，再将数组中的第二个元素的值赋值给迭代变量，再执行循环体】<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly571nnsbj30bc06vgo9.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly577p421j30bc092q5y.jpg"><br> 3）使用block遍历<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly57ef4cnj30ef08042f.jpg"></p>
]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title>NSDate：</title>
    <url>/2019/06/30/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/Objective-C/NSDate%EF%BC%9A/</url>
    <content><![CDATA[<hr>
<p>可以得到当前的时间，得到的是当前系统的格林威治时间（0时区），北京是东八区<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly5o1171hj305t018wer.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly5o7clp5j305t018t8v.jpg"></p>
<p>转换成自己想要输出的格式：【日期转换为字符串】<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly5od3jaij30cz09vdkg.jpg"><br>将字符串转换为日期：<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly5ok8nbnj30ab03m76b.jpg"></p>
<p>在当前格林威治的时间基础上增加多少秒：【负数表示减少】<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly5oqeafij30by01iaak.jpg"></p>
<p>计算时间之差：<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly5ow587ij30aq04gq4k.jpg"></p>
<p>拿到日期的各个部分：<br>1）<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly5p2ugrcj30a602vgmz.jpg"><br>2）<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly5p8wu1nj30jw04hdip.jpg"></p>
]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title>NSMutableString：</title>
    <url>/2019/07/10/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/Objective-C/NSMutableString%EF%BC%9A/</url>
    <content><![CDATA[<hr>
<p>会耗费很长的时间，每次循环的时候都会创建一个新的字符串对象，因为字符串的恒定性<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly53lb14dj309j02uab2.jpg"></p>
<p>NSMutableString是Foundation框架中的一个类，从NSString继承，所以NSMutableString对象是用来存储字符串数据的，NSMutableString在父类NSString的基础之上做了扩展，存储在NSMutableString对象中的字符串数据可以更改，具备可变性</p>
<p>往可变字符串对象中追加字符串【第二个是以拼接的方式追加】<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly53s1pjpj30do070acc.jpg"></p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly53z5gynj30ac02rgmw.jpg"></p>
<p>NSMutableString从NSString继承，在使用NSString的地方完全可以使用NSMutableString</p>
<p>使用NSMutableString来做大批量的字符串拼接：【NSMutableString只有一个，每次修改的时候直接修改的是这个对象中的数据】<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly546qf6vj309a037jsf.jpg"></p>
<p>平时使用NSString，做大量拼接的时候使用NSMutableString</p>
]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title>NSFileManager：</title>
    <url>/2019/07/03/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/Objective-C/NSFileManager%EF%BC%9A/</url>
    <content><![CDATA[<hr>
<p>NSFileManager是Foundation框架提供的一个类，用来操作磁盘上的文件和文件夹，对它们进行创建、删除、复制、拷贝、移动</p>
<p>NSFileManager类的对象是以单例模式创建的：<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly5hp8zrzj30a801h0t2.jpg"></p>
<p>常用方法之判断：<br>1）判断指定的文件或者文件夹在磁盘上是否真实的存在<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly5hwrwlrj30ao084tb6.jpg"><br>2）判断指定的路径是否真实的存储在我们的磁盘之上，并且判断这个路径是一个文件夹路径还是一个文件路径<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly5i34wtlj30b30at41h.jpg"><br>3）判断指定的文件夹或者文件是否可以读取<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly5iam1klj30e503nq4e.jpg"><br>4）判断指定的文件夹或者文件是否可以写入<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly5ih8vqpj30ce01vjs5.jpg"><br>5）判断指定的文件夹或者文件是否可以删除<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly5imyiflj30al01vmxv.jpg"></p>
<p>常用方法之获取信息：<br>1）获取指定文件或者文件夹的属性信息<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly5iurvuij30ig09j0wu.jpg"><br>只是想拿到文件或文件夹的大小信息：<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly5j2k4vtj30hp02h75e.jpg"><br>2）获取指定目录下的所有的文件和目录【所有的都拿到】<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly5j9tj1qj30e5031wfo.jpg"><br>3）获取指定目录下所有的子目录和文件【不包括孙子辈】<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly5jghamuj30hn055770.jpg"></p>
<p>常用方法之文件/目录的创建：<br>1）在指定的目录创建文件<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly5jn99twj30hu0avwht.jpg"><br>2）在指定的目录创建文件夹【第2个参数：YES做一路创建，NO就不会】<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly5jvbsdpj30hs04xmyp.jpg"><br>3）拷贝文件<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly5k3djl0j30if04emz8.jpg"><br>4）移动/剪切文件—文件的重命名<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly5kdngvaj30i0028t9s.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly5kja7xfj30i0028dh1.jpg"><br>5）删除文件【删除的文件不会倒在废纸篓，而是直接删除】<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly5kpuzkyj30f4028gmj.jpg"></p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly5kx5ehjj30dx0b0wi3.jpg"></p>
]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title>NSNumber：</title>
    <url>/2019/07/06/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/Objective-C/NSNumber%EF%BC%9A/</url>
    <content><![CDATA[<hr>
<p>无论是NSArray还是NSMutableArray里面都只能存储OC对象，基本数据类型是无法存储的</p>
<p>NSNumber是Foundation框架中定义好的一个类，这个类的对象的作用就是用来包装基本数据类型的<br>1）先将基本数据类型包装到NSNumber对象中<br>2）再将NSNumber对象存储到NSArray数组中<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly5bbtua2j308v04tdhg.jpg"></p>
<p>简写方式：<br>【@10代表是一个NSNumber对象，这个对象中包装的是整型的10】<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly5bj7seij306i02rmxu.jpg"></p>
<p>如果后面的数据是一个变量，那么这个变量就必须要使用小括弧括起来：<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly5bph0vzj304z02074e.jpg"></p>
]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title>NSMutableArray：</title>
    <url>/2019/07/07/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/Objective-C/NSMutableArray%EF%BC%9A/</url>
    <content><![CDATA[<hr>
<p>NSMutableArray是NSArray的子类，NSMutableArray仍然是一个数组，具备NSArray数组的特点</p>
<p>NSMutableArray相对于父类做的扩展：NSMutableArray数组的元素可以动态的新增和删除</p>
<p>NSMutableArray数组的创建：<br>1）这样创建出来的数组对象数组的元素是0，仍然是有意义的，因为我们可以动态的新增和删除元素<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly58rw66dj309a01imxu.jpg"><br>2）<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly58z08tvj30ek00ymxk.jpg"></p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly5952cp6j308x026t9p.jpg"></p>
<p>往可变数组中新增元素：<br>1）<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly59benhdj30b2074wgy.jpg"><br>2）<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly59idpbnj30b208c0vc.jpg"><br>3）将另外一个数组中的每一个元素添加到可变数组中<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly59pypqoj309m06vdhk.jpg"></p>
<p>在可变数组中指定的下标中插入一个元素：<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly59w2dbyj30fj06vwg6.jpg"></p>
<p>删除可变数组中指定下标的元素：<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly5a269h9j30em056my8.jpg"></p>
<p>删除可变数组中所有的指定的元素：<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly5a9icxxj30fb04sta9.jpg"></p>
<p>删除指定范围中的所有指定的元素：<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly5ag7ttdj30fr02s3zm.jpg"></p>
<p>删除最后一个元素：<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly5amtdcdj30fr042myp.jpg"></p>
<p>删除所有元素：<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly5asugj5j30fr04j0u7.jpg"></p>
]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title>NSObject指针和id指针</title>
    <url>/2019/08/25/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/Objective-C/NSObject%E6%8C%87%E9%92%88%E5%92%8Cid%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<hr>
<p>NSObject是OC中所有类的基类，根据LSP，NSObject指针就可以指向任意的OC对象，所以，NSObject指针是一个万能指针，可以指向任意的OC对象</p>
<p>缺点：如果要调用指向的子类对象的独有的方法，就必须要做类型转换</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSObject *obj1&#x3D;[Person new];</span><br><span class="line">[(Person *)obj1 sayHi];</span><br><span class="line"></span><br><span class="line">NSObject *obj2&#x3D;[Student new];</span><br><span class="line">[(Student *)obj2 study];</span><br><span class="line"></span><br><span class="line">NSObject *obj3&#x3D;@&quot;jack&quot;;</span><br><span class="line">[(NSString *)obj3 length];</span><br></pre></td></tr></table></figure>

<p>id指针：是一个万能指针，可以指向任意的OC对象</p>
<p>id是一个typedef自定义类型，在定义的时候已经加了<em>，所以，声明id指针的时候不需要再加</em>了</p>
<p>通过NSObject指针去调用对象的方法的时候，编译器会做编译检查<br>通过id类型的指针去调用对象的方法的时候，编译器直接通过，无论你调用什么方法【该运行错误的还是运行错误】</p>
<p>注意：id指针只能调用对象的方法，不能使用点语法，如果使用点语法就会直接报编译错误</p>
<p>如果我们要声明一个万能指针，不要使用NSObject，而是使用id</p>
]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title>NSString：</title>
    <url>/2019/09/17/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/Objective-C/NSString%EF%BC%9A/</url>
    <content><![CDATA[<hr>
<p>1）NSString是一个数据类型，用来保存OC字符串<br>2）NSString是Foundation框架中的一个类，作用是存储OC字符串的，所以OC中的字符串本质上是用NSString对象来存储的</p>
<p>其实完整的标准的创建NSString对象的方式：<br>NSString *str0=[NSString new];<br>NSString *str1=[NSString string];<br>这种方式创建的字符串是空字符串 @“”</p>
<p>但是，NSString是我们最常用的一个对象，所以OC使用了一种更为简单的方式来创建字符串对象：直接使用@来表示一个OC字符串<br>@“jack”;(这个其实本质上是一个NSString对象)</p>
<p>NSString *str=@“jack”;【str的值是这个对象的地址，%p打印的是指针变量的值；%@打印的是指针变量指向的对象】<br>NSString *str1=[NSString stringWithFormat:@“jack”];</p>
<hr>
<p>NSString最常用的类方法：</p>
<ol>
<li><p><code>+ (instancetype)stringWithUTF8String:(const char *)nullTerminatedCString;</code><br>Instancetype作为返回值，代表返回的是当前这个类的对象<br>作用：将C语言的字符串转换为OC字符串对象</p>
</li>
<li><p><code>+ (instancetype)stringWithFormat:(NSString *)format,….</code><br>作用：拼接一个字符串对象，使用变量或者其他数据拼接成OC字符串<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly3llywhfj30hj05ctav.jpg"></p>
</li>
</ol>
<hr>
<p>NSString最常用的对象方法：</p>
<ol>
<li><p>length方法，返回值为NSUInteger，其实就是unsigned long<br>得到字符串的字符的个数，可以处理中文<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly3lx9vl5j308x044myd.jpg"></p>
</li>
<li><p>得到字符串中指定下标的字符<br><code>* (unichar)characterAtIndex:(NSUInteger)index;</code><br>返回值是unichar，其实就是unsinged short，占据两个字节</p>
</li>
</ol>
<p>如果要输出unichar变量的值使用%C(中文输出)<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly3m5g3snj309h04ldh3.jpg"></p>
<ol start="3">
<li>判断两个字符串的内容是否相同，不要用==去判断，因为这样有可能会出问题：<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly3me1e4aj30co06ywgl.jpg"></li>
</ol>
<p>判断相等的方式：<br><code>* (BOOL)isEqualToString:(NSString *)aString;</code><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly3mkylqvj30cr0900v4.jpg"></p>
<ol start="4">
<li>比较字符串的大小</li>
</ol>
<p><code>* (NSComparisonResult)compare:(NSString *)string;</code><br>完全可以使用int来接收结果，因为返回值是一个枚举<br>返回值如果是-1（小于），0（等于），1（大于）<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly3ms9hzuj308o054gn3.jpg"></p>
]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title>NSString类：</title>
    <url>/2019/07/20/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/Objective-C/NSString%E7%B1%BB%EF%BC%9A/</url>
    <content><![CDATA[<hr>
<p>NSString是一个数据类型，保存OC字符串的，实际上NSString的本质是一个类<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly4rhv2ywj3081022756.jpg"><br>使用这种方式创建的字符串是一个空的字符@“”</p>
<p>当我们调用NSString的类方法来创建对象的时候，创建的字符串对象是存储在堆区</p>
<p>OC提供了一种更为快速的创建字符串对象的方式，使用前缀@</p>
<p>@“jack”;<br>本质上这是一个NSString对象，这个NSString对象中存储的是”jack”这个字符串，这个字符串对象是存储在常量区（数据段）的</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly4rpku0sj30gi096mye.jpg"></p>
<p>NSString的恒定性：当在内存中创建一个字符串对象以后，这个字符串对象的内容就无法更改，当我们重新为字符串指针初始化值的时候，并不是修改原来的字符串对象，而是重新的创建一个字符串对象，将这个字符串对象的地址重新赋值给字符串指针变量<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly4rxdc8kj30eg0ae756.jpg"></p>
<p>当系统准备要在内存中创建字符串对象的时候，会先检查内存中是否有相同内容的字符串对象，如果有直接指向，如果没有才会重新创建</p>
<p>存储在常量区的数据不会被回收，所以存储在常量区的字符串对象也不会被回收【堆区也一样】<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly4s4r2d6j30ck08tdjc.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly4scarf2j30dj09i77o.jpg"></p>
]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title>NSValue：</title>
    <url>/2019/07/01/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/Objective-C/NSValue%EF%BC%9A/</url>
    <content><![CDATA[<hr>
<p>NSRange、CGPoint、CGSize、CGRect这些都是结构体，他们的变量是无法存储到集合之中，要先将这些结构体变量存储到OC对象中，再将OC对象存储到集合之中<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly5nl0ri2j30a80d4td5.jpg"></p>
]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title>NSDictionary与NSMutableDictionary：</title>
    <url>/2019/07/05/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/Objective-C/NSDictionary%E4%B8%8ENSMutableDictionary%EF%BC%9A/</url>
    <content><![CDATA[<hr>
<p>NSArray与NSMutableArray的缺点：数组元素的下标不固定，都有可能会发生变化，无法通过下标来唯一确定数组中的元素</p>
<p>存储数据的时候，必须要为存储的数据取一个别名，这个别名的作用就是用来确定别名对应的数据的，这种存储数据的方式就叫做键值对的存储方式（Key-Value）</p>
<p>它们是数组，是以键值对的形式存储数据的，往这个数组中存储数据的同时必须要指定这个数据的别名才可以，要找到存储在这个数组中的数据，通过别名来找，而不是通过下标</p>
<p>NSDictionary：字典数组<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly5c9eceqj30ar027my6.jpg"></p>
<p>创建字典数组：<br>1）这种方式无意义<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly5cgt98qj309901raas.jpg"><br>2）<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly5cmnc6zj30gb018gma.jpg"><br>3）简要方式<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly5ct29xbj30gb0183z1.jpg"></p>
<p>使用：<br>1）根据别名取值：<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly5d0yy6ij30dd01qwep.jpg"><br>2）键值对的数量：<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly5d7cblej30dd01q0sv.jpg"><br>3）<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly5ddq3fwj308002ajrl.jpg"><br>4）<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly5djk64yj309302amxd.jpg"><br>5）遍历字典数组【字典数组中的数据无法使用下标去取，所以普通的for循环就无用了】</p>
<p>1.使用for in循环遍历出来的是字典数组中所有的键，再通过键取出对应的值<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly5dqj0frj30ax0b4gov.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly5dxr6l8j30eq097dj6.jpg"><br>2.使用block遍历<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly5e6jq5cj30ix0c442y.jpg"></p>
<p>字典数组存储数据的原理：<br>1）并不是按照顺序依次存储的<br>2）存储键值对的时候，会根据键和数组的长度做一个哈希算法，算出一个下标，将这个键值对存储在该下标处<br>3）取值的时候也是做哈希算法</p>
<p>与NSArray对比：<br>1）NSArray数组的元素是按照顺序来存储的，字典数组中存储的下标是算出来的<br>2）存储的效率NSArray要高一些<br>如果取值的时候是把所有的数据取出来，NSArray效率高<br>如果只是取数组中指定的几个元素，字典数组效率高</p>
<p>NSMutableDictionary：存储在其中的元素可以动态的新增和删除</p>
<p>创建可变字典数组：<br>1）有意义<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly5ehtossj30an01kmy0.jpg"><br>2）<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly5eorn5vj30bb017aao.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly5ev5o60j309300vwep.jpg"></p>
<p>新增键值对：【如果键重复，后添加的就会替换原有的】<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly5f0tn78j30ba03r0tq.jpg"></p>
<p>删除所有键值对：<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly5f7h0phj30ba07atar.jpg"><br>删除某一个键值对：<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly5fdptw3j306j02a74k.jpg"></p>
<p>字典数组的信息持久化：保存到plist文件里：<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly5flzn7fj30bp044taj.jpg"><br>从plist文件中还原：<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly5fsa5waj30ff08qtbu.jpg"></p>
]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title>OC与C的对比：</title>
    <url>/2019/09/27/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/Objective-C/OC%E4%B8%8EC%E7%9A%84%E5%AF%B9%E6%AF%94%EF%BC%9A/</url>
    <content><![CDATA[<hr>
<h3 id="数据类型："><a href="#数据类型：" class="headerlink" title="数据类型："></a>数据类型：</h3><ol>
<li>OC中支持C语言的所有的数据类型</li>
<li>BOOL类型：可以存储YES或者NO中的任意一个数据；一般情况下BOOL类型的变量用来存储条件表达式的结果</li>
</ol>
<p>typedef signed char BOOL;<br>BOOL类型变量的本质实际上是一个有符号的char变量</p>
<ol start="3">
<li>Boolean类型的变量可以存储true或者false</li>
</ol>
<p>typedef unsigned char BOOL;<br>Boolean类型变量的本质实际上是一个无符号的char变量</p>
<ol start="4">
<li>class 类型：类</li>
<li>id类型：万能指针</li>
<li>nil与NULL差不多</li>
<li>SEL：方法选择器</li>
<li>block：代码段</li>
</ol>
<hr>
<h3 id="运算符："><a href="#运算符：" class="headerlink" title="运算符："></a>运算符：</h3><p>OC支持C语言中所有的运算符：</p>
<ul>
<li>赋值运算符：=</li>
<li>算术运算符：+、-、*、/、%</li>
<li>复合赋值运算符：+=、-=、*=、/=、%=</li>
<li>自增与自减：++、—-</li>
<li>关系运算符：&gt;、&gt;=、&lt;、&lt;=、==、!=</li>
<li>逻辑运算符：&amp;&amp;、||、!</li>
<li>取地址运算符：&amp;</li>
<li>指针访问运算符：*</li>
<li>位运算符：&amp;、|、^、~</li>
</ul>
<hr>
<h3 id="控制语句："><a href="#控制语句：" class="headerlink" title="控制语句："></a>控制语句：</h3><p>OC支持C所有的控制语句：</p>
<ul>
<li>if结构</li>
<li>switch-case结构</li>
<li>while循环</li>
<li>do-while循环</li>
<li>for循环</li>
<li>数组</li>
<li>函数</li>
<li>指针</li>
</ul>
<hr>
<h3 id="关键字："><a href="#关键字：" class="headerlink" title="关键字："></a>关键字：</h3><ol>
<li>OC支持C语言中全部的关键字，并且效果一致</li>
<li>OC也新增了一些关键字，OC新增的关键字绝大多数都是以@开头</li>
</ol>
<ul>
<li>@interface</li>
<li>@implmentation</li>
<li>@public</li>
</ul>
<hr>
<h3 id="函数的定义和调用："><a href="#函数的定义和调用：" class="headerlink" title="函数的定义和调用："></a>函数的定义和调用：</h3><p>函数的定义和调用与C语言的完全一致</p>
]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title>职工管理系统：</title>
    <url>/2019/06/13/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/C++/%E8%81%8C%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%EF%BC%9A/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>OC中的结构体：</title>
    <url>/2019/07/02/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/Objective-C/OC%E4%B8%AD%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93%EF%BC%9A/</url>
    <content><![CDATA[<hr>
<p>在Foundation框架中，已经定义好了一个结构体CGPoint<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly5lkgxctj30a004rta9.jpg"></p>
<p>声明CGPoint变量并初始化的方式：<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly5lrlrqej30a003dq3j.jpg"><br>4）Foundation框架中提供的函数来快速的创建一个CGPoint变量<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly5ly1aslj307x01q74o.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly5m3tapgj306v018aa7.jpg"></p>
<p>——————————————</p>
<p>CGSize：<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly5mahct2j307n03wjsl.jpg"></p>
<p>CZSize声明并初始化的方式：<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly5mh1uucj30a406lgno.jpg"></p>
<p>—————————————</p>
<p>CGRect和NSRect：<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly5mompl0j308f04ujss.jpg"></p>
<p>CGRect的声明和初始化：<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly5mvvzbbj30ao04u75p.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly5n3btvqj309102g3z8.jpg"></p>
]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title>Objective-C概述：</title>
    <url>/2019/09/30/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/Objective-C/Objective-C%E6%A6%82%E8%BF%B0%EF%BC%9A/</url>
    <content><![CDATA[<hr>
<p>Objective-C简称Obj-C或者OC</p>
<p>Objective-C：面向对象的C语言，所以，OC的本质还是C语言</p>
<ol>
<li>OC是在C的基础之上增加了一小部分的面向对象的语法，将C语言复杂的、繁琐的语法封装的更为简单</li>
<li>完全兼容C语言，也就是说在OC语言中可以写任意的C语言的代码</li>
</ol>
<h3 id="OC简要发展历史："><a href="#OC简要发展历史：" class="headerlink" title="OC简要发展历史："></a>OC简要发展历史：</h3><ul>
<li>20世纪80年代初期，Brad Cox结合C语言和Smalltalk的优势设计出了Objective-C语言</li>
<li>1985年，乔布斯创建NeXT公司，致力于设计经济实惠且功能强大的工作站，并选择Unix作为其工作站的操作系统</li>
<li>后来，NeXT公司设计出了NextStep(使用OC语言编写的一套功能强大的界面工具包)</li>
<li>1995年，NeXT公司获得OC的全部商业版权</li>
<li>1996年，苹果公司收购NeXT，NextStep得到了Mac开发人员的广泛认可，NextStep更名为Cocoa，从此OC成为开发Mac平台的主力语言</li>
<li>随着iPhone、iPad的火爆，OC又成为了iOS平台上的中流砥柱</li>
</ul>
<h3 id="OC的未来："><a href="#OC的未来：" class="headerlink" title="OC的未来："></a>OC的未来：</h3><ul>
<li>苹果在2014年的WWDC大会上正式推出Swift，在2015年的WWDC上宣布年底发布的Swift 2.0将开源</li>
<li>Swift语言的优点：快速、现代、安全、互动且全面优于Objective-C语言</li>
<li>按照苹果的行事风格，Swift一定会取代OC成为iOS开发的主力语言，但是目前来看，要实现这一目标，还有一段路需要走【很多的企业在此之前他们已经使用Objective-C语言开发好了自己的程序，使用Swift重写是不可能的、Swift刚刚发布，还有很多Bug没有完善，企业不愿意当小白鼠、Swift本身还没有成型，在后期发布的版本中有大量的变化甚至包括语法的变化】</li>
<li>OC的光芒注定要被Swift的闪耀遮盖</li>
</ul>
]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title>block与函数的异同：</title>
    <url>/2019/07/26/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/Objective-C/block%E4%B8%8E%E5%87%BD%E6%95%B0%E7%9A%84%E5%BC%82%E5%90%8C%EF%BC%9A/</url>
    <content><![CDATA[<hr>
<p>相同点：都是封装一段代码</p>
<p>不同的：<br>1）block是一个数据类型，可以声明block类型的变量；而函数就只是函数<br>2）block可以作为函数的参数，而函数不能直接作为函数的参数</p>
]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title>SEL</title>
    <url>/2019/08/31/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/Objective-C/SEL/</url>
    <content><![CDATA[<hr>
<p>SEL全称叫做selector选择器，是一个数据类型，所以要在内存中申请空间存储数据</p>
<p>SEL其实是一个类，SEL对象是用来存储一个方法的</p>
<p>如何将方法存储在类对象之中：<br>1）先创建一个SEL对象<br>2）将方法的信息存储在这个SEL对象之中<br>3）再将这个SEL对象作为类对象的属性<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly3s7o0v8j30990bv75r.jpg"></p>
<p>因为SEL是一个typedef类型的，在自定义的时候已经加<em>了，所以我们在声明SEL指针的时候不需要加</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SEL s1&#x3D;@selector(sayHi);</span><br><span class="line">NSLog(@&quot;s1 &#x3D; %p&quot;,s1);</span><br></pre></td></tr></table></figure>

<h3 id="调用方法的本质："><a href="#调用方法的本质：" class="headerlink" title="调用方法的本质："></a>调用方法的本质：</h3><p><code>[p1 sayHi];</code></p>
<p>内部的原理：<br>1）先拿到存储sayHi方法的SEL对象，也就是拿到存储sayHi方法的SEL数据，SEL消息<br>2）将这个SEL消息发送给p1对象<br>3）这个时候，p1对象接收到SEL消息以后，就知道要调用方法<br>4）根据对象的isa指针找到存储类的类对象<br>5）找到这个类对象以后，在这个类对象中去搜寻是否有和传入的SEL数据相匹配的，如果有就执行，如果没有再找父类，直到NSObject<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly3sgiec7j30iv0bata9.jpg"></p>
<p>OC最重要的一个机制：消息机制，调用方法的本质其实就是为对象发送SEL消息<br><code>[p1 sayHi];</code>  为p1对象发送一条sayHi消息</p>
<p>手动的为对象发送SEL消息：<br>1）先得到方法的SEL数据<br>2）将这个SEL消息发送给p1对象</p>
<p>调用对象的方法，将SEL数据发送给对象：<code>- (id)performSelector:(SEL)aSelector;</code></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Person *p1=[Person new];</span><br><span class="line"></span><br><span class="line">SEL s1=<span class="keyword">@selector</span>(sayHi);</span><br><span class="line">[p1 performSelector:s1];</span><br><span class="line"></span><br><span class="line">[p1 sayHi];</span><br></pre></td></tr></table></figure>

<p>调用一个对象的方法有两种：<br>1）[对象名 方法名];<br>2）手动的为对象发送SEL消息</p>
<p>注意：<br>1）如果方法有参数，那么方法名是带了冒号的<br>2）如果方法有参数，要传递参数就调用另外一个方法<br><code>* (id)performSelector:(SEL)aSelector withObject:(id)object;</code></p>
<p><code>* (id)performSelector:(SEL)aSelector withObject:(id)object1 withObject:(id)object2;</code><br>3)如果有多个参数，那就重新创建一个类把多个参数封装进去</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">Person *p1=[Person new];</span><br><span class="line"></span><br><span class="line">SEL s1=<span class="keyword">@selector</span>(eatWithFood:);</span><br><span class="line">[p1 performSelector:s1 withObject:<span class="string">@&quot;红烧肉&quot;</span>];</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title>block作为函数的参数：</title>
    <url>/2019/07/29/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/Objective-C/block%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0%EF%BC%9A/</url>
    <content><![CDATA[<hr>
<p>定义：<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly4m5ef33j307v05xta6.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly4maxin7j307v05x402.jpg"></p>
<p>调用：<br>1）如果要调用的函数的参数是block类型的，那么要求在调用的时候传入一个和形参block要求的代码段<br>2）调用的时候，可以先将代码段存储到一个block变量中，然后再传递这个block变量；也可以直接将符合要求的代码段写在小括弧中传递<br>3）小技巧：通过Xcode提示可以快速的生成block代码段的框架<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly4mhp6yxj30860cj0v8.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly4mq35tjj30et0brtbg.jpg"></p>
<p>将block作为函数的参数可以实现什么效果：可以将调用者自己写的一段代码传递到函数的内部去执行</p>
]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title>block的基本使用：</title>
    <url>/2019/08/02/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/Objective-C/block%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%EF%BC%9A/</url>
    <content><![CDATA[<hr>
<p>1）block是一个数据类型，我们可以声明一个block类型的变量<br>2）不同类型的变量中可以存储不同类型的数据，block类型的变量中专门存储一段代码，这段代码可以有参数，可以有返回值</p>
<p>Block变量的声明：<br>1）虽然block变量中是用来存储一段代码的，但是一个block变量中并不是任意的一段代码都可以存进去的，而是有限定的；也就是说，声明block变量的时候，必须要指定这个block变量存储的代码是否有参数，是否有返回值，一旦指定以后，这个block变量中就只能存储这样的代码段了<br>2）语法：返回值类型 (^block变量的名称)(参数列表);<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly4hpakdcj30fg02j3zi.jpg"></p>
<p>初始化block变量：<br>1）原理：写一个符合block要求的代码段，存储到block变量中就可以了<br>2）代码段的书写格式：</p>
<pre><code>          ^返回值类型(参数类型)&#123;
                    代码段;
          &#125;;</code></pre>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly4i0b989j303y02i0t6.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly4i7bl9oj305j01vglz.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly4idsc7nj305j01v74m.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly4ikffggj30b901vdgd.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly4iq8m2dj30e209wt9y.jpg"></p>
<p>  如何执行存储在block变量中的代码段：<br>语法格式：block变量名();<br>【有参数就传参数，有返回值就接】</p>
]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title>block作为函数的返回值</title>
    <url>/2019/07/27/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/Objective-C/block%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC/</url>
    <content><![CDATA[<hr>
<p>当将block作为函数的返回值的时候，返回值的类型就必须要使用typedef定义的短类型<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly4oobs8cj307506sgmp.jpg"></p>
]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title>block的简写：</title>
    <url>/2019/08/01/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/Objective-C/block%E7%9A%84%E7%AE%80%E5%86%99%EF%BC%9A/</url>
    <content><![CDATA[<hr>
<p>1）如果我们写的代码段没有返回值，那么代码段的void可以省略【既没有参数也没有返回值，代码段的void和小括弧都省略，只写一个^】<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly4jb918tj305501vwes.jpg"><br>注意：这里说的是代码段的返回值如果是void可以省略，声明block变量的返回值无论是什么都不可以省略<br>2）如果我们写的代码段没有参数，那么代码段的小括弧可以省略<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly4jj02nbj305501vaad.jpg"><br>3）声明block变量的时候，如果有指定参数，可以只写参数的类型而不写参数的名称<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly4jpbdmzj309k01vaal.jpg"><br>注意：这个地方我们说的是声明block变量的时候，代码段的类型和名称都要写<br>4）无论代码段是否有返回值，在写代码的时候，可以不写返回值类型，省略；如果在写代码段的时候，省略了返回值，这个时候系统会自动的确定返回值的类型，如果代码段中没有返回任何数据，那么它会认为这个代码段是没有返回值的，如果代码段中有返回数据，返回的数据是什么类型它就会认为这个代码段是什么类型<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly4jviexhj309k01v0t6.jpg"></p>
<p>建议：仍然按照我们最标准的写法来写block变量和block代码段，因为这样可以提高代码的阅读性</p>
]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title>copy和mutableCopy：</title>
    <url>/2019/06/29/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/Objective-C/copy%E5%92%8CmutableCopy%EF%BC%9A/</url>
    <content><![CDATA[<hr>
<p>无论在MRC还是ARC下，如果属性的类型是NSString类型的，@property参数使用copy</p>
<p>Copy是一个方法，定义在NSObject类之中，作用是拷贝对象</p>
<p>没有产生新对象，而是直接将对象本身的地址返回，这种拷贝我们叫做浅拷贝：【拷贝出来的是不可变字符串对象】<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly5q0qv3tj306q04hq40.jpg"></p>
<p>有产生一个新对象，这样的拷贝我们叫做深拷贝<br>【是一个不可变的字符串对象】<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly5q7luchj30d904habq.jpg"></p>
<p>mutableCopy：定义在NSObject类之中，作用是拷贝对象</p>
<p>可变字符串对象，深拷贝：<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly5qh8mp5j309304habj.jpg"></p>
<p>可变字符串对象，深拷贝：<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly5qnexwjj30cz04e40c.jpg"></p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly5qtfylfj30i401bq4a.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly5qzota7j30b301bgma.jpg"></p>
<p>若字符串对象存储在常量区中，存储在常量区的数据是不允许被回收的，所以存储在常量区的字符串对象的引用计数器是一个很大的数，并且retain和release无效<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly5r7iivlj30bi05ddhh.jpg"><br>若字符串存储在堆区，这个字符串对象和普通的对象是一样的，引用计数器默认是1<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly5rg0qtpj30hn09e76v.jpg"></p>
<p>字符串对象如果是浅拷贝，会将对象的引用计数器+1；如果是深拷贝，原来的对象的引用计数器不变，新拷贝出来的对象的引用计数器为1<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly5rn5qvoj30gz07racr.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly5rtvicaj30gz091422.jpg"></p>
<p>1）<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly5s0mmywj30aj08k0u6.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly5s772gjj30gl0ceq4y.jpg"><br>2）<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly5seqqloj30cw082gnh.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly5skon20j30gy0bvtar.jpg"><br>3）<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly5srfi3rj308p06j0u2.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly5syxinyj306i05b0to.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly5t4ha35j30d908swh9.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly5tb70nsj30fn0cb777.jpg"></p>
<p>Copy方法的确是定义在NSObject类中的一个方法，但是copy方法的内部还调用了另外一个方法：copyWithZone，这个方法是定义在NSCoping协议之中的，因为我们的类没有遵守这个协议，所以当我们自定义的类调用copy方法的时候就会出错<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly5tjhrdtj308p06jq3z.jpg"></p>
<p>解决方案：【return self;就是浅拷贝了】<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly5trimc8j30cr02nmyr.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly5txruhkj308p03v0tu.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly5u3ddrej30dv07awgb.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly5uarq3oj30dv099acu.jpg"></p>
]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title>instancetype：</title>
    <url>/2019/08/24/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/Objective-C/instancetype%EF%BC%9A/</url>
    <content><![CDATA[<hr>
<p>父类中的类方法创建一个父类对象返回:<br>1）如果返回值写为父类类型的，那么子类来调用这个方法得到的就是父类指针，解决方式：把返回值改为id类型的<br>2）方法的内部创建对象的时候，不要写死了，因为写死创建的对象就固定了，我们希望哪一个类来调用这个方法就创建哪一个类的对象，解决方式：把类名写为self，哪一个类来调用这个方法，self就指的是哪一个类，创建的就是哪一个类的对象<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly3xl2ab3j305401u3yr.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly3xsac6yj308o04k3zo.jpg"><br>3）方法的返回值是id类型的，问题就是任意指针都可以接收这个方法的返回值，编译器连个警告都没有<br>解决方式：如果方法的返回值是instancetype，代表方法的返回值是当前这个类的对象</p>
<p>使用建议：<br>1）如果方法内部是在创建当前类的对象，不要写死成类名[类名 new];而是用self代替类名<br>2）如果方法的返回值是当前类的对象，也不要写死了，而是写成instancetype</p>
<p>id和instancetype的区别：<br>1）instancetype只能作为方法的返回值，不能在其他地方使用<br>id既可以声明指针变量，也可以作为参数，也可以作为返回值<br>2）instancetype是一个有类型的，代表当前类的对象<br>id是一个无类型的指针，仅仅是一个地址</p>
]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title>self关键字：</title>
    <url>/2019/09/12/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/Objective-C/self%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<hr>
<p>在方法的内部可以定义一个和属性名相同的局部变量，这个时候，如果在方法中访问这个同名的变量，访问的是局部变量，如果需要访问属性就需要使用关键字self</p>
<p>self可以在对象方法和类方法中使用，self是一个指针，在对象方法中self指向当前对象，在类方法中self指向当前类</p>
<h3 id="self在对象方法中使用："><a href="#self在对象方法中使用：" class="headerlink" title="self在对象方法中使用："></a>self在对象方法中使用：</h3><p>作用：<br>1）可以使用self显示的访问当前对象的属性：self-&gt;属性，代表访问的是当前对象的这个属性<br>2）可以使用self来调用当前对象的其他的对象方法</p>
<p>必须使用self的场景：<br>1）如果在方法中存在和属性同名的局部变量，你如果想要访问同名的局部变量，直接写就可以了，你如果想要访问当前对象的同名属性，必须使用self<br>2）在对象方法中，如果要调用当前对象的其他的对象方法，必须使用self</p>
<p>属性要求以下划线开头，局部变量不要求以下划线开头，按照这个规范来，实际上是不会重名的</p>
<h3 id="self在类方法中使用："><a href="#self在类方法中使用：" class="headerlink" title="self在类方法中使用："></a>self在类方法中使用：</h3><p>self是一个指针，指向当前这个类在代码段中的地址【就相当于这个类】</p>
<p>作用：可以在类方法中使用self来显示的调用本类的其他的类方法</p>
<p>总结取到类在代码段中的地址的方式：<br>1）调试查看对象的isa指针的值<br>2）在类方法中查看self的值<br>3）调用对象的对象方法class，就会返回这个对象所属的类在代码段中的地址<br>4）调用类的类方法class，就会返回这个类在代码段中的地址</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">Person *p1=[Person new];</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%p&quot;</span>,[p1 <span class="keyword">class</span>]);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%p&quot;</span>,[Person <span class="keyword">class</span>]);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>对象方法可以声明多次，但是只会认为有一次，只能实现一次，否则会报错【对象方法之间是不能重名的；类方法之间也不能重名；但是对象方法和类方法是可以重名的，通过类名来调用，调用的就是类方法，通过对象名来调，调用的就是对象方法】</p>
<p>注意：<br>1）在对象方法中，self代表当前对象，所以可以通过self访问当前对象的成员，在对象方法中，不能使用self调用本类的类方法<br>2）在类方法中，self代表当前这个类，所以，可以通过self调用当前类的其他的类方法，在类方法中，不能通过self访问对象的成员，不能直接去访问属性和调用对象的方法</p>
]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title>Objective-C基础语法：</title>
    <url>/2019/09/29/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/Objective-C/Objective-C%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%EF%BC%9A/</url>
    <content><![CDATA[<hr>
<p>OC程序源文件的后缀名是.m【m是message，代表OC中最重要的消息机制】<br>C程序源文件的后缀名为.c</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly3afh9okj30ae04eq3e.jpg"></p>
<ol>
<li><code>#import</code>指令：</li>
</ol>
<p>1）以#开头，是一个预处理指令<br>2）是<code>#include</code>指令的增强版，将文件的内容在预编译的时候拷贝到写指令的地方，同一个文件无论被<code>#import</code>多少次，只会包含一次；如果<code>#include</code>指令要实现这个效果，就必须要配合条件编译指令来实现<br>3）简要原理：<code>#import</code>指令在包含文件的时候，底层会先判断这个文件是否被包含，如果被包含就会略过，否则才会包含</p>
<ol start="2">
<li>框架：</li>
</ol>
<p>是一个功能集，苹果或者第三方事先将一些程序在开发程序的时候经常要用到的功能事先写好，把这些功能封装在一个一个的类或者函数中，这些函数和类的集合就叫做框架【有点像C语言的函数库】</p>
<p>Foundation:这个框架提供了一些最基础的功能【输入输出，数据类型】<br>Foundation.h这个文件包含了Foundation框架中的其他的所有的头文件，所以，我们只要包含Foundation.h就相当于包含了Foundation框架中所有的头文件，那么Foundation框架中的所有的函数和类就可以直接使用</p>
<ol start="3">
<li><p>@autoreleasepool是自动释放池</p>
</li>
<li><p>NSLog函数：</p>
</li>
</ol>
<p>是printf函数的增强版，向控制台输出信息</p>
<p>NSLog(@“格式控制字符串”，变量列表);</p>
<p>增强点：<br>1）输出一些调试相关信息【执行这段代码的时间，程序的名称，进程编号，线程编号，输出的信息】<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly3ap8ay0j30dq022mxd.jpg"><br>2）在输出完信息之后会自动换行<br>3）OC中其实新增了一些数据类型，NSLog函数不仅仅可以输出C数据类型变量的值还可以输出OC新增的数据类型的变量的值</p>
<p>如果在字符串的末尾加了一个‘\n’代表换行，那么函数的自动换行功能就会失效</p>
<ol start="5">
<li>字符串的存储方式：</li>
</ol>
<p>C语言的字符串的存储方式：<br>1）使用字符数组存储<br>2）使用字符指针</p>
<p>OC中设计了一个更为好用的用来存储字符串的一个类型：NSString<br>NSString类型的指针变量专门用来存储OC字符串的地址</p>
<p>OC的字符串常量必须要使用一个前缀@符号，NSString类型的指针变量只能存储OC字符串的地址<br>NSString *str=@“jack”;</p>
<p>NSLog函数的第一个参数是一个OC字符串，所以NSLog函数的第一个实参应该以@符号开头<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly3b111ivj30in07c0ty.jpg"></p>
<p>NS前缀：NextStep—&gt;Cocoa—&gt;Foundation框架之中</p>
<p>@符号：<br>1）将C字符串转换为OC字符串<br>2）OC中的绝大部分的关键字都是以@符号开头</p>
]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title>setter方法内存管理：</title>
    <url>/2019/08/16/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/Objective-C/setter%E6%96%B9%E6%B3%95%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%9A/</url>
    <content><![CDATA[<hr>
<p>这辆车多了一个人使用：<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly439s1xfj30f20az40u.jpg"></p>
<p>当传进来的对象赋值给当前对象的属性，代表传入的对象多了一个人使用，所以我们应该先为这个传入的对象发送一条retain消息，再赋值；当当前对象销毁的时候，代表属性指向的对象少一个人使用，就应该在dealloc中release<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly43jfs8aj30bj0b50w7.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly43qq5edj30f20azdjm.jpg"></p>
<p>宝马车未被销毁，发生内存泄露：<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly43xxjs3j30eh0csgod.jpg"><br>当我们将传入的Car对象赋值给_car属性的时候，有两重意思：一个是_car属性原本指向的对象少一个人使用，另一个是新传入的对象多一个人使用；所以我们应该先将_car属性原本指向的对象release，再将传入的新对象retain</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly4453h1pj30b304pwg3.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly44cdm33j30eh0csgqq.jpg"></p>
<p>出现僵尸对象错误的原因：在于新旧对象是同一个对象<br>解决的方案：当发现新旧对象是同一个对象的时候，什么都不用做；只有当新旧对象不是同一个对象的时候，才release旧的，retain新的<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly44k48nfj30en0b4wi1.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly44qyyydj306x0680tu.jpg"></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import<span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&quot;Person.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc,<span class="keyword">const</span> <span class="keyword">char</span> * argv[])&#123;</span><br><span class="line">    </span><br><span class="line">    Person *p1=[Person new];</span><br><span class="line"></span><br><span class="line">    Car *bmw=[Car new];</span><br><span class="line">    bmw.speed=<span class="number">100</span>;</span><br><span class="line">    p1.car=bmw;</span><br><span class="line"></span><br><span class="line">    [bmw release];</span><br><span class="line"></span><br><span class="line">    bmw.speed=<span class="number">200</span>;</span><br><span class="line">    p1.car=bmw;</span><br><span class="line"></span><br><span class="line">    [p1 release];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import<span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Car</span> : <span class="title">NSObject</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> _speed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setSpeed:(<span class="keyword">int</span>)speed;</span><br><span class="line">- (<span class="keyword">int</span>)speed;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)run;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&quot;Car.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Car</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)dealloc&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;速度为%d的车子销毁了.&quot;</span>,_speed);</span><br><span class="line">    [<span class="keyword">super</span> dealloc];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setSpeed:(<span class="keyword">int</span>)speed&#123;</span><br><span class="line"></span><br><span class="line">    _speed=speed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">int</span>)speed&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> _speed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)run&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;速度为%d的车正在行驶&quot;</span>,_speed);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import<span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&quot;Car.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    Car *_car;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setCar:(Car *)car;</span><br><span class="line">- (Car *)car;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)drive;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&quot;Person.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)dealloc&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;人死了&quot;</span>);</span><br><span class="line">    [_car release];</span><br><span class="line">    [<span class="keyword">super</span> dealloc];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setCar:(Car *)car&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//说明新旧对象不是同一个对象</span></span><br><span class="line">    <span class="keyword">if</span>(_car != car)&#123;</span><br><span class="line"></span><br><span class="line">        [_car release];   <span class="comment">//才去release旧的</span></span><br><span class="line">        _car = [car <span class="keyword">retain</span>];    <span class="comment">//retain新的</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (Car *)car&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> _car;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)drive&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;走啊，去拉萨&quot;</span>);</span><br><span class="line">    [_car run];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>特别注意：我们内存管理的范围是OC对象，所以，只有属性的类型是OC对象的时候，这个属性的setter方法才要像上面那样写【对象类型就是类或协议所声明的指针类型，例如:NSString *string ,其中，NSString是一个类，NSString *是它指针类型或叫对象类型。】</p>
]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title>super关键字（特指这个方法是从父类继承过来的）：</title>
    <url>/2019/09/10/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/Objective-C/super%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%88%E7%89%B9%E6%8C%87%E8%BF%99%E4%B8%AA%E6%96%B9%E6%B3%95%E6%98%AF%E4%BB%8E%E7%88%B6%E7%B1%BB%E7%BB%A7%E6%89%BF%E8%BF%87%E6%9D%A5%E7%9A%84%EF%BC%89%EF%BC%9A/</url>
    <content><![CDATA[<hr>
<p>1）可以用在类方法和对象方法之中</p>
<p>2）在对象方法中可以使用super关键字调用当前对象从父类继承过来的对象方法</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">self</span> sayHi];</span><br><span class="line">[<span class="keyword">super</span> sayHi];</span><br></pre></td></tr></table></figure>

<p>3）在类方法中，super关键字可以调用当前类从父类继承过来的类方法【类方法也能被子类继承，父类中的类方法可以使用父类名来调用，也可以使用子类名调用】</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">[Person hehe];</span><br><span class="line">[Student hehe];</span><br><span class="line">[<span class="keyword">self</span> hehe];</span><br><span class="line">[<span class="keyword">super</span> hehe];</span><br></pre></td></tr></table></figure>

<p>4）super只能用来调用父类的对象方法或者类方法，不能用来访问属性</p>
]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title>static关键字：</title>
    <url>/2019/09/13/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/Objective-C/static%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%9A/</url>
    <content><![CDATA[<hr>
<p>static不能修饰属性，也不能修饰方法，可以修饰方法中的局部变量</p>
<p>如果方法中的局部变量被static修饰，那么这个变量就会被变成静态变量，存储在常量区，当方法执行完毕之后，不会回收，下次再执行这个方法的时候，直接使用而不用再声明了</p>
<p>如果方法的返回值是当前类的对象，那么方法的返回值就写instancetype</p>
]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title>内存管理的原则：</title>
    <url>/2019/08/19/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/Objective-C/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E5%8E%9F%E5%88%99%EF%BC%9A/</url>
    <content><![CDATA[<hr>
<p>1）有对象的创建，就要匹配一个release<br>2）retain的次数和release的次数要匹配<br>3）谁用谁retain，谁不用谁release<br>4）只有在多一个人用的时候才retain，少一个人使用的时候才release</p>
<p>有始有终，有加就有减，有retain就应该匹配一个release，一定要平衡</p>
]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title>关于block块访问外部变量的值的问题</title>
    <url>/2019/07/30/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/Objective-C/%E5%85%B3%E4%BA%8Eblock%E5%9D%97%E8%AE%BF%E9%97%AE%E5%A4%96%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E5%80%BC%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<hr>
<p>1）在block代码块的内部可以取定义在外部的变量的值，包括定义在外部的局部变量和全局变量<br>2）在block代码块的内部可以修改全局变量的值，但是不能修改定义在外部的局部变量的值<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly4l9a64rj307v091mz1.jpg"><br>3）如果你希望我们定义的局部变量可以允许在block代码的内部去修改，那么就为这个局部变量加一个__block(两个下划线)的修饰符<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly4lhnhysj307v01c0sv.jpg"></p>
]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title>创建一个对象，这个对象在内存中是如何分配的?</title>
    <url>/2019/09/03/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/Objective-C/%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%EF%BC%8C%E8%BF%99%E4%B8%AA%E5%AF%B9%E8%B1%A1%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E6%98%AF%E5%A6%82%E4%BD%95%E5%88%86%E9%85%8D%E7%9A%84?/</url>
    <content><![CDATA[<hr>
<p>1）子类对象中有自己的属性和所有父类的属性</p>
<p>2）代码段中的每一个类都有一个叫做isa的指针，这个指针指向它的父类，一直指到NSObject</p>
<p>子类方法重写以后，调用的就是子类重写的方法了<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly3qvna2bj30il0chdhq.jpg"></p>
]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title>内存管理概述：</title>
    <url>/2019/08/21/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/Objective-C/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E8%BF%B0%EF%BC%9A/</url>
    <content><![CDATA[<hr>
<p>内存的作用：存储数据</p>
<p>1）如何将数据存储到内存之中：声明一个变量<br>2）当数据不再被使用的时候，占用的内存空间如何被释放？</p>
<p>内存中的五大区域：<br>1）栈：局部变量，当局部变量的作用域被执行完毕之后，这个局部变量就会被系统立即回收<br>2）堆：OC对象，使用C函数申请的空间<br>3）BSS段：未初始化的全局变量、静态变量，一旦初始化就回收，并转存到数据段之中<br>4）数据段：已经初始化的全局变量、静态变量，直到程序结束的时候才会被回收<br>5）代码段：代码，程序结束的时候，系统会自动回收存储在代码段中的数据</p>
<p>栈、BSS段、数据段、代码段，存储在它们中的数据的回收是由系统自动完成的，不需要我们干预</p>
<p>分配在堆区中的OC对象是肯定需要被回收的，但系统不会自动回收，直到程序结束的时候才会被回收【轰炸机的小游戏，肯定不能等到程序结束才回收，因为有些人玩的时间很长】</p>
<p>内存管理的范围：只需要管理存储在堆中的OC对象的回收，其他区域中的数据的回收是系统自动管理的</p>
<p>对象应该什么时候被回收：当有人使用这个对象的时候，这个对象就千万不能回收；只有在没有任何人使用这个对象的时候才可以回收</p>
<h3 id="引用计数器："><a href="#引用计数器：" class="headerlink" title="引用计数器："></a>引用计数器：</h3><ol>
<li>每一个对象都有一个属性，叫做retainCount，叫做引用计数器，类型是unsigned long，占据8个字节</li>
</ol>
<p>引用计数器的作用：用来记录当前这个对象有多少个人在使用它，默认情况下，创建一个对象出来，这个对象的引用计数器的默认值是1</p>
<ol start="2">
<li><p>当多一个人使用这个对象的时候，应该先让这个对象的引用计数器的值+1，代表这个对象多一个人使用</p>
</li>
<li><p>当这个对象少一个人使用的时候，应该先让这个对象的引用计数器的值-1，代表这个对象少一个人使用</p>
</li>
<li><p>当这个对象的引用计数器变为0的时候，代表这个对象无人使用，这个时候系统就会自动回收这个对象，在对象被回收的时候，会自动调用对象的dealloc方法</p>
</li>
</ol>
<p>如何操作引用计数器：</p>
<ol>
<li>为对象发送一条retain消息，对象的引用计数器就会+1，当多一个人使用对象的时候才发</li>
<li>为对象发送一条release消息，对象的引用计数器就会-1，当少一个人使用对象的时候才发</li>
<li>为对象发送一条retainCount消息，就可以取到对象的引用计数器的值</li>
</ol>
<h3 id="内存管理的分类："><a href="#内存管理的分类：" class="headerlink" title="内存管理的分类："></a>内存管理的分类：</h3><ol>
<li><p>MRC：Manual Reference Counting手动引用计数，手动内存管理（2011年以前，iOS5之前）：当多一个人使用对象的时候，要求程序员手动的发送retain消息，少一个人使用的时候程序员手动的发送release消息</p>
</li>
<li><p>ARC：Automatic Reference Counting自动引用计数，自动内存管理：系统自动的在合适的地方发送retain，release消息</p>
</li>
</ol>
]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title>分组导航标记、方法与函数的不同：</title>
    <url>/2019/09/23/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/Objective-C/%E5%88%86%E7%BB%84%E5%AF%BC%E8%88%AA%E6%A0%87%E8%AE%B0%E3%80%81%E6%96%B9%E6%B3%95%E4%B8%8E%E5%87%BD%E6%95%B0%E7%9A%84%E4%B8%8D%E5%90%8C%EF%BC%9A/</url>
    <content><![CDATA[<hr>
<h3 id="分组导航标记："><a href="#分组导航标记：" class="headerlink" title="分组导航标记："></a>分组导航标记：</h3><p>1）#pragma mark 分组名：就会在导航条对应的位置显示一个标题<br>2）#pragma mark -：就会在导航条对应的位置显示一条水平分割线<br>3）#pragma mark - 分组名：就会在导航条对应的位置先产生一条水平分割线，再显示标题</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly3fzp8kbj30gr0hbq7e.jpg"></p>
<hr>
<h3 id="方法与函数的不同："><a href="#方法与函数的不同：" class="headerlink" title="方法与函数的不同："></a>方法与函数的不同：</h3><ol>
<li>OC方法的声明只能写在@interface的大括弧的外面，实现只能写在@implementation之中<br>函数除了在函数的内部和@interface的大括弧之中，其他地方都可以写</li>
</ol>
<p>就算把函数写在类中，这个函数仍然不属于类，所以创建的对象中也没有这个函数<br>注意：函数不要写在类中，虽然这样是可以的，但是千万不要这么做，因为这么做是极度不规范的</p>
<ol start="2">
<li>调用的方式不同：函数可以直接调用，但是方法必须要先创建对象，通过对象来调用</li>
<li>方法是属于类的，而函数是一个独立的</li>
</ol>
<p>注意点：</p>
<ol>
<li>@interface是类的声明，@implementation是类的实现，它们之间不能相互嵌套</li>
<li>类必须先声明然后再实现</li>
<li>类的声明和实现必须都要有，特殊情况下可以只有实现没有声明，虽然可以这样，但是千万不要这么写，极不规范</li>
<li>类的声明必须要放在使用类的前面，实现可以放在使用类的后面</li>
<li>属性名一定要以下划线开头，这是规范；<br>类名的每一个单词的首字母大写</li>
<li>属性不允许声明的时候初始化</li>
<li>OC方法必须要创建对象通过对象名来调用</li>
<li>如果方法只有声明，没有实现，编译器会给一个警告，不会报错</li>
</ol>
<p>如果指针指向的对象有方法的声明而没有方法的实现，那么这个时候通过指针来调用这个方法在运行的时候就会报错</p>
<p>unrecognized selector sent to instance 0x100420510<br>只要看到这个错误，说明要么对象中根本就没有这个方法，要么只有方法的声明而没有方法的实现</p>
]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title>分类/类别/类目(category)：</title>
    <url>/2019/08/06/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/Objective-C/%E5%88%86%E7%B1%BB%E7%B1%BB%E5%88%AB%E7%B1%BB%E7%9B%AE(category)%EF%BC%9A/</url>
    <content><![CDATA[<hr>
<p>让一个类占多个模块，将功能相似的方法定义在同一个模块中<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly4dcrtitj30ts0i412s.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly4djx97dj30ts0i4wnl.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly4dqcc3pj30ts0i4dms.jpg"></p>
<p>分类的使用：如果要访问分类中定义的成员，就要把分类的头文件引进来</p>
<p>分类的作用：<br>1）将一个类分为多个模块<br>2）为一个已经存在的类添加方法（扩展一个类）</p>
<p>使用分类的注意事项：<br>1）分类只能增加方法，不能增加属性<br>2）在分类之中可以写@property，但是不会自动生成私有属性，也不会自动生成getter、setter的实现，只会生成getter、setter的声明，所以需要自己写getter和setter的实现，也需要自己定义属性，这个属性必须在本类中<br>3）在分类的方法实现中不可以直接访问本类的真私有属性（定义在本类的@implementation之中，@interface中的可以访问），但是可以通过调用本类的getter和setter来访问属性<br>4）分类中可以存在和本类同名的方法，当分类中有和本类中同名的方法的时候，优先调用分类的方法，哪怕没有引入分类的头文件；如果多个分类中有相同的方法，优先调用最后编译的分类<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly4dy1db4j30qz0avjse.jpg"></p>
]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title>动态类型和静态类型</title>
    <url>/2019/08/26/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/Objective-C/%E5%8A%A8%E6%80%81%E7%B1%BB%E5%9E%8B%E5%92%8C%E9%9D%99%E6%80%81%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<hr>
<p>OC是一门弱语言：编译器在编译的时候，语法检查的时候没有那么严格，不管你怎么写都是可以的</p>
<p>强类型的语言：编译器在编译的时候，做语法检查的时候，行就是行，不行就是不行</p>
<p>静态类型：指的是一个指针指向的对象是一个本类对象<br>动态类型：指的是一个指针指向的对象不是本类对象</p>
<p>编译检查：编译器在编译的时候，能不能通过一个指针去调用指针指向的对象的方法？判断原则：看指针所属的类型之中是否有这个方法，如果有就认为可以调用，编译通过，如果这个类中没有，那么编译报错【苹果下的编译器的名字叫LLVM】</p>
<p>我们可以将指针的类型做转换，来达到骗过编译器的目的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Animal *a1&#x3D;[Pig new];</span><br><span class="line">[(Pig *)a1 eat];</span><br></pre></td></tr></table></figure>

<p>运行检查：编译检查只是骗过了编译器，但是这个方法究竟能不能执行？<br>所以在运行的时候，会去检查对象中是否真的有这个方法，如果有就执行，如果没有就报错</p>
<p>LSP父类指针指向子类对象，实际上任意的指针可以指向任意的对象，编译器是不会报错的；当一个子类指针指向一个父类对象的时候，编译器允许通过子类指针去调用子类独有的方法，但是在运行的时候是会出问题的，因为父类对象中根本没有子类成员</p>
]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title>使用URL来读写字符串数据</title>
    <url>/2019/07/18/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/Objective-C/%E4%BD%BF%E7%94%A8URL%E6%9D%A5%E8%AF%BB%E5%86%99%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<hr>
<p>优势：既可以读写本地磁盘文件，还可以读写网页文件、ftp服务器上的文件<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly4v5t795j30br02pq4i.jpg"></p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly4vb18afj30js04675w.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly4vgr3ssj30jz039ac6.jpg"></p>
]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title>匿名对象：</title>
    <url>/2019/09/16/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/Objective-C/%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1%EF%BC%9A/</url>
    <content><![CDATA[<hr>
<p>如果我们创建一个对象，没有用一个指针存储这个对象的地址，也就是没有任何指针指向这个对象，那么这个对象就叫做匿名对象</p>
<p>因为new实际上是一个类方法，这个方法做的事情就是创建对象，返回值是创建的对象的地址，[Person new]这句代码的结果实际上就是创建的那个对象的指针，那我们可以直接使用<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly3n9yn0aj308o060gn2.jpg"></p>
<p>注意点：<br>1）匿名对象只能使用一次<br>2）每次创建匿名对象都是不同的对象</p>
<p>什么时候使用匿名对象：<br>1）如果某个对象的成员只会被我们使用一次，用完之后这个对象再也不需要了，那么就可以使用匿名对象<br>2）如果方法的参数是一个对象，而调用者为这个参数赋值的对象就是专门来给这个方法传递的并且这个对象调用者不会再使用，那么这个时候就可以直接为方法传递一个匿名对象（上帝杀人）<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly3nhsewpj308o03q0tg.jpg"></p>
]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title>协议的类型限制(代理设计模式)：</title>
    <url>/2019/07/22/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/Objective-C/%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%B1%BB%E5%9E%8B%E9%99%90%E5%88%B6(%E4%BB%A3%E7%90%86%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F)%EF%BC%9A/</url>
    <content><![CDATA[<hr>
<p>NSObject&lt;协议名称1，协议名称2….&gt;  *指针名;<br>Id&lt;协议名称1，协议名称2….&gt;  指针名;</p>
<p>这个时候，这个指针可以指向遵守了指定协议的任意对象，如果指定的对象没有遵守这个协议，会报一个警告【多个协议必须同时遵守，只遵守一个也会报警告】</p>
<p>为什么要做协议的类型限制：<br>1）遵守了某个协议的类，，就相当于这个类拥有了这个协议所定义的行为<br>2）因为我要调用这个对象中的协议方法，只有类遵守了协议，这个类中才一定会有协议方法<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly4qhkaw7j309x011weq.jpg"></p>
]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title>动态类型检测：</title>
    <url>/2019/08/23/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/Objective-C/%E5%8A%A8%E6%80%81%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%B5%8B%EF%BC%9A/</url>
    <content><![CDATA[<hr>
<p>编译——运行</p>
<p>我们就希望，可以写代码来先判断一下对象中是否有这个方法，如果有再去执行，如果没有就不去执行</p>
<p>1）判断对象中是否有指定的对象方法【最常用】<br><code>* (BOOL)respondsToSelector:(SEL)aSelector;</code></p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly3yinfucj30ck081q4i.jpg"></p>
<p>2）判断类中是否有指定的类方法【最常用】<br><code>+ (BOOL)instancesRespondToSelector:(SEL)aSelector;</code></p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly3yr2d5dj30c701jjru.jpg"></p>
<p>3）判断指定的对象是否为指定类的对象或者子类对象<br><code>* (BOOL)isKindOfClass:(Class)aClass;【判断s1对象是否为NSObject对象或者NSObject的子类对象】</code><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly3yyfn8kj30ck03eq3s.jpg"></p>
<p>4）判断对象是否为指定类的对象，不包括子类<br><code>* (BOOL)isMemberOfClass:(Class)aClass;</code></p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly3z5pubqj30ck03e3zb.jpg"></p>
<p>5）判断类是否为另外一个类的子类<br><code>+ (BOOL)isSubclassOfClass:(Class)aClass;</code></p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly3zdfgttj309l01jwet.jpg"></p>
]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title>协议的基本使用(protocol)：</title>
    <url>/2019/07/25/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/Objective-C/%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8(protocol)%EF%BC%9A/</url>
    <content><![CDATA[<hr>
<p>作用：专门用来声明一大堆方法（不能声明属性，也不能实现方法，只能用来写方法的声明），只要某个类遵守了这个协议，就相当于拥有这个协议中的所有的方法声明，而不用自己去定义</p>
<p>协议的声明：</p>
<p>@protocol 协议名称 <NSObject></p>
<p>方法的声明;</p>
<p>@end<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly4pbw8nij30ku06smzn.jpg"></p>
<p>在协议中，只能用来声明方法，就是专门用来写方法声明的，就是用来被类遵守的</p>
<p>如果想要让一个类拥有协议中定义的所有的方法声明，那么就让这个类遵守这个协议，类只要遵守一个协议，那么这个类就拥有了这个协议中定义的所有的方法的声明</p>
<p>@interface 类名 ： 父类名 &lt;协议名称&gt;</p>
<p>@end</p>
<p>：表示继承<br>&lt;&gt;表示遵守的协议</p>
<p>这个类只是拥有了这个协议中的方法的声明而已，没有实现，所以这个类还应该实现协议中的方法</p>
<p>如果类不实现协议中的方法，其实也不会报错，编译器只是会报警告；但是当创建对象，来调用这个没有实现的协议中的方法的时候，就会报错</p>
<p>类是单继承，但是协议可以多遵守<br>@interface 类名：父类名 &lt;协议名称1，协议名称2……&gt;</p>
<p>@end</p>
]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title>多文件开发、对象和方法：</title>
    <url>/2019/09/22/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/Objective-C/%E5%A4%9A%E6%96%87%E4%BB%B6%E5%BC%80%E5%8F%91%E3%80%81%E5%AF%B9%E8%B1%A1%E5%92%8C%E6%96%B9%E6%B3%95%EF%BC%9A/</url>
    <content><![CDATA[<hr>
<h3 id="多文件开发："><a href="#多文件开发：" class="headerlink" title="多文件开发："></a>多文件开发：</h3><p>所有的类都写在main.m这个源文件之中，导致后期的维护非常不方便，也不利于团队开发</p>
<p>推荐的方式：把一个类写在一个模块之中，而一个模块至少包含两个文件：<br>.h头文件写类(方法)的声明，因为要用到Foundation框架中的NSObject类，所以要在这个头文件中引入Foundation框架的头文件<br>.m实现文件写类(方法)的实现，先引入模块的头文件，这样才会有类的声明</p>
<p>如果要用到类，只需要引入这个模块的头文件就可以了</p>
<p>添加类模块的更简洁的方式：<br>NewFile—Cocoa Class自动生成模块文件.h .m，自动的将类的声明和实现写好<br>【填写的名称是决定模块文件的名称，类名是可以自己再改的，但是建议模块的文件名和模块中的类名保持一致，这样方便代码的管理】</p>
<hr>
<h3 id="对象和方法：对象作为方法的参数，对象作为方法的返回值"><a href="#对象和方法：对象作为方法的参数，对象作为方法的返回值" class="headerlink" title="对象和方法：对象作为方法的参数，对象作为方法的返回值"></a>对象和方法：对象作为方法的参数，对象作为方法的返回值</h3><p>类的本质是我们自定义的一个数据类型，因为对象在内存中的大小是由我们自己决定的，多写几个属性对象就大一些，少写几个属性对象占用的空间就小一些</p>
<p>数据类型：是在内存中开辟空间的一个模版</p>
<p>既然类是一个数据类型，那么类就可以作为方法的参数：<code>- (void)test:(Dog *)dog;</code></p>
<p>注意：</p>
<ol>
<li><p>当对象作为方法的参数的时候，参数类型是类指针<br><code>- (void)test:(Dog *)dog;</code></p>
</li>
<li><p>调用方法的时候，如果方法的参数是一个对象，那么给实参的时候，实参要求也必须是一个符合要求的对象，否则就会出问题</p>
</li>
<li><p>当对象作为方法的参数传递的时候，是地址传递，所以在方法内部通过形参去修改形参指向的对象的时候，会影响实参变量指向的对象的值</p>
</li>
</ol>
<p>对象也可以作为方法的返回值：当方法执行完毕后，如果有一个对象方法的内部不知道如何处理，并且这个对象是调用者翘首以盼的，那么这个时候我们就应该将这个对象返回</p>
<hr>
<h3 id="上帝杀人案例："><a href="#上帝杀人案例：" class="headerlink" title="上帝杀人案例："></a>上帝杀人案例：</h3><p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly3gk8yjuj30h60cztcm.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly3gsa1xvj30yf0mpk29.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly3gyisa0j30yf0mp13b.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly3h5c7vmj30yf0mpn7g.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly3hdb2y9j30yf0mp7g8.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly3hjfacaj30yf0mpgxg.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly3hpvt24j30yf0mpqfd.jpg"></p>
]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串的其他常用方法：</title>
    <url>/2019/07/11/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/Objective-C/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%85%B6%E4%BB%96%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%EF%BC%9A/</url>
    <content><![CDATA[<hr>
<p>1）去掉字符串前后的空格，中间的空格无法去掉<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly51qgsy0j30fx06tad7.jpg"><br>2）将字符串转换为大写或小写<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly51x9y6qj30cb06840r.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly524pxi8j30a8068mz3.jpg"><br>3）去掉字符串前后的小写字母或大写字母<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly52cqs2cj30i903m0u7.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly52iprgaj30jc037409.jpg"><br>4）去掉头尾指定的字符串<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly52pho42j30i804tad2.jpg"></p>
]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串对象常用方法：</title>
    <url>/2019/07/19/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/Objective-C/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AF%B9%E8%B1%A1%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%EF%BC%9A/</url>
    <content><![CDATA[<hr>
<p>1）使用拼接的方式创建一个NSString对象<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly4syggh6j30g8033jsk.jpg"><br>2）得到字符串的长度<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly4t5fjwdj307001i3ys.jpg"><br>3）得到字符串中指定下标的字符<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly4tdcp6rj307x01iaam.jpg"><br>4）判断两个字符串的内容是否相等【不能使用==去比较，因为==比较的是字符串指针变量的值，而我们要比的是两个字符串指针指向的字符串对象的内容是否相同】<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly4tl3zi6j30bc05n40g.jpg"><br>5）将C语言的字符串转换为OC字符串对象<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly4trsvb6j30b8047wfp.jpg"><br>6）将OC字符串对象转换为C语言的字符串<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly4ty3h0jj309h02pwf4.jpg"></p>
<p>7）将字符串内容写入到磁盘上的某一个文件之中</p>
<p>参数1:将字符串内容写入到哪一个文件之中，写上文件的路径</p>
<p>参数2:YES，先将内容写入到一个临时文件，如果成功再将这个文件搬到指定的目录【安全，效率低】；NO，直接将内容写入到指定的文件【不安全，效率高】；推荐使用NO</p>
<p>参数3:指定写入的时候使用的编码</p>
<p>参数4:二级指针，要传递一个NSError指针的地址，<br>如果写入成功，这个指针的值就是nil，如果写入失败，这个指针就会指向一个错误的对象，这个对象描述了发生错误的信息【这个对象的localizedDescription方法可以得到发生错误的简要信息】，所以我们要判断是否写入成功，也可以判断这个指针的值是否为nil</p>
<p>如果不想知道发生错误的原因，那么第四个参数给nil就可以了</p>
<p>返回值是BOOL类型的，代表是否写入成功<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly4u5a1g9j30it093jtr.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly4ucm95tj30ls0b7q8f.jpg"></p>
<p>8）从磁盘上的文件中读取文件中的内容<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly4uk68hpj30kp09tjuv.jpg"></p>
]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串的开始和结束判断：</title>
    <url>/2019/07/16/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/Objective-C/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%BC%80%E5%A7%8B%E5%92%8C%E7%BB%93%E6%9D%9F%E5%88%A4%E6%96%AD%EF%BC%9A/</url>
    <content><![CDATA[<hr>
<p>判断字符串是否以指定的字符串开头：<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly4wvn0qrj30a7033t9t.jpg"></p>
<p>判断字符串是否以指定的字符串结尾：<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly4x19zmej30at02pab9.jpg"></p>
]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title>单例模式：</title>
    <url>/2019/06/28/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/Objective-C/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%EF%BC%9A/</url>
    <content><![CDATA[<hr>
<p>一个类的对象，无论在何时创建，无论在什么地方创建，也无论创建多少次，创建出来的都是同一个对象</p>
<p>无论如何创建对象，最终都会调用alloc方法来创建，alloc方法的内部，其实什么都没做，只是调用了allocWithZone方法，实际上真正申请空间创建对象的事情是allocWithZone方法在做</p>
<p>实现单例模式的方法：重写allocWithZone方法<br>【规范：如果类是一个单例模式，要求为类提供一个类方法，来返回这个单例对象，类方法必须以shared类名；default类名】<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly5uzu8nij306t03fjsc.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly5v6ikp3j30ae0a6di8.jpg"><br>单例对象可以被共享，存储在单例对象中的数据可以被共享；如果数据需要被整个程序所共享，那么将数据以属性的方式存储在单例对象中</p>
]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串的截取：</title>
    <url>/2019/07/14/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/Objective-C/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%88%AA%E5%8F%96%EF%BC%9A/</url>
    <content><![CDATA[<hr>
<p>1）从指定的下标处一直截取到最后<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly4zb5xh6j30bw04a0ty.jpg"><br>2）从第0个开始截取指定的个数<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly4zhmnfcj30bw079q4c.jpg"><br>3）截取指定的一段范围<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly4zpwv7tj30cm062dha.jpg"></p>
]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串的搜索：</title>
    <url>/2019/07/15/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/Objective-C/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%90%9C%E7%B4%A2%EF%BC%9A/</url>
    <content><![CDATA[<hr>
<p>在主串中搜索子串：</p>
<p>1）这个方法是从前往后搜索，第一次匹配的子串：<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly4xgefenj308n04dq4j.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly4xmsu37j308o06cgn9.jpg"></p>
<p>2）从后往前搜索<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly4xtjkr0j30dc069mz7.jpg"><br>NSRange结构体：是Foundation框架中定义的一个结构体，结构体变量一般用来表示一段范围</p>
<p>声明并初始化结构体变量的方式：<br>1）<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly4y13jrrj304701laaa.jpg"><br>2）<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly4y87sdpj304n01lglp.jpg"><br>3）<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly4yf6eo7j308c01lt8x.jpg"><br>4）Foundation框架中定义了一个函数，这个函数可以快速的创建一个NSRange结构体变量<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly4ylayunj30bw01kwf1.jpg"><br>5）Foundation框架中定义了一个函数，可以将一个NSRange结构体变量转换为NSString<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly4ysii0yj30bw01xwf7.jpg"></p>
]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title>协议之间的继承：</title>
    <url>/2019/07/23/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/Objective-C/%E5%8D%8F%E8%AE%AE%E4%B9%8B%E9%97%B4%E7%9A%84%E7%BB%A7%E6%89%BF%EF%BC%9A/</url>
    <content><![CDATA[<hr>
<p>协议与协议之间可以相互继承</p>
<p>语法：</p>
<p>@protocol 协议名称 &lt;父协议名称&gt;</p>
<p>@end</p>
<p>效果：子协议中不仅有自己的方法的声明，还有父协议中的所有的方法的声明；如果某个类遵守了某份协议，那么这个类就拥有了这个协议和这个协议的父协议中的所有方法的声明</p>
<p>类的名称可以和协议的名称一致：<br>在Foundation框架中，有一个类叫做NSObject，是所有OC类的基类<br>在Foundation框架中，有一个协议叫做NSObject</p>
<p>NSObject协议被NSObject类遵守，所以，NSObject协议中的所有的方法全部的OC类都拥有了，这么说，所有的OC类都遵守了NSObject协议，NSObject协议也叫做基协议</p>
<p>写协议的规范：要求所有的协议都必须直接的或间接的从NSObject基协议继承</p>
]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title>多态：</title>
    <url>/2019/09/05/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/Objective-C/%E5%A4%9A%E6%80%81%EF%BC%9A/</url>
    <content><![CDATA[<hr>
<p>指的是同一个行为，对于不同的事物具有完全不同的表现形式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Person *p1&#x3D;[Chinese new];</span><br><span class="line">Person *p2&#x3D;[Japanese new];</span><br><span class="line">Person *p3&#x3D;[Korea new];</span><br><span class="line"></span><br><span class="line">[p1 sayHi];</span><br><span class="line">[p2 sayHi];</span><br><span class="line">[p3 sayHi];</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title>单个对象的内存管理：</title>
    <url>/2019/08/17/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/Objective-C/%E5%8D%95%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%9A/</url>
    <content><![CDATA[<hr>
<p>内存泄露：指的是一个对象没有被及时的回收，在该回收的时候而没有被回收，一直驻留在内存中，直到程序结束的时候才回收</p>
<p>单个对象的内存泄漏情况：<br>1）有对象的创建，而没有对应的release<br>2）retain的次数和release的次数不匹配<br>3）在不适当的时候，为指针赋值为nil<br>4）在方法中为传入的对象进行不适当的retain</p>
<p>如何保证单个对象可以被回收：<br>1）有对象的创建就必须要匹配一个release<br>2）retain次数和release次数一定要匹配<br>3）只有在指针成为野指针的时候才赋值nil<br>4）在方法中不要随意的为传入的对象retain</p>
]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串的比较：</title>
    <url>/2019/07/17/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/Objective-C/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%AF%94%E8%BE%83%EF%BC%9A/</url>
    <content><![CDATA[<hr>
<p>1）<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly4vy1kf8j308o081tak.jpg"><br>2）忽略大小写的比较<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly4w5qs9wj30bk093gni.jpg"><br>3）只比较字符串中数字的大小【格式相同】<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly4wefctkj30af024wf7.jpg"></p>
]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串的替换：</title>
    <url>/2019/07/13/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/Objective-C/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9B%BF%E6%8D%A2%EF%BC%9A/</url>
    <content><![CDATA[<hr>
<p>将字符串中的第一个参数替换为第二个参数（全部替换）<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly50a3ikwj30ga07amzb.jpg"><br>这个方法还可以做删除，原理是将其替换为@“”</p>
]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title>对象作为类的属性：</title>
    <url>/2019/09/21/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/Objective-C/%E5%AF%B9%E8%B1%A1%E4%BD%9C%E4%B8%BA%E7%B1%BB%E7%9A%84%E5%B1%9E%E6%80%A7%EF%BC%9A/</url>
    <content><![CDATA[<hr>
<p>一个Target中的类无法直接在另外一个Target中访问</p>
<p>如果要访问其他Target中的类，找到其他Target中的类，右键Show in Finder，选中这个模块直接拖拽到当前类中（上面两个按钮要勾上）</p>
<hr>
<p>类的属性代表这类事物具有的共同的特征，代表这个类所拥有的东西<br>类的方法代表这个类所具备的行为，这个类所具备的功能</p>
<p>对象作为类的属性【人拥有一条狗，狗拥有圈圈】</p>
<p>属性的本质是变量，在创建对象的时候，对象中的属性是按照类模版中的规定挨个挨个的创建出来的，类模版中属性是什么类型，那么对象中的属性就是什么类型</p>
<p>如果对象的属性是另外一个类的对象，这个属性仅仅是一个指针变量而已，并没有对象产生，这个时候还要为这个属性赋值一个对象的地址才可以正常使用</p>
<hr>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly3i6vc8ij30e80ci0x6.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly3if923rj30rl0li47k.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly3iluho8j30rl0li7d1.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly3isba0uj30rl0li47f.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly3iyjddfj30rl0liaik.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly3j4di4qj30rl0liqbw.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly3javqy8j30rl0lin60.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly3jlxii5j30rl0li48d.jpg"></p>
]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title>对象在内存中是如何存储的：</title>
    <url>/2019/09/24/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/Objective-C/%E5%AF%B9%E8%B1%A1%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E6%98%AF%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8%E7%9A%84%EF%BC%9A/</url>
    <content><![CDATA[<hr>
<h3 id="内存中的五大区域："><a href="#内存中的五大区域：" class="headerlink" title="内存中的五大区域："></a>内存中的五大区域：</h3><ol>
<li>栈：存储局部变量</li>
<li>堆：程序员手动申请的字节空间</li>
<li>BSS段：存储未被初始化的全局变量、静态变量</li>
<li>数据段（常量区）：存储已被初始化的全局变量、静态变量、常量数据</li>
<li>代码段：存储代码，存储程序的代码</li>
</ol>
<h3 id="类加载："><a href="#类加载：" class="headerlink" title="类加载："></a>类加载：</h3><p>在程序运行期间，当某个类第一次被访问到的时候，会将这个类存储到内存中的代码段区域，这个过程叫做类加载；只有类在第一次被访问的时候才会做类加载，一旦类被加载到代码段以后，直到程序结束的时候才会被释放。<br>1）在创建对象的时候，肯定是需要访问类的<br>2）声明一个类的指针变量也会访问类的</p>
<hr>
<h3 id="对象在内存中究竟是如何存储的："><a href="#对象在内存中究竟是如何存储的：" class="headerlink" title="对象在内存中究竟是如何存储的："></a>对象在内存中究竟是如何存储的：</h3><p>假设这个写在函数之中：Person *p1=[Person new];</p>
<ol>
<li>Person *p1：会在栈内存中申请一块空间，在栈内存中声明一个Person类型的指针变量p1。p1是一个指针变量，只能存储地址</li>
<li>[Person new]：真正在内存中创建对象的其实是这句代码</li>
</ol>
<p>New做的事情：</p>
<ol>
<li>在堆内存中申请一块合适大小的空间</li>
<li>在这个空间中根据类的模版创建对象，类模版中定义了什么属性，就把这些属性依次的声明在对象之中，对象中还有另外一个属性，叫做isa，是一个指针，指向对象所属的类在代码段中的地址</li>
<li>初始化对象的属性：<br>如果属性的类型是基本数据类型，那么就赋值为0；<br>如果是C语言的指针类型就赋值为NULL；<br>如果是OC的类指针类型，就赋值为nil</li>
</ol>
<p>NULL(nil)只能作为指针变量的值，如果一个指针变量的值是NULL(nil)代表这个指针不指向内存中的任何一块空间，NULL(nil)其实是一个宏，就是0</p>
<p>建议：C指针用NULL，int *p1=NULL;<br>     OC的类指针用nil，Person *p1=nil;</p>
<p>如果一个类指针的值为nil，代表这个指针不指向任何对象：Person *p1=nil;<br>这个时候，如果通过p1指针去访问p1指针指向的对象的属性，会运行报错；<br>如果通过p1指针去调用对象的方法，运行不会报错但是方法不会执行，没有反应</p>
<ol start="4">
<li>返回对象的地址：</li>
</ol>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly3egsgpuj30tu0ee0ud.jpg"></p>
<hr>
<h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><ol>
<li>对象中只有属性，而没有方法，自己类的属性+一个isa指针指向代码段中的类</li>
<li>如何访问对象的属性：指针名-&gt;属性名；<br>根据指针，找到指针所指的对象，再找到对象中的属性来访问</li>
<li>如何调用方法：[指针名 方法名];<br>先根据指针名找到对象，对象发现要调用方法，再根据对象的isa指针找到类，然后调用类里的方法</li>
<li>为什么不把方法存储在对象中：因为每一个对象的方法的代码实现都是一模一样的，没有必要为每一个对象都保存一个方法，这样的话就太浪费空间了</li>
</ol>
<hr>
<h3 id="同类型的指针变量之间是可以相互赋值的："><a href="#同类型的指针变量之间是可以相互赋值的：" class="headerlink" title="同类型的指针变量之间是可以相互赋值的："></a>同类型的指针变量之间是可以相互赋值的：</h3><p>Person *p1=[Person new];<br>Person *p2=p1;</p>
<p>这是完全没有问题的，p1和p2的类型都是Person指针类型的，代表将p1的值赋值给p2，而p1的值是对象的地址，所以就把对象的地址赋值给了p2，所以p1和p2指向了同一个对象<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly3eptuz8j30t10gsdi1.jpg"></p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly3eyt68jj30eu0hiq50.jpg"></p>
<hr>
<h3 id="目前为止，只要看见new，就说明新创建了一个对象："><a href="#目前为止，只要看见new，就说明新创建了一个对象：" class="headerlink" title="目前为止，只要看见new，就说明新创建了一个对象："></a>目前为止，只要看见new，就说明新创建了一个对象：</h3><p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly3f685doj30s40ic0vf.jpg"></p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly3fdfd6oj30fi0hnjtj.jpg"></p>
]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title>应用实例：</title>
    <url>/2019/07/28/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/Objective-C/%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B%EF%BC%9A/</url>
    <content><![CDATA[<hr>
<p>写一个数组类，给这个数组类提供一个方法，将一个国家字符串数组进行排序：</p>
<p>比较j和j+1这两个字符串，我们直接比较的是字母顺序，但是这么写的话就写死了<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly4n7iz3dj30qm0mo7e9.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly4newe30j30qm0mo7dh.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly4nl63s9j30qm0moak6.jpg"></p>
<p>比较这两个字符串的大小，不要方法的内部自己写代码去比，因为不管写什么代码都会写死的，让调用者自己写一段代码来比较这两个字符串的大小</p>
<p>当方法的内部需要执行一个功能，但是这个功能具体的实现函数的内部不确定，那么这个时候，就使用block让调用者将这个功能的具体实现传递进来<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly4nrq4dij30qm0mogwa.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly4nynd5hj30qm0motic.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly4o6dc03j30qm0mo7ek.jpg"></p>
]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串的类型转换：</title>
    <url>/2019/07/12/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/Objective-C/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%EF%BC%9A/</url>
    <content><![CDATA[<hr>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly50pcdbvj308k02oq4f.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly50vjti2j30b907ataq.jpg"></p>
<p>注意：从头开始转换，能转换多少就是多少，当遇到不能转换的时候就停止转换<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly512f5guj30b506t404.jpg"></p>
]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title>延展(Extension)：</title>
    <url>/2019/08/03/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/Objective-C/%E5%BB%B6%E5%B1%95(Extension)%EF%BC%9A/</url>
    <content><![CDATA[<hr>
<p>1）是一个特殊的分类，所以延展也是类的一部分<br>2）特殊之处：没有名字；只有声明没有实现，和本类共享一个实现</p>
<p>语法：<br>             @interface 本类名（）</p>
<pre><code>         @end</code></pre>
<p>没有实现，和本类共享一个实现<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly4gvnfu5j30xm0j4n6p.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly4h2dpt9j30xm0j4dnc.jpg"></p>
<p>延展和分类的区别：<br>1）分类有名字，延展没有名字，是一个匿名的分类<br>2）每一个分类都有单独的声明和实现，而延展只有声明，没有单独的实现，和本类共享一个实现<br>3）分类中只能新增方法，而延展中任意的成员都可以写<br>4）分类中可以写@property，但是只会生成getter、setter的声明；延展中写@property，会自动生成私有属性，也会生成getter、setter的声明和实现</p>
<p>延展的应用场景：<br>1）要为类写一个私有的@property，生成的getter、setter方法只能在类的内部访问，不能在外部访问【@property生成私有属性、生成getter、setter的实现，不要声明】<br>2）延展不会独占一个文件，都是将延展直接写在本类的实现文件中，这个时候写在延展中的成员，就相当于是这个类的私有成员，只能在本类的实现中访问，外部不能访问</p>
<p>注意：<br>1）如果想要为类写一个真私有属性，虽然我们可以定义在@implementation之中，但是不要这么写，这样很不规范，写一个延展，将这个私有属性定义在延展中<br>2）如果要为类写一个私有方法，建议将声明写在延展中，实现写在本类的实现中，提高代码的阅读性<br>3）如果想要为类写一个私有的@property，就直接写在延展中就可以了<br>4）延展天生就是来私有化类的成员的，如果类的成员只希望在类的内部访问，那么就将其定义在延展中，如果类的成员允许被外界访问，定义在本类的@interface中</p>
]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title>异常处理：</title>
    <url>/2019/09/19/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/Objective-C/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%EF%BC%9A/</url>
    <content><![CDATA[<hr>
<p>一般情况下，错误指的是我们写的源代码不符合语法规范，然后编译报错，导致程序无法编译</p>
<p>Bug指的是程序可以编译、链接、执行，但程序执行的结果并不是我们所预想的那样，可以通过调试寻找发生Bug的原因</p>
<p>异常指的是程序可以编译、链接、执行，当程序在执行的时候，处于某种特定条件下程序的执行就会终止，后果是程序会立即崩溃，立即终止运行并且后面的代码不会执行了</p>
<hr>
<p>异常处理的目的：为了让程序在执行的时候如果发生了异常而不崩溃，继续往下执行</p>
<p>语法：<br>         @try{</p>
<pre><code>       &#125;
     @catch(NSException *ex)&#123;

       &#125;</code></pre>
<p>将有可能发生异常的代码放在@try中，当@try中的代码在执行的时候如果发生了异常，不会崩溃，而是会立即跳转到@catch中去执行里面的代码，当@catch的代码执行完毕后，结束@try…@catch往下执行，如果@try中的代码在执行的时候没有发生异常，就会略过@catch往下执行</p>
<p>当@try中的代码在执行的时候发生了异常，@try块发生异常的后面的代码不会执行，而是立即转到@catch</p>
<p>注意：</p>
<ol>
<li>@catch中的代码只有在@try的代码发生异常的时候才会执行，所以，@catch中我们一般情况下写处理异常的代码（发生这个异常之后，要做什么事情）</li>
<li>@catch的参数NSException *ex，通过%@打印出ex指向的对象的值，可以拿到发生异常的原因</li>
<li>@try…@catch后面还可以跟一个@finally{}，@finally中的代码，无论@try中是否发生了异常都会被执行</li>
<li>@try…@catch并不是万能的，不是所有的运行时错误都可以处理的【C语言的异常是无法处理的】，在实际的开发过程中，使用@try用的相对比较少的，避免异常我们最常用的方式还是逻辑判断</li>
</ol>
]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title>对象与对象之间的关系：</title>
    <url>/2019/09/14/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/Objective-C/%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%AF%B9%E8%B1%A1%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB%EF%BC%9A/</url>
    <content><![CDATA[<hr>
<p>组合关系：一个类是由其他的几个类联合起来组合而成【计算机由主板、显卡等组成】</p>
<p>依赖关系：一个对象的方法的参数是另外一个对象【人依赖于手机】</p>
<p>耦合度：当修改一个对象的时候对另外一个对象的影响程度【低耦合，高耦合】</p>
<p>高内聚：一个对象仅仅做与自己相关的事情【单一职责原则】</p>
<p>关联关系：一个类作为另外一个类的属性，但是它们不是组合关系，而是一个拥有的关系【人拥有狗】</p>
<p>继承关系</p>
]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title>框架</title>
    <url>/2019/07/21/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/Objective-C/%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<hr>
<p>框架：苹果或者第三方事先写好了一些功能很厉害的类，把这些类交给我们使用，这些类的集合我们叫做框架</p>
<p>Foundation框架：是一个包，这里面有很多类、函数、定义了一些数据类型，这个框架中的类都是一些最基础的类(NSString、NSObject)，其他的框架都是基于Foundation框架的</p>
]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title>点语法</title>
    <url>/2019/08/30/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/Objective-C/%E7%82%B9%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<hr>
<p>OC的对象如果要为属性赋值或者取值，就要调用对应的getter或者setter方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Person *p1&#x3D;[Person new];</span><br><span class="line"></span><br><span class="line">[p1 setName:@&quot;jack&quot;];</span><br><span class="line">[p1 setAge:18];</span><br><span class="line">[p1 setGender:GenderMale];</span><br></pre></td></tr></table></figure>

<p>OC中使用点语法来访问对象的属性：</p>
<p>语法：对象名.去掉下划线的属性名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">p1.name&#x3D;@&quot;jack&quot;;    &#x2F;&#x2F;这个时候就会将@&quot;jack&quot;赋值给p1对象的_name属性</span><br><span class="line">NSString *name&#x3D;p1.name;   &#x2F;&#x2F;把p1对象的_name属性的值取出来</span><br></pre></td></tr></table></figure>

<p>点语法的原理：<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly3tat0tqj30f206iad5.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly3thwrydj30f20400uh.jpg"></p>
<p>注意：<br>1）在getter和setter中慎用点语法，因为有可能会造成无限递归，程序崩溃</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)setAge:(int)age&#123;</span><br><span class="line"></span><br><span class="line">   self.age&#x3D;age;    &#x2F;&#x2F;[self setAge:age];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2）<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly3tpwwz4j30ck03sjt9.jpg"><br>3）如果属性没有封装getter和setter是无法使用点语法的，因为点语法的本质是getter和setter方法</p>
]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title>构造方法：</title>
    <url>/2019/08/22/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/Objective-C/%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%EF%BC%9A/</url>
    <content><![CDATA[<hr>
<p>类名 *指针名=[类名 new];</p>
<p>new方法的内部，其实是先调用的alloc方法，再调用的init方法</p>
<p>alloc方法是一个类方法，作用：哪一个类调用这个方法，就创建哪个类的对象，并把对象返回<br>init方法是一个对象方法，作用：初始化对象<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly3zv5vdcj306r023q3h.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly4014u9pj308p0233z0.jpg"></p>
<p>创建对象的完整步骤：应该先使用alloc创建一个对象，然后再使用init初始化这个对象，才可以使用这个对象；虽然没有初始化的对象有的时候也可以使用，但是千万不要这么做，使用一个未经初始化的对象是极其危险的</p>
<hr>
<p>init方法（构造方法）：</p>
<p>作用：初始化对象，为对象的属性赋初始值</p>
<p>所以我们创建一个对象如果没有为这个对象的属性赋值，这个对象的属性是有默认值的，我们每次新创建一个对象，这个对象的属性都被初始化了</p>
<p>我们想要让创建的对象的属性的默认值不是nil、NULL、0，而是我们自定义的，那么这个时候，我们就可以重写init方法<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly407m6y2j30eq04iwh1.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly40euuvyj306105rjsj.jpg"></p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly40kv6zwj307e03nmy0.jpg"></p>
<p>调用父类init方法的原因：因为父类的init方法会初始化父类的属性，所以必须要保证当前对象中的父类属性也同时被初始化</p>
<p>赋值给self的原因是调用父类的init方法，会返回初始化成功的对象，实际上返回的就是当前对象，但是我们要判断是否初始化成功</p>
<p>重写init方法以后，这样每次创建出来的对象的属性都是一样的<br>但是，我想创建对象的时候，对象的属性的值由创建对象的人来指定，而不是写死在init方法中</p>
<p>自定义构造方法的规范：<br>1）自定义构造方法的返回值必须是instancetype<br>2）自定义构造方法的名称必须以initWith开头<br>3）方法的实现和init的要求一样<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly40s4tcgj30dr01ddga.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly40z8d3jj30dr03kmyc.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly415rr3gj30cd01ct93.jpg"><br>这个时候就不能直接[Dog new]了</p>
]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title>方法重写：</title>
    <url>/2019/09/06/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/Objective-C/%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99%EF%BC%9A/</url>
    <content><![CDATA[<hr>
<p>子类从父类继承，子类就继承了父类的方法，就意味着子类拥有了这个功能，但是有的时候，虽然子类也拥有父类的这个行为，但是这个行为的具体的实现和父类不同</p>
<p>如何重写：直接在自己类的实现中将这个方法重新实现一遍就可以了</p>
<p>当一个父类指针指向一个子类对象的时候，通过这个父类指针调用的方法如果在子类对象中重写了，那么调用的就是子类重写的方法</p>
]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title>猜拳游戏：</title>
    <url>/2019/09/20/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/Objective-C/%E7%8C%9C%E6%8B%B3%E6%B8%B8%E6%88%8F%EF%BC%9A/</url>
    <content><![CDATA[<hr>
<p>枚举或者结构体定义在什么地方：如果只是一个类要用，那么就定义在这个类的头文件中；<br>如果多个类要用，那么就定义在一个单独的头文件中</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//Player.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&quot;FistType.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Player</span> : <span class="title">NSObject</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">@public</span></span><br><span class="line">    <span class="built_in">NSString</span> *_name;</span><br><span class="line">    <span class="keyword">int</span> _score;</span><br><span class="line">    FistType _selectedType;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)showFist;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据传入的整型的数返回对应字符串拳头</span></span><br><span class="line">- (<span class="built_in">NSString</span> *)fistTypeWithNumber:(<span class="keyword">int</span>)number;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//Player.m</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">&quot;Player.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Player</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)showFist&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//提示用户选择拳头</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;亲爱的玩家[%@]，请选择你要出的拳头 1.剪刀 2.石头 3.布&quot;</span>,_name);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//接收用户输入的拳头</span></span><br><span class="line">    <span class="keyword">int</span> userSelect=<span class="number">0</span>;</span><br><span class="line">    scanf(<span class="string">&quot;%d&quot;</span>,&amp;userSelect);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//显示用户选择的拳头</span></span><br><span class="line">    <span class="comment">//要取出整型的数代表的字符串的拳头的类型</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSString</span> *type=[<span class="keyword">self</span> fistTypeWithNumber:userSelect];  <span class="comment">//如果要在方法中调用当前对象的另外一个方法：[self 方法名];self代表当前对象</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;玩家[%@]出的拳头是:%@&quot;</span>,_name,type);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将用户选择的拳头存储在当前对象的属性中</span></span><br><span class="line">    _selectedType=userSelect;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *)fistTypeWithNumber:(<span class="keyword">int</span>)number&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">switch</span> (number) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">@&quot;剪刀&quot;</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">@&quot;石头&quot;</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">@&quot;布&quot;</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">@&quot;你输入的不对哟，请重新输入&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//Robot.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&quot;FistType.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Robot</span> : <span class="title">NSObject</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">@public</span></span><br><span class="line">    <span class="built_in">NSString</span> *_name;</span><br><span class="line">    FistType _selectedType;</span><br><span class="line">    <span class="keyword">int</span> _score;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)showFist;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//Robot.m</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">&quot;Robot.h&quot;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&quot;stdlib.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Robot</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)showFist&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//随机出拳</span></span><br><span class="line">    <span class="keyword">int</span> robotSelect=arc4random_uniform(<span class="number">3</span>)+<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//显示随机出的拳头</span></span><br><span class="line">    <span class="built_in">NSString</span> *type=[<span class="keyword">self</span> fistTypeWithNumber:robotSelect];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;机器人[%@]出的拳头是：%@&quot;</span>,_name,type);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将出的拳头保存在当前对象的属性中</span></span><br><span class="line">    _selectedType=robotSelect;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *)fistTypeWithNumber:(<span class="keyword">int</span>)number&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">switch</span> (number) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">@&quot;剪刀&quot;</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">@&quot;石头&quot;</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">@&quot;布&quot;</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">@&quot;你输入的不对哟，请重新输入&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//Judge.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&quot;Robot.h&quot;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&quot;Player.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Judge</span> : <span class="title">NSObject</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">@public</span></span><br><span class="line">    <span class="built_in">NSString</span> *_name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)caiJueWithPlayer:(Player *)player andRobot:(Robot *)robot;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//Judge.m</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">&quot;Judge.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Judge</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)caiJueWithPlayer:(Player *)player andRobot:(Robot *)robot&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//先拿到玩家和机器人出的拳头</span></span><br><span class="line">    FistType playerType=player-&gt;_selectedType;</span><br><span class="line">    FistType robotType=robot-&gt;_selectedType;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断输赢，为胜利的对象加分，显示结果</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     剪刀1 石头2 布3</span></span><br><span class="line"><span class="comment">     1  3  -2</span></span><br><span class="line"><span class="comment">     2  1  1</span></span><br><span class="line"><span class="comment">     3  2  1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;我是裁判[%@],现在我来宣布比赛结果&quot;</span>,_name);</span><br><span class="line">    <span class="keyword">if</span>(playerType-robotType==<span class="number">-2</span> || playerType-robotType==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//玩家胜利，提示</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;恭喜玩家[%@]取得了胜利&quot;</span>,player-&gt;_name);</span><br><span class="line">        <span class="comment">//为玩家加分</span></span><br><span class="line">        player-&gt;_score++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(playerType==robotType)&#123;</span><br><span class="line">        <span class="comment">//平局</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;[%@]、[%@]你们真是心有灵犀一点通啊！&quot;</span>,player-&gt;_name,robot-&gt;_name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//机器人胜利</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;恭喜机器人[%@]取得了胜利&quot;</span>,robot-&gt;_name);</span><br><span class="line">        robot-&gt;_score++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//显示得分</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;---玩家：[%@]:[%d]----------机器人：[%@]:[%d]&quot;</span>,player-&gt;_name,player-&gt;_score,robot-&gt;_name,robot-&gt;_score);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//FistType.h</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//剪刀枚举</span></span><br><span class="line">    FistTypeJianDao=<span class="number">1</span>,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//石头枚举</span></span><br><span class="line">    FistTypeShiTou=<span class="number">2</span>,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//布枚举</span></span><br><span class="line">    FistTypeBu=<span class="number">3</span>,</span><br><span class="line">    </span><br><span class="line">&#125;FistType;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//main.m</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&quot;Judge.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    </span><br><span class="line">    Player *xiaoMing=[Player new];</span><br><span class="line">    xiaoMing-&gt;_name=<span class="string">@&quot;小明&quot;</span>;</span><br><span class="line">  </span><br><span class="line">    Robot *aGou=[Robot new];</span><br><span class="line">    aGou-&gt;_name=<span class="string">@&quot;阿尔法狗&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    Judge *heiShao=[Judge new];</span><br><span class="line">    heiShao-&gt;_name=<span class="string">@&quot;黑哨&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">       [xiaoMing showFist];</span><br><span class="line">       [aGou showFist];</span><br><span class="line">       [heiShao caiJueWithPlayer:xiaoMing andRobot:aGou];</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;还要再玩一把嘛(y/n)&quot;</span>);</span><br><span class="line">        <span class="keyword">char</span> ans=<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        rewind(stdin);</span><br><span class="line">        scanf(<span class="string">&quot;%c&quot;</span>,&amp;ans);</span><br><span class="line">        <span class="keyword">if</span>(ans != <span class="string">&#x27;y&#x27;</span>)&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;欢迎下次再来玩哦！&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>执行结果：<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly3k6bek0j30la05kaca.jpg"></p>
]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title>私有属性和私有方法</title>
    <url>/2019/09/08/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/Objective-C/%E7%A7%81%E6%9C%89%E5%B1%9E%E6%80%A7%E5%92%8C%E7%A7%81%E6%9C%89%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<hr>
<p>我们刚才讲的@private修饰的属性叫做私有属性，只能在类的内部访问，但是在外界的时候，Xcode仍然会提示这个对象中有这个属性，只不过没权访问，我们想要实现的效果是真私有，让外界不知道对象里面有这么一个属性<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly3q1ab8zj30cq059myg.jpg"></p>
<p>其实在@implementation之中也可以写一个大括弧，把属性定义在@implementation的大括弧之中，这里面的属性，是一个私有属性，各种访问修饰符无效，外界根本就不会提示</p>
<p>将属性定义在@implementation之中和将属性定义在@interface之中并标记为@private唯一的区别：提示和不提示，都不能在外界访问</p>
<hr>
<p>私有方法：方法不写声明只写实现，那么这个方法就是一个私有方法，只能在本类的其他方法中调用，不能在外界调用</p>
]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title>第一个MRC程序：</title>
    <url>/2019/08/20/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/Objective-C/%E7%AC%AC%E4%B8%80%E4%B8%AAMRC%E7%A8%8B%E5%BA%8F%EF%BC%9A/</url>
    <content><![CDATA[<hr>
<p>要写MRC的程序，必须先把Xcode默认的ARC模式关闭，开启MRC</p>
<p>在ARC机制下，retain，release，dealloc这些方法无法调用<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly41osfo1j30m40lkgo4.jpg"></p>
<p>重写dealloc方法的规范：<br>必须要调用父类的dealloc方法，并且要放在最后一句代码</p>
<p>测试引用数据：<br>1）新创建一个对象，这个对象的引用计数器的值默认是1<br>2）当对象的引用计数器变为0的时候，对象就会被系统立即回收，并自动调用dealloc方法<br>3）为对象发送retain消息，对象的引用计数器就会+1<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly41xz6fwj30dc0bw42n.jpg"></p>
<p>为对象发送release消息，并不是回收对象，而是让对象的引用计数器-1，当对象的引用计数器的值变为0的时候，对象才会被系统立即回收</p>
]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title>简化block变量的复杂定义：</title>
    <url>/2019/07/31/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/Objective-C/%E7%AE%80%E5%8C%96block%E5%8F%98%E9%87%8F%E7%9A%84%E5%A4%8D%E6%9D%82%E5%AE%9A%E4%B9%89%EF%BC%9A/</url>
    <content><![CDATA[<hr>
<p>定义block变量的时候，类型很长：<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly4kfk6v3j306v029gm2.jpg"></p>
<p>Typedef的使用场景：将一个长类型定义为一个短类型<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly4kl9atoj306v029t96.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly4kqxm5wj307v02h0te.jpg"></p>
]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title>类和对象：</title>
    <url>/2019/09/25/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/Objective-C/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%EF%BC%9A/</url>
    <content><![CDATA[<hr>
<p>对象：现实生活中的一个具体存在，看得见摸得着，拿过来就可以直接使用</p>
<p>类：对一群具有相同特征或者行为的事物的一个统称，抽象的，不能直接使用</p>
<p>类是模版，类的对象是根据这个模版创建出来的，类模版中有什么，对象中就有什么，绝不可能多，也绝不可能少</p>
<p>设计类的三要素：<br>1）类的名字<br>2）这类事物具有的相同的特征<br>3）这类事物具有的共同的行为</p>
<p>注意：<br>1）类必须要有声明和实现<br>2）类名的首字母必须要以大写开头<br>3）属性的名字必须要以_开头（下划线）</p>
<hr>
<h3 id="定义类的语法："><a href="#定义类的语法：" class="headerlink" title="定义类的语法："></a>定义类的语法：</h3><ol>
<li><p>位置：直接写在源文件中，不要写在main函数之中</p>
</li>
<li><p>类的定义分为两部分：<br>1）类的声明<br> @inteface 类名：NSObject{</p>
<pre><code> 这类事物具有的共同的特征，将他们定义为变量</code></pre>
<p>}</p>
</li>
</ol>
<p>//一类事物不仅具有相同的特征还具有相同的行为，行为就是一个功能，C语言中使用函数来表示一个功能，OC的类具有的行为，我们使用方法来表示</p>
<pre><code>//将方法的声明写在这里
(返回值类型)方法名称；

@end

2）类的实现
@implementation 类名

//将方法的实现写在这里

@end</code></pre>
<h3 id="创建类的对象："><a href="#创建类的对象：" class="headerlink" title="创建类的对象："></a>创建类的对象：</h3><pre><code> 类名 *对象名=[类名 new];</code></pre>
<h3 id="使用对象："><a href="#使用对象：" class="headerlink" title="使用对象："></a>使用对象：</h3><ol>
<li><p>访问对象的属性：默认情况下，对象的属性是不允许被外界直接访问的，如果允许对象的属性可以被外界访问，那么就在声明属性的时候加一个@public关键字</p>
</li>
<li><p>访问对象属性的方式：</p>
<p>对象名-&gt;属性名=值；<br>(*对象名).属性名；</p>
</li>
</ol>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly3ctyrqvj30ka0gt76r.jpg"></p>
<hr>
<h3 id="无参方法的声明和实现："><a href="#无参方法的声明和实现：" class="headerlink" title="无参方法的声明和实现："></a>无参方法的声明和实现：</h3><p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly3d7jcc7j30ki0j1ad3.jpg"></p>
<h3 id="有一个参数方法的声明和实现："><a href="#有一个参数方法的声明和实现：" class="headerlink" title="有一个参数方法的声明和实现："></a>有一个参数方法的声明和实现：</h3><p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly3dfyxpjj30kl0jpadi.jpg"></p>
<h3 id="带多个参数方法的声明和实现："><a href="#带多个参数方法的声明和实现：" class="headerlink" title="带多个参数方法的声明和实现："></a>带多个参数方法的声明和实现：</h3><p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly3do1m5dj30mu0jy77s.jpg"></p>
<hr>
<p>在方法的实现中，可以直接访问属性，这个方法是通过哪一个对象来调用的，那么方法中的直接访问的属性就是哪一个对象的：<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly3dwggcpj30kk0hcmzw.jpg"></p>
]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title>类方法的规范：</title>
    <url>/2019/08/12/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/Objective-C/%E7%B1%BB%E6%96%B9%E6%B3%95%E7%9A%84%E8%A7%84%E8%8C%83%EF%BC%9A/</url>
    <content><![CDATA[<hr>
<p>一般情况下，要求提供与自定义构造方法相同功能的类方法，这样可以快速的创建一个对象；使用类方法创建的对象，要求这个对象在方法中就已经被autorelease过了，这样，我们只要在自动释放池中调用类方法来创建对象，那么创建的对象就会被自动的加入到自动释放池中<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly482dqqwj30f106m76p.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly488qmluj30fa0a6n03.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly48f8eabj30d603o0tu.jpg"></p>
]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title>终端写第一个OC程序：</title>
    <url>/2019/09/28/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/Objective-C/%E7%BB%88%E7%AB%AF%E5%86%99%E7%AC%AC%E4%B8%80%E4%B8%AAOC%E7%A8%8B%E5%BA%8F%EF%BC%9A/</url>
    <content><![CDATA[<hr>
<h3 id="OC程序的编译，链接，执行："><a href="#OC程序的编译，链接，执行：" class="headerlink" title="OC程序的编译，链接，执行："></a>OC程序的编译，链接，执行：</h3><ol>
<li><p>在.m文件中写上符合OC语法规范的源代码：<br>clear清屏<br>cd /Users/ljlmacbookair/Desktop/OC2<br>touch main.m</p>
</li>
<li><p>使用编译器将源代码编译为目标文件【预处理，检查语法，编译】<br>cc -c main.m</p>
</li>
<li><p>链接<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly3bloyncj30ft0550tb.jpg"><br>如果程序中使用到了框架中的函数或者类，那么在链接的时候，就必须要告诉编译器去哪一个框架中找这个函数或者类<br>cc main.o -framework Foundation</p>
</li>
<li><p>链接成功以后就会生成一个a.out可执行文件，执行就可以了<br>./a.out</p>
</li>
</ol>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly3bty2jqj30i70apq3m.jpg"></p>
<hr>
<h3 id="OC程序和C程序各个阶段的后缀名："><a href="#OC程序和C程序各个阶段的后缀名：" class="headerlink" title="OC程序和C程序各个阶段的后缀名："></a>OC程序和C程序各个阶段的后缀名：</h3><pre><code>源文件   目标文件  可执行文件</code></pre>
<p>C    .c       .o       .out<br>OC   .m       .o       .out</p>
]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title>知识点补充：</title>
    <url>/2019/08/04/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/Objective-C/%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A1%A5%E5%85%85%EF%BC%9A/</url>
    <content><![CDATA[<hr>
<p>ARC机制与垃圾回收机制(GC)的区别：</p>
<p>GC：程序在运行期间有一个东西叫做垃圾回收器，不断的扫描堆中的对象是否无人使用，若无人使用则回收</p>
<p>ARC：不是运行时，而是在编译的时候就在合适的地方插入retain，release……..插入的代码足以让对象无人使用的时候引用计数器为0，则回收</p>
<p>此程序main函数中第一行宝马的引用计数器应为1，第二行执行后p1为1，宝马这时应该为2，但是此程序实际上宝马的引用计数器不是2，还是1；错误原因在于构造方法_car=car;这一句，直接将car赋值给属性_car，并没有做retain，release，这一行应该改为self.car=car;<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly4fpmzgpj30940730ty.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly4fwyql2j307x04owfj.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly4g3ky9qj307x07tta4.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly4g9g30sj307x02jdg8.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly4gf6minj307x04jaao.jpg"></p>
]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title>结构体和类的区别：</title>
    <url>/2019/09/02/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/Objective-C/%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A/</url>
    <content><![CDATA[<hr>
<h3 id="相同点：都可以将多个数据封装为一个整体"><a href="#相同点：都可以将多个数据封装为一个整体" class="headerlink" title="相同点：都可以将多个数据封装为一个整体"></a>相同点：都可以将多个数据封装为一个整体</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Date</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> year;</span><br><span class="line">    <span class="keyword">int</span> month;</span><br><span class="line">    <span class="keyword">int</span> day;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Date</span>:<span class="title">NSObject</span></span>&#123;</span><br><span class="line">       <span class="keyword">int</span> year;</span><br><span class="line">       <span class="keyword">int</span> month;</span><br><span class="line">       <span class="keyword">int</span> day;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="不同点："><a href="#不同点：" class="headerlink" title="不同点："></a>不同点：</h3><p>1）结构体只能封装数据，而类不仅可以封装数据还可以封装行为【如果表示的这个实体，不仅是由多个数据组成，这个实体还具有行为，只能使用类】</p>
<p>2）结构体变量分配在栈空间（如果是一个局部变量的情况下），而对象分配在堆空间<br>【栈的特点：空间相对较小，但是存储在栈中的数据访问的效率更高一些；堆的特点：空间相对较大，但是存储在堆中的数据访问的效率相对较低】</p>
<p>3）赋值不同：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//结构体：Student</span></span><br><span class="line"><span class="comment">//类：Person</span></span><br><span class="line"></span><br><span class="line">Student s1=&#123;“jack”,<span class="number">19</span>,GenderMale&#125;;</span><br><span class="line">Student s2=s1;</span><br><span class="line"></span><br><span class="line">Person *p1=[Person new];</span><br><span class="line">Person *p2=p1;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title>类的本质：</title>
    <url>/2019/09/01/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/Objective-C/%E7%B1%BB%E7%9A%84%E6%9C%AC%E8%B4%A8%EF%BC%9A/</url>
    <content><![CDATA[<hr>
<p>1）类第一次被访问的时候，就会被加载到代码段中存储（类加载）<br>2）类一旦被加载到代码段之后是不会被回收的，除非程序结束</p>
<p>类是以什么样的形式存储在代码段的：<br>1）任何存储在内存中的数据都有一个数据类型<br>2）任何在内存中申请的空间也有自己的类型<br><code>Person *p1=[Person new];</code><br>3)在代码段存储类的那块空间是什么类型？</p>
<p>在代码段中存储类的步骤：<br>1）先在代码段中创建一个Class对象，Class是Foundation框架中的一个类，这个Class对象就是用来存储类信息的<br>2）将类的信息存储在这个Class对象之中，这个Class对象至少有三个属性：存储的这个类的名称，存储的这个类的属性，存储的这个类的方法</p>
<p>所以类是以Class对象的形式存储在代码段的，存储类的这个Class对象，我们也叫做类对象，用来存储类的一个对象</p>
<p>所以存储类的类对象也有一个叫做isa指针的属性，这个指针指向存储父类的类对象<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly3ri3eq9j307d0ch3yx.jpg"></p>
<h3 id="如何拿到存储在代码段中的类对象："><a href="#如何拿到存储在代码段中的类对象：" class="headerlink" title="如何拿到存储在代码段中的类对象："></a>如何拿到存储在代码段中的类对象：</h3><p>1）调用类的类方法class就可以得到存储类的类对象的地址【声明Class指针的时候不需要加<em>，因为在typedef的时候已经加</em>了】</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Class c1&#x3D;[Person class];</span><br><span class="line">NSLog(@&quot;c1 &#x3D; %p&quot;,c1);</span><br></pre></td></tr></table></figure>

<p>2）调用对象的对象方法class，就可以得到存储这个对象所属的类的Class对象的地址</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Person *p1&#x3D;[Person new];</span><br><span class="line">Class c2&#x3D;[p1 class];</span><br></pre></td></tr></table></figure>

<p>3）对象中的isa指针的值其实就是代码段中存储类的类对象的地址</p>
<h3 id="如何使用类对象："><a href="#如何使用类对象：" class="headerlink" title="如何使用类对象："></a>如何使用类对象：</h3><p>1）拿到存储类的类对象以后，<code>Class c1=[Person class];</code><br>c1对象就是Person类，c1完全等价于Person</p>
<p>2）使用类对象来调用类的类方法</p>
<p>3）可以使用类对象来调用new方法，创建存储在类对象中的类的对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Class c1&#x3D;[Person class];</span><br><span class="line">Person *p1&#x3D;[c1 new];</span><br></pre></td></tr></table></figure>

<p>4）注意：使用类对象只能调用类的类方法，因为类对象就等价于存在其中的类</p>
]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title>访问修饰符：用来修饰属性</title>
    <url>/2019/09/09/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/Objective-C/%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6%EF%BC%9A%E7%94%A8%E6%9D%A5%E4%BF%AE%E9%A5%B0%E5%B1%9E%E6%80%A7/</url>
    <content><![CDATA[<hr>
<p>可以限定对象的属性在哪一段范围之中访问</p>
<ol>
<li><p>@private私有的，被@private修饰的属性只能在本类的内部访问，只能在本类的方法实现中访问</p>
</li>
<li><p>@protected受保护的，被@protected修饰的属性只能在本类和本类的子类中访问，只能在本类和子类的方法实现中访问</p>
</li>
<li><p>@package：被@package修饰的属性，可以在当前框架中访问</p>
</li>
<li><p>@public：公共的，被@public修饰的属性可以在任意的地方访问</p>
</li>
</ol>
<p>如果不为属性指定访问修饰符，那么默认的就是@protected</p>
<p>子类仍然可以继承父类的私有属性，只不过在子类中无法去直接访问从父类继承过来的私有属性，但是如果父类中有一个方法在为属性赋值或者取值，那么子类可以调用这个方法间接的访问父类的私有属性</p>
<p>访问修饰符的作用域：从写访问修饰符的地方开始往下，直到遇到另外一个访问修饰符或者结束大括弧为止，中间的所有的属性都应用于这个访问修饰符</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span>:<span class="title">NSObject</span></span>&#123;</span><br><span class="line">   <span class="keyword">@private</span></span><br><span class="line">   <span class="built_in">NSString</span> *_name;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">@public</span></span><br><span class="line">   <span class="keyword">int</span> _age;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">int</span> _x;</span><br><span class="line">   <span class="keyword">@protected</span></span><br><span class="line">   <span class="keyword">int</span> _y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用建议：<br>1）@public无论什么情况下都不要使用，属性不要直接暴露给外界<br>2）@private如果属性只想在本类中使用，不想在子类中使用，那么就使用它<br>3）@protected：如果你希望属性只在本类和本类的子类中使用<br>推荐使用默认的@protected</p>
<p>访问修饰符只能用来修饰属性，不能用来修饰方法</p>
]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title>里氏替换原则—LSP</title>
    <url>/2019/09/07/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/Objective-C/%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99%E2%80%94LSP/</url>
    <content><![CDATA[<hr>
<p>子类可以替换父类的位置，并且程序的功能不受影响</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">Person *p1=[Person new];</span><br><span class="line">Student *s1=[Student new];</span><br><span class="line"></span><br><span class="line">Person *p2=[Student new];</span><br></pre></td></tr></table></figure>

<p>为什么？<br>1）父类指针迫切的需求要一个父类对象，而我们给了一个子类对象，这是完全没有问题的【你想要一个人，我给你一个学生】<br>2）因为父类中拥有的成员子类都有，所以不会影响程序的功能</p>
<p>里氏替换原则的表现形式：<br>当一个父类指针指向一个子类对象的时候，这里就有里氏替换原则</p>
<p>里氏替换原则的作用：<br>1）一个指针中不仅可以存储本类对象的地址还可以存储子类对象的地址<br>2）如果一个指针的类型是NSObject类型的，那么这个指针中可以存储任意的OC对象的地址<br>3）如果一个数组的元素的类型是一个OC指针类型的，那么这个数组中不仅可以存储本类对象还可以存储子类对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Person *ps[3];</span><br><span class="line"></span><br><span class="line">ps[0]&#x3D;[Person new];</span><br><span class="line">ps[1]&#x3D;[Student new];</span><br><span class="line">ps[2]&#x3D;[ItCastStu new];</span><br></pre></td></tr></table></figure>

<p>4）如果一个数组的元素是NSObject指针类型，那么意味着任意的OC对象都可以存储到这个数组之中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSObject *objs[4];</span><br><span class="line"></span><br><span class="line">objs[0]&#x3D;[Person new];</span><br><span class="line">objs[1]&#x3D;[Student new];</span><br><span class="line">objs[2]&#x3D;[ItCastStu new];</span><br><span class="line">objs[3]&#x3D;@&quot;jack&quot;;</span><br></pre></td></tr></table></figure>

<p>5）如果一个方法的参数是一个对象，那么我们在为这个参数传值的时候可以传递一个本类对象，也可以传递一个子类对象，对方法中的代码不会有丝毫的影响</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">God *ys&#x3D;[God new];</span><br><span class="line"></span><br><span class="line">Person *p1&#x3D;[Person new];</span><br><span class="line">[p1 setName:@&quot;大狗&quot;];</span><br><span class="line"></span><br><span class="line">Student *s1&#x3D;[Student new];</span><br><span class="line">[s1 setName:@&quot;小明&quot;];</span><br><span class="line"></span><br><span class="line">ItCastStu *stu&#x3D;[ItCastStu new];</span><br><span class="line">[stu setName:@&quot;小东&quot;];</span><br><span class="line"></span><br><span class="line">[ys killWithPerson:stu];</span><br></pre></td></tr></table></figure>

<p>当一个父类指针指向一个子类对象的时候，通过这个父类指针就只能去调用子类对象中的父类成员，子类独有的成员无法访问</p>
]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title>非正式协议：</title>
    <url>/2019/08/05/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/Objective-C/%E9%9D%9E%E6%AD%A3%E5%BC%8F%E5%8D%8F%E8%AE%AE%EF%BC%9A/</url>
    <content><![CDATA[<hr>
<p>为系统自带的类写分类，这个就叫做非正式协议</p>
<p>分类的作用：<br>1）将一个类分为多个模块<br>2）为一个已经存在的类添加方法（扩展一个类）</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly4eg0j8bj30a00900v0.jpg"><br>如果想为NSString写一个方法：<br>（此方法无参数，因为NSString本身就是字符串）<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly4en32rmj309303qq3s.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly4et5aqkj309307f766.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly4f0jo8dj30ai09saco.jpg"></p>
]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title>自动释放池：</title>
    <url>/2019/08/13/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/Objective-C/%E8%87%AA%E5%8A%A8%E9%87%8A%E6%94%BE%E6%B1%A0%EF%BC%9A/</url>
    <content><![CDATA[<hr>
<p>原理：存入到自动释放池中的对象，在自动释放池被销毁的时候，会自动调用存储在该自动释放池中的所有对象的release方法</p>
<p>可以解决的问题：将创建的对象，存入到自动释放池之中，就不再需要手动的release这个对象了，因为池子销毁的时候，就会自动的调用池中所有的对象的release</p>
<p>如何创建自动释放池：<br>@autoreleasepool{</p>
<p>}<br>这对大括弧代表这个自动释放池的范围</p>
<p>如何将对象存储到自动释放池之中：在自动释放池之中调用对象的autorelease方法，就会将这个对象存入到当前自动释放池之中</p>
<p>这个autorelease方法返回的是对象本身，所以我们可以这么写：<br>@autoreleasepool{<br>      Person *p1=[[[Person alloc] init] autorelease];<br>}<br>这个时候，当这个自动释放池执行完毕之后，就会立即为这个自动释放池中的对象发送一条release消息<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly47ex751j309h03ajry.jpg"></p>
<p>八大注意：<br>1）只有在自动释放池中调用了对象的autorelease方法，这个对象才会被存储到这个自动释放池之中，如果只是将对象的创建代码写在自动释放池之中，而没有调用对象的autorelease方法，是不会将这个对象存储到这个自动释放池之中的<br>2）对象的创建可以在自动释放池的外面，在自动释放池之中调用对象的autorelease方法，就可以将这个对象存储到这个自动释放池之中<br>3）如果对象的autorelease方法的调用放在自动释放池的外面，是无法将其存储到这个自动释放池之中的，autorelease的调用只有放在自动释放池之中，才可以将其存储到自动释放池<br>4）当自动释放池结束的时候，仅仅是对存储在自动释放池中的对象发送一条release消息，而不是销毁对象<br>5）如果在自动释放池中调用同一个对象的autorelease方法多次，就会将对象存储多次到自动释放池之中，在自动释放池结束的时候，会为对象发送多条release消息，那么这个时候就会出现僵尸对象错误<br>6）如果在自动释放池中调用了存储到自动释放池中的对象的release方法，在自动释放池结束的时候，还会再调用对象的release方法，这个时候就有可能会造成野指针操作（也可以调用存储在自动释放池中的对象的retain方法）<br>7）将对象存储到自动释放池并不会使对象的引用计数器+1，所以其好处就是：创建对象将对象存储在自动释放池，就不需要再写一个release了<br>8）自动释放池可以嵌套，调用对象的autorelease方法，会将对象加入到当前自动释放池之中，只有在当前自动释放池结束的时候才会向对象发送release消息</p>
]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title>野指针与僵尸对象：</title>
    <url>/2019/08/18/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/Objective-C/%E9%87%8E%E6%8C%87%E9%92%88%E4%B8%8E%E5%83%B5%E5%B0%B8%E5%AF%B9%E8%B1%A1%EF%BC%9A/</url>
    <content><![CDATA[<hr>
<p>C语言中的野指针：定义一个指针变量，没有初始化，这个指针变量的值是一个垃圾值，指向一块随机的空间，这个指针就叫做野指针</p>
<p>OC中的野指针：指针指向的对象已经被回收了，这样的指针就叫做野指针</p>
<p>内存回收的本质：申请一个变量实际上就是向系统申请指定字节数的空间，这些空间系统就不会再分配给别人了；当变量被回收的时候，代表变量占用的字节空间从此以后系统就可以分配给别人使用了，但是字节空间中存储的数据还在（这就是野指针的来源）</p>
<p>对象回收的本质：对象占用的空间可以分配给别人，当这个对象占用的空间没有分配给别人之前，其实对象数据还在</p>
<p>僵尸对象：一个已经被释放的对象，但是这个对象所占的空间还没有分配给别人，这样的对象叫做僵尸对象；我们通过野指针去访问僵尸对象的时候，有可能没问题，也有可能有问题，当僵尸对象占用的空间还没有分配给别人的时候就没问题</p>
<p>我们认为只要对象成为了僵尸对象，无论如何都不允许访问了，就希望如果访问的是僵尸对象，无论如何都会报错</p>
<p>Xcode有一个僵尸对象的实时检查机制，可以将这个机制打开，打开之后，只要访问的是僵尸对象，无论空间是否分配，就会报错<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly42ith55j30ow0f2n3m.jpg"></p>
<p>为什么不默认打开僵尸对象检测：一旦打开僵尸对象检测，那么在每访问一个对象的时候，都会先检查这个对象是否为一个僵尸对象，这样是极其消耗性能的</p>
<p>如何避免僵尸对象错误？<br>当一个指针成为野指针以后，将这个指针的值设置为nil<br>当一个指针的值为nil，通过这个指针去调用对象的方法（包括使用点语法）的时候，不会报错，只是没有任何反应；但是如果通过直接访问属性，就会报错</p>
<p>无法复活一个僵尸对象</p>
]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title>类方法：</title>
    <url>/2019/09/18/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/Objective-C/%E7%B1%BB%E6%96%B9%E6%B3%95%EF%BC%9A/</url>
    <content><![CDATA[<hr>
<p>OC中的方法分为两种：</p>
<ol>
<li>对象方法/实例方法：如果想要调用对象方法就必须要先创建对象，通过对象名来调用</li>
<li>类方法：类方法的调用不依赖于对象，如果要调用类方法，不需要去创建对象，而是直接通过类名来调用</li>
</ol>
<p>类方法的声明：【只有“+”“-”号的区别】<br><code>+ (返回值类型)方法名;</code></p>
<p>调用：[类名 类方法名];（不需要创建对象）</p>
<p>类方法和对象方法的调用过程：<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly3l08rmvj30hi0ba75o.jpg"></p>
<p>类方法的特点：<br>1）节约空间：因为调用类方法不需要创建对象<br>2）提高效率：因为调用类方法不需要拐弯，直接找到类，直接执行类中的类方法</p>
<p>在类方法中不能直接访问属性（类方法在执行的时候有可能还没有对象，虽然不能直接访问属性，但是我们可以在类方法中创建一个对象，访问这个对象的属性）<br>1）属性是在对象创建的时候，跟随着对象一起创建在对象之中<br>2）类第一次被访问的时候会做类加载，是把类的代码存储在代码段</p>
<p>在类方法中也不能通过self直接调用当前类的其他的对象方法，因为对象方法只能通过对象来调用，而这个时候没有对象</p>
<p>在对象方法中可以直接调用类方法</p>
<p>如果方法不需要直接访问属性也不需要直接调用其他的对象方法，那么我们就可以将这个方法定义为类方法，这样就节约空间提高效率</p>
<p>关于类方法的规范：<br>1）如果我们写一个类，那么就要求为这个类提供一个和类名同名的类方法，这个方法创建一个最纯洁的对象返回<br>2）如果你希望创建的对象的属性的值由调用者指定，那么就为这个类方法带参数</p>
]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title>面向对象的三大特征：</title>
    <url>/2019/09/15/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/Objective-C/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81%EF%BC%9A/</url>
    <content><![CDATA[<hr>
<p>封装：类就是更高级别的封装，类将数据和行为封装为了一个整体</p>
<p>优点：</p>
<ol>
<li>屏蔽内部的实现，外界不需要知道内部是如何实现的，只需要知道这个对象有什么用</li>
<li>方便操作</li>
<li>后期的维护十分的便利</li>
</ol>
<p>属性的封装：</p>
<p>存在的问题：为对象的属性赋值的时候，语法上其实只要数据的类型是属性的类型就是可以的，但是情理上这么做是不合的（人的年龄）</p>
<p>解决问题：<br>1）将属性的@public去掉<br>2）为类提供一个方法，这个方法专门为这个属性赋值，这个方法我们叫做setter</p>
<p>setter方法：<br>1）这个方法是一个对象方法，因为这个方法要为属性赋值；<br>2）这个方法没有返回值；<br>3）这个方法的名称必须以set开头，跟上去掉下划线首字母大写的属性名；<br>4）这个方法一定是有参数的，参数的类型和属性的类型一致，参数的名称和属性的名称一致（去掉下划线）<br>5）在方法的实现中，判断传入的数据是否符合逻辑，如果符合逻辑则赋值，否则做默认处理<br>6）外界想要为对象的属性赋值，那么就调用这个对象的setter方法，将要赋值的数据传入这个方法</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly3o30cn3j308o06v0u1.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly3oaai7pj309w08xabx.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly3ogduznj308k06s75l.jpg"></p>
<p>以上又有一个问题：在外界无法取出属性的值了</p>
<p>getter方法：<br>1）是一个对象方法，因为这个方法做的事情是拿到属性的值返回<br>2）有返回值，返回值的类型和属性的类型一致<br>3）这个方法的名称直接就是属性的名称（去掉下划线）<br>4）这个方法没有参数<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly3on7kdlj303u00saa3.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly3oudea4j303u01yq33.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly3p1a4z4j309k01omxi.jpg"></p>
<p>只要属性需要被外界访问，就要为这个属性封装setter和getter，哪怕在赋值或者取值的时候没有任何逻辑验证</p>
<p>只读封装：为属性封装的时候，只提供getter，不提供setter<br>只写封装：为属性封装的时候，只提供setter，不提供getter</p>
]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title>集合的内存管理：</title>
    <url>/2019/07/04/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/Objective-C/%E9%9B%86%E5%90%88%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%9A/</url>
    <content><![CDATA[<hr>
<p>NSArray：集合<br>NSDictionary：字典集合</p>
<p>在MRC模式下，将对象存储到集合之中，会为这个对象的引用计数器+1，当集合销毁的时候，就会向存储在集合中的所有对象发送一条release消息<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly5gmsm0zj30a809en06.jpg"></p>
<p>使用@[]或者@{}创建的集合已经被autorelease过了<br>直接调用和类同名的类方法创建的对象也是被autorelease过了<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly5gurak1j30el03qq43.jpg"></p>
<p>在ARC模式下，集合的元素是一个强类型的指针<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly5h0y01xj305a01h0sy.jpg"></p>
]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title>面向过程和面向对象：</title>
    <url>/2019/09/26/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/Objective-C/%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E5%92%8C%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%9A/</url>
    <content><![CDATA[<hr>
<h3 id="优缺点分析："><a href="#优缺点分析：" class="headerlink" title="优缺点分析："></a>优缺点分析：</h3><ol>
<li><p>面向过程的解决问题的缺点：后期的维护和修改不方便</p>
</li>
<li><p>面向对象的解决问题的优点：<br>1）后期的维护和修改十分方便<br>2）使用面向对象设计我们的程序，可以让我们的程序在后期的维护和修改当中更加的方便和快捷</p>
</li>
</ol>
]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title>继承、NSObject：</title>
    <url>/2019/09/11/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/Objective-C/%E7%BB%A7%E6%89%BF%E3%80%81NSObject%EF%BC%9A/</url>
    <content><![CDATA[<hr>
<p>继承的目的：儿子类想拥有父亲类中的所有的成员，但是不想自己去定义，而是想凭空拥有</p>
<p>继承的语法：<br><code>@interface 子类名：父类名 </code></p>
<p>@end</p>
<p>术语：<br><code>@interface Student:Person</code><br>1）Student类从Person类继承，Student类是Person类的子类，Person类是Student类的父类<br>2）Student类从Person类派生，Student类是Person类的派生类，Person类是Student类的基类</p>
<p>在新创建类模版的时候指定父类，Xcode就会自动的帮助你完成一系列事情</p>
<p>继承是类在继承，而不是对象在继承，我们创建对象，对象与对象之间是毫无关系的，只是子类对象中拥有父类对象中的同样的成员</p>
<p>千万不要为了继承而去继承，不要为了仅仅是得到某个类的成员你就不顾伦理去乱继承（人继承狗类？）</p>
<p>子类从父类继承，就意味着子类拥有了父类的所有成员，包括属性和方法 </p>
<p>如果有一个成员不是所有的子类都拥有的，那么这个成员就不应该定义在父类之中，因为一旦定义在父类之中，那么所有的子类全都有了，父类中只定义所有的子类都拥有的</p>
<p>继承的特点：<br>1）单根性：一个类只能有一个父类，不能有多个父类<br>2）传递性：A类从B类继承，B类从C类继承，那么A类就同时拥有B、C类的成员</p>
<hr>
<p>NSObject类是OC中所有类的祖宗类，因为OC中的类全部都是直接的或者间接的从它继承</p>
<p>NSObject类：这是Foundation框架中的类，在这个类中有一个类方法new，这个方法是用来创建对象的，方法的返回值是创建的这个对象的指针；也就是说，如果要创建类的对象，就必须要调用这个new方法，如果我们想要让我们的类具备创建对象的能力，就必须要让我们的类直接或者间接的从NSObject类继承</p>
<p>在NSObject类之中，还定义了一个属性，这个属性叫做isa指针，所以每一个子类对象中都有一个叫做isa指针</p>
<p>子类中不能存在和父类同名的属性</p>
]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title>const修饰基本数据类型</title>
    <url>/2018/09/19/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80/const%E4%BF%AE%E9%A5%B0%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<hr>
<p><code>const int num = 10;</code><br>一般情况下来说，被const修饰的变量具备一定程度上的不可变性【只能取值不能修改】</p>
<p>const修饰数组：<code>const int arr[4]=&#123;10,20,30,40&#125;;</code>，数组的元素的值不能修改,数组变量已经是const的指针了，这里的const表明数组的每个单元都是const int，所以必须通过初始化进行赋值</p>
<p>const修饰指针：<br>1）<br><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gna53uqy8yj30kl0dhjti.jpg"><br>2）<code>int const * p1=&amp;num;</code>效果同上<br>3）<code>int * const p1=&amp;num;</code><br>p1的值不能修改，但是可以通过p1去修改p1指向的变量的值<br><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gna5al9nfmj30at0cggmx.jpg"><br>4）<code>int const * const p1=&amp;num;</code><br>既不能修改p1的值，也不能通过p1去修改p1指向的变量的值</p>
<p>当函数的参数是一个指针的时候，这个时候函数的内部是有可能会修改实参变量的值,所以要加一个const:<br><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gna5jqxhtjj30d70amta0.jpg"></p>
]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>scanf输入多个数据出现的问题</title>
    <url>/2018/09/27/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80/scanf%E8%BE%93%E5%85%A5%E5%A4%9A%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<hr>
<p>如果使用scanf函数一次输入多个数据，只能是整型和浮点型，如果有char字符型混合输入，就会出现问题：<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glffiv25wlj30e709fjsj.jpg"></p>
<p>图中可以看到：num3的值并没有打印出来，出现这种情况的原因是什么呢？？？</p>
<ol>
<li><p>在执行scanf函数的时候，会让用户输入一个数据，数据输入完毕之后，并不是将这个数据直接赋值给变量，而是先将数据存储在缓冲区，输入的任何数据都会存储在缓冲区中</p>
</li>
<li><p>在执行scanf函数的时候，会先检查缓冲区中是否有数据，如果缓冲区中没有数据，那么就会让用户从键盘输入，如果缓冲区中有数据，直接从缓冲区中将数据拿出来，不会让用户输入数据</p>
</li>
<li><p>当从缓冲区中拿数据的时候，如果要拿的数据的类型是整型或者实型，如果拿到的数据的类型是空格、回车、Tab键，就会被自动忽略，继续往下拿；如果要拿的数据是字符型，不会忽略任何数据</p>
</li>
</ol>
<p>我们来分析下面的一段程序：程序中要求用户输入一个整型数据num1，但是这个时候我们偏偏输入两个整型数据10、20，这个时候缓冲区其实有四个数据：10、空格、20、换行，执行第一个printf后结果为10，这是我们事先预料好的；当第二个scanf执行的时候，程序根本就不会让用户输入数据，因为缓冲区中已经有整型数据20了【当从缓冲区中拿数据的时候，如果要拿的数据的类型是整型或者实型，如果拿到的数据的类型是空格、回车、Tab键，就会被自动忽略，继续往下拿】，所以最终程序会直接打印出num2=20<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glffj3ejggj30al0aj3zn.jpg"></p>
<p>让我们再回头看第一个程序：为什么num3的值打印出来的结果为空？？？<br>执行完第11行程序以后，缓冲区中的数据为10、空格、2.5、空格、a、换行；打印num1、num2的值的时候，因为是整型或者浮点型，程序会自动忽略空格和换行，所以输出结果为num1=10，num2=2.500000；但是num3是一个字符型的数据，程序并不会忽略任何的数据，最后打印出来的结果为num3= ；【这里打印出来了一个空格，并不是空】</p>
<p>那这个时候就有问题了，如果scanf输入多个数据中包含字符型数据时，我就是想要输出来字符型数据，该怎么做呢？？？</p>
<p>解决方案：通过<code>rewind(stdin);</code>这行代码把缓冲区中的数据全部清空，这个时候缓冲区中没有任何数据了<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glffjeysa5j30cs0grdhv.jpg"></p>
<p>写C代码时，如果遇到整型、浮点型、字符型同时出现在scanf函数中的时候，要十分注意缓冲区中数据的情况！！</p>
]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>typedef</title>
    <url>/2018/09/15/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80/typedef/</url>
    <content><![CDATA[<hr>
<p>为一个已经存在的数据类型取一个别名【为结构体和枚举取一个别名】<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glxi4qiiifj30bu095mzv.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glxi4yx9dsj30be0543zo.jpg"></p>
<p>size_t其实就是unsigned long</p>
<p>C语言提供了一个叫做typedef的功能来声明一个已有的数据类型的新名字，比如 typedef int Length;</p>
]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>macOS终端下执行第一个C程序</title>
    <url>/2018/09/29/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80/macOS%E7%BB%88%E7%AB%AF%E4%B8%8B%E6%89%A7%E8%A1%8C%E7%AC%AC%E4%B8%80%E4%B8%AAC%E7%A8%8B%E5%BA%8F/</url>
    <content><![CDATA[<hr>
<p>在其他操作系统中，编译，加载，运行等规则会有所不同！</p>
<p>1）新建一个文件夹“C语言程序演示”</p>
<p>2）在终端中cd进入这个新建的文件夹</p>
<p>3）在新文件夹中touch hello.c建立一个后缀名为.c的源程序<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glfft27gloj30lz07ldhb.jpg"></p>
<p>4）在hello.c源文件中写第一个C语言的代码<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glfft9zgknj30m704ogm2.jpg"></p>
<p>5）通过cc hello.c命令进行编译，如果源程序没有什么错误，编译过程将顺利进行，并生成一个可执行文件a.out【cc -c 源文件名称：编译，生成.o文件，叫做目标文件，存储的是.c文件中的代码对应的二进制指令；cc 目标文件名称：连接，为.o的目标文件添加启动代码，告诉编译器，要调用的函数在什么地方】<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glffthb0i2j30mp07b0ue.jpg"></p>
<p>6）然后我们输入./a.out，即可运行a.out，打印出程序结果</p>
]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>值传递、地址传递</title>
    <url>/2018/09/22/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80/%E5%80%BC%E4%BC%A0%E9%80%92%E3%80%81%E5%9C%B0%E5%9D%80%E4%BC%A0%E9%80%92/</url>
    <content><![CDATA[<hr>
<p>值传递：当函数参数的类型是int、float、double、char类型的时候，调用者传入一个实参变量，函数执行完毕之后，对实参变量的值没有影响</p>
<p>我们来分析下面一段代码：为啥test函数和main函数中num的值不一样呢？？<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glffk6urjqj30be0drwfn.jpg"></p>
<p>程序执行原理：<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glffkohma6j314x0r7h0l.jpg"></p>
<p>地址传递：数组作为函数的参数时是地址传递，在传值的时候，是把实参数组名传递进来，数组名代表数组地址，所以这个时候传值传的是数组的地址，把数组的地址传递给了函数的参数，所以函数的参数也指向了实参数组【当数组作为函数的参数的时候，在函数的内部去修改这个参数数组的元素，其实修改的就是实参数组的元素】</p>
<p>当数组作为函数的参数的时候，那么在传递的时候，会丢失数组的长度，在函数的内部使用sizeof计算参数数组的字节数，得到的永远都是8<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glffl328kkj30mv0eygnk.jpg"></p>
<p>内部原理：如果函数的参数是一个数组，在声明这个参数的时候，并不会去真正的创建数组，而是去声明一个用来存储数组地址的指针变量，这个指针变量在内存中占据8个字节<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glffliqdhdj30j40cqabp.jpg"></p>
<p>那我们函数内部想要得到原来的数组长度该怎么办呢？？</p>
<p>如果我们的函数的参数是一个数组，这个时候还必须得加一个参数，让调用者将这个数组的长度传递进来<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glffltm3edj30b70c6wfn.jpg"></p>
<p>如果我们为函数写了一个数组作为参数，其实编译器在编译的时候，已经把这个数组换成了指针【所以，以后为函数写一个数组参数的时候，不要写数组了，直接按照下图写一个指针】<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gotlugi84bj30an0acwfh.jpg"></p>
]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>与申请字节空间有关的三个函数</title>
    <url>/2018/09/18/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80/%E4%B8%8E%E7%94%B3%E8%AF%B7%E5%AD%97%E8%8A%82%E7%A9%BA%E9%97%B4%E6%9C%89%E5%85%B3%E7%9A%84%E4%B8%89%E4%B8%AA%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<hr>
<p><code>#include&lt;stdlib.h&gt;</code></p>
<p>向堆区申请字节空间来使用：我们在堆区申请的字节空间，如果不主动释放，那么系统是不会释放掉的，除非程序结束</p>
<p>1）malloc()：向堆空间申请指定连续的字节空间来使用【参数是size_t类型的，也就是unsigned long】<br>返回值是void *，返回的是创建的空间中第一个字节的地址<br><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gna6x4706nj308202vq3c.jpg"></p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gna6r77yjrj30ms0jltcc.jpg"></p>
<p>2）calloc()：calloc申请的字节，申请完之后，系统会将字节中的数据清零<br><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gna73t2s58j30cv0fb3zs.jpg"></p>
<p>3）realloc()：当我们发现我们之前在堆区申请的字节空间不够用的时候，就可以使用realloc函数来为我们的字节空间扩容<br>【如果原来的空间后面还有剩余的空间，并且足够扩容，那么直接就扩容在后面；如果原来的空间后面有剩余空间但是剩下的空间不够扩容，就重新找一块足够的空间申请，将原来的数据拷贝过来，原来的空间被自动释放】</p>
<p>空间由3个变成4个，扩容了一个：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gna76tyrnxj30cv06e3z6.jpg"></p>
]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>函数</title>
    <url>/2018/09/23/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80/%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<hr>
<p>函数：函数是一块代码，接收零个或多个参数，做一件事情，并返回零个或一个值</p>
<p>循环：同一段代码反复不停的执行<br>重用/复用：有一段代码，多个地方都要执行一次，但是不是反复不停的执行</p>
<p>定义在函数内部的变量，我们就叫做局部变量<br>定义在函数外部的变量，我们就叫做全局变量，直接定义在源文件下面</p>
<p>局部变量只能在当前函数的内部访问<br>全局变量从定义的地方开始，后面的所有函数中都可以访问这个全局变量</p>
<p>声明一个局部变量，如果没有为这个局部变量赋初始值，那么这个局部变量中的值是一个垃圾值；声明一个全局变量，如果没有为这个全局变量赋初始值，那么这个全局变量的初始值为0</p>
<p>如果全局变量的类型是char类型，并且我们也没有初始化，那么系统就会自动的为这个char变量赋值一个‘\0’，代表一个不可见的字符，这个字符的ASCII码就是0</p>
<p>CPU执行声明局部变量的那句话的时候，才会在内存中声明局部变量，当作用域结束以后，就会自动回收；程序一启动，就在内存中创建全局变量，程序结束的时候全局变量才会被回收</p>
<p>可以定义一个和全局变量名称相同的局部变量【不建议】</p>
<p>声明在函数名称后面的小括弧中的变量就叫做这个函数的参数，参数实际上就是定义在函数内部的局部变量，所以在函数的内部不能再定义一个局部变量的名称和参数的名称一样</p>
<p>形参：声明在函数名的小括弧中的参数<br>实参：在调用函数的时候，实际上为形参赋的值</p>
<p>return关键字用在函数体中，在函数体中如果遇到了return关键字，就会立即结束这个函数的执行<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gotmep4m79j30an091wf6.jpg"></p>
<p>函数的声明(.h)和实现(.c)</p>
<p>当我们的程序的函数过多的时候，就要考虑分模块开发，一个模块至少包含两个文件，.h文件专门写函数的声明，.c文件专门写函数的实现 ，其他人想要调用函数，只需要导入头文件就可以了</p>
]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>基本概念</title>
    <url>/2018/09/30/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<hr>
<p>C语言的发展：</p>
<ol>
<li>C语言是从B语言发展而来的，B语言是从BCPL发展而来的，BCPL是从FORTRAN发展而来的</li>
<li>BCPL和B都支持指针间接方式，所以C也支持了</li>
<li>C语言还受到了PL/I的影响，还和PDP-II的机器语言有很大关系</li>
<li>1973年3月，第三版的Unix上出现了C语言的编译器</li>
<li>1973年11月，第四版的Unix(System Four)发布了，这个版本是完全用C语言重新写的</li>
</ol>
<p>C语言标准：</p>
<ol>
<li>1989年ANSI发布了一个标准：ANSI C</li>
<li>1990年ISO接受了ANSI的标准：C89</li>
<li>C的标准在1995年和1999年两次更新：C95和C99</li>
<li>所有的当代编译器都支持C99了</li>
</ol>
<p>环境、开发环境和IDE：</p>
<ol>
<li>环境：就是一个软件</li>
<li>开发环境：用于开发程序的一个软件，就是说这个软件是用来开发程序的</li>
<li>IDE：集成开发环境，集成的意思是多个功能集合在一起，所以就是集多种功能于一身的用来开发程序的软件</li>
</ol>
<p>程序的执行：</p>
<ol>
<li>解释：借助一个程序，那个程序能试图理解你的程序，然后按照你的要求执行</li>
<li>编译：借助一个程序，就像一个翻译，把你的程序翻译成计算机真正能懂的语言（机器语言写的程序），然后这个机器语言写的程序就能直接执行了</li>
<li>解释型语言VS编译型语言：语言本无解释和编译之分，解释型语言有特殊的计算能力，编译型语言有确定的运算性能</li>
<li>C需要被编译才能运行，所以你需要编辑器和编译器或者IDE（集成开发环境）</li>
</ol>
<p>现代的编程语言在语法上的差异很小，几乎都是C-like语言，语言的能力和适用领域主要是由库和传统所决定的</p>
<p>程序是用特殊的编程语言写出来表达如何解决问题的，不是用编程语言来和计算机交谈，而是描述要求它如何做事情的过程和方法，我们要让计算机做计算，就需要找出计算的步骤，然后用编程语言写出来；计算机做的所有的事情都叫做计算，计算的步骤就是算法</p>
]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串</title>
    <url>/2018/09/12/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80/%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<hr>
<h3 id="字符串数据在C中的存储方式："><a href="#字符串数据在C中的存储方式：" class="headerlink" title="字符串数据在C中的存储方式："></a>字符串数据在C中的存储方式：</h3><p>内存中的五大区域：</p>
<ol>
<li>栈：是专门用来存储局部变量的，所有的局部变量都是声明在栈区域中</li>
<li>堆：允许程序员手动的从堆申请指定字节数的空间来使用</li>
<li>BSS段：是用来存储未初始化的全局变量和静态变量，声明一个全局变量，如果我们没有初始化，在程序运行最开始的时候，这个全局变量是没有初始化的，存储在BSS段【程序运行后系统就自动的初始化为0，并把初始化后的全局变量存储在数据段中】</li>
<li>数据段/常量区：用来存储已经初始化的全局变量、静态变量和常量数据</li>
<li>代码段：用来存储程序的代码/指令</li>
</ol>
<p>字符串数据在C语言中有两种存储方式：</p>
<ol>
<li><p>使用字符数组来存储：将字符串数据的每一个字符存储到字符数组中，并追加一个’\0’代表存储结束<br><code>char name[]=“jack”;</code></p>
</li>
<li><p>使用字符指针来存储字符串数据：直接将一个字符串数据初始化给一个字符指针<br><code>char* name =“jack”;</code></p>
</li>
</ol>
<p>1）当它们都是局部变量的时候：</p>
<p>字符数组是申请在栈区，字符串的每一个字符存储在这个字符数组的每一个元素中；<br>指针变量是声明在栈区的，字符串数据是以字符数组的形式存储在常量区的，指针变量中存储的是字符串在常量区的地址<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glffrlt05vj30k30ebdgq.jpg"></p>
<p>2）当它们作为全局变量的时候：</p>
<p>字符数组是存储在常量区的，字符串的每一个字符存储在这个字符数组的每一个元素中；<br>指针变量也是存储在常量区的，字符串数据是以字符数组的形式存储在常量区的，指针变量中存储的是字符串在常量区的地址<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glffruf6mdj30bb0d20tf.jpg"></p>
<p>3）<br>以字符数组的形式存储字符串数据，不管是全局的还是局部的，都可以使用下标去修改字符数组中的每一个元素；<br>以字符指针的形式存储字符串数据，不管是全局的还是局部的，都不能通过指针去修改指向的字符串数据</p>
<p>当我们以字符指针的形式要将字符串数据存储到常量区的时候，并不是直接将字符串存储到常量区，而是先检查常量区中是否有相同内容的字符串，如果有直接将这个字符串的地址拿过来返回，如果没有，才会将这个字符串数据存储在常量区中</p>
<p>当我们重新为字符指针初始化一个字符串的时候，并不是修改原来的字符串，而是重新的创建了一个字符串，把这个新的字符串的地址赋值给它<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glffs2gcrdj30hj0dwmyx.jpg"></p>
<p>几个比较容易混的点：</p>
<ol>
<li><p>这样是可以的，但是不是把“jack”改成了“rose”，而是重新创建了一个“rose”，把“rose”的地址赋值给name<br><code>char *name = &quot;jack&quot;;</code><br><code>name = &quot;rose&quot;;</code></p>
</li>
<li><p>这样是不行的，name是数组名，代表数组的地址，不能为数组名赋值<br><code>char name[]=&quot;jack&quot;;</code><br><code>name = &quot;rose&quot;;</code></p>
</li>
<li><p>这样做是可以的，直接修改数组的元素<br><code>name[0]=&#39;r&#39;;</code><br><code>name[1]=&#39;o&#39;;</code><br><code>name[2]=&#39;s&#39;;</code><br><code>name[3]=&#39;e&#39;;</code><br><code>name[4]=&#39;\0&#39;;</code></p>
</li>
</ol>
<hr>
<h3 id="统计字符串中某一个字符出现的次数："><a href="#统计字符串中某一个字符出现的次数：" class="headerlink" title="统计字符串中某一个字符出现的次数："></a>统计字符串中某一个字符出现的次数：</h3><p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glffsbyo8oj30lt0da75z.jpg"></p>
<hr>
<h3 id="使用字符指针数组来存储多个字符串数据："><a href="#使用字符指针数组来存储多个字符串数据：" class="headerlink" title="使用字符指针数组来存储多个字符串数据："></a>使用字符指针数组来存储多个字符串数据：</h3><p>这是一个一维数组，每一个元素的类型是char指针：<br><code>char* names[4] = &#123;&quot;jack&quot;,&quot;rose&quot;,&quot;lily&quot;,&quot;lilei&quot;&#125;;</code></p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glffskcpb7j30iw0b00u6.jpg"></p>
<hr>
<p>在声明字符数组的同时，如果初始化了部分元素，那么其他的字符会被初始化为’\0’，‘\0’是一个字符，是一个不可见的字符，打印出来啥都没有，这个字符的ASCII码是0</p>
<p>在C语言中字符串数据必须要用双引号引起来</p>
<p>C语言中存储字符串数据：将字符串数据的每一个字符存储到字符数组中，并在后面追加一个’\0’代表字符串存储完毕<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glxi8i55dkj30db05zaap.jpg"></p>
<p>最根本的方式存储字符串：<br><code>char name[5]=&#123;‘j’,’a’,’c’,’k’,’\0’&#125;;</code></p>
<p><code>char name[]=&#123;“jack”&#125;;</code><br>系统会自动的将这个字符串中的每一个字符存储到字符数组中，并自动的追加一个’\0’</p>
<p>最常用的方式：<br><code>char name[]=“jack”;</code></p>
<p>如果我们使用字符数组存储字符串数据的时候，没有指定这个字符数组的长度，那么这个时候这个字符数组的长度为字符串长度+1</p>
<p>我们在使用字符数组存储字符串数据的时候，最好不要指定长度了</p>
<p>如果在声明一个字符数组的同时我们就初始化一个字符数据给这个数组，那么这个时候是可以用中文的【这个字符数组的长度为7，因为一个中文占3个字节】<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glxi8rla1wj3050014jrg.jpg"></p>
<p>使用格式控制符%s就可以输出存储在字符数组中的字符串数据【%s从给定的数组的地址开始，一个字节一个字节的输出，直到遇到’\0’为止】<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glxi91mct2j3092056gm5.jpg"></p>
<p>无需&amp;<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glxi9bfcgxj304n04ijrv.jpg"></p>
<p>使用scanf函数：<br>1）如果用户输入的字符串数据在给定的字符数组中存储不下的时候，就会运行报错<br>2）用户在输入字符串的时候，如果输入了空格，就会认为输入结束</p>
<p>不能使用sizeof去计算字符数组的长度来得到字符串的长度，因为有可能字符串数据存储在字符数组中只占了一部分空间<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glxi9jg8u9j308707xt9x.jpg"><br>解决方法：<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glxi9se9s7j30930bnq4h.jpg"></p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glxia1pfybj30h10c741i.jpg"></p>
<p>字符串常量：<br>“Hello”会被编译器变成一个字符数组放在某处，这个数组的长度是6，结尾还有表示结束的0<br>两个相邻的字符串常量会被自动连接起来</p>
<p>C语言的字符串是以字符数组的形态存在的，不能用运算符对字符串做运算，通过数组的方式可以遍历字符串，唯一特殊的地方是字符串字面量可以用来初始化字符数组</p>
<p><code>char *s=“Hello,world!”;</code><br>s是一个指针，初始化为指向一个字符串常量，由于这个常量所在的地方，所以实际上s是const char *s，但是由于历史的原因，编译器接受不带const的写法，但是试图对s所指的字符串做写入会导致严重的后果<br>如果需要修改字符串，应该用数组：char s[]=“Hello,world!”;<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glxia9htm4j309h0bbt9t.jpg"><br>数组：这个字符串在这里，作为本地变量空间自动被回收<br>指针：这个字符串不知道在哪里，处理参数，动态分配空间</p>
<p>如果要构造一个字符串，用数组<br>如果要处理一个字符串，用指针<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glxiakld2vj30fp0a8tb0.jpg"></p>
<p>在%和s之间的数字表示最多允许读入的字符的数量，这个数字应该比数组的大小小一<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glxiasvnmmj30b708cab2.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glxib200p8j30gr0b2gnl.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glxib903fkj30dc0adt9x.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glxibg4a5qj30pk06kabt.jpg"></p>
<h3 id="stdio-h文件："><a href="#stdio-h文件：" class="headerlink" title="stdio.h文件："></a>stdio.h文件：</h3><p>puts()函数：用来输出字符串的【优点是输出完毕之后自动换行，缺点是只能输出字符串，也不能使用占位符】<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glxibov60sj308c04i0tg.jpg"></p>
<p>fputs()函数：将字符串数据输出到指定的流中【标准输出流：控制台；文件流：磁盘上的文件】<br>输出到标准输出流中：<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glxibzbnetj308v04aaaw.jpg"><br>将字符串存储到文件中：<br>1）要先声明一个文件指针，指向磁盘上的文件【fopen函数可以创建一个指向文件的指针】<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glxicgau45j30cf04ajto.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glxicneawlj30cc036jsu.jpg"><br>2）使用fputs()函数将字符串写入到指定的文件流中<br>3）写完之后一定要记得使用fclose()函数将这个文件关闭<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glxicvtjlej30dr07o0ue.jpg"></p>
<p>gets()函数：从控制台接收用户输入一个字符串数据【优点是当用户输入的数据包含空格的时候，会连空格一起接收；缺点是和scanf函数一样不安全，当用来存储字符串的数据的字符数组的长度不够的时候，程序就会崩溃】<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glxid4nt7oj30cd05rjt7.jpg"></p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glxidd0fioj305d068my6.jpg"></p>
<p>fgets()函数：从指定的流中读取字符串，这个流可以是标准输入流：控制台，也可以是文件流<br>1）从标准输入流中读取数据<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glxidlb0bhj30e701j0tw.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glxidswxpij3094049wfb.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glxidzv4r0j30hr04ptba.jpg"><br>解决方案：<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glxie6ulcrj30aa01e3z8.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glxiednglnj308m0aumzb.jpg"><br>2）从文件流中读取数据<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glxiekzz5jj30dq09xtby.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glxieru4tnj30an03ydgj.jpg"></p>
<h3 id="string-h头文件：strlen-strcmp-strcpy-strcat-strchr-strstr"><a href="#string-h头文件：strlen-strcmp-strcpy-strcat-strchr-strstr" class="headerlink" title="string.h头文件：strlen,strcmp,strcpy,strcat,strchr,strstr"></a>string.h头文件：strlen,strcmp,strcpy,strcat,strchr,strstr</h3><p>strlen:<br><code>size_t strlen(const char *s);</code><br>返回s的字符串长度（不包括结尾的0）<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glxiezump7j30a00a73zm.jpg"></p>
<p>strcmp:<br><code>int strcmp(const char *s1,const char *s2);</code><br>比较两个字符串，返回：<br>0:  s1==s2<br>1:   s1&gt;s2<br>-1:  s1&lt;s2<br><code>int strncmp(const char *s1,const char *s2,size_t n);</code>只比较前几个字符<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glxifahbiyj30fd0grgo7.jpg"></p>
<p>strcpy:【存储字符串1的字符数组长度不够，无法存储字符串2，这个时候运行就会崩溃】<br><code>char *strcpy(char *restrict dst,const char *restrict src);</code><br>把src的字符串拷贝到dst，restrict表明src和dst不重叠<br>返回dst,为了能链起代码来</p>
<p>复制一个字符串：<br><code>char *dst=(char *)malloc(strlen(src)+1);</code><br><code>strcpy(dst,src);</code><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glxigx7as1j30at0f4dh5.jpg"><br>把name2拷贝到name1:<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glxih2cxooj30h107idhj.jpg"></p>
<p>strcat:【接的时候会把第一个字符串后的’\0’干掉】<br><code>char *strcat(char *restrict s1,const char *restrict s2);</code><br>把s2拷贝到s1的后面，接成一个长的字符串<br>返回s1<br>s1必须具有足够的空间</p>
<p>strcpy,strcat不安全！！</p>
<p>安全版本：<br><code>char *strncpy(char *restrict dst,const char *restrict src,size_t n);</code><br><code>char *strncat(char *restrict s1,const char *restrict s2,size_t n);</code></p>
<p>字符串中找字符：<br><code>char *strchr(const char *s,int c);</code><br><code>char *strrchr(const char *s,int c);</code><br>返回NULL表示没有找到<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glxihcb8s7j30b90hmjt5.jpg"></p>
<p>字符串中找字符串：<br><code>char *strstr(const char *s1,const char *s2);</code><br><code>char *strcasestr(const char *s1,const char *s2);</code></p>
]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>指针</title>
    <url>/2018/09/20/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80/%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<hr>
<p>变量的值：存储在变量中的数据叫做变量的值<br>变量的地址：一个变量是由一个或多个字节组成的，组成这个变量的低字节的地址，就是这个变量的地址</p>
<p>变量的地址就叫做指针，指针变量就是专门用来存储地址的变量，专门用来存储另外一个变量的地址，那么我们就说这个指针变量指向了另外一个变量【它自己也有一个地址】，通过指针变量可以间接的访问指针变量指向的另外一个变量</p>
<p><code>int* p1;</code>，代表声明了一个叫做p1的指针变量，这个指针变量的类型是int<em>，这个</em>代表这个变量不是一个普通变量，而是一个专门用来存储地址的指针变量【只能存储int变量的地址】</p>
<p>指针变量初始化只能给他一个地址：<code>int* p1=&amp;num;</code><br><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gn91mcrhboj30ae0bodh3.jpg"></p>
<p>使用指针间接的操作指向的变量：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int num &#x3D; 10;</span><br><span class="line">int* p1&#x3D;&amp;num;</span><br><span class="line">*p1&#x3D;100;  &#x2F;&#x2F;*p1代表指向的变量，也就是num</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运算符&amp;：获得变量的地址，它的操作数必须是变量:<code>int i;printf(“%p”,&amp;i);</code><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glxhj9ui8ij307q09odgd.jpg"></p>
<p>*是一个单目运算符，用来访问指针的值所表示的地址上的变量,可以做右值也可以做左值<br><code>int k=*p;</code><br><code>*p=k+1;</code></p>
<p>指针的一些注意点：</p>
<p>1）【指针+1】并不是在指针地址的基础之上加一个字节的地址，而是在这个指针地址的基础之上加一个单位变量占用的字节数【这个时候p1指向的就是num1】<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glxhg7ivdkj30c90bkq5b.jpg"></p>
<p>2）<em>p++的意思是取出p所指的那个数据，之后再把p移到下一个位置去，</em>的优先级虽然高，但是没有++高，常用于数组类的连续空间操作<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glxhm5m48oj30bb0a0ab0.jpg"></p>
<p>3）<code>int* p1;</code><br>我们声明一个指针变量，如果没有为其初始化，那么这个时候这个指针变量是有值的，这个值是一个垃圾值，，这个时候，这个指针变量就有可能指向了一块随机的空间，像这样的指针我们就叫做野指针【最好给他初始化一下：<code>int *p1=NULL;</code>NULL值代表指针变量不指向内存中的任何地址】</p>
<p>4）多个指针指向同一变量：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gn91xcb2vdj315g0ni0to.jpg"></p>
<p>5）指针分好多类型，但无论指针什么类型，在内存中都是占据着8个字节，指向不同类型的指针是不能直接互相赋值的，这是为了避免用错指针</p>
<p>6）p1指针变量中存储的是num变量的地址，也就是num变量的低字节的地址，这个时候p1指针能操作多少个字节是根据指针的类型来决定的【这就是为什么指针要分类型，还必须跟指向的普通变量的类型一致】<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glxhf08v8wj30b7084taf.jpg"></p>
<p>一级指针和多级指针：</p>
<p>一个指针变量中存储的是一个普通变量的地址，像这样的指针，我们就叫做一级指针<br>一个指针变量中存储的是一个一级指针变量的地址，像这样的指针，我们就叫做二级指针<br><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gn92ltsw2wj31120mcmxz.jpg"></p>
<p>声明多级指针：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gn998qjxb7j30af0icdho.jpg"></p>
<p>一级指针只能存储普通变量的地址，二级指针只能存储一级指针变量的地址</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gn98zgc3j9j318a0rlaby.jpg"></p>
<p>指针与数组：</p>
<p>使用指针来遍历数组：<br>1）<br><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gn99jgtfkfj30fr0c43zp.jpg"><br>2）本方法中不能换成*(arr++)，数组名代表数组的地址，而数组一旦创建，数组的地址就确定了，不能改变，所以我们不能为数组名赋值，不能修改数组名的值，但是可以使用数组名的值<br><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gn99mgl7u2j30aj0c4dgp.jpg"><br>3）此方法跟前两种不一样<br><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gn99qqsj9pj30aj0hl3zt.jpg"></p>
<p>中括弧的本质【数组arr[0]等价于*(arr+0)，操作数组我们虽然使用中括弧下标来操作，实际上内部仍然是使用指针来操作】：<br>指针变量后面可以使用中括弧，在中括弧中写上下标来访问数据：p1[n]完全等价于*(p1+n)<br><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gn99xbws2zj30ar0as3zf.jpg"></p>
<p>函数参数表中的数组实际上是指针,但是可以用数组的运算符[]进行运算</p>
<p>数组变量是特殊的指针：<br>1）数组变量本身表达地址，所以<code>int a[10];int *p=a;</code>无需用&amp;取地址，但是数组的单元表达的是变量，需要用&amp;取地址<br>2）[]运算符可以对数组做，也可以对指针做<br>3）*运算符可以对指针做，也可以对数组做<br>4）数组变量是const的指针，所以不能被赋值：<code>int a[];int * const a;</code></p>
<p>如果一个数组是用来存储指针类型的数据的话，那么这个数组就叫做存储指针的数组：<code>int* arr[3];</code><br><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gn9a4ckuynj30ar0cejsi.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gn9agvrf6oj30l40ee0uo.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gn9b10dl9tj312r0u0jt3.jpg"></p>
<p>指针之间的运算：指针与指针之间只能做减法运算，不能做加乘除运算，可以做比较运算</p>
<p>指针与指针之间可以做减法运算，结果是一个long类型的数据，代表两个指针指向的变量之间相差多少个单位变量<br><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gn9b7tzxtoj30b90a4wfi.jpg"></p>
<p>如果参与减法运算的两个指针不指向同一个数组，先求出两个指针的差/每一个指针变量对应的普通变量占用的字节数<br><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gn9c45qb5jj30820b9q3s.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gn9cb0hgoej30wj0o5gm5.jpg"></p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glxhlrqxiyj309l0ea400.jpg"></p>
<p>指针的比较运算：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gn9cewazj5j30aw0aiq3r.jpg"></p>
<p>指向函数的指针：<br>程序在运行的时候，会将程序加载到内存，程序中的函数肯定存在于内存的代码段中，我们可以声明一个指针，存储这个函数的地址，让这个指针指向这个函数，使用指针来间接的调用函数</p>
<p>一个指向函数的指针，并不是任意的函数都可以指向，要求指向的函数的返回值类型和参数类型必须要与指针的描述一样<br><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gna41zr25bj30ci0cemy8.jpg"><br>函数的名称就代表这个函数的地址：【注意不要在函数名后加小括弧，如果加了小括弧，就代表指向这个函数，拿到这个函数的返回值】</p>
<p>如果指向的函数有参数有返回值，调用的时候有参数就传参，有返回值就接！</p>
]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>指针作为函数的参数、返回值</title>
    <url>/2018/09/21/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80/%E6%8C%87%E9%92%88%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0%E3%80%81%E8%BF%94%E5%9B%9E%E5%80%BC/</url>
    <content><![CDATA[<hr>
<p>指针作为函数的参数：</p>
<p>当我们调用一个函数的时候，如果这个函数的参数是一个指针，那么我们就必须要为这个指针传递一个和指针类型相同的普通变量的地址，这个时候，在函数的内部去访问参数指针指向的变量的时候，其实访问的就是实参变量<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glffo9ym4oj30bc0auwfb.jpg"></p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glffomb06ij30au08j74n.jpg"></p>
<p>下面的程序遇到了一个问题：函数内部只能返回一个数据<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glffpcykhkj30mu0hsac6.jpg"></p>
<p>当函数需要返回多个数据的时候就可以使用指针作为函数的参数</p>
<p>解决方法：使用指针作为函数的参数，让调用者将自己的变量的地址传递到函数的内部，函数的内部通过指针就可以修改实参变量的值<br>1）<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glffpnj5coj30gk0hsac8.jpg"><br>2）<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glffpzfmnaj30l10ihmzz.jpg"></p>
<p>指针作为函数的返回值：</p>
<p>可以返回局部变量的值，但是不能返回局部变量的地址<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glffqcr895j30mt0d7dh7.jpg"></p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glffqobzh0j30gv0880tt.jpg"></p>
<p>如果你就是要返回一个指针，那么你就要保证这个指针指向的空间在函数结束以后仍然存在，那么这个时候，就可以将空间申请在堆区，然后返回堆区的地址【使用完后一定要记得free】<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glffqwsyqoj30b50fwgn1.jpg"></p>
]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>控制流</title>
    <url>/2018/09/25/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80/%E6%8E%A7%E5%88%B6%E6%B5%81/</url>
    <content><![CDATA[<hr>
<h3 id="C选择结构、循环结构整理"><a href="#C选择结构、循环结构整理" class="headerlink" title="C选择结构、循环结构整理"></a>C选择结构、循环结构整理</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1）if-else if-else</span><br><span class="line"></span><br><span class="line">2）switch-case：选择结构</span><br><span class="line"></span><br><span class="line">switch(表达式)&#123;</span><br><span class="line"></span><br><span class="line">    case 值1:</span><br><span class="line">         执行代码;</span><br><span class="line">         break;</span><br><span class="line"></span><br><span class="line">    case 值2:</span><br><span class="line">         执行代码;</span><br><span class="line">         break;</span><br><span class="line"></span><br><span class="line">    case 值3:</span><br><span class="line">         执行代码;</span><br><span class="line">         break;</span><br><span class="line"></span><br><span class="line">    default:</span><br><span class="line">         执行代码;</span><br><span class="line">         break;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">3）while循环</span><br><span class="line"></span><br><span class="line">4）do while循环【当循环体无论如何至少要执行一次的时候使用】</span><br><span class="line"></span><br><span class="line">do&#123;</span><br><span class="line"></span><br><span class="line">    循环体;</span><br><span class="line">&#125;while(条件表达式);</span><br><span class="line"></span><br><span class="line">5）for循环【当循环次数确定的时候，一般使用for循环；当循环次数不确定的时候，一般使用while循环】</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="控制流的一些注意点"><a href="#控制流的一些注意点" class="headerlink" title="控制流的一些注意点"></a>控制流的一些注意点</h3><p>1）小技巧：Xcode中选中要对齐的代码：control+i，就会自动对齐</p>
<p>2）while循环应用场景：</p>
<p>-循环体确定，循环次数也确定<br>-循环体确定，循环的次数不确定，但是循环继续或者结束的条件确定<br>-遍历指定范围的数<br>-找出指定范围中符合特定条件的数<br>-求累加和与平均值<br>-找一堆数中的最大数和最小数<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glxh49zsp4j30ah0fuq4f.jpg"><br>-计数<br>-穷举【一个一个试】<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glxh4kw3e2j30ah0c0wfe.jpg"></p>
<p>3）定义在一个大括弧中的变量，只能在这个大括弧中访问，出了大括弧，CPU立即将变量回收，无法访问到了:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> num=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(num &gt; <span class="number">0</span>)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> age = <span class="number">10</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;age=%d\n&quot;</span>,age);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;age=%d\n&quot;</span>,age);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们可以自定义一个作用域来提前释放一个变量:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;i=%d\n&quot;</span>,i);</span><br><span class="line">&#125;   <span class="comment">//这个时候，i就会在这里释放</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>4）无大括号else的匹配：else总是和最近的那个if匹配</p>
<p>5）if-else与switch-case的区别：前者从头开始遍历，后者直接跳转到符合要求处<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glxh4xnkazj30a60bsdgw.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glxh58mcvwj30a60cw3zv.jpg"></p>
<p>每一个case块后面的break在语法上是可以不写的，break的意思代表立即结束整个switch-case结构，如果case块中没有break，那么就会直接穿透到下一个case中执行代码，直到遇到break才会结束switch结构，或者执行完</p>
<p>如果多个case块的处理逻辑是一样的，那么我们可以利用case穿透简写代码</p>
<p>switch后面的表达式任何类型都是可以的，除了实型</p>
<p>如果case块中要声明变量，那么这个case块就必须要使用大括弧</p>
<p>switch结构只能做等值判断，不能直接做范围判断，并且case后面的数据不能有变量</p>
<p>break的作用：<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glxh5fvmj6j309u0cf3zj.jpg"></p>
<p>6）break和continue的区别：</p>
<p>如果在循环体中遇到了break，就会立即结束当前循环结构，但是还会继续外层循环</p>
<p>continue只能使用在循环体中，如果遇到了continue，会立即结束本次循环，然后回去判断循环条件【注意一下while循环体和for循环体不一样(前者可能包括i++，后者不包括)】</p>
<p>break和continue都只能作用于当前循环体！</p>
<p>一道比较有意思的面试题：<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glxh5o8fj7j309y07g0te.jpg"></p>
<p>7）while和do-while的区别：前者先判断条件后进循环体，后者先进循环体再判断条件</p>
<p>8）for循环中，三个表达式都可以省略，但是分号不能省略；如果第二个表达式省略，那么循环条件默认就是成立的</p>
<p>for循环三个表达式其实可以是任意的C语句：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gotjwcr25nj30e40c2dgf.jpg"></p>
<p>9）goto：可以将CPU的执行跳转到当前函数的别的地方继续执行</p>
<p>当执行到goto语句的时候，CPU就会跳转到指定的标签的地方继续往下执行</p>
<p>goto语句也可以实现循环操作<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gotk2627j4j30bg09tjsd.jpg"></p>
<p>goto可以往前跳，也可以往后跳，但是只能在当前函数中跳</p>
<p>取标签名下面的那一句代码不能是声明变量：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gotk3hqcfrj30cg09tdgu.jpg"></p>
<p>10）break和goto：<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glxh67f0xwj30hz0dstai.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glxh6f018yj30hz0dsjt1.jpg"></p>
]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>数据类型</title>
    <url>/2018/09/28/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<hr>
<h3 id="C数据类型、格式控制符整理"><a href="#C数据类型、格式控制符整理" class="headerlink" title="C数据类型、格式控制符整理"></a>C数据类型、格式控制符整理</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C数据类型：</span><br><span class="line"></span><br><span class="line">1⃣️基本数据类型：</span><br><span class="line">整型：char、short、int、long、long long(C99)</span><br><span class="line">浮点型：float、double、long double(C99)</span><br><span class="line">布尔型：bool(C99)</span><br><span class="line"></span><br><span class="line">1）char：字符类型，一个字节（一个字节&#x3D;八个比特），-128～+127</span><br><span class="line">2）short：短整型，通常为16位，两个字节，-32768～32767</span><br><span class="line">3）int：取值范围取决于具体的机器，通常代表特定机器中整数的自然长度，通常为16位，其取值范围在-2147483648 ～ +2147483647之间，也有用32位表示的int类型</span><br><span class="line">4）long：长整型，四个字节，至少占32位存储单元，在某些机器上int与long类型的长度相同</span><br><span class="line">5）long long：八个字节</span><br><span class="line">6）float类型：取值范围取决于具体的机器，通常是32位，可以存储有效位数不超过7位的小数，取值范围一般在10^(-38)~10^(+38)之间</span><br><span class="line">7）double：双精度浮点型，64位，可以存储有效位数不超过16位的小数</span><br><span class="line"></span><br><span class="line">2⃣️构造类型：数组、结构体、枚举</span><br><span class="line"></span><br><span class="line">3⃣️指针类型</span><br><span class="line"></span><br><span class="line">4⃣️空类型：void</span><br><span class="line"></span><br><span class="line">5⃣️typedef自定义类型</span><br><span class="line"></span><br><span class="line">C格式控制符：不同类型的数据在变量中存储的形式是不一样的，所以在读取变量中的数据的时候，类型不同读取的方式也不同</span><br><span class="line"></span><br><span class="line">%hd：short</span><br><span class="line"></span><br><span class="line">%d：读取int整型，以十进制输出</span><br><span class="line">%o：读取int整型，以八进制输出（一个以0开始的数字字面量是8进制）</span><br><span class="line">%x：读取int整型，以十六进制输出（一个以0x开始的数字字面量是16进制，8进制和16进制只是如何把数字表达为字符串，与内部如何表达数字无关）</span><br><span class="line"></span><br><span class="line">%ld：long</span><br><span class="line">%lld：long long</span><br><span class="line"></span><br><span class="line">%hu：unsigned short</span><br><span class="line">%u：unsigned int</span><br><span class="line">%lu：unsigned long</span><br><span class="line">%llu：unsigned long long</span><br><span class="line"></span><br><span class="line">float和double类型的printf都使用%f或%e，float的scanf使用%f，double的scanf使用%lf</span><br><span class="line"></span><br><span class="line">%c：char类型，表示字符</span><br><span class="line">%s表示字符串</span><br><span class="line"></span><br><span class="line">%p：地址</span><br><span class="line"></span><br><span class="line">%%表示百分号（%）本身</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="数据类型的一些注意点"><a href="#数据类型的一些注意点" class="headerlink" title="数据类型的一些注意点"></a>数据类型的一些注意点</h3><ol>
<li><p>一个C语言程序，无论其大小如何，都是由函数和变量组成的，函数中包含一些语句，以指定所要执行的计算操作；变量则用于存储计算过程中使用的值。main是一个特殊的函数名，每个程序都从main函数的起点开始执行，每个程序都必须在某个位置包含一个main函数；函数之间进行数据交换的一种方法是调用函数向被调用函数提供一个值（称为参数）列表</p>
</li>
<li><p>变量的命名规则：变量名是由字母和数字组成的序列，但其第一个字符必须为字母，下划线“_”被看作是字母，通常用于命名较长的变量名，以提高其可读性。由于库例程的名字通常以下划线开头，因此变量名不要以下划线开头</p>
</li>
<li><p>变量就是内存中开辟的用来存储数据的那块空间，所以变量是用来存储数据的，我们声明一个变量，如果没有为这个变量赋值，这个变量是有值的，这个值是一个随机数、垃圾值</p>
</li>
<li><p>在同一个大括弧中不允许定义多个变量名相同的变量，不同大括弧可以</p>
</li>
<li><p>自动类型转换：当我们为变量赋值的时候，如果赋值的数据的类型和变量的类型不一致，这时候C系统会将赋值的数据的类型转换为变量的类型再赋值</p>
</li>
</ol>
<p>如果某个算术运算符的所有操作数均为整型，则执行整型运算。但是，如果某个算术运算符有一个浮点型操作数和一个整型操作数，则在开始运算之前整型操作数将会被转换为浮点型</p>
<p>强制类型转换：要把一个量强制转换成另一个类型（通常是较小的类型）:<code>(int)10.2</code>，注意这时候的安全性，小的变量不总能表达大的量：<code>(short)32768</code></p>
<p>强制类型转换只是从那个变量计算出了一个新的类型的值，它并不改变那个变量，无论是值还是类型都不改变</p>
<p>强制类型转换的优先级高于四则运算：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">double a&#x3D;1.0;</span><br><span class="line">double b&#x3D;2.0;</span><br><span class="line">int I&#x3D;(int)a&#x2F;b;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li><p>在printf函数的参数中，只能用\n表示换行符，如果用程序的换行代替\n，C编译器将会产生一条错误信息。printf函数永远不会自动换行，这样我们可以多次调用该函数以分阶段得到一个长的输出行。<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glxh214vrcj30lp041aam.jpg"></p>
</li>
<li><p>printf函数并不是C语言本身的一部分，C语言本身并没有定义输入/输出功能。printf仅仅是标准库函数中一个有用的函数而已，这些标准库函数在C语言程序中通常都可以使用。</p>
</li>
<li><p>printf输出inf表示超过范围的浮点数，printf输出nan表示不存在的浮点数</p>
</li>
<li><p>scanf函数是一个阻塞式的函数，当CPU执行到这个函数的时候，CPU的执行就会暂停，不会继续往下执行了，并等待用户输入数据</p>
</li>
<li><p>scanf函数后面不要加\n</p>
</li>
<li><p>如果没有特殊需要，只使用double，现代CPU能直接对double做硬件运算，性能不会比float差，在64位的机器上，数据存储的速度也不比float慢</p>
</li>
<li><p><code>#include&lt;stdbool.h&gt;</code>之后就可以使用bool和true、false了</p>
</li>
<li><p>在C语言中如果我们直接写一个小数，那么这个小数的类型是double类型的，如果我们就是希望这个小数是一个float类型的，那么就在这个小数的后面加一个f/F</p>
</li>
<li><p>char类型的变量中只能存储单个字符，并且这单个字符还要用单引号引起来；如果char类型的变量中存储的字符超过一个，那么它只会保存最后一个字符（char变量中可以存储一个空格，无法存储中文，因为在C语言中，一个中文占3个字节）</p>
</li>
<li><p>字符型变量是用来存储字符常量的变量。将一个字符常量存储到一个字符变量中，实际上是将该字符的ASCII码值（无符号整数）存储到内存单元中。【‘A’——65、‘a’——97、‘0’——48，为char变量赋值的时候可以直接赋值ASCII码】</p>
</li>
<li><p>所有整型都包括signed(带符号)和unsigned(无符号)两种形式，且可以表示无符号常量与十六进制字符常量；</p>
</li>
</ol>
<p>unsigned类型的数总是正值或0，如果char对象占用8位，那么unsigned char类型变量的取值范围为0～255，而signed char类型变量的取值范围则为-128～127（在采用对二的补码的机器上）</p>
<p>如果一个字面量常数想要表达自己是unsigned，可以在后面加U【255U】，用l或L表示long(long)</p>
<p>unsigned的初衷并非扩展数能表达的范围，而是为了做纯二进制运算，主要是为了移位</p>
<ol start="17">
<li>无论是float还是double，默认都只显示小数点后6位(不足的用0补齐，多余六位的只保留六位)<br><code>%.nf</code>：表示显示小数点后n位<br><code>%m.nf</code>：如果变量整体的位数(小数点默认显示n位，无n的默认显示6位，小数点不足6位的在后面补0，大于6位的按6位计算)小于m，不足的地方就会以空格补齐（正数在前面补齐，负数在后面补齐）；如果变量整体的位数大于字符宽，那么实际有多少位就显示多少位(%0mf，不足的地方以0补齐)</li>
</ol>
]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>数组</title>
    <url>/2018/09/24/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80/%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<hr>
<p>局部变量的回收：在大括弧执行完毕之后，定义在这个大括弧中的变量就会被系统立即回收，声明变量的时候，其实是找系统为你从高地址向低地址分配指定字节数的连续空间，当变量回收的时候，其实就是告诉系统变量占用的字节不再使用了，可以分配给别的变量了，变量所占用的字节的数据是不会清空的【垃圾值的由来】</p>
<p>当将全局变量声明出来以后，系统会自动的将全局变量中的数据清零</p>
<p>一维数组：</p>
<p><code>int arr[3];</code>，其中所有的元素具有相同的数据类型，一旦创建，不能改变大小</p>
<p>数组中的元素在内存中是连续依次排列的：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gotkioh0zmj30ji0cwq31.jpg"></p>
<p>遍历数组：<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glxh93cc4nj30a80an751.jpg"></p>
<p>一维数组的初始化：<br>1）使用这种方式初始化，数组的长度就不能使用变量了，但是使用宏可以【也可以干脆直接省略数组中的长度，这样数组的长度就是由大括弧中的数据的个数来决定的】</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int len&#x3D;3;</span><br><span class="line">int arr[len]&#x3D;&#123;10,20,30&#125;;  &#x2F;&#x2F;错误</span><br></pre></td></tr></table></figure>

<p>2）<code>int arr[3]=&#123;10&#125;;</code><br>这个时候数组的第0个元素的值是10，其他的元素的值被自动初始化为0，所以如果我们要将数组中的所有元素全部初始化为0，只需要在大括弧中写一个0就可以了</p>
<p>3）指定下标的初始化，其他的元素的值就自动初始化为0：<br><code>int arr[3]=&#123;[1]=10,[2]=20&#125;;</code></p>
<p>声明一个数组，在内存中从高字节向低字节申请连续的（数组的长度*每个元素的字节数）个字节的空间</p>
<p>数组的元素的本质就是一个普通类型的变量，一个数组就是由多个普通类型的变量联合而成的</p>
<p>C语言的数组名中存储的就是数组的地址！<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glxh9jcmngj30cs0a7t9s.jpg"></p>
<p>数组的大小：<code>sizeof(a)/sizeof(a[0])</code><br>sizeof给出整个数组所占据的内容的大小，单位是字节；sizeof(a[0])给出数组中单个元素的大小，于是相除就得到了数组的单元个数；这样的代码，一旦修改数组中初始的数据，不需要修改遍历的代码</p>
<p>数组的赋值：数组变量本身不能被赋值，要把一个数组的所有元素交给另一个数组，必须采用遍历</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">     b[i]=a[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>二维数组：</p>
<p>二维数组的长度一般认为是元素的个数【行*列】</p>
<p>二维数组的遍历：a[i][j]是一个int，表示第i行第j列上的单元<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glxh9v4el4j307402jdfy.jpg"></p>
<p>二维数组的初始化：</p>
<p>1）<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glxha9wqxbj305s01zwej.jpg"><br>1.列数是必须给出的，行数可以由编译器来数<br>2.每行一个{}，逗号分隔<br>3.最后的逗号可以存在，有古老的传统</p>
<p>2）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[<span class="number">3</span>][<span class="number">4</span>]=&#123;&#123;<span class="number">10</span>&#125;,&#123;<span class="number">20</span>&#125;,&#123;<span class="number">30</span>&#125;&#125;;</span><br><span class="line">a[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">10</span></span><br><span class="line">a[<span class="number">1</span>][<span class="number">0</span>]=<span class="number">20</span></span><br><span class="line">a[<span class="number">2</span>][<span class="number">0</span>]=<span class="number">30</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>其他元素会自动初始化为0<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glxhb8rvt3j30a60a5gmg.jpg"></p>
<p>3）<br><code>int arr[3][4]=&#123;10,20,30,40,50&#125;;</code><br>按照顺序去初始化每一个元素，其他的元素的值就会被自动初始化为0<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glxhbelj0nj30a60a5gmh.jpg"></p>
<p>4）<br><code>int arr[3][4]=&#123;[1]=&#123;10,20,30,40&#125;,[2]=&#123;50,60,70,80&#125;&#125;;</code><br>给指定的行初始化，其他的元素自动初始化为0<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glxhc1anppj30d20a5t9o.jpg"></p>
<p>二维数组从高地址向低地址申请了连续的（行<em>列</em>每一个元素占用的字节）个字节空间</p>
<p>二维数组在内存中仍然是一块连续的空间，并不是一个表格<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glxhcaulzwj307309pq4i.jpg"></p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glxhcl3fthj30h60a13zp.jpg"></p>
<p>求二维数组的长度的方法与一维数组一样：<code>sizeof(arr)/sizeof(arr[0][0]);</code></p>
<p>求二维数组的行数：<code>sizeof(arr)/sizeof(arr[0]);</code></p>
<p>求二维数组的列数：<code>sizeof(arr[0])/sizeof(arr[0][0]);</code></p>
<p>如果函数的参数是一个一维数组，那么我们在传递的时候可以传递二维数组的某一行，二维数组的行其实是一个一维数组</p>
<p>二维数组也可以作为函数的参数【与一维数组类似】，但是其中形参的行数可以省略，列数不能省略，实参与形参的行数可以任意，实参的列数与形参的列数必须一致</p>
<p>解决方案【与一维数组稍微不同！】<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gotl11m25ij30ec0ejta1.jpg"></p>
]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>枚举(enum)</title>
    <url>/2018/09/16/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80/%E6%9E%9A%E4%B8%BE(enum)/</url>
    <content><![CDATA[<hr>
<p>支持新创建一种数据类型，这个数据类型的变量的取值被限定，枚举值的名称都以枚举类型来开头<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gotryrxn87j309u0a2aat.jpg"></p>
<p>每一个枚举值/枚举项都有一个对应的整型的数，默认从0开始，依次的递增【实际上可以手动的赋值】，无论是什么类型的枚举变量，都是占据4个字节，枚举变量中真正存储的是枚举值所对应的整型的数</p>
<p>枚举类型名字通常并不真的使用，要用的是在大括号里的名字，因为它们就是常量符号，它们的类型是int，值依次从0到n<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glxi473xg2j307v09j74z.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glxi4hhd77j30ax0eh40i.jpg"></p>
<p>虽然枚举类型可以当作类型使用，但是实际上很少用</p>
]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>结构体(struct)</title>
    <url>/2018/09/17/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80/%E7%BB%93%E6%9E%84%E4%BD%93(struct)/</url>
    <content><![CDATA[<hr>
<p>我们使用结构体仅仅是创建了一个新的数据类型而已，并没有声明变量，是在指定新的数据类型是由哪些成员组合而成</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct Student&#123;</span><br><span class="line">   char *name;</span><br><span class="line">   int age;</span><br><span class="line">   int score;</span><br><span class="line">   float height;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct Student stu;  &#x2F;&#x2F;代表声明了一个struct Student类型的变量，变量名字叫做stu，这个时候stu才是一个变量，才会在内存中申请空间</span><br></pre></td></tr></table></figure>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glxhvh4495j30h80hotb6.jpg"></p>
<p>结构体初始化：<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glxhv8x83jj30jd09vgn6.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glxhuwh5gkj30ba0b975g.jpg"></p>
<p>结构和数组有点像，数组用[]运算符和下标访问其成员，结构用.运算符和名字访问其成员</p>
<p>匿名结构体：这个结构体类型没有名称，只能在声明结构体的同时就创建变量，不能单独的声明这个结构体类型的变量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct&#123;</span><br><span class="line">   char *barnd;</span><br><span class="line">   char *color;</span><br><span class="line">   int price;</span><br><span class="line">&#125;fengshan1;</span><br></pre></td></tr></table></figure>

<p>声明一个结构体变量，如果没有为这个结构体变量的成员赋值，那么成员是有值的，这个值是一个垃圾值；在声明结构体变量的同时，只要初始化一个成员，其他的成员就会被自动的初始化为0</p>
<p>如果结构体类型是定义在函数的内部的，那么这个结构体类型只能在这个函数的内部使用，如果我们希望这个结构体类型可以用在所有的函数中，那么就把这个结构体类型定义在函数的外面</p>
<p>结构体之间比较：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gogwvleyadj30g90h8myy.jpg"></p>
<p>相同结构体类型的变量之间是可以相互赋值的【值传递】</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct Student xiaoMing&#x3D;&#123;&quot;小明&quot;,19,100&#125;;</span><br><span class="line">struct Student xiaoHua&#x3D;xiaoMing;</span><br></pre></td></tr></table></figure>

<p>结构体数组：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gotrki2rqej30b10i9wg2.jpg"></p>
<p>结构体指针：结构体变量是一个变量，<code>struct Student xiaoMing=&#123;“小明”,18,100&#125;;</code> xiaoMing首先是一个变量，类型是struct Student类型的，既然xiaoMing是一个变量，那么这个变量肯定是有地址的，既然有地址，那么就可以声明一个指针指向这个结构体变量<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glxhx01qhnj30g90e6q4p.jpg"></p>
<p>结构指针：和数组不同，结构变量的名字并不是结构变量的地址，必须使用&amp;运算符<br><code>struct date *pDate=&amp;today;</code><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glxhx9fwlpj30bc08xq3v.jpg"></p>
<p>结构体作为函数参数：<br><code>int numberOfDays(struct date d)</code><br>整个结构可以作为参数的值传入函数<br>这时候是在函数内新建一个结构变量，并复制调用者的结构的值<br>也可以返回一个结构<br>这与数组完全不同<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glxhxkvjyyj30jy0k0jve.jpg"></p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glxhxwivxvj30mv0kbn0u.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glxhy57d7vj30cm0f3dho.jpg"></p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glxhyd0uqtj30mr0jyn0h.jpg"></p>
<p>结构体作为函数的参数【值传递】：<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glxhyx4lttj308d03g750.jpg"></p>
<p>改成指针后就是地址传递了</p>
<p>结构体完全可以作为函数的返回值，在返回的时候，直接将这个结构体变量的值返回即可</p>
<p>如果你要返回结构体变量的地址，那么就要把这个结构体变量创建在堆区：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gnai3lzs2oj30e60c6diw.jpg"></p>
]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>联合(union)</title>
    <url>/2018/09/14/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80/%E8%81%94%E5%90%88(union)/</url>
    <content><![CDATA[<hr>
<p>所有的成员共享一个空间<br>同一时间只有一个成员是有效的<br>union的大小是其最大的成员<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glxi57et9dj309h0a1my5.jpg"></p>
]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>运算符和表达式</title>
    <url>/2018/09/26/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80/%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<hr>
<h3 id="C运算符、优先级整理"><a href="#C运算符、优先级整理" class="headerlink" title="C运算符、优先级整理"></a>C运算符、优先级整理</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C运算符：</span><br><span class="line"></span><br><span class="line">赋值运算符【&#x3D;、+&#x3D;、-&#x3D;、*&#x3D;、&#x2F;&#x3D;、%&#x3D;】</span><br><span class="line">算术运算符【+、-、*、&#x2F;、%】</span><br><span class="line">关系运算符【&#x3D;&#x3D;、!&#x3D;、&gt;、&gt;&#x3D;、&lt;、&lt;&#x3D;】</span><br><span class="line">自增自减运算符【++、—-】</span><br><span class="line">逗号运算符【,】</span><br><span class="line">逻辑运算符【&amp;&amp;(与)、||(或)、！】</span><br><span class="line">取地址运算符【&amp;】</span><br><span class="line"></span><br><span class="line">C优先级：</span><br><span class="line">1）（）：从左到右</span><br><span class="line">2）!  +  -  ++  —：从右到左（单目的+和-）</span><br><span class="line">3）*  &#x2F;  %：从左到右</span><br><span class="line">4）+  -：从左到右</span><br><span class="line">5）&lt;  &lt;&#x3D;  &gt;  &gt;&#x3D;：从左到右</span><br><span class="line">6）&#x3D;&#x3D;  !&#x3D;：从左到右</span><br><span class="line">7）&amp;&amp;：从左到右</span><br><span class="line">8）||：从左到右</span><br><span class="line">9）&#x3D;  +&#x3D;  -&#x3D;  *&#x3D;  &#x2F;&#x3D;  %&#x3D;：从右到左</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="运算符和表达式的一些注意点"><a href="#运算符和表达式的一些注意点" class="headerlink" title="运算符和表达式的一些注意点"></a>运算符和表达式的一些注意点</h3><p>1）逃逸字符：用来表达无法印出来的控制字符或特殊字符，它由一个反斜杠”\”开头，后面跟上另一个字符，这两个字符合起来，组成了一个字符：<code>printf(“请分别输入身高的英尺和英寸，”“如输入\“5 7 \”表示5英尺7英寸：“);</code></p>
<p>\b：回退一格<br>\t：到下一个表格位<br>\n：换行<br>\r：回车<br>\”：双引号<br>\’：单引号<br>\：反斜杠本身</p>
<p>转义符只能是小写字母，每个转义符只能看作一个字符</p>
<p>垂直制表符“\v”和换页符“\f”对屏幕没有任何影响，但会影响打印机执行相应的操作</p>
<p>在C语言程序中，通常会用转义符表示不可打印的字符</p>
<p>2）如果参与算术表达式的操作数的类型不一致，那么这个算术表达式的结果的类型就是范围最大的那个类型</p>
<p>3）m % n的结果一定是在0～（n-1）之间</p>
<p>4）char类型的数据可以参与算术运算，当算术表达式中的操作数是一个char数据的时候，会先将这个char数据的ASCII码取出来代替，然后再参与算术运算，实际上它是一个int类型的数据在参与运算；char数据也可以参与比较运算</p>
<p>5）const是一个修饰符，加在int的前面，用来给这个变量加上一个const（不变的）的属性。这个const的属性表示这个变量的值一旦初始化，就不能再修改了，如果你试图对常量做修改，把它放在赋值运算符的左边，就会被编译器发现，指出为一个错误</p>
<p>6）无论是前自增表达式还是后自增表达式，都是将自身的值增加1<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glxh33jsm1j308l09qt9g.jpg"></p>
<p>7）sizeof是一个运算符，给出某个类型或变量在内存中所占据的字节数：<code>sizeof(int)、sizeof(i)</code></p>
<p>sizeof是静态运算符，它的结果在编译时刻就决定了，不要在sizeof的括号里做运算，这些运算不会做的</p>
<p>8）逻辑运算是对逻辑量进行的运算，结果只有0或1，逻辑量是关系运算或逻辑运算的结果</p>
<p>逻辑非！【!a，如果a是true，结果就是false，如果a是false，结果是true】<br>逻辑与&amp;&amp;【a &amp;&amp; b，如果a和b都是true，结果就是true，否则就是false】<br>逻辑或||【a || b，如果a和b有一个是true，结果为true，两个都是false，结果为false】</p>
<p><code>x&gt;4 &amp;&amp; x&lt;6</code>：像4&lt;x&lt;6这样的式子，不是C能正确计算的式子，因为4&lt;x的结果是一个逻辑值(0或1)</p>
<p>短路：逻辑运算是自左向右进行的，如果左边的结果已经能够决定结果了，就不会做右边的计算；对于&amp;&amp;，左边是false时就不做右边了；对于||，左边是true时就不做右边了</p>
<p>不要把赋值，包括复合赋值组合进表达式！<code>a==6 &amp;&amp; b==1；a==6 &amp;&amp; b+=1</code></p>
<p>9）三元表达式、条件运算符（可以部分代替if else）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">count = (count&gt;<span class="number">20</span>) ? count<span class="number">-10</span> : count+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(count &gt; <span class="number">20</span>)</span><br><span class="line">     count = count<span class="number">-10</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">     count = count+<span class="number">10</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>10）逗号运算符：逗号用来连接两个表达式，并以其右边的表达式的值作为它的结果。逗号的优先级是所有的运算符中最低的，所以它两边的表达式会先计算；逗号的组合关系是自左向右，所以左边的表达式会先计算，而右边的表达式的值就留下来作为逗号运算的结果<br><code>for（i=0，j=10；i&lt;j；i++，j—）</code></p>
<p>逗号表达式的目的并不是想要前面表达式的结果，而只是想要前面的表达式执行，要最后一个表达式的结果<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glxh3kuorlj30as081dgg.jpg"></p>
]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>进制</title>
    <url>/2018/09/13/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80/%E8%BF%9B%E5%88%B6/</url>
    <content><![CDATA[<hr>
<p>C语言可以识别的进制：<br>1）二进制【C语言中如果要写二进制，就加一个0b的前缀】<br>2）八进制【加一个0前缀】<br>3）十进制<br>4）十六进制【加一个0x前缀】</p>
<p>%d：将整型变量中的数据以十进制的形式输出来<br>%o：将整型变量中的数据以八进制的形式输出来<br>%x：将整型变量中的数据以十六进制的形式输出来</p>
<p>数码：指的是这个数据的每一位数字<br>数位：数码在这个数中的位置，从右到左依次递增，从0开始<br>基数：就是进制<br>位权：数码*（基数的数位次方）</p>
<p>进制转换：</p>
<p>1）十进制转换为二进制(除2取余法)：将这个数除以2，直到商为0，然后将余数倒序 【十进制转换为八进制/十六进制类似】</p>
<p>2）二进制转换为十进制(加权法)：将这个二进制的每个数码的位权相加【八进制/十六进制转换为十进制类似】</p>
<p>3）二进制转换为八进制(三合一)：将这个二进制从低位到高位每三个分成一组，高位不够补0，将每一组转换为十进制，将每一组的十进制连起来（二进制转换为十六进制类似）</p>
<p>4）八进制转换为二进制(一拆三)（十六进制转换为二进制类似）</p>
<p>5）八进制—&gt;十六进制；八—&gt;二—&gt;十六</p>
<p>6）十六进制—&gt;八进制：十六—&gt;二—&gt;八</p>
<p>内存中的数据存储单元是由一个一个的二进制位组成的，每一个二进制位只能存储0或者1；把内存中的八个二进制位分为一组，叫做一个字节，作为存储数据的最小基本单元</p>
<p>如果要往内存中存储数据的话，就至少要使用一个字节，这时候一个字节最多可以表示256种数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">单位换算：</span><br><span class="line">1字节(byte)&#x3D;8bit</span><br><span class="line">1KB&#x3D;1024byte</span><br><span class="line">1MB&#x3D;1024KB</span><br><span class="line">1GB&#x3D;1024MB</span><br><span class="line">1TB&#x3D;1024GB</span><br></pre></td></tr></table></figure>

<p>我们在声明变量的时候，并不是去开辟一块空间，而是向系统在内存中申请一块指定字节数的连续的字节空间</p>
<p>char——1个字节<br>int——4个字节<br>float—4个字节<br>double—8个字节</p>
<p>sizeof：计算常量、变量在当前系统上内存中占用的字节数【sizeof(数据类型)、sizeof(变量名)、sizeof(常量) 】</p>
<p>char类型的变量在内存中占据一个字节，char类型的常量在内存中占据四个字节</p>
<p>变量在内存中占据的字节数，会因为系统版本、编译器的不同而发生变化</p>
<p>原码、反码、补码都是二进制，只不过是二进制的不同表现形式，数据是以补码的二进制存储的</p>
<p>int类型的变量，在内存中占据4个字节，32位，为了可以表示正负性，使用最高位来表示正负，最高位为0，表示正，最高位为1，表示负，所以用来表示数据的只有31位，2^31，最小值为-2147483648，最大值为2147483647</p>
<p>原码：最高位表示符号位，剩下的位数是这个数的绝对值的二进制<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glxi69iy5bj307a02ot9e.jpg"></p>
<p>反码：正数的反码就是其原码，负数的反码就是在其原码的基础之上，符号位不变，其他位取反</p>
<p>补码：正数的补码就是其原码，负数的补码就是在其反码的基础上+1</p>
<p>为什么数据要以补码的形式存储呢？因为计算机中只有加法没有减法，为了更加低成本的计算出结果，所以使用补码来存储数据</p>
<p>位运算指的是一个二进制数据的每一位来参与运算，前提是这个数必须是一个二进制</p>
<p>注意：<br>1）参与位运算的二进制数据必须是补码形式<br>2）位运算的结果也是二进制的补码形式</p>
<p>1）按位与(&amp;)：参与按位与的两个二进制数，如果都为1，那么结果就为1，只要有一位为0，那么结果就为0【3 &amp; 2 = 2】</p>
<p>任何数按位与1的结果是这个数的最低位，偶数的最低位一定是0，奇数的最低位一定是1，所以如果要判断这个数是奇数还是偶数，只要用这个数按位与1就可以了，如果结果为1，那么就是奇数，如果结果为0，那么就是偶数</p>
<p>2）按位或(|)：参与按位或的二进制数据，只要有一位是1，那么结果就为1，只有当两位都是0的时候结果才为0</p>
<p>3）按位取反(~)：单目运算符，将这个二进制数的每一位取反</p>
<p>4）按位异或(^)：参与按位异或的二进制的位，相同为0，不同为1</p>
<p>交换两个变量的值可以用异或运算</p>
<p>5）按位左移(&lt;&lt;)：参与按位左移运算的二进制数据，向左移动指定的位数，低位不够补0，高位溢出丢弃【左移运算有可能会改变其正负性；将一个数左移n位，相当于将这个数乘以2的n次方】<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glxi6k91e2j307w02zmxr.jpg"></p>
<p>6）按位右移(&gt;&gt;)：参与按位右移运算的二进制数据，向右移动指定的位数，低位溢出丢弃，高位补符号位【右移运算不会改变其正负性；将一个数右移n位，相当于将这个数除以2的n次方】<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glxi6ste1mj307c03g3zi.jpg"></p>
<p>变量的存储：</p>
<p>变量占用的字节空间一定是连续的，内存中存储数据的最小基本单位是字节，每个字节都有一个独一无二的内存地址，是一个十六进制的数</p>
<p>在为变量分配字节空间的时候，是从高地址向低地址分配的</p>
<p>存储在变量中的数据是以数据的二进制补码形式存储进去的【低位存储在低字节，高位存储在高字节】</p>
<p>变量的地址：</p>
<p>是组成这个变量的低字节的地址，使用&amp;取地址可以取出变量的地址</p>
<p>%p：取地址<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glxi71lgauj30hv0b2dhy.jpg"></p>
<p>声明变量就会占用内存空间，实际上程序在运行的时候，并不是说只有我们的代码才会声明变量，系统自己也会在内存中申请空间存储数据</p>
<p>short int：在内存中占据两个字节【最高位表示符号位，2^15，所以最小值：-32768，最大值：32767】【%hd来输出，%d可能会有问题】</p>
<p>long short：在32位系统下占4个字节，在64位占8个字节【%ld来输出】</p>
<p>long long int：在32位和64位下都占据8个字节【%lld来输出】</p>
<p>unsigned int，2^32，最高位不用来表示符号位了，所以最小值为0【%u来输出】</p>
<p>unsigned short int【%hu来输出】</p>
<p>字符数据在内存中存储的是这个字符所对应的ASCII码的二进制补码【实际上就是一个整数，可以用%d输出】</p>
<p>char变量是一个有符号的，最高位表示符号位</p>
<p>%c读取的时候，先从变量中读取出存储在变量中的整数，然后再去ASCII码表中去查找这个整数对应的字符，再显示这个字符</p>
]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>预处理指令</title>
    <url>/2018/09/11/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80/%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<hr>
<p>C语言的代码主要分为两类：<br>1）C代码<br>2）预处理代码：以#开头的代码</p>
<p>预处理指令的分类：<br>1）文件包含指令：#include<br>2）宏定义：#define【可以将一段C代码定义为一个标识，使用这个标识就可以使用这段代码】<br>3）条件编译指令：#if【只编译指定的C代码为二进制指令】</p>
<p>预处理指令的特点：<br>1）都是以#开头<br>2）预处理指令的后面没有分号</p>
<h3 id="文件包含指令："><a href="#文件包含指令：" class="headerlink" title="文件包含指令："></a>文件包含指令：</h3><p>文件包含指令作用：可以将指定的文件的内容拷贝到写指令的地方<br><code>#include”文件路径”</code><br><code>#include&lt;文件路径&gt;</code></p>
<p>绝对路径：路径从根目录开始<br>相对路径：相对于当前这个文件夹的路径，和当前文件路径相同的部分删除【一般把导入文件放到和main.c相同的文件夹下】</p>
<p><code>#include”文件路径”和#include&lt;文件路径&gt;</code>的寻找指定文件的方式不一样：<br>1）前者先去当前源文件所在的目录中查找这个文件，如果有直接包含，如果没有再去系统自带的编译器目录中查找，如果有直接包含，如果没有报错<br>2）后者直接去编译器目录中查找，如果有包含，没有报错</p>
<h3 id="宏定义："><a href="#宏定义：" class="headerlink" title="宏定义："></a>宏定义：</h3><p>它是一个预处理指令，所以它在编译之前执行，可以将一段C代码定义为一个标识，使用这个标识就可以使用这段代码<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glxijf41hgj308005tdgi.jpg"></p>
<p>宏的原理：在预编译的时候，就会执行源文件中的预处理指令，会将C代码中使用宏名的地方替换为宏值【任意的C代码】，将C代码中的宏名替换为宏值的过程叫做宏替换/宏代换</p>
<p>在定义宏的时候不会去检查语法，只有当完成了宏替换的时候，才会去检查替换以后是否符合语法规范</p>
<p>如果宏值是一个表达式，那么宏值并不是这个表达式的结果，而是这个表达式本身</p>
<p>如果宏值中包括一个变量名，那么在使用这个宏之前必须要保证这个变量已经存在</p>
<p>【默认情况下，宏从定义的地方一直到文件结束都可以使用，#undef 宏名可以让指定的宏提前失效】<br><code>#define N 10</code></p>
<p>只能在中间使用这个宏，#undef N下面宏失效</p>
<p><code>#undef N</code></p>
<p>字符串中如果出现了宏名，系统不会认为这是一个宏，而是认为是字符串的一部分<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glxijrlkunj30i40570tm.jpg"></p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glxik0ojunj308u023jrv.jpg"></p>
<p>如果宏后面跟了分号，那么就会把分号作为宏值的一部分</p>
<p>我们在定义宏的时候，宏名是可以带参数的，在这个宏值中可以直接使用这个参数，如果使用的宏有参数，那么就必须要在使用它的时候为这个宏的参数传值<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glxik7s408j308804njsj.jpg"></p>
<p>宏不是函数，所以宏的参数不需要加类型说明符</p>
<p>为带参数的宏传值的时候，是本色传递，如果传递一个变量，并不是传递这个变量的值<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glxikggxayj308907lmyp.jpg"></p>
<h3 id="条件编译指令："><a href="#条件编译指令：" class="headerlink" title="条件编译指令："></a>条件编译指令：</h3><p>默认的情况下，所有的C代码都会被编译为二进制代码，条件编译指令可以让编译器只编译指定部分的代码</p>
<p>在预编译的时候，如果条件成立，就会将其中的C代码编译成二进制指令，如果条件不成立，就不会将其中的C代码编译成二进制指令【条件只能是宏，不能是变量】<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glxikpk32qj308l0agdhp.jpg"></p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glxikxggnsj30im0auq53.jpg"></p>
<p>If语句无论如何全部都要被编译为二进制指令，条件编译指令只会将符合条件的C代码编译为二进制指令</p>
<p>如果定义了指定的宏，就编译其中的代码<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glxil58iv2j308a08mjte.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glxilbvot6j308a02r3z1.jpg"></p>
<p>无论一个文件被#include多少次，只希望它最终只会被包含一次<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glxilixiwnj308a038jrv.jpg"></p>
<h3 id="static和extern："><a href="#static和extern：" class="headerlink" title="static和extern："></a>static和extern：</h3><p>C语言中的关键字，用来修饰变量和函数</p>
<p>如果局部变量被static修饰，这个变量就叫做静态变量，静态变量不再存储在栈区域，而是存储在常量区，当函数执行完之后，这个静态变量不会被回收，后面再去执行这个函数的时候，声明静态变量的这句话就不会再执行了，直接略过，直接使用这个静态变量的值【静态变量只有一份】<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glxilridhgj30ic0c0tas.jpg"></p>
<p>extern不能修饰局部变量</p>
<p>当我们分模块开发的时候，如果要在模块中声明全局变量，全局变量的声明要写在.h文件中，全局变量的实现要写在.c文件中【如果将全局变量定义在模块中，这个全局变量就必须要使用static或者extern修饰】</p>
<p>如果定义在模块中的全局变量使用extern修饰，这个模块中的全局变量就可以跨模块访问；使用static修饰，这个模块中的全局变量就只能在当前模块中访问</p>
<p>如果函数被extern修饰，那么这个函数可以跨模块调用；如果函数被static修饰，那么这个函数只能在当前模块中调用，无法跨模块调用</p>
<p>如果函数没有写static或者extern，那么这个函数默认就是extern</p>
]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>vi的基本使用：</title>
    <url>/2018/10/22/Apple%E3%80%81Linux/%E3%80%8ALinux%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%A4%A7%E5%85%A8%E3%80%8B/vi%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%EF%BC%9A/</url>
    <content><![CDATA[<hr>
<h2 id="本文目录"><a href="#本文目录" class="headerlink" title="本文目录"></a>本文目录</h2><ol>
<li>使用vi的原因</li>
<li>启动、退出、保存vi</li>
<li>vi的三种工作模式</li>
<li>移动光标</li>
<li>基本编辑 a.撤销命令 b.删除文本 c.剪切、复制和粘贴文本 d.合并行</li>
<li>查找和替换 a.行内搜索 b.搜索整个文件 c.全局搜索和替换</li>
<li>编辑多个文件 a.切换文件 b.载入更多的文件 c.文件之间的内容复制 d.插入整个文件</li>
</ol>
<hr>
<h3 id="使用vi的原因："><a href="#使用vi的原因：" class="headerlink" title="使用vi的原因："></a>使用vi的原因：</h3><ol>
<li>vi总是可用的，如果用户面前的系统没有图形界面，例如是远程服务器或者是本地系统的X配置不可用，那么vi就会成为救命的稻草。POSIX（一种UNIX系统的程序兼容标准）要求系统必须配备有vi</li>
<li>vi是轻量级的软件，运行速度快。对很多任务来说，启动vi比在菜单中找到一个图形界面编辑器并等待几兆大小的编辑器载入要容易的多。另外，vi的设计还非常利于打字</li>
<li>用户不想被其他Linux和UNIX用户蔑视</li>
</ol>
<hr>
<h3 id="启动、退出、保存vi："><a href="#启动、退出、保存vi：" class="headerlink" title="启动、退出、保存vi："></a>启动、退出、保存vi：</h3><p>启动vi：vi 新文件名</p>
<p>退出、保存vi：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">esc</span><br><span class="line">   :w 保存文件但不退出vi</span><br><span class="line">   :w file 将修改另外保存到file中，不退出vi（另存为）【此命令在以新名称保存文件的同时，并不更改编辑中的原文件的名称，当用户继续编辑时，编辑的还是原文件而不是新文件】</span><br><span class="line">   :w! 强制保存，不退出vi</span><br><span class="line">   :wq 保存文件并退出vi</span><br><span class="line">   :wq! 强制保存文件，并退出vi</span><br><span class="line">   :q 不保存文件，退出vi</span><br><span class="line">   :q! 不保存文件，强制退出vi</span><br><span class="line">   :e! 放弃所有修改，从上次保存文件开始再编辑</span><br><span class="line">   命令模式下输入ZZ 保存当前文档并退出vi</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="vi的三种工作模式："><a href="#vi的三种工作模式：" class="headerlink" title="vi的三种工作模式："></a>vi的三种工作模式：</h3><p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glj084wz3ej30h807y0sz.jpg"></p>
<p>如果用户阅读vi的说明文档，会困惑的发现命令模式被称为普通模式，而使用ex命令则被称为命令模式</p>
<hr>
<h3 id="移动光标（命令模式下）："><a href="#移动光标（命令模式下）：" class="headerlink" title="移动光标（命令模式下）："></a>移动光标（命令模式下）：</h3><ol>
<li>l或右方向键：右移一位</li>
<li>h或左方向键：左移一位</li>
<li>j或下方向键：下移一行</li>
<li>k或上方向键：上移一行</li>
<li>数字0：至本文开头</li>
</ol>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glj08m6xkwj30c2090jry.jpg"></p>
<hr>
<h3 id="基本编辑："><a href="#基本编辑：" class="headerlink" title="基本编辑："></a>基本编辑：</h3><p>在命令模式下按u键可以撤销用户多步操作</p>
<p>删除文本（命令模式下）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x：当前字符</span><br><span class="line">3x：当前字符和之后2个字符</span><br></pre></td></tr></table></figure>

<p>剪切(d)、复制(y)和粘贴(p)文本：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">命令d不只是删除文本，而是在剪切文本，用户每次使用d命令之后，都会复制删除的内容进缓存（类似剪贴板），然后用户就可以使用p命令将缓存中的内容粘贴到光标之后或使用P命令将内容粘贴到光标之前</span><br><span class="line"></span><br><span class="line">dd：当前行</span><br><span class="line">5dd：当前行和之后4行</span><br><span class="line">dW：当前字符到下一单词的起始</span><br><span class="line">d$：当前字符到当前行的末尾</span><br><span class="line">d0：当前字符到当前行的起始</span><br><span class="line">d^：当前字符到当前行下一个非空字符</span><br><span class="line">dG：当前行到文件末尾</span><br><span class="line">d20G：当前行到文件第20行</span><br><span class="line"></span><br><span class="line">yy：当前行</span><br><span class="line">5yy：当前行和之后4行</span><br><span class="line">yW：当前字符到下一单词的起始</span><br><span class="line">y$：当前字符到当前行的末尾</span><br><span class="line">Y0：当前字符到当前行的起始</span><br><span class="line">y^：当前字符到当前行下一个非空字符</span><br><span class="line">yG：当前行到文件末尾</span><br><span class="line">y20G：当前行到文件第20行</span><br></pre></td></tr></table></figure>

<p>合并行(J)：vi在行的概念上非常严格，通常来说，将光标移动到行的末端并删除行的末尾字符并不能将此行与下一行合并</p>
<hr>
<h3 id="查找和替换"><a href="#查找和替换" class="headerlink" title="查找和替换:"></a>查找和替换:</h3><p>行内搜索：命令f在行内进行搜索，并将光标移至搜索到的下一个指定字符。比如命令fa就会将光标移动到本行下一处出现字符a的地方，在执行过一次行内搜索之后，输入分号可以使vi重复上一次搜索</p>
<p>搜索整个文件：命令“/”可以完成对单词或短语的搜索，当用户使用“/”命令后，一个“/”符号会出现在屏幕的底部。接下来，输入需要搜索的单词或短语，以Enter结束，光标就会移动到下一处包含被搜索字符串的地方，使用n命令可以重复此搜索</p>
<p>全局搜素和替换：vi使用ex命令来执行几行之内或者整个文件中的搜索和替换操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:%s&#x2F;Line&#x2F;line&#x2F;g</span><br><span class="line">    :冒号用于启动一条ex命令</span><br><span class="line">    %确定了操作作用的范围，%简洁的代表了从文件的第一行到最后一行（还可以用1,2表示从第一行到第二行），如果不明确指出命令的作用范围，那么命令只会在当前行生效</span><br><span class="line">    s指定了具体的操作：替换</span><br><span class="line">    &#x2F;Line&#x2F;line搜索和替换的文本</span><br><span class="line">    g代指global（全局），也就是说对搜索到的每一行的每一个实例进行替换，如果g缺失，那么只替换每一行第一个符合条件的实例</span><br><span class="line">          </span><br><span class="line">在命令末尾添加c，则命令在每次替换之前都会请求用户确认:</span><br><span class="line"></span><br><span class="line">:%s&#x2F;Line&#x2F;line&#x2F;gc</span><br><span class="line">    y：执行替换</span><br><span class="line">    n：跳过此次替换</span><br><span class="line">    a：执行此次替换和之后的所有替换</span><br><span class="line">    q或者ESC：停止替换</span><br><span class="line">    l：执行此次替换并退出替换，是last的缩写</span><br><span class="line">    Ctrl-E，Ctrl-Y：分别是向下滚动和向上滚动，能用于查看替换处的上下文</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="编辑多个文件"><a href="#编辑多个文件" class="headerlink" title="编辑多个文件:"></a>编辑多个文件:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi file1 file2 file3… 打开多个文件</span><br></pre></td></tr></table></figure>

<p>切换文件： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:n下一个文件 :N上一个文件</span><br></pre></td></tr></table></figure>

<p>当用户从一个文件切换到另一个的时候，vi要求用户必须先保存对当前文件做出的修改才能切换到其他文件。若要放弃对文件的修改并使vi强制切换到另一个文件，可在命令后添加感叹号！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:buffers   查看正在编辑的文件列表</span><br><span class="line">:buffer 2  切换到文件2</span><br></pre></td></tr></table></figure>

<p>载入更多的文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:e 文件名【使用此命令载入的文件不会响应:n或:N命令，而需要使用:buffer加文件编号来切换文件】  </span><br></pre></td></tr></table></figure>

<p>文件之间的内容复制：使用之前的复制粘贴命令即可</p>
<p>插入整个文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:r text1  将text1文件内容插入到当前文件光标处</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Apple、Linux</category>
      </categories>
      <tags>
        <tag>《Linux命令行大全》</tag>
      </tags>
  </entry>
  <entry>
    <title>shell是什么：</title>
    <url>/2018/10/31/Apple%E3%80%81Linux/%E3%80%8ALinux%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%A4%A7%E5%85%A8%E3%80%8B/shell%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9A/</url>
    <content><![CDATA[<hr>
<ol>
<li><p>date：显示当前系统的时间和日期<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gm3bx3p0j0j307z00zglk.jpg"></p>
</li>
<li><p>cal ：默认情况下显示当月的日历<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gm3bxw4osaj307z03rt8q.jpg"></p>
</li>
<li><p>df ：查看磁盘驱动器当前的可用空间<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gm3byoge23j30jq07dmxl.jpg"></p>
</li>
<li><p>free ：显示可用内存<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gm3bzieefvj30i401xwei.jpg"></p>
</li>
<li><p>exit ：结束终端会话（或直接关闭终端窗口）</p>
</li>
</ol>
<hr>
<p>（1）shell是一个接收由键盘输入的命令，并将其传递给操作系统来执行的程序 </p>
<p>（2）当使用图形用户界面时，需要另一种叫做终端仿真器的程序与shell进行交互（KDE环境下使用的是konsole,GNOME环境下使用的是gnome-terminal,但是在桌面菜单上很可能将它们简单的统称为终端） </p>
<p>（3）shell提示符：username@machinename,其后是当前工作目录(长度更长一些)和一个$符号；如果shell提示符的最后一个字符是#，而不是一个$符号，那么终端会话将享有超级用户特权<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gm3bofhcxcj307k00mq2v.jpg"></p>
<p>（4）命令历史记录：在默认情况下，大部分Linux发行版本能够存储最近输入的500个命令 </p>
]]></content>
      <categories>
        <category>Apple、Linux</category>
      </categories>
      <tags>
        <tag>《Linux命令行大全》</tag>
      </tags>
  </entry>
  <entry>
    <title>命令的使用：</title>
    <url>/2018/10/29/Apple%E3%80%81Linux/%E3%80%8ALinux%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%A4%A7%E5%85%A8%E3%80%8B/%E5%91%BD%E4%BB%A4%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%9A/</url>
    <content><![CDATA[<hr>
<ol>
<li><p>type命令是一个shell内置命令，可根据指定的命令名显示shell将要执行的命令类型：type command<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gliz92a68kj305b01rt8k.jpg"></p>
</li>
<li><p>which命令可以确定一个给定可执行文件的准确位置<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gliz9a9puyj304g00qwe9.jpg"></p>
</li>
</ol>
<p>which命令只适用于可执行程序，而不适用于内置命令和命令别名（真正可执行程序的替代物），试图在shell内置命令（例如cd）中使用which命令时，要么没响应，要么得到一条错误信息<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gliz9i8dcjj30ab01xjrc.jpg"></p>
<ol start="3">
<li>bash为每一个shell内置命令提供了一个内置的帮助工具，输入help，然后输入shell内置命令的名称即可使用该帮助工具<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gliz9wjbwmj30ah03474i.jpg"></li>
</ol>
<p>注意：出现在命令语法描述中的方括号表示一个可选的选项，竖线符号代表的是两个互斥的选项，这种表示法说明，cd命令后可能有一个-L参数，也可能是-P参数，甚至可以跟参数dir</p>
<ol start="4">
<li></li>
</ol>
<p>–help选项描述了命令支持的语法和选项<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gliza5o59nj30bq04y3ys.jpg"></p>
<ol start="5">
<li>大多数供命令行使用的可执行文件，提供一个称之为manual或者是man page的正式文档，该文档可以用一种称为man的特殊分页程序来查看：man program(这里的program是需要查看的命令名称)</li>
</ol>
<p>man ls:<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gm4f4rykzej30oi0hpjtr.jpg"></p>
<p>在大多数Linux系统中，man命令调用less命令来显示手册文档<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glizaeqfmxj30c60b9gmc.jpg"></p>
<ol start="6">
<li><p>apropos:<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glizamkfw2j30c604xjrp.jpg"></p>
</li>
<li><p>whatis程序显示匹配具体关键字的手册页的名字和一行描述<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glizb17digj306y00ogle.jpg"></p>
</li>
<li><p>GNU项目提供了info页面来代替手册文档，info页面可通过info阅读器来显示，info页面使用超链接，这与网页结构很相似</p>
</li>
</ol>
<p>info ls:<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gm4fe4idw2j30ip0fr0ua.jpg"></p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glizbhxpgbj30ce0aumxy.jpg"></p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glizbp9wptj30ce046aab.jpg"></p>
<ol start="9">
<li>通过alias命令将以上命令整合成一条新的命令【给这条命令起了一个名字foo，现在foo就代表这条命令了】<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glizczjsn1j30ce033t8p.jpg"></li>
</ol>
<p>unalias foo:删除别名<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glizdacld0j307c01dq2q.jpg"></p>
<p>要查看在环境中定义的所有别名，可以使用不带参数的alias命令<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glizdkapwbj30j90cbt96.jpg"></p>
<p>在命令行定义别名还有一个小问题：当shell会话结束时，这些别名也随之消失了</p>
<hr>
<ol>
<li><p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gliyu527coj30b905qaah.jpg"></p>
</li>
<li><p>命令行小技巧：通过使用分号来分隔多条命令，就可以将多条命令输入在一行之中<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glizcoqgh6j30aj027t8l.jpg"></p>
</li>
</ol>
]]></content>
      <categories>
        <category>Apple、Linux</category>
      </categories>
      <tags>
        <tag>《Linux命令行大全》</tag>
      </tags>
  </entry>
  <entry>
    <title>扩展和引用：</title>
    <url>/2018/10/27/Apple%E3%80%81Linux/%E3%80%8ALinux%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%A4%A7%E5%85%A8%E3%80%8B/%E6%89%A9%E5%B1%95%E5%92%8C%E5%BC%95%E7%94%A8%EF%BC%9A/</url>
    <content><![CDATA[<hr>
<p>扩展：每次输入命令行按下Enter键时，bash都会在执行命令之前对文本进行多重处理，产生这个结果的处理过程称为扩展，有了扩展功能，在输入内容后，这些内容将在shell对其执行之前被扩展成其他内容</p>
<p>echo:shell内置命令，把文本参数内容打印到标准输出<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glizlv90o7j30c206kaat.jpg"></p>
<p>路径名扩展：通过使用通配符来实现扩展的机制<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glizmabgl6j30c2076aae.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glizmhqyvqj30bj0833zm.jpg"></p>
<p>波浪线扩展：如果把～用在一个单词的开头，那么它将被扩展为指定用户的主目录名，如果没有指定用户命名，则扩展为当前用户的主目录<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glizmpa600j306p02bmx1.jpg"></p>
<p>算术扩展：shell支持通过扩展来运行算术表达式，这允许我们把shell提示符当作计算器来使用：<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glizn0yi1kj306700pwe9.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glizn83eygj30by0dbjsd.jpg"></p>
<p>花括号扩展：可以按照花括号里面的模式创建多种文本字符串<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gliznh6ye2j30b400ywed.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gliznog9xaj30ch0c5q4c.jpg"></p>
<p>参数扩展：<br>命名为USER的变量包含你的用户名，为了触发参数扩展，并显示出USER的内容：<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glizo60m0lj30ch06b74o.jpg"></p>
<p>命令替换：可以把一个命令的输出作为一个扩展模式使用<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glizoeshhdj30ch0a5my8.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glizommplyj30ch02p0sq.jpg"></p>
<hr>
<p>引用：</p>
<p>在第一个例子中，shell会对echo命令的参数列表进行单词分割，去除多余的空白；在第二个例子中，因为$1是一个未定义的变量，所以参数扩展将把$1的值替换为空字符串<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gm4jbr4pelj30e4020q37.jpg"></p>
<p>shell提供了一种称为引用（quoting）的机制，用来有选择性的避免不想要的扩展</p>
<p>双引号：<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glizp18fyjj30ch06qdgm.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glizp8g70bj30ch0h9q4q.jpg"><br>在第一个例子中，没有加上引号的命令替换将导致命令行被识别为命令后面跟着38个参数；而在第二个例子中加了双引号，使得命令行被识别为命令后面只跟着一个参数，这个参数包含着嵌入空格和换行字符</p>
<p>单引号：<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glizpo276cj30ch044q36.jpg"></p>
<p>转义字符：</p>
<p>有时候我们只是想要引用单个字符，这种情况可以通过在该字符前加上反斜杠来实现，这里的反斜杠称为转义字符，转义字符经常在双引号中用来有选择性的阻止扩展：<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gm4jwvu1dtj30ii01a0sy.jpg"></p>
<p>转义字符也常用来消除文件名中某个字符的特殊含义，比如文件名中可以使用在shell中通常具有特殊含义的字符，这些字符包括“$”、“!”、“&amp;”、空格等</p>
<p>如果想要显示反斜杠字符，可以通过使用两个反斜杠“\”来实现，需要注意的是，单引号中的反斜杠将失去它的特殊含义，而只被当成一个普通字符</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glizq34wvej30bh034mxg.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glizqb1nrij30bh08hjse.jpg"></p>
]]></content>
      <categories>
        <category>Apple、Linux</category>
      </categories>
      <tags>
        <tag>《Linux命令行大全》</tag>
      </tags>
  </entry>
  <entry>
    <title>定制提示符</title>
    <url>/2018/10/21/Apple%E3%80%81Linux/%E3%80%8ALinux%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%A4%A7%E5%85%A8%E3%80%8B/%E5%AE%9A%E5%88%B6%E6%8F%90%E7%A4%BA%E7%AC%A6%EF%BC%9A/</url>
    <content><![CDATA[<hr>
<p>系统的默认提示符：提示符中包含了用户名、主机名和当前的工作目录<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gm6ppfye3kj307d00mq2v.jpg"></p>
<p>提示符是由名为PS1（提示符字符串1）的环境变量定义的，echo命令可以帮助用户看到PS1的值<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glj09b7dqbj30nh010q2x.jpg"></p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glj09ize3cj30bc0b8gm9.jpg"></p>
<p>尝试设计提示符：</p>
<p>备份：<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glj09qkd4rj30gj01dwei.jpg"><br>在终端会话中，用户随时可以通过这个过程的逆操作来复原最初的提示符<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glj09xvqisj304v00zdfn.jpg"></p>
<p>如果提示符为空：那么用户不会得到任何提示<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gm6q28dp1zj308r01zweg.jpg"></p>
<p>将提示符设置成最简略的内容：<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gm6q4a38mvj308r014mx3.jpg"></p>
<p>在提示符中添加了一个铃声，每当系统显示提示符的时候，用户都会听到哔哔声，这在一些情况下可能会很有帮助，比如可以在一个耗时比较长的命令执行完毕时通知用户：<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gm6q8uabxwj308s00njrb.jpg"></p>
<p>包括主机名和当天的时间信息：<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gm6qbaaq4rj308s016748.jpg"></p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gm6qshmbmnj309v014t8o.jpg"></p>
<p>添加颜色：字符颜色是由发送到终端仿真器的一个ANSI转义代码来控制的，该转义代码嵌入到了要显示的字符流中，控制代码不会打印到屏幕上，而是被终端解释为一条指令：<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glj0ackd61j30bc08b0sy.jpg"></p>
<p>创造红色的提示符：但是此时用户输入的所有文字也变成红色了<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gm6r252exbj30ez02174b.jpg"></p>
<p>修复这个问题：<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gm6r50qgefj30hf020jrf.jpg"></p>
<p>设置文本的背景颜色，背景颜色不支持粗体属性：<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glj0ajudgqj30bc024jrc.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glj0apu63vj30bc03odft.jpg"></p>
<p>文本除了正常(0)和粗体(1)属性外，还可以设置为下划线(4)、闪烁(5)和斜体(7)，为了维持好的品味，许多终端仿真器拒绝使用闪烁属性</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glj0aypwkdj30c508yjs2.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glj0b7prflj30c50cywfq.jpg"></p>
]]></content>
      <categories>
        <category>Apple、Linux</category>
      </categories>
      <tags>
        <tag>《Linux命令行大全》</tag>
      </tags>
  </entry>
  <entry>
    <title>导航、Linux系统、操作文件与目录：</title>
    <url>/2018/10/30/Apple%E3%80%81Linux/%E3%80%8ALinux%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%A4%A7%E5%85%A8%E3%80%8B/%E5%AF%BC%E8%88%AA%E3%80%81Linux%E7%B3%BB%E7%BB%9F%E3%80%81%E6%93%8D%E4%BD%9C%E6%96%87%E4%BB%B6%E4%B8%8E%E7%9B%AE%E5%BD%95%EF%BC%9A/</url>
    <content><![CDATA[<hr>
<ol>
<li><p>pwd(打印工作目录)：显示当前工作目录（第一次登录系统时或是启动终端仿真器会话时，当前工作目录被设置成主目录，每个用户账号都有一个主目录，作为普通用户操作时，这是唯一一个允许用户写文件的地方）<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gm3ci6pionj308b014748.jpg"></p>
</li>
<li><p>ls：列出当前工作目录的文件和目录<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gliywyej7aj30fb01fq2s.jpg"></p>
</li>
</ol>
<p>通过ls命令可以查看目录内容，确定各种重要文件和目录的属性</p>
<p>ls 指定目录：列出指定要显示的目录<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gliyxa2amij30jr00zweb.jpg"></p>
<p>ls ~ /usr：列出用户主目录（由符号波浪线表示）和/usr目录的内容<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gliyxjeh5dj30jr030749.jpg"></p>
<p>ls -l：将输出以长格式显示<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gliyxs6llzj30jr0580t6.jpg"></p>
<p>选项和参数：通常，命令后面跟有一个或多个选项，带有不同选项的命令其功能也不一样；此外，命令后面还会跟有一个或多个参数，这些参数是命令作用的对象【command -options arguments】</p>
<p>大部分命令使用的选项是在单个字符前加上连字符，如-l，但是很多命令，包括GNU项目里的命令，也支持在单字前加两个连字符的长选项，而且很多命令也允许多个短选项串在一起使用</p>
<p>ls命令包含了两个选项，l选项产生长格式输出，而t选项则表示以文件修改时间的先后将结果进行排序，加上长选项—reverse，则结果会以相反的顺序输出<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gliyy74i5uj30jr07hwf8.jpg"></p>
<p>ls命令的常用选项<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gliyyo3wyoj30b405kq39.jpg"></p>
<p>下面的例子来自于Ubuntu系统：<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gliyywb97tj30b403574i.jpg"><br>ls长列表字段：<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gliyz85s98j30bb02kdfx.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gliyzg9xhjj30ax030t8q.jpg"></p>
<ol start="3">
<li>cd 目标工作目录的路径名：改变工作目录（即在文件系统树的位置）</li>
</ol>
<p>路径名指的是沿着分枝到达目标目录的路由，路径名分为两种：绝对路径名和相对路径名</p>
<p>绝对路径名：从根目录开始，其后紧接着一个又一个文件树分支，直到到达目标目录或文件</p>
<p>/usr/bin:大多数系统程序都安装在这个目录里【根目录(在路径名中用前导斜杠来表示)中有一个目录是usr,该目录包含一个bin目录】<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gliyzq9lisj30gv09bq3b.jpg"></p>
<p>相对路径名：从工作目录开始，通常使用一些特殊符号来表示文件系统树中的相对位置（“.” ”..”）<br>“.”代表当前工作目录<br>“..”代表当前工作目录的父目录</p>
<p>我们希望把工作目录改变成/usr/bin的父目录/usr<br>1）绝对路径名<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gliz055iztj303202pwea.jpg"><br>2）相对路径名<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gliz0xhmuqj303202p3yb.jpg"></p>
<p>也可以把工作目录从/usr变到/usr/bin<br>1）绝对路径名<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gliz1caukmj304902pjr7.jpg"><br>2）相对路径名<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gliz1mjwjaj304902pglf.jpg"></p>
<p>几乎在所有的情况下都可以省略“./”，因为它是隐含的，一般而言，如果没有指定路径名，则默认为工作目录</p>
<p>cd的一些快捷方式：<br>1）cd：将当前工作目录改变为主目录<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gliz1vo4phj30490260sj.jpg"><br>2）cd -:将工作目录改变成先前的工作目录<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gliz24ja80j30490280sj.jpg"><br>3）cd ~username：将工作目录改变为username的主目录<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gm3d90h274j30ax03et8y.jpg"></p>
<ol start="4">
<li><p>file filename：确定文件的类型<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gliz2fc2haj30ax01ewee.jpg"></p>
</li>
<li><p>less filename：查看文本文件的内容，Q键退出less程序<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gliz2o610oj30jo0daaal.jpg"></p>
</li>
</ol>
<p>less程序最常使用的键盘命令：<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gliz2vyg6kj306e02hwed.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gliz362t6sj30aw03a74a.jpg"></p>
<ol start="6">
<li>符号链接：</li>
</ol>
<p>在浏览过程中，我们可能会看到带有如下条目的目录信息<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gliz3gvurkj30b700f743.jpg"></p>
<p>该条目信息的第一个字母是l，而且看起来像是有两个文件名，这种特殊的文件叫做符号链接（又叫软链接或symlink）</p>
<p>假设，一个程序需要使用包含foo文件中的一个共享资源，但foo版本变化很频繁，这样，在文件名中包含版本号会是一个好主意，因此管理员或其他相关方就能够看到安装了foo的哪个版本，这就出现了一个问题，如果改变了共享资源的名称，就必须跟踪每个可能使用了该共享资源的程序，并且当安装了该资源新的版本后，都要让使用它的程序去寻找新的资源名</p>
<p>假设foo的安装版本是2.6，他的文件名是foo-2.6，然后创建一个符号链接foo指向foo-2.6，这意味着，当一个程序打开foo文件时，它实际上打开的是文件foo-2.6.这样一来皆大欢喜，依赖foo文件的程序能够找到它，并且也能看到实际安装的版本。当需要升级到foo-2.7时，只需将该文件添加到系统里，删除符号链接文件foo，创建一个指向新版本的符号链接即可，这不仅解决了版本升级的问题，也可以将两种版本都保存在机器里。假如foo-2.7存在一个程序错误需要切换到旧的版本，同样，只需要删除指向新版本的符号链接，重新创建指向旧版本的符号链接即可</p>
<p>硬链接：默认情况下，每个文件有一个硬链接，该硬链接会给文件起名字。当创建一个硬链接的时候，也为这个文件创建了一个额外的目录条目<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gliz3ymcjfj30bd01ygli.jpg"></p>
<p>硬链接和文件本身没有什么区别，与包含符号链接的目录列表不同，包含硬链接的目录列表没有特别的链接指示说明。当硬链接被删除时，只是删除了这个链接，但是文件本身的内容依然存在（也就是说，该空间没有释放），除非该文件的所有链接都被删除了</p>
<p>ln file link：创建硬链接</p>
<p>ln -s item link:创建符号链接，这里的item可以是文件也可以是目录</p>
<p>符号链接是通过创建一个特殊类型的文件来起作用的，该文件包含了指向引用文件或目录的文本指针<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gliz3p41z6j30bd02mt8w.jpg"></p>
<ol start="7">
<li><p>由于shell需要经常使用文件名，因此它提供了一些特殊字符来帮助你快速指定一组文件名，这些特殊字符称为通配符，通配符（也叫文件名替换）允许用户依据字符模式选择文件名<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gliz5f1vvwj30b707bmxh.jpg"><br>通配符的使用使得为文件名构建复杂的筛选标准成为可能：<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gliz5oxz1nj30b701hmx1.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gliz5vrasqj30b704eq34.jpg"></p>
</li>
<li><p>mkdir dir1：创建单个dir1目录</p>
</li>
</ol>
<p>mkdir dir1 dir2 dir3：创建3个目录</p>
<ol start="9">
<li>cp：复制文件和目录<br>cp item1 item2：将单个文件或目录item1复制到文件或目录item2中<br>cp item1 . :将item1复制到当前目录<br>cp item… directory：将多个项目（文件或目录）复制进一个目录中</li>
</ol>
<p>需要注意的是，在没有任何警告的情况下，cp命令会覆盖第一次的复制内容（命令一样的情况下）<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gliz6agmv7j30b704pt90.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gliz6ixst5j30b703wmxe.jpg"></p>
<ol start="10">
<li>mv：文件移动和文件重命名（在这两种情况下，完成操作后，原来的文件名将不存在）</li>
</ol>
<p>mv item1 item2:将文件（或目录）item1移动（或重命名）为item2<br>mv item… directory：将一个或多个条目从一个目录移动到另一个目录下<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gliz6s48b9j30b706rjrx.jpg"></p>
<ol start="11">
<li>rm item… ：移除（删除）文件和目录<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gliz71tsn6j30b707wt9k.jpg"></li>
</ol>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gliz79k27mj30b703q74e.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gliz7oyenvj30b703fdfv.jpg"></p>
<hr>
<p>（1）与Windows相同，类UNIX操作系统（Linux）也是以称之为分层目录结构的方式来组织文件的，文件系统的第一个目录叫做根目录，它包含了文件和子目录，子目录里包含了更多的文件和子目录，依此类推</p>
<p>（2）在Windows系统中，每个存储设备都有一个独立的文件系统树。而在类UNIX系统中，无论多少驱动器或存储设备与计算机相连，通常只有一个文件系统树。根据系统管理员的设置，存储设备将会连接（挂载）到文件系统树的不同位置，系统管理员要负责系统的维护 </p>
<p>（3）树通常是倒立显示的，顶部是根目录，依次向下排列的是子目录<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gliysz8hrej306n057wef.jpg"></p>
<p>（4）以“.”字符开头的文件名是隐藏的，这仅说明ls不会列出这些文件，除非输入ls -a,在创建用户账号时，主目录里会放置一些隐藏文件，用来配置账号信息，此外，一些应用程序也会将它们的配置文件和设置文件以隐藏文件的形式放在主目录下面<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gm3ddkhsjfj30dg055dgo.jpg"></p>
<p>（5）与UNIX一样，在Linux中，文件名与命令是区分大小写的 </p>
<p>（6）Linux没有文件扩展名的概念，我们可以按照自己的喜好随意给文件命名，文件的内容或用途由其他方式来决定 </p>
<p>（7）Linux支持长文件名，但是在创建文件名的过程中，仅句号、连字符和下划线是可以使用的，文件名中不要嵌入空格，可以使用下划线 </p>
<p>（8）在Linux系统中找到的目录：<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gliytnrpmfj30b70dmgn1.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gliytw7npwj30b708p3zd.jpg"></p>
<hr>
<p>实战演练：<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gm3ffnt6oqj30eu08yt9e.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gm3ffwsikij30u010adl3.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gm3fg3i45pj30tz121wk1.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gm3fgar2u8j30tu11z44m.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gm3fgqh4uej30u011qwkc.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gm3fgx369gj30qj0vzq9f.jpg"></p>
]]></content>
      <categories>
        <category>Apple、Linux</category>
      </categories>
      <tags>
        <tag>《Linux命令行大全》</tag>
      </tags>
  </entry>
  <entry>
    <title>编写第一个shell脚本：</title>
    <url>/2018/09/30/Apple%E3%80%81Linux/%E3%80%8ALinux%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%A4%A7%E5%85%A8%E3%80%8B/%E7%BC%96%E5%86%99%E7%AC%AC%E4%B8%80%E4%B8%AAshell%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<hr>
<p>shell脚本是一个包含一系列命令的文件，shell读取这个文件，然后执行这些命令，就好像这些命令是直接输入到命令行中一样；shell既是一个强大的命令行接口，也是一个脚本语言解释器，大多数能够在命令行中完成的工作都可以在脚本中完成，反之亦然</p>
<p>为了成功创建和运行一个shell脚本，我们需要做三件事：<br>1）编写脚本：shell脚本是普通的文本文件，所以我们需要一个文本编辑器来编辑它，最好文本编辑器可以提供“语法高亮”功能，从而能够看到脚本元素彩色代码视图，“语法高亮”可以定位一些常见的错误<br>2）使脚本可执行：系统相当严格，它不会将任何老式的文本文件当作程序，所以我们需要将脚本文件的权限设置为允许执行<br>3）将脚本放置在shell能够发现的位置：当没有显式指定路径名时，shell会自动的寻找某些目录，来查找可执行文件，为了最大程度的方便，我们将脚本放置在这些目录下</p>
<p>文本行中，在“#”符号后面的所有内容会被忽略<br>“#!”字符序列是一种特殊的结构，称之为shebang，用来告知操作系统，执行后面的脚本应该使用的解释器的名字，每一个shell脚本都应该将其作为第一行<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gm6shhl6zdj30ft0ea0t7.jpg"></p>
<p>可执行权限：对于脚本，有两种常见的权限设置，权限为755的脚本，每个人都可以执行；权限为700的脚本，只有脚本的所有人才能执行，注意，为了能够执行脚本，它必须是可读的<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gm6sks35a8j30ft05ywfl.jpg"></p>
<p>脚本文件的位置：为了使脚本运行，我们必须显式指定脚本文件的路径<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gm6sou3x6zj30ft016q31.jpg"></p>
<p>如果没有显式指定路径，则系统在查找一个可执行程序时，需要搜索一系列目录，这就是当我们在命令行中输入ls时，系统知道要执行/bin/ls的原因。/bin目录是系统会自动搜索的一个目录。</p>
<p>目录列表存放在名为PATH的环境变量中，这个PATH变量包含一个由冒号分隔开的待搜索目录的列表：<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gm6t443lygj30ft01rmxd.jpg"></p>
<p>如果脚本位于该列表中的任何一个目录中，问题就解决了<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gm6tf9f2tpj30u00y0afg.jpg"></p>
<p>这两个命令一样，为了减少输入，当在命令行中输入选项时，短选项更可取，但是在编写脚本时，长选项名可以提高可读性<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gm6thrjqd3j30ft03f0ta.jpg"></p>
<p>缩进和行连接：<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gm6tmwe2p8j30qc0fwq4e.jpg"></p>
<p>脚本和命令行的一个区别是，脚本可以使用制表符来实现缩进，但在命令行中，Tab键用来激活自动补齐功能</p>
]]></content>
      <categories>
        <category>Apple、Linux</category>
      </categories>
      <tags>
        <tag>《Linux命令行大全》</tag>
      </tags>
  </entry>
  <entry>
    <title>环境：</title>
    <url>/2018/10/23/Apple%E3%80%81Linux/%E3%80%8ALinux%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%A4%A7%E5%85%A8%E3%80%8B/%E7%8E%AF%E5%A2%83%EF%BC%9A/</url>
    <content><![CDATA[<hr>
<p>在shell会话调用环境期间，shell会存储大量的信息，程序使用存储在环境中的数据来确定我们的配置，尽管大多数系统程序使用配置文件来存储程序设置，但是也有一些程序会查找环境中存储的变量来调整自己的行为，用户可以使用环境来自定义shell</p>
<p>尽管shell在环境中存储了两种基本类型的数据，但是在bash中，这两种类型基本上没有区别。这两种数据类型分别是环境变量和shell变量。shell变量是由bash存放的少量数据，环境变量就是除此之外的所有其他变量。除变量之外，shell还存储了一些编程数据，也就是别名和shell函数</p>
<p>set命令会同时显示shell变量和环境变量，而printenv只会显示环境变量<br>printenv | less:<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gm5z95xygfj30m80glmyg.jpg"></p>
<p>命令printenv也能够列出特定变量的值：<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glj04pr6c7j307500zwea.jpg"></p>
<p>在使用set命令时，如果不带选项或参数，那么只会显示shell变量、环境变量以及任何已定义的shell函数，与printenv命令不同的是，set命令的输出结果是按照字母顺序排列的<br>set | less:<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gm5zdx147cj30m80gl754.jpg"></p>
<p>如需要查看单个变量的值，也可以使用echo命令<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glj056qwzjj308e010dfn.jpg"></p>
<p>set命令和printenv命令都不能显示的一个环境元素是别名，要查看别名，需使用不带任何参数的alias命令<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glj05eaok3j30jn04cjro.jpg"></p>
<p>一些有趣的变量：<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glj05lqkhoj30bw0a7751.jpg"></p>
<p>环境是如何建立的：用户登录系统后，bash程序就会启动并读取一系列称为启动文件的配置脚本，这些脚本定义了所有用户共享的默认环境。接下来，bash会读取更多存储在主目录下的用于定义个人环境的启动文件。这些步骤的确切顺序是由启动的shell会话类型决定的</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glj05tdca7j30bw0bpjsh.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glj060i1jmj30bw033glq.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glj067tdq8j30bw0dymyg.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glj06f9b80j30cu0act9p.jpg"></p>
<p>修改环境：<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glj06mhoxsj30c1042aag.jpg"></p>
<p>文本编辑器：<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glj06u80omj30c10b1mys.jpg"></p>
<p>使用文本编辑器配置文件：所有的文本编辑器都可以通过在命令行输入编辑器名称和需编辑的文件名称的方式启动，如果输入的文件不存在，编辑器会认为用户想要创建一个新的文件</p>
<p>扩展名.bak、.sav、.old和.orig是常用的标示备份文件的方法</p>
<p>激活修改：因为只有在启动shell会话时才会读取.bashrc，所以对.bashrc做出的修改只有在关闭shell终端会话并重启的时候才会生效。也可以使用命令强制命令bash重新读取.bashrc文件<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glj07agqqpj30c100gmwy.jpg"></p>
<p>在shell脚本和bash启动文件中，注释是以“#”开头的</p>
]]></content>
      <categories>
        <category>Apple、Linux</category>
      </categories>
      <tags>
        <tag>《Linux命令行大全》</tag>
      </tags>
  </entry>
  <entry>
    <title>软件包管理</title>
    <url>/2018/10/20/Apple%E3%80%81Linux/%E3%80%8ALinux%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%A4%A7%E5%85%A8%E3%80%8B/%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<hr>
<p>决定Linux发行版本质量最重要的因素是软件包系统和支持该发行版本社区的活力<br>软件包管理是一种在系统上安装、维护软件的方法<br>不同的Linux发行版用的是不同的软件包系统，并且原则上适用于一种发行版的软件包与其他版本是不兼容的。多数Linux发行版采用的不外乎两种软件包技术阵营，即Debian的.deb技术和Red Hat的.rpm技术，当然也有一些特例。比如Gentoo，Slackware和Foresight等<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glj0cd1g8dj30b802faa2.jpg"><br>软件包系统工作方式：Linux系统所有软件均可在网上找到，并且多数是以软件包文件的形式由发行商提供，其余则以可手动安装的源代码形式存在<br>1）软件包文件<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glj0clkpy6j30bo01xgln.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glj0csgm6xj30bo02vaaa.jpg"><br>2）库<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glj0czcr9zj30bo07bq3u.jpg"><br>3）依赖关系<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glj0d6c1foj30bo033aab.jpg"><br>4）高级和低级软件包工具：软件包管理系统通常包含两类工具—执行如安装、删除软件包文件等任务的低级工具和进行元数据搜索及提供依赖性解决的高级工具<br>尽管所有Red-Hat系列版本都使用相同的低级工具（rpm），但使用的高级工具却不尽相同<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glj0ddrnj3j30b50220so.jpg"><br>常见软件包管理任务：<br>1）在库里面查找软件包<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glj0dmbq5vj30b502gt8n.jpg"><br>2）安装库中的软件包<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glj0dt2u46j30bh03vwel.jpg"><br>3）安装软件包文件中的软件包<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glj0e0uwm3j30bh06f0t7.jpg"><br>4）删除软件包<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glj0e7pkf5j30a4021t8n.jpg"><br>5）更新库中的软件包<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glj0ef1d32j30bf04pglt.jpg"><br>6）更新软件包文件中的软件包<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glj0em2kusj30bf06q0t5.jpg"><br>7）列出已安装的软件包列表<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glj0etvctzj30bf027mx2.jpg"><br>8）判断软件包是否安装<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glj0eztknsj30bf041q33.jpg"><br>9）显示已安装软件包的相关信息<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glj0f6ycmgj30b704jt8w.jpg"><br>10）查看某具体文件由哪个软件包安装得到<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glj0fcsm3yj30b2022mx3.jpg"></p>
]]></content>
      <categories>
        <category>Apple、Linux</category>
      </categories>
      <tags>
        <tag>《Linux命令行大全》</tag>
      </tags>
  </entry>
  <entry>
    <title>进程：</title>
    <url>/2018/10/24/Apple%E3%80%81Linux/%E3%80%8ALinux%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%A4%A7%E5%85%A8%E3%80%8B/%E8%BF%9B%E7%A8%8B%EF%BC%9A/</url>
    <content><![CDATA[<hr>
<p>现代操作系统通常都支持多重任务处理，多重任务处理是指系统通过快速切换运行中的程序来实现多任务的同时执行，Linux内核通过使用进程来管理多重任务，进程是Linux用来安排不同程序等待CPU调度的一种组织方式</p>
<p>进程如何工作：系统启动时，内核先把它的一些程序初始化为进程，然后运行一个称为init的程序，init程序将依次运行一系列称为脚本初始化的shell脚本(放在/etc目录下)，这些脚本将会启动所有的系统服务，其中的很多服务都是通过守护程序来实现的，而后台程序只是呆在后台做它们自己的事情，并且没有用户界面，因此，即使没有用户登录，系统也在忙于执行一些例行程序</p>
<p>一个程序的运行可以触发其他程序的运行，在进程系统中这种情况被表述为父进程创建子进程</p>
<p>内核会保存每个进程的信息以便确保任务有序进行，比如，每个进程将被分配一个称为进程ID(PID，process ID)的号码。进程ID是按递增的顺序来分配的，init进程的PID始终为1.内核也记录分配给每个进程的内存信息以及用来恢复运行的进程就绪信息。和文件系统类似，进程系统中也存在所有者、用户ID、有效用户ID等</p>
<p>ps命令：查看进程信息（默认情况下，ps命令输出的信息并不是很多，只是输出和当前终端会话相关的进程信息）<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glj0006g2mj307n01twed.jpg"><br>1）TTY是teletype(电传打字机)的缩写，代表了进程的控制终端<br>2）UNIX在这里也显示了进程的运行时间，TIME字段表示了进程消耗的CPU时间总和</p>
<p>添加x选项(注意这里没有前置的连字符)将告知ps命令显示所有的进程，而不需要关注它们是由哪个终端（如果有其他的情况）所控制的。TTY列中出现的“？”表示没有控制终端<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glj007jv3fj30az03kt8s.jpg"></p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glj00gxvimj30by0843zc.jpg"><br>这些进程状态的后面可以带其他的字符来表示不同的特殊进程特性</p>
<p>ps aux：将会显示属于每个用户的进程信息，使用这些选项时不带前置连字符将使得命令以“BSD模式(BSD-style)”运行。ps命令的Linux版本可以模拟多种UNIX版本中ps程序的运行方式：<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glj00nd6mxj30i40gbacd.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glj00vqb5sj30bl03wwen.jpg"></p>
<p>虽然ps命令可以显示有关机器运行情况的很多信息，但是它提供的只是在ps命令被执行时刻机器状态的一个快照。要查看机器运行情况的动态视图，可以使用top命令</p>
<p>top程序将按照进程活动的顺序，以列表的形式持续更新显示系统进程的当前信息（默认每3秒更新一次），它主要用于查看系统“最高（top）”进程的运行情况，top命令显示的内容包含两个部分，顶部显示的是系统总体状态信息，下面显示的是一张按CPU活动时间排序的进程情况表<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glj013xn4ij30ht0fljtm.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glj01c9x5pj30bq08474w.jpg"></p>
<p>top程序可以接受许多键盘指令，其中最常用的有两个：一个是h，输入后将显示程序的帮助界面；另一个是q，用来退出top命令</p>
<p>主流的桌面环境都提供了用来显示类似top命令的输出信息的图形化应用程序，但是top命令优于图形化版本，这是因为top命令运行的更快，而且消耗的系统资源要少得多，毕竟，系统监控程序不应该减缓正在被监控的系统的处理速度</p>
<p>控制进程：</p>
<p>1）中断进程：在终端里按下Ctrl-C键将会中断一个程序，它意味着我们委婉的请求程序结束，许多（但不是所有）命令行程序都可以使用这种方法来实现中断</p>
<p>2）使进程在后台运行：<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glj01tbtp6j30ch0bbdgy.jpg"></p>
<p>3）使进程回到前台运行：<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glj02138isj30ch03bdfv.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glj0290owaj30ch03b0ss.jpg"></p>
<p>4）停止（暂停）进程：<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glj02g73wwj30ch0c5jsu.jpg"></p>
<p>信号：</p>
<p>kill命令通常用来“杀死”（终止）进程，它可以用来终止运行不正常的程序或者反过来拒绝终止的程序<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glj02nvarpj30bz084t9r.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glj02u4h7bj30bz07ldgf.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glj033owauj30bz0gx75z.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glj03ay3q2j30bz0703yx.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glj03hman5j30c306r74n.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glj03oj9q0j30c30493yr.jpg"></p>
]]></content>
      <categories>
        <category>Apple、Linux</category>
      </categories>
      <tags>
        <tag>《Linux命令行大全》</tag>
      </tags>
  </entry>
  <entry>
    <title>高级键盘技巧：</title>
    <url>/2018/10/26/Apple%E3%80%81Linux/%E3%80%8ALinux%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%A4%A7%E5%85%A8%E3%80%8B/%E9%AB%98%E7%BA%A7%E9%94%AE%E7%9B%98%E6%8A%80%E5%B7%A7%EF%BC%9A/</url>
    <content><![CDATA[<hr>
<p>光标移动：<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glizrdb7wkj30b304q74e.jpg"></p>
<p>修改文本：<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glizrkw8gtj30b303njrg.jpg"></p>
<p>剪切和粘贴文本：<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glizruja5cj30c30dbmyw.jpg"></p>
<p>自动补齐功能：在输入命令时，按Tab键将触发自动补齐功能<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glizs2bosij30c30cc3zn.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glizsbamuxj30c3033t8t.jpg"></p>
<p>使用历史命令：bash会保存使用过命令的历史记录，这些命令的历史记录列表保存在用户主目录的.bash_history文件中</p>
<p>搜索历史命令：</p>
<p>history | less：查看历史记录的内容列表<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gm4urxz90fj30ft0dh3ze.jpg"></p>
<p>bash默认会保存用户最近使用过的500个命令，其中500是个默认值</p>
<p>找到用来列出/usr/bin目录下内容的命令：<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gm4uve9539j30ft01sdg0.jpg"></p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gm4uy2xan2j30q60473yw.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glizsxnarkj30cj0hp767.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glizt5h42mj30cj03uq32.jpg"></p>
<p>历史记录扩展：<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gliztcdou8j30cj0d7gn2.jpg"></p>
]]></content>
      <categories>
        <category>Apple、Linux</category>
      </categories>
      <tags>
        <tag>《Linux命令行大全》</tag>
      </tags>
  </entry>
  <entry>
    <title>重定向和管道：</title>
    <url>/2018/10/28/Apple%E3%80%81Linux/%E3%80%8ALinux%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%A4%A7%E5%85%A8%E3%80%8B/%E9%87%8D%E5%AE%9A%E5%90%91%E5%92%8C%E7%AE%A1%E9%81%93%EF%BC%9A/</url>
    <content><![CDATA[<hr>
<p>I/O是输入/输出(input/output)的缩写，I/O重定向可以把命令行的输入重定向为从文件中获取内容，也可以把命令行的输出结果重定向到文件中，如果我们将多个命令行关联起来，将形成非常强大的命令：管道</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glizeqvzxuj30ch08pgmg.jpg"></p>
<p>标准输出重定向：I/O重定向功能可以重新定义标准输出内容发送到哪里，使用重定向操作符“&gt;”，后面接文件名，就可以把标准输出重定向到另一个文件中，而不是显示在屏幕上，主要用于把命令的输出内容保存到一个文件中<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glizf06oqgj306x00f3ya.jpg"></p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glizf87zzbj30bh0apwfs.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glizffquh0j30bh05474q.jpg"></p>
<p>标准错误重定向：<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glizfnc1haj30bh05fmxn.jpg"></p>
<p>将标准输出和标准错误重定向到同一个文件:<br>1）传统的方法，在旧版本的shell中使用<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glizfve3loj30bh04m0t3.jpg"><br>2）在这个例子中，只使用一个标记符“&amp;&gt;”就把标准输出和标准错误都重定向到了文件中<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glizg4zbwxj30bh00ddfm.jpg"></p>
<p>处理不想要的输出：<br>有时候沉默是金，命令执行后我们并不希望得到输出，而是想把这个输出丢弃，尤其是在输出错误和状态信息的情况下更为需要。系统提供了一种方法，即通过把输出重定向到一个称为/dev/null的特殊文件中来实现它，这个文件是一个称为位桶(bit bucket)的系统设备，它接受输入但是不对输入进行任何处理<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glizgdhj5sj30bh00gjr6.jpg"></p>
<p>标准输入重定向：</p>
<p>cat file..：合并文件，读取一个或多个文件，并把它们复制到标准输出文件中<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glizgmcf0lj30bs04l3yu.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glizgz7n3hj30bs02hmx5.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glizhajm28j30bs0dvgmy.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glizhhyxr6j30bs04g0t2.jpg"></p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glizhor315j305k02pdfo.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glizhv5faxj304l01sa9v.jpg"></p>
<hr>
<p>管道:命令从标准输入到读取数据，并将数据发送到标准输出的能力是使用了名为管道的shell特性，使用管道操作符“｜”可以把一个命令的标准输出传送到另一个命令的标准输入中</p>
<p>command | command【标准输出—&gt;标准输入】</p>
<p>通过使用该技术，可以很方便的检查任意一条生成标准输出的命令的运行结果<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glizibiakuj305l00lgld.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gm4h2cgg86j30ip0fr40v.jpg"></p>
<p>过滤器：管道功能经常用来对数据执行复杂的操作，也可以把多条命令合在一起构成一个管道，这种方式中用到的命令通常被称为过滤器(filter)，过滤器接受输入，按照某种方式对输入进行改变，然后再输出它</p>
<p>sort：假设要把/bin和/usr/bin目录下的所有可执行程序合并成一个列表，并且按照顺序排列，最后再查看这个列表<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glizil3clfj307600e3ya.jpg"></p>
<p>uniq：经常和sort命令结合使用，uniq可以接受来自于标准输入或者一个单一文件名参数对应的已排好序的数据列表，默认情况下，该命令删除列表中的所有重复行<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gliziu2la1j30bk02v74d.jpg"></p>
<p>wc(字数统计，word count)：用来显示文件中包含的行数、字数和字节数<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glizj1vf79j30bk03o3yr.jpg"></p>
<p>grep：在文件中查找匹配文本<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glizjbax9lj30n00ihta3.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glizjj2tgmj30bk061aaa.jpg"></p>
<p>head/tail：打印文件的开头部分/结尾部分：<br>head命令将输出文件的前10行，tail命令则输出文件的最后10行，可以通过-n选项来调整输出的行数<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glizjqic2mj30m006tjrx.jpg"></p>
<p>这些命令选项也可以应用在管道中：<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glizk01j1xj306r02mmwz.jpg"></p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glizk6pwcij30c208pab4.jpg"></p>
<p>tee：读取标准输入，再把读到的内容复制到标准输出（允许数据可以继续向下传输到管道中）和一个或更多的文件中去【标准输入—&gt;标准输出】</p>
<p>在使用grep命令过滤管道内容之前，先使用tee命令来获取整个目录列表并输出到ls.txt文件中：<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gm4i5ibpcuj30fg0aoq3m.jpg"></p>
]]></content>
      <categories>
        <category>Apple、Linux</category>
      </categories>
      <tags>
        <tag>《Linux命令行大全》</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift字符串和字符</title>
    <url>/2020/12/27/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/Swift/Swift%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E5%AD%97%E7%AC%A6/</url>
    <content><![CDATA[<h2 id="Swift-字符串"><a href="#Swift-字符串" class="headerlink" title="Swift 字符串"></a>Swift 字符串</h2><p>Swift字符串是一系列字符的集合，它的数据类型为String</p>
<h3 id="创建字符串"><a href="#创建字符串" class="headerlink" title="创建字符串"></a>创建字符串</h3><p>可以通过使用字符串字面量或String类的实例来创建一个字符串</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用字符串字面量</span></span><br><span class="line"><span class="keyword">var</span> stringA = <span class="string">&quot;Hello,World!&quot;</span></span><br><span class="line"><span class="built_in">print</span>(stringA)</span><br><span class="line"></span><br><span class="line"><span class="comment">//String实例化</span></span><br><span class="line"><span class="keyword">var</span> stringB = <span class="type">String</span>(<span class="string">&quot;Hello,World!&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(stringB)</span><br></pre></td></tr></table></figure>

<h3 id="空字符串"><a href="#空字符串" class="headerlink" title="空字符串"></a>空字符串</h3><p>可以使用字符串属性isEmpty来判断字符串是否为空</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gqx0hlqt4rj30fs0l6djg.jpg"></p>
<h3 id="字符串常量"><a href="#字符串常量" class="headerlink" title="字符串常量"></a>字符串常量</h3><p>可以将一个字符串赋值给一个变量或常量，变量是可修改的，常量是不可修改的</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="comment">//变量是可修改的，常量是不可修改的</span></span><br><span class="line"><span class="keyword">var</span> stringA = <span class="string">&quot;hello &quot;</span></span><br><span class="line">stringA += <span class="string">&quot;world&quot;</span></span><br><span class="line"><span class="built_in">print</span>(stringA)</span><br></pre></td></tr></table></figure>

<h3 id="字符串中插入值"><a href="#字符串中插入值" class="headerlink" title="字符串中插入值"></a>字符串中插入值</h3><p>字符串插值是一种构建新字符串的方式，可以在其中包含常量、变量、字面量和表达式。插入的字符串字面量的每一项都在以反斜线为前缀的圆括号中</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> varA = <span class="number">20</span></span><br><span class="line"><span class="keyword">let</span> constA = <span class="number">100</span></span><br><span class="line"><span class="keyword">var</span> varC: <span class="type">Float</span> = <span class="number">20.0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> stringA = <span class="string">&quot;\(varA) 乘以 \(constA) 等于 \(varC * 100)&quot;</span></span><br><span class="line"><span class="built_in">print</span>(stringA)</span><br></pre></td></tr></table></figure>

<h3 id="字符串连接"><a href="#字符串连接" class="headerlink" title="字符串连接"></a>字符串连接</h3><p>字符串可以通过<code>+</code>连接</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> constA = <span class="string">&quot;hello &quot;</span></span><br><span class="line"><span class="keyword">let</span> constB = <span class="string">&quot;world&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> stringA = constA + constB</span><br><span class="line"><span class="built_in">print</span>(stringA)</span><br></pre></td></tr></table></figure>

<h3 id="字符串长度"><a href="#字符串长度" class="headerlink" title="字符串长度"></a>字符串长度</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> varA = <span class="string">&quot;www.baidu.com&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\(varA), 长度为\(varA.count)&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h3><p>可以使用<code>==</code>来比较两个字符串是否相等</p>
<h3 id="Unicode字符串"><a href="#Unicode字符串" class="headerlink" title="Unicode字符串"></a>Unicode字符串</h3><p>Unicode 是一个国际标准，用于文本的编码，Swift 的 String 类型是基于 Unicode建立的。你可以循环迭代出字符串中 UTF-8 与 UTF-16 的编码</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gqx15s0bvmj30ho1120yl.jpg"></p>
<h3 id="字符串函数及运算符"><a href="#字符串函数及运算符" class="headerlink" title="字符串函数及运算符"></a>字符串函数及运算符</h3><table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">函数/运算符 &amp; 描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>isEmpty</strong>  判断字符串是否为空，返回布尔值</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><strong>hasPrefix(prefix: String)</strong>  检查字符串是否拥有特定前缀</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><strong>hasSuffix(suffix: String)</strong>  检查字符串是否拥有特定后缀</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><strong>Int(String)</strong>  转换字符串数字为整型。 实例: <code>let myString: String = &quot;256&quot; let myInt: Int? = Int(myString)</code></td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><strong>String.count</strong>  计算字符串的长度</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><strong>utf8</strong>  您可以通过遍历 String 的 utf8 属性来访问它的 UTF-8 编码</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left"><strong>utf16</strong>  您可以通过遍历 String 的 utf8 属性来访问它的 utf16 编码</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left"><strong>unicodeScalars</strong>  您可以通过遍历String值的unicodeScalars属性来访问它的 Unicode 标量编码</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left"><strong>+</strong>  连接两个字符串，并返回一个新的字符串</td>
</tr>
<tr>
<td align="left">10</td>
<td align="left"><strong>+=</strong>  连接操作符两边的字符串并将新字符串赋值给左边的操作符变量</td>
</tr>
<tr>
<td align="left">11</td>
<td align="left"><strong>==</strong>  判断两个字符串是否相等</td>
</tr>
<tr>
<td align="left">12</td>
<td align="left"><strong>&lt;</strong>  比较两个字符串，对两个字符串的字母逐一比较</td>
</tr>
<tr>
<td align="left">13</td>
<td align="left"><strong>!=</strong>  比较两个字符串是否不相等</td>
</tr>
</tbody></table>
<h2 id="Swift-字符-Character"><a href="#Swift-字符-Character" class="headerlink" title="Swift 字符(Character)"></a>Swift 字符(Character)</h2><p>Swift的字符是一个单一的字符串字面量，数据类型为Character</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果你想在Character类型的常量中存储更多的字符，则程序执行会报错</span></span><br><span class="line"><span class="keyword">let</span> char1: <span class="type">Character</span> = <span class="string">&quot;A&quot;</span></span><br><span class="line"><span class="keyword">let</span> char2: <span class="type">Character</span> = <span class="string">&quot;B&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(char1)</span><br><span class="line"><span class="built_in">print</span>(char2)</span><br></pre></td></tr></table></figure>

<h3 id="空字符变量"><a href="#空字符变量" class="headerlink" title="空字符变量"></a>空字符变量</h3><p>Swift中不能创建空的Character类型变量或常量</p>
<h3 id="遍历字符串中的字符"><a href="#遍历字符串中的字符" class="headerlink" title="遍历字符串中的字符"></a>遍历字符串中的字符</h3><p>Swift 的 String 类型表示特定序列的 Character（字符） 类型值的集合。 每一个字符值代表一个 Unicode 字符</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ch <span class="keyword">in</span> <span class="string">&quot;baidu&quot;</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(ch)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字符串连接字符"><a href="#字符串连接字符" class="headerlink" title="字符串连接字符"></a>字符串连接字符</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> varA: <span class="type">String</span> = <span class="string">&quot;Hello &quot;</span></span><br><span class="line"><span class="keyword">let</span> varB: <span class="type">Character</span> = <span class="string">&quot;G&quot;</span></span><br><span class="line"></span><br><span class="line">varA.append(varB)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(varA)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift函数和闭包</title>
    <url>/2020/12/25/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/Swift/Swift%E5%87%BD%E6%95%B0%E5%92%8C%E9%97%AD%E5%8C%85/</url>
    <content><![CDATA[<h2 id="Swift函数"><a href="#Swift函数" class="headerlink" title="Swift函数"></a>Swift函数</h2><p>Swift函数用来完成特定任务的独立的代码块</p>
<ul>
<li>函数声明：告诉编译器函数的名字、返回类型及参数</li>
<li>函数定义：提供了函数的实体</li>
</ul>
<h3 id="函数定义和调用"><a href="#函数定义和调用" class="headerlink" title="函数定义和调用"></a>函数定义和调用</h3><p>Swift 定义函数使用关键字 <strong>func</strong>。</p>
<p>定义函数的时候，可以指定一个或多个输入参数和一个返回值类型。</p>
<p>每个函数都有一个函数名来描述它的功能。通过函数名以及对应类型的参数值来调用这个函数。函数的参数传递的顺序必须与参数列表相同。</p>
<p>函数的实参传递的顺序必须与形参列表相同，**-&gt;** 后定义函数的返回值类型。</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gqxydhh9ldj30jo0e60ud.jpg"></p>
<h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><p>函数可以接受一个或者多个参数，这些参数被包含在函数的括号中，以逗号分隔</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gqxyjowc6rj30qg0e676g.jpg"></p>
<h3 id="不带参数的函数"><a href="#不带参数的函数" class="headerlink" title="不带参数的函数"></a>不带参数的函数</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gqxyp7yv8xj30dg0e6jsi.jpg"></p>
<h3 id="元组作为函数的返回值"><a href="#元组作为函数的返回值" class="headerlink" title="元组作为函数的返回值"></a>元组作为函数的返回值</h3><p>函数返回值类型可以是字符串，整型，浮点型等。</p>
<p>元组与数组类似，不同的是，元组中的元素可以是任意类型，使用的是圆括号。</p>
<p>你可以用元组（tuple）类型让多个值作为一个复合值从函数中返回。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="comment">//在一个Int数组中找出最小值和最大值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minMax</span><span class="params">(array: [Int])</span></span> -&gt; (<span class="built_in">min</span>: <span class="type">Int</span>, <span class="built_in">max</span>: <span class="type">Int</span>) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> currentMin = array[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">var</span> currentMax = array[<span class="number">0</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> array[<span class="number">1</span>..&lt;array.<span class="built_in">count</span>] &#123;</span><br><span class="line">        <span class="keyword">if</span> value &lt; currentMin &#123;</span><br><span class="line">            currentMin = value</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> value &gt; currentMax &#123;</span><br><span class="line">            currentMax = value</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (currentMin, currentMax)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> bounds = minMax(array: [<span class="number">8</span>, -<span class="number">6</span>, <span class="number">2</span>, <span class="number">109</span>, <span class="number">3</span>, <span class="number">71</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;最小值为 \(bounds.min) ，最大值为 \(bounds.max)&quot;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果你不确定返回的元组一定不为nil，那么你可以返回一个可选的元组类型</span></span><br><span class="line"><span class="comment">//注意：可选元组类型如(Int, Int)?与元组包含可选类型如(Int?, Int?)是不同的.可选的元组类型，整个元组是可选的，而不只是元组中的每个元素值。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//前面的minMax(_:)函数返回了一个包含两个Int值的元组。但是函数不会对传入的数组执行任何安全检查，如果array参数是一个空数组，如上定义的minMax(_:)在试图访问array[0]时会触发一个运行时错误。为了安全地处理这个&quot;空数组&quot;问题，将minMax(_:)函数改写为使用可选元组返回类型，并且当数组为空时返回nil</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minMax</span><span class="params">(array: [Int])</span></span> -&gt; (<span class="built_in">min</span>: <span class="type">Int</span>, <span class="built_in">max</span>: <span class="type">Int</span>)? &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> array.isEmpty &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> currentMin = array[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">var</span> currentMax = array[<span class="number">0</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> array[<span class="number">1</span>..&lt;array.<span class="built_in">count</span>] &#123;</span><br><span class="line">        <span class="keyword">if</span> value &lt; currentMin &#123;</span><br><span class="line">            currentMin = value</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> value &gt; currentMax &#123;</span><br><span class="line">            currentMax = value</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (currentMin, currentMax)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> bounds = minMax(array: [<span class="number">8</span>, -<span class="number">6</span>, <span class="number">2</span>, <span class="number">109</span>, <span class="number">3</span>, <span class="number">71</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;最小值为 \(bounds!.min) ，最大值为 \(bounds!.max)&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="没有返回值的函数"><a href="#没有返回值的函数" class="headerlink" title="没有返回值的函数"></a>没有返回值的函数</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runoob</span><span class="params">(site: String)</span></span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;菜鸟教程官网： \(site)&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">runoob(site: <span class="string">&quot;http://www.runoob.com&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="函数参数名称"><a href="#函数参数名称" class="headerlink" title="函数参数名称"></a>函数参数名称</h3><p>函数参数都有一个外部参数名和一个局部参数名</p>
<h4 id="局部参数名在函数的实现内部使用"><a href="#局部参数名在函数的实现内部使用" class="headerlink" title="局部参数名在函数的实现内部使用"></a>局部参数名在函数的实现内部使用</h4><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gqxzjw8f1rj30i80gejtj.jpg"></p>
<h4 id="外部参数名"><a href="#外部参数名" class="headerlink" title="外部参数名"></a>外部参数名</h4><p>可以在局部参数名前指定外部参数名，中间以空格分隔，外部参数名用于在函数调用时传递给函数的参数。</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gqxzrhryerj30pe0h6goc.jpg"></p>
<h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><p>可变参数可以接受零个或多个值。函数调用时，你可以用可变参数来指定函数参数，其数量是不确定的。可变参数通过在变量类型名后面加入（…）的方式来定义。</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gqxzyhr9mbj30l60kw0vy.jpg"></p>
<h3 id="常量、变量、I-O参数"><a href="#常量、变量、I-O参数" class="headerlink" title="常量、变量、I/O参数"></a>常量、变量、I/O参数</h3><p>一般默认在函数中定义的参数都是常量参数，也就是这个参数你只可以查询使用，不能改变它的值。如果想要声明一个变量参数，可以在参数定义前加 inout 关键字，这样就可以改变这个参数的值了。</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gqy07v0ljfj31as0kgdku.jpg"></p>
<h3 id="函数类型及使用"><a href="#函数类型及使用" class="headerlink" title="函数类型及使用"></a>函数类型及使用</h3><p>每个函数都有种特定的函数类型，由函数的参数类型和返回类型组成</p>
<h4 id="使用函数类型"><a href="#使用函数类型" class="headerlink" title="使用函数类型"></a>使用函数类型</h4><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gqy0g0p7ayj30z60feadc.jpg"></p>
<h3 id="函数类型作为参数类型，函数类型作为返回类型"><a href="#函数类型作为参数类型，函数类型作为返回类型" class="headerlink" title="函数类型作为参数类型，函数类型作为返回类型"></a>函数类型作为参数类型，函数类型作为返回类型</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gqy0nlakyxj30rw0j8n12.jpg"></p>
<h3 id="函数嵌套"><a href="#函数嵌套" class="headerlink" title="函数嵌套"></a>函数嵌套</h3><p>函数嵌套指的是函数内定义一个新的函数，外部的函数可以调用函数内定义的函数。</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gqy2qj7asoj30ra0kgwhx.jpg"></p>
<h2 id="Swift闭包"><a href="#Swift闭包" class="headerlink" title="Swift闭包"></a>Swift闭包</h2><p>闭包是自包含的功能代码块，可以在代码中使用或者用来作为参数传值，全局函数和嵌套函数其实就是特殊的闭包</p>
<p>闭包的形式：</p>
<table>
<thead>
<tr>
<th>全局函数</th>
<th>嵌套函数</th>
<th>闭包表达式</th>
</tr>
</thead>
<tbody><tr>
<td>有名字但不能捕获任何值。</td>
<td>有名字，也能捕获封闭函数内的值。</td>
<td>无名闭包，使用轻量级语法，可以根据上下文环境捕获值。</td>
</tr>
</tbody></table>
<p>Swift中的闭包有很多优化的地方: </p>
<ol>
<li>根据上下文推断参数和返回值类型</li>
<li>从单行表达式闭包中隐式返回（也就是闭包体只有一行代码，可以省略return）</li>
<li>可以使用简化参数名，如$0, $1(从0开始，表示第i个参数…)</li>
<li>提供了尾随闭包语法(Trailing closure syntax)</li>
</ol>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gqy3c1w56bj30ik0k8771.jpg"></p>
<h3 id="闭包表达式"><a href="#闭包表达式" class="headerlink" title="闭包表达式"></a>闭包表达式</h3><p>闭包表达式是一种利用简洁语法构建内联闭包的方式，闭包表达式提供了一些语法优化，使得撰写闭包变的简单明了</p>
<h4 id="sorted-方法"><a href="#sorted-方法" class="headerlink" title="sorted 方法"></a>sorted 方法</h4><ol>
<li><p>Swift 标准库提供了名为 <strong>sorted(by:)</strong> 的方法，会根据您提供的用于排序的闭包函数将已知类型数组中的值进行排序。 排序完成后，sorted(by:) 方法会返回一个与原数组大小相同，包含同类型元素且元素已正确排序的新数组。原数组不会被 sorted(by:) 方法修改。</p>
</li>
<li><p>sorted(by:)方法需要传入两个参数：</p>
</li>
<li><ul>
<li>已知类型的数组</li>
<li>闭包函数，该闭包函数需要传入与数组元素类型相同的两个值，并返回一个布尔类型值来表明当排序结束后传入的第一个参数排在第二个参数前面还是后面。如果第一个参数值出现在第二个参数值前面，排序闭包函数需要返回 <strong>true</strong>，反之返回 <strong>false</strong>。</li>
</ul>
</li>
</ol>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gqy3n6bhjij31na0hqjxq.jpg"></p>
<h3 id="参数名称缩写"><a href="#参数名称缩写" class="headerlink" title="参数名称缩写"></a>参数名称缩写</h3><p>Swift自动为内联函数提供了参数名称缩写功能，可以直接通过<code>$0,$1,$2</code>来顺序调用闭包的参数</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gqy3v0zd98j30lg0eg0uv.jpg"></p>
<h3 id="运算符函数"><a href="#运算符函数" class="headerlink" title="运算符函数"></a>运算符函数</h3><p>Swift 的<code>String</code>类型定义了关于大于号 (<code>&gt;</code>) 的字符串实现，其作为一个函数接受两个<code>String</code>类型的参数并返回<code>Bool</code>类型的值。 而这正好与<code>sort(_:)</code>方法的第二个参数需要的函数类型相符合。 因此，可以简单地传递一个大于号，Swift可以自动推断出您想使用大于号的字符串函数实现</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gqy3yike4nj30lg0egwg7.jpg"></p>
<h3 id="尾随闭包"><a href="#尾随闭包" class="headerlink" title="尾随闭包"></a>尾随闭包</h3><p>尾随闭包是一个书写在函数括号之后的闭包表达式，函数支持将其作为最后一个参数调用</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gqy43w5sm0j30lg0eg0um.jpg"></p>
<h3 id="捕获值"><a href="#捕获值" class="headerlink" title="捕获值"></a>捕获值</h3><ol>
<li><p>闭包可以在其定义的上下文中捕获常量或变量。</p>
</li>
<li><p>即使定义这些常量和变量的原域已经不存在，闭包仍然可以在闭包函数体内引用和修改这些值。</p>
</li>
<li><p>Swift最简单的闭包形式是嵌套函数，也就是定义在其他函数的函数体内的函数。 </p>
</li>
<li><p>嵌套函数可以捕获其外部函数所有的参数以及定义的常量和变量。</p>
</li>
</ol>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeIncrementor</span><span class="params">(forIncrement amount: Int)</span></span> -&gt; () -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> runningTotal = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//incrementor函数并没有获取任何参数，但是在函数体内访问了runningTotal和amount变量。这是因为其通过捕获在包含它的函数体内已经存在的runningTotal和amount变量而实现。由于没有修改amount变量，incrementor实际上捕获并存储了该变量的一个副本，而该副本随着incrementor一同被存储。所以我们调用这个函数时会累加</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">incrementor</span><span class="params">()</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        runningTotal += amount</span><br><span class="line">        <span class="keyword">return</span> runningTotal</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> incrementor</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> incrementByTen = makeIncrementor(forIncrement: <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(incrementByTen())  <span class="comment">//返回值为10</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(incrementByTen())  <span class="comment">//返回值为20</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(incrementByTen())  <span class="comment">//返回值为30</span></span><br></pre></td></tr></table></figure>

<h3 id="闭包是引用类型"><a href="#闭包是引用类型" class="headerlink" title="闭包是引用类型"></a>闭包是引用类型</h3><ol>
<li><p>上面的例子中，incrementByTen是常量，但是这些常量指向的闭包仍然可以增加其捕获的变量值。这是因为函数和闭包都是引用类型。</p>
</li>
<li><p>无论您将函数/闭包赋值给一个常量还是变量，您实际上都是将常量/变量的值设置为对应函数/闭包的引用。 上面的例子中，incrementByTen指向闭包的引用是一个常量，而并非闭包内容本身。这也意味着如果您将闭包赋值给了两个不同的常量/变量，两个值都会指向同一个闭包</p>
</li>
</ol>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeIncrementor</span><span class="params">(forIncrement amount: Int)</span></span> -&gt; () -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> runningTotal = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//incrementor函数并没有获取任何参数，但是在函数体内访问了runningTotal和amount变量。这是因为其通过捕获在包含它的函数体内已经存在的runningTotal和amount变量而实现。由于没有修改amount变量，incrementor实际上捕获并存储了该变量的一个副本，而该副本随着incrementor一同被存储。所以我们调用这个函数时会累加</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">incrementor</span><span class="params">()</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        runningTotal += amount</span><br><span class="line">        <span class="keyword">return</span> runningTotal</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> incrementor</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> incrementByTen = makeIncrementor(forIncrement: <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(incrementByTen())  <span class="comment">//返回值为10</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(incrementByTen())  <span class="comment">//返回值为20</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(incrementByTen())  <span class="comment">//返回值为30</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> alsoIncrementByTen = incrementByTen</span><br><span class="line"><span class="built_in">print</span>(alsoIncrementByTen())  <span class="comment">//返回值也为40</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//这里的值没有发生改变，是因为函数被调用结束就被释放了，没有用一个常量或变量去引用它，相当于每次调用都是一个新的函数</span></span><br><span class="line"><span class="built_in">print</span>(makeIncrementor(forIncrement: <span class="number">20</span>)())  <span class="comment">//结果为20</span></span><br><span class="line"><span class="built_in">print</span>(makeIncrementor(forIncrement: <span class="number">20</span>)())  <span class="comment">//结果为20</span></span><br><span class="line"><span class="built_in">print</span>(makeIncrementor(forIncrement: <span class="number">20</span>)())  <span class="comment">//结果为20</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift枚举和结构体</title>
    <url>/2020/12/24/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/Swift/Swift%E6%9E%9A%E4%B8%BE%E5%92%8C%E7%BB%93%E6%9E%84%E4%BD%93/</url>
    <content><![CDATA[<h2 id="Swift-枚举"><a href="#Swift-枚举" class="headerlink" title="Swift 枚举"></a>Swift 枚举</h2><p>枚举简单的说也是一种数据类型，只不过是这种数据类型只包含自定义的特定数据，它是一组有共同特性的数据的集合</p>
<p>枚举的功能为：</p>
<ul>
<li>它声明在类中，可以通过实例化类来访问它的值。</li>
<li>枚举也可以定义构造函数（initializers）来提供一个初始成员值；可以在原始的实现基础上扩展它们的功能。</li>
<li>可以遵守协议（protocols）来提供标准的功能。</li>
</ul>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义枚举</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">DaysofaWeek</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Sunday</span>  <span class="comment">//case关键词表示一行新的成员值将被定义</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Monday</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">TUESDAY</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">WEDNESDAY</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">THURSDAY</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">FRIDAY</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Saturday</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> weekDay = <span class="type">DaysofaWeek</span>.<span class="type">THURSDAY</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> weekDay &#123;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">case</span> .<span class="type">Sunday</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;星期天&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> .<span class="type">Monday</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;星期一&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> .<span class="type">TUESDAY</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;星期二&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> .<span class="type">WEDNESDAY</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;星期三&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> .<span class="type">THURSDAY</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;星期四&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> .<span class="type">FRIDAY</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;星期五&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> .<span class="type">Saturday</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;星期六&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：和 C 和 Objective-C 不同，Swift 的枚举成员在被创建时不会被赋予一个默认的整型值。在上面的*<code>DaysofaWeek</code><em>例子中，</em><code>Sunday</code><em>，</em><code>Monday</code><em>，</em><code>……</code><em>和</em><code>Saturday</code><em>不会隐式地赋值为</em><code>0</code><em>，</em><code>1</code><em>，</em><code>……</code><em>和</em><code>6</code><em>。相反，这些枚举成员本身就有完备的值，这些值是已经明确定义好的</em><code>DaysofaWeek</code>*类型。</p>
<p>枚举可分为相关值与原始值：</p>
<table>
<thead>
<tr>
<th align="left">相关值</th>
<th align="left">原始值</th>
</tr>
</thead>
<tbody><tr>
<td align="left">不同数据类型</td>
<td align="left">相同数据类型</td>
</tr>
<tr>
<td align="left">实例: enum {10,0.8,”Hello”}</td>
<td align="left">实例: enum {10,35,50}</td>
</tr>
<tr>
<td align="left">值的创建基于常量或变量</td>
<td align="left">预先填充的值</td>
</tr>
<tr>
<td align="left">相关值是当你在创建一个基于枚举成员的新常量或变量时才会被设置，并且每次当你这么做得时候，它的值可以是不同的。</td>
<td align="left">原始值始终是相同的</td>
</tr>
</tbody></table>
<h3 id="相关值"><a href="#相关值" class="headerlink" title="相关值"></a>相关值</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gqy7zaz6thj319u0n4wkk.jpg"></p>
<h3 id="原始值"><a href="#原始值" class="headerlink" title="原始值"></a>原始值</h3><p>原始值可以是字符串，字符，或者任何整型值或浮点型值。每个原始值在它的枚举声明中必须是唯一的。</p>
<p>在原始值为整数的枚举时，不需要显式的为每一个成员赋值，Swift会自动为你赋值。例如，当使用整数作为原始值时，隐式赋值的值依次递增1。如果第一个值没有被赋初值，将会被自动置为0。</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gqy83cuaq2j30ia0n4tbw.jpg"></p>
<h2 id="Swift-结构体"><a href="#Swift-结构体" class="headerlink" title="Swift 结构体"></a>Swift 结构体</h2><p>Swift 结构体是构建代码所用的一种通用且灵活的构造体。我们可以为结构体定义属性（常量、变量）和添加方法，从而扩展结构体的功能。</p>
<p>与 C 和 Objective C 不同的是：</p>
<ul>
<li>结构体不需要包含实现文件和接口。 </li>
<li>结构体允许我们创建一个单一文件，且系统会自动生成面向其它代码的外部接口。 </li>
</ul>
<p>结构体总是通过被复制的方式在代码中传递，因此它的值是不可修改的。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MarkStruct</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> mark1: <span class="type">Int</span> = <span class="number">100</span></span><br><span class="line">    <span class="keyword">var</span> mark2: <span class="type">Int</span> = <span class="number">78</span></span><br><span class="line">    <span class="keyword">var</span> mark3: <span class="type">Int</span> = <span class="number">98</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结构体实例化</span></span><br><span class="line"><span class="keyword">var</span> marks = <span class="type">MarkStruct</span>()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(marks.mark1, marks.mark2, marks.mark3)</span><br></pre></td></tr></table></figure>

<h3 id="结构体应用"><a href="#结构体应用" class="headerlink" title="结构体应用"></a>结构体应用</h3><p>在代码中，你可以使用结构体来定义你的自定义数据类型，结构体实例总是通过值传递来定义你的自定义数据类型</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ReSolution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> width = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> height = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个结构体</span></span><br><span class="line"><span class="keyword">let</span> hd = <span class="type">ReSolution</span>(width: <span class="number">1920</span>, height: <span class="number">1080</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结构体赋值,实际上做的是拷贝操作,cinema和hd结构体在内存中各自占用独立的空间</span></span><br><span class="line"><span class="keyword">var</span> cinema = hd</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改cinema结构体,不会影响hd结构体</span></span><br><span class="line">cinema.width = <span class="number">2048</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;cinema is now \(cinema.width) pixels wide&quot;</span>) <span class="comment">// return:2048</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hd is still \(hd.width) pixels wide&quot;</span>)       <span class="comment">// return:1920</span></span><br></pre></td></tr></table></figure>

<p>与值类型不同，引用类型在被赋予到一个变量、常量或者被传递到一个函数时，操作的并不是其拷贝。因此，引用的是已存在的实例本身而不是其拷贝。类就是引用类型。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ResolutionClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> width = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> height = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(width: <span class="type">Int</span>,height: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.width = width</span><br><span class="line">        <span class="keyword">self</span>.height = height</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个类对象</span></span><br><span class="line"><span class="keyword">let</span> hdClass = <span class="type">ResolutionClass</span>(width: <span class="number">1920</span>, height: <span class="number">1080</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类对象赋值,引用同一个内存空间</span></span><br><span class="line"><span class="keyword">var</span> cinemaClass = hdClass</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改cinema对象,本质上也是修改hdClass对象</span></span><br><span class="line">cinemaClass.width = <span class="number">2048</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;cinemaClass is now \(cinemaClass.width) pixels wide&quot;</span>)  <span class="comment">// return: 2048</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hdClass is also \(hdClass.width) pixels wide&quot;</span>)         <span class="comment">// return: 2048</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift数组和字典</title>
    <url>/2020/12/26/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/Swift/Swift%E6%95%B0%E7%BB%84%E5%92%8C%E5%AD%97%E5%85%B8/</url>
    <content><![CDATA[<h2 id="Swift-数组"><a href="#Swift-数组" class="headerlink" title="Swift 数组"></a>Swift 数组</h2><p>Swift 数组使用有序列表存储同一类型的多个值。相同的值可以多次出现在一个数组的不同位置中。</p>
<p>Swift 数组会强制检测元素的类型，如果类型不同则会报错，Swift 数组应该遵循像Array<Element>这样的形式，其中Element是这个数组中唯一允许存在的数据类型。</p>
<p>如果创建一个数组，并赋值给一个变量，则创建的集合就是可以修改的。这意味着在创建数组后，可以通过添加、删除、修改的方式改变数组里的项目。如果将一个数组赋值给常量，数组就不可更改，并且数组的大小和内容都不可以修改。</p>
<h3 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建了一个类型为Int，数量为3，初始值为0的空数组</span></span><br><span class="line"><span class="keyword">var</span> someInts1 = [<span class="type">Int</span>](repeating: <span class="number">0</span>, <span class="built_in">count</span>: <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> someInts2: [<span class="type">Int</span>] = []</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建了含有三个元素的数组</span></span><br><span class="line"><span class="keyword">var</span> someInts3: [<span class="type">Int</span>] = [<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>]</span><br></pre></td></tr></table></figure>

<h3 id="访问数组"><a href="#访问数组" class="headerlink" title="访问数组"></a>访问数组</h3><p>我们可以根据数组的索引来访问数组的元素，index索引从0开始，即索引0对应第一个元素，索引1对应第二个元素</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建了一个类型为Int，数量为3，初始值为10的空数组</span></span><br><span class="line"><span class="keyword">var</span> someInts = [<span class="type">Int</span>](repeating: <span class="number">10</span>, <span class="built_in">count</span>: <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(someInts[<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(someInts[<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(someInts[<span class="number">2</span>])</span><br></pre></td></tr></table></figure>

<h3 id="修改数组"><a href="#修改数组" class="headerlink" title="修改数组"></a>修改数组</h3><p>你可以使用<code>append()</code>方法或者赋值运算符<code>+=</code>在数组末尾添加元素</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gqx3wkbns0j30e60mmadb.jpg"></p>
<h3 id="遍历数组"><a href="#遍历数组" class="headerlink" title="遍历数组"></a>遍历数组</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gqx44e7p52j30yh0u0wkx.jpg"></p>
<h3 id="合并数组"><a href="#合并数组" class="headerlink" title="合并数组"></a>合并数组</h3><p>可以使用加法操作符（+）来合并两种已存在的相同类型数组。新数组的数据类型会从两个数组的数据类型中推断出来</p>
<p>![image-20210527173142243](/Users/liaojialong/Library/Application Support/typora-user-images/image-20210527173142243.png)</p>
<h3 id="count属性"><a href="#count属性" class="headerlink" title="count属性"></a>count属性</h3><p>可以使用count属性来计算数组元素的个数</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gqx4clhhxkj30ki0ecdhn.jpg"></p>
<h3 id="isEmpty属性"><a href="#isEmpty属性" class="headerlink" title="isEmpty属性"></a>isEmpty属性</h3><p>可以通过只读属性isEmpty来判断数组是否为空，返回布尔值</p>
<h2 id="Swift-字典"><a href="#Swift-字典" class="headerlink" title="Swift 字典"></a>Swift 字典</h2><p>Swift 字典用来存储无序的相同类型数据的集合，Swift 字典会强制检测元素的类型，如果类型不同则会报错。</p>
<p>Swift 字典每个值（value）都关联唯一的键（key），键作为字典中的这个值数据的标识符。</p>
<p>和数组中的数据项不同，字典中的数据项并没有具体顺序。我们在需要通过标识符（键）访问数据的时候使用字典，这种方法很大程度上和我们在现实世界中使用字典查字义的方法一样。</p>
<p>Swift 字典的key没有类型限制可以是整型或字符串，但必须是唯一的。</p>
<p>如果创建一个字典，并赋值给一个变量，则创建的字典就是可以修改的。这意味着在创建字典后，可以通过添加、删除、修改的方式改变字典里的项目。如果将一个字典赋值给常量，字典就不可修改，并且字典的大小和内容都不可以修改</p>
<h3 id="创建字典"><a href="#创建字典" class="headerlink" title="创建字典"></a>创建字典</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个空字典，键的类型为Int，值的类型为String</span></span><br><span class="line"><span class="keyword">var</span> someDict1 = [<span class="type">Int</span>: <span class="type">String</span>]()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> someDict2: [<span class="type">Int</span>: <span class="type">String</span>] = [:]</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> someDict3: [<span class="type">Int</span>: <span class="type">String</span>] = [<span class="number">1</span>: <span class="string">&quot;One&quot;</span>, <span class="number">2</span>: <span class="string">&quot;Two&quot;</span>, <span class="number">3</span>: <span class="string">&quot;Three&quot;</span>]</span><br></pre></td></tr></table></figure>

<h3 id="访问字典"><a href="#访问字典" class="headerlink" title="访问字典"></a>访问字典</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gqxw9bknbij60sm0fq0uz02.jpg"></p>
<h3 id="修改字典"><a href="#修改字典" class="headerlink" title="修改字典"></a>修改字典</h3><p>我们可以使用 <strong>updateValue(forKey: )</strong> 增加或更新字典的内容。如果 key 不存在，则添加值，如果存在则修改 key 对应的值。</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gqxwkuuzp3j30su0iugp2.jpg"></p>
<p>也可以通过指定的key来修改字典的值</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gqxwow9d71j30su0iuq6c.jpg"></p>
<h3 id="移除Key-Value对"><a href="#移除Key-Value对" class="headerlink" title="移除Key-Value对"></a>移除Key-Value对</h3><p>我们可以使用 <strong>removeValueForKey()</strong> 方法来移除字典 key-value 对。如果 key 存在该方法返回移除的值，如果不存在返回 nil </p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gqxwt4l01xj30su0fygoh.jpg"></p>
<p>也可以通过指定键的值为nil来移除key-value对</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gqxwvtn30nj30su0fygo5.jpg"></p>
<h3 id="遍历字典"><a href="#遍历字典" class="headerlink" title="遍历字典"></a>遍历字典</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gqxx2c8mjij30w60o4wjn.jpg"></p>
<h3 id="字典转换为数组"><a href="#字典转换为数组" class="headerlink" title="字典转换为数组"></a>字典转换为数组</h3><p>可以提取字典的键值(key-value)对，并转换为独立的数组</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gqxx8uoz8dj30sq0lmtcj.jpg"></p>
<h3 id="count-属性"><a href="#count-属性" class="headerlink" title="count 属性"></a>count 属性</h3><p>可以使用只读的count属性来计算字典有多少个键值对</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gqxxb8l0bmj30sq0eiq4g.jpg"></p>
<h3 id="isEmpty-属性"><a href="#isEmpty-属性" class="headerlink" title="isEmpty 属性"></a>isEmpty 属性</h3><p>可以通过只读属性 <strong>isEmpty</strong> 来判断字典是否为空，返回布尔值</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gqxxeuvzx5j30sq0eumzi.jpg"></p>
]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift介绍</title>
    <url>/2020/12/31/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/Swift/Swift%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<hr>
<h2 id="Swift介绍"><a href="#Swift介绍" class="headerlink" title="Swift介绍"></a>Swift介绍</h2><p>Swift是一种支持多编程范式和编译式的开源编程语言，苹果于2014年WWDC发布</p>
<p>Swift结合了C和Objective-C的优点并且不受C兼容性的限制</p>
<p>2015年6月8日，苹果于WWDC 2015上宣布，Swift将开放源代码，包括编译器和标准库</p>
<h2 id="Playground"><a href="#Playground" class="headerlink" title="Playground"></a>Playground</h2><p>Swift的playground就像是一个可交互的文档，它是用来练手学Swift的，写一句代码出一行结果，可以实时查看代码的结果，是学习Swift语言的利器</p>
<p>playground创建iOS程序默认代码如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> greeting = <span class="string">&quot;Hello, playground&quot;</span></span><br></pre></td></tr></table></figure>

<p>创建macOS程序默认代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Cocoa</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> greeting = <span class="string">&quot;Hello, playground&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="Swift基本语法"><a href="#Swift基本语法" class="headerlink" title="Swift基本语法"></a>Swift基本语法</h2><h3 id="Swift引入"><a href="#Swift引入" class="headerlink" title="Swift引入"></a>Swift引入</h3><p>我们可以使用 <strong>import</strong> 语句来引入任何的 Objective-C 框架（或 C 库）到 Swift 程序中。例如 <strong>import cocoa</strong> 语句导入了使用了 Cocoa 库和API，我们可以在 Swift 程序中使用他们。Cocoa 本身由 Objective-C 语言写成，Objective-C 又是 C 语言的严格超集，所以在 Swift 应用中我们可以很简单的混入 C 语言代码，甚至是 C++ 代码。</p>
<h3 id="Swift标记"><a href="#Swift标记" class="headerlink" title="Swift标记"></a>Swift标记</h3><p>Swift程序由多种标记组成，标记可以是单词、标识符、常量、字符串或符号</p>
<p><code>print(&quot;test&quot;)</code></p>
<h3 id="Swift注释"><a href="#Swift注释" class="headerlink" title="Swift注释"></a>Swift注释</h3><p>Swift的注释与C语言极其相似，单行注释以两个反斜杠开头</p>
<p>多行注释以<code>/*</code>开始，以<code>*/</code>结束</p>
<p>与C语言的多行注释有所不同的是，Swift的多行注释可以嵌套在其他多行注释内部，多行注释的嵌套使你可以更快捷方便的注释代码块，即使代码块中已经有了注释</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这是一行注释</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 这也是一条注释</span></span><br><span class="line"><span class="comment"> 但跨越多行 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 这是第一个多行注释的开头</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> <span class="comment">/* 这是嵌套的第二个多行注释 */</span></span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> 这是第一个多行注释的结尾 */</span></span><br></pre></td></tr></table></figure>

<h3 id="分号"><a href="#分号" class="headerlink" title="分号"></a>分号</h3><p>与其他语言不同的是，Swift不要求在每行语句的结尾使用分号(;)，但当你在同一行书写多条语句时，必须用分号隔开</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> greeting = <span class="string">&quot;Hello, playground&quot;</span>; <span class="built_in">print</span>(greeting)</span><br></pre></td></tr></table></figure>

<h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><p>标识符就是给变量、常量、方法、函数、枚举、结构体、类、协议等指定的名字</p>
<ul>
<li>Swift语言中标识符的命名规则：<ol>
<li>区分大小写</li>
<li>标识符首字符可以以下划线(_)或者字母开始，但不能是数字</li>
<li>标识符中其他字符可以是下划线、字母或数字</li>
</ol>
</li>
</ul>
<p>如果一定要使用关键字作为标识符，可以在关键字前后添加重音符号(`)</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> `<span class="class"><span class="keyword">class</span>` = &quot;<span class="title">Runoob</span>&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><p>关键字是类似于标识符的保留字符序列，除非用重音符号将其括起来，否则不能用作标识符，关键字是对编译器具有特殊意义的预定义保留标识符</p>
<h4 id="与声明有关的关键字"><a href="#与声明有关的关键字" class="headerlink" title="与声明有关的关键字"></a>与声明有关的关键字</h4><table>
<thead>
<tr>
<th>class</th>
<th>deinit</th>
<th>enum</th>
<th>extension</th>
</tr>
</thead>
<tbody><tr>
<td>func</td>
<td>import</td>
<td>init</td>
<td>internal</td>
</tr>
<tr>
<td>let</td>
<td>operator</td>
<td>private</td>
<td>protocol</td>
</tr>
<tr>
<td>public</td>
<td>static</td>
<td>struct</td>
<td>subscript</td>
</tr>
<tr>
<td>typealias</td>
<td>var</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h4 id="与语句有关的关键字"><a href="#与语句有关的关键字" class="headerlink" title="与语句有关的关键字"></a>与语句有关的关键字</h4><table>
<thead>
<tr>
<th>break</th>
<th>case</th>
<th>continue</th>
<th>default</th>
</tr>
</thead>
<tbody><tr>
<td>do</td>
<td>else</td>
<td>fallthrough</td>
<td>for</td>
</tr>
<tr>
<td>if</td>
<td>in</td>
<td>return</td>
<td>switch</td>
</tr>
<tr>
<td>where</td>
<td>while</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h4 id="表达式和类型关键字"><a href="#表达式和类型关键字" class="headerlink" title="表达式和类型关键字"></a>表达式和类型关键字</h4><table>
<thead>
<tr>
<th>as</th>
<th>dynamicType</th>
<th>false</th>
<th>is</th>
</tr>
</thead>
<tbody><tr>
<td>nil</td>
<td>self</td>
<td>Self</td>
<td>super</td>
</tr>
<tr>
<td>true</td>
<td><code>_COLUMN_</code></td>
<td><code>_FILE_</code></td>
<td><code>_FUNCTION_</code></td>
</tr>
<tr>
<td><code>_LINE_</code></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h4 id="在特定上下文中使用的关键字"><a href="#在特定上下文中使用的关键字" class="headerlink" title="在特定上下文中使用的关键字"></a>在特定上下文中使用的关键字</h4><table>
<thead>
<tr>
<th>associativity</th>
<th>convenience</th>
<th>dynamic</th>
<th>didSet</th>
</tr>
</thead>
<tbody><tr>
<td>final</td>
<td>get</td>
<td>infix</td>
<td>inout</td>
</tr>
<tr>
<td>lazy</td>
<td>left</td>
<td>mutating</td>
<td>none</td>
</tr>
<tr>
<td>nonmutating</td>
<td>optional</td>
<td>override</td>
<td>postfix</td>
</tr>
<tr>
<td>precedence</td>
<td>prefix</td>
<td>Protocol</td>
<td>required</td>
</tr>
<tr>
<td>right</td>
<td>set</td>
<td>Type</td>
<td>unowned</td>
</tr>
<tr>
<td>weak</td>
<td>willSet</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="Swift空格"><a href="#Swift空格" class="headerlink" title="Swift空格"></a>Swift空格</h3><p>Swift语言并不是像C/C++、Java那样完全忽视空格，Swift对空格的使用有一定的要求，但是又不像Python对缩进的要求那么严格</p>
<p>在Swift中，运算符不能直接跟在变量或常量的后面</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//推荐使用这种写法</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">1</span> + <span class="number">2</span></span><br></pre></td></tr></table></figure>

<h3 id="Swift字面量"><a href="#Swift字面量" class="headerlink" title="Swift字面量"></a>Swift字面量</h3><p>所谓字面量，就是指像特定的数字、字符串或者是布尔值这样，能够直接了当的指出自己的类型并为变量进行赋值的值</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="number">42</span>                 <span class="comment">// 整型字面量</span></span><br><span class="line"><span class="number">3.14159</span>            <span class="comment">// 浮点型字面量</span></span><br><span class="line"><span class="string">&quot;Hello, world!&quot;</span>    <span class="comment">// 字符串型字面量</span></span><br><span class="line"><span class="literal">true</span>               <span class="comment">// 布尔型字面量</span></span><br></pre></td></tr></table></figure>

<h3 id="打印输出"><a href="#打印输出" class="headerlink" title="打印输出"></a>打印输出</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Runoob&quot;</span>)  <span class="comment">//输出Runoob</span></span><br></pre></td></tr></table></figure>

<p>如果我们想让其不换行输出，只需要将最后一个参数赋值为空字符串即可：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="number">0</span>...<span class="number">10</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\(x) &quot;</span>, terminator: <span class="string">&quot;&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="number">0</span>...<span class="number">10</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\(x) &quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你需要接收用户的输入可以使用 <strong>readLine()</strong></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> theInput = <span class="built_in">readLine</span>()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>权限：</title>
    <url>/2018/10/25/Apple%E3%80%81Linux/%E3%80%8ALinux%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%A4%A7%E5%85%A8%E3%80%8B/%E6%9D%83%E9%99%90%EF%BC%9A/</url>
    <content><![CDATA[<hr>
<p>传统的UNIX操作系统与那些传统的MS-DOS操作系统不同，区别在于它们不仅是多重任务处理系统，而且还是多用户系统,这意味着同一时间内可以有多个用户使用同一台计算机</p>
<p>id命令可以获得用户身份标识的相关信息<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glizu9qa41j30lz00x749.jpg"></p>
<p>1）用户账户定义在文件/etc/passwd中，对于每一个用户账户，文件/etc/passwd中都定义了对应用户的用户（登录）名、uid、gid、账户的真实姓名、主目录以及登录shell信息<br>2）用户组定义在文件/etc/group中，如果查看文件/etc/passwd和文件/etc/group的内容，可以发现除了普通用户账户信息之外，文件中还有对应于超级用户（uid为0）和其他不同种类的系统用户的账户信息<br>3）在创建用户账户和群组时，这些文件随着文件/etc/shadow的变动而修改，文件/etc/shadow中保存了用户的密码信息</p>
<p>对文件和目录的访问权限是按照读访问、写访问以及执行访问来定义的：<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glizuixqg3j30cb0gudhc.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glizuvora2j30cb0azjse.jpg"></p>
<p>chmod：更改文件或者目录的模式（权限），只有文件所有者和超级用户才可以更改文件或者目录的模式<br>1）八进制数字表示法：使用八进制数字来设置所期望的权限模式<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glizv3e7itj30cb04uzk8.jpg"></p>
<p>通过使用3位八进制数字，我们可以分别设置文件所有者、组成员和其他所有用户的文件模式<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glizvc9v8ej30b002nglq.jpg"></p>
<p>2）符号表示法：分为三部分：更改会影响谁、要执行哪个操作、要设置哪种权限<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glizvjhikhj30c007lwf2.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glizvpqhcgj30c006pdgh.jpg"></p>
<p>umask命令控制着创建文件时指定给文件的默认权限，它使用八进制表示法来表示从文件模式属性中删除一个位掩码<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glizvxxw2dj30c00bp75h.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glizw5zh8jj30c0075wf6.jpg"></p>
<p>有三种方法用来转换身份：<br>1）注销系统并以其他用户的身份重新登录系统<br>2）使用su命令<br>3）使用sudo命令</p>
<p>在shell会话状态下，使用su命令将允许你假定为另一个用户的身份，既可以以这个用户的ID来启动一个新的shell会话，也可以以这个用户的身份来发布一个命令<br>使用sudo命令将允许管理者创建一个称为/etc/sudoer的配置文件，并且定义一些特定的命令，这些命令只有被赋予为假定身份的特定用户才允许执行</p>
<p>su：以其他用户和组ID的身份来运行shell<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glizwesdzhj30c00d1myp.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glizwn6pxpj30c0026746.jpg"></p>
<p>sudo：以另一个用户的身份执行命令<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glizwu31xvj30c00au75q.jpg"></p>
<p>chown：更改文件或者目录的所有者和所属群组，需要超级用户的权限<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glizx1ua7rj30c0053t91.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glizx8o30ej30c008ldgs.jpg"></p>
<p>chgrp：在更早的UNIX版本中，chown命令只能更改文件的所有者，而不能改变文件所属群组，为了达到这个目的，可以使用chgrp</p>
<p>实例：<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glizxgbk8yj30c004iaah.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glizxn0wz4j30c00hfabs.jpg"><br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glizxun33nj30c00e5jt6.jpg"></p>
<p>passwd：设置或者更改密码<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glizy2rqv9j30c009fdgm.jpg"></p>
]]></content>
      <categories>
        <category>Apple、Linux</category>
      </categories>
      <tags>
        <tag>《Linux命令行大全》</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift类</title>
    <url>/2020/12/23/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/Swift/Swift%E7%B1%BB/</url>
    <content><![CDATA[<h2 id="Swift类"><a href="#Swift类" class="headerlink" title="Swift类"></a>Swift类</h2><p>Swift类是构建代码所用的一种通用且灵活的构造体，我们可以为类定义属性(常量、变量)和方法，与其他编程语言所不同的是，Swift并不要求你为自定义类去创建独立的接口和实现文件，你所要做的是在一个单一文件中定义一个类，系统会自动生成面向其他代码的外部接口</p>
<h3 id="类和结构体对比"><a href="#类和结构体对比" class="headerlink" title="类和结构体对比"></a>类和结构体对比</h3><p>共同点：</p>
<ul>
<li>定义属性用于存储值</li>
<li>定义方法用于提供功能</li>
<li>定义附属脚本用于访问值</li>
<li>定义构造器用于生成初始化值</li>
<li>通过扩展以增加默认实现的功能</li>
<li>符合协议以对某类提供标准功能</li>
</ul>
<p>类还具有的附加功能：</p>
<ul>
<li>继承允许一个类继承另一个类的特征</li>
<li>类型转换允许在运行时检查和解释一个类实例的类型</li>
<li>解构器允许一个类实例释放任何其所被分配的资源</li>
<li>引用计数允许对一个类的多次引用</li>
</ul>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> studname: <span class="type">String</span> = <span class="string">&quot;John&quot;</span></span><br><span class="line">    <span class="keyword">var</span> age: <span class="type">Int</span> = <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实例化类</span></span><br><span class="line"><span class="keyword">let</span> studrecord = student()</span><br><span class="line"></span><br><span class="line"><span class="comment">//类的属性可以通过.来访问</span></span><br><span class="line"><span class="built_in">print</span>(studrecord.studname, studrecord.age)</span><br></pre></td></tr></table></figure>

<h3 id="恒等运算符"><a href="#恒等运算符" class="headerlink" title="恒等运算符"></a>恒等运算符</h3><p>因为类是引用类型，有可能有多个常量和变量在后台同时引用某一个类实例，为了能够判定两个常量或者变量是否引用同一个类实例，Swift内建了两个恒等运算符</p>
<table>
<thead>
<tr>
<th align="left"><strong>恒等运算符</strong></th>
<th align="left"><strong>不恒等运算符</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">运算符为：===</td>
<td align="left">运算符为：!==</td>
</tr>
<tr>
<td align="left">如果两个常量或者变量引用同一个类实例则返回 true</td>
<td align="left">如果两个常量或者变量引用不同一个类实例则返回 true</td>
</tr>
</tbody></table>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gqz39bkyoxj60ia0ssn2j02.jpg"></p>
<h2 id="Swift属性"><a href="#Swift属性" class="headerlink" title="Swift属性"></a>Swift属性</h2><p>Swift属性将值跟特定的类、结构或枚举关联</p>
<p>属性可分为存储属性和计算属性：</p>
<table>
<thead>
<tr>
<th align="left"><strong>存储属性</strong></th>
<th align="left"><strong>计算属性</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">存储常量或变量作为实例的一部分</td>
<td align="left">计算（而不是存储）一个值</td>
</tr>
<tr>
<td align="left">用于类和结构体</td>
<td align="left">用于类、结构体和枚举</td>
</tr>
</tbody></table>
<h3 id="存储属性"><a href="#存储属性" class="headerlink" title="存储属性"></a>存储属性</h3><p>一个存储属性就是存储在特定类或结构体的实例里的一个常量或变量，存储属性可以是变量存储属性，也可以是常量存储属性</p>
<ul>
<li>可以在定义存储属性的时候指定默认值</li>
<li>也可以在构造过程中设置或修改存储属性的值，甚至修改常量存储属性的值</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> digits: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">let</span> <span class="type">Pi</span> = <span class="number">3.1415</span>  <span class="comment">//代码中Pi在定义存储属性的时候指定默认值，所以不管你什么时候实例化结构体，它都不会改变</span></span><br><span class="line">    <span class="comment">//如果你定义的是一个常量存储属性，如果尝试修改它就会报错</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> n = <span class="type">Number</span>(digits: <span class="number">12345</span>)</span><br><span class="line">n.digits = <span class="number">12</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(n.digits, n.<span class="type">Pi</span>)</span><br></pre></td></tr></table></figure>

<h3 id="延迟存储属性"><a href="#延迟存储属性" class="headerlink" title="延迟存储属性"></a>延迟存储属性</h3><p>延迟存储属性是指当第一次被调用的时候才会计算其初始值的属性，在属性声明前使用<code>lazy</code>来标示一个延迟存储属性</p>
<p>注意：必须将延迟存储属性声明成变量，因为属性的值在实例构造完成之前可能无法得到，，而常量属性在构造过程完成之前必须要有初始值，因此无法声明成延迟属性</p>
<p>延迟存储属性一般用于：延迟对象的创建、当属性的值依赖于其他未知类</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">sample</span> </span>&#123;</span><br><span class="line">    <span class="built_in">lazy</span> <span class="keyword">var</span> no = number()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">&quot;Swift&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> firstsample = sample()</span><br><span class="line"><span class="built_in">print</span>(firstsample.no.name)</span><br></pre></td></tr></table></figure>

<h3 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h3><p>除存储属性外，类、结构体和枚举可以定义计算属性，计算属性不直接存储值，而是提供一个getter来获取值，一个可选的setter来间接设置其他属性或变量的值</p>
<p>![image-20210529110941684](/Users/liaojialong/Library/Application Support/typora-user-images/image-20210529110941684.png)</p>
<h3 id="只读计算属性"><a href="#只读计算属性" class="headerlink" title="只读计算属性"></a>只读计算属性</h3><p>只有getter没有setter的计算属性就是只读计算属性，只读计算属性总是返回一个值，可以通过<code>.</code>运算符访问，但不能设置新的值</p>
<p>![image-20210529111909855](/Users/liaojialong/Library/Application Support/typora-user-images/image-20210529111909855.png)</p>
<h3 id="属性观察器"><a href="#属性观察器" class="headerlink" title="属性观察器"></a>属性观察器</h3><p>属性观察器监控和响应属性值的变化，每次属性被设置值的时候都会调用属性观察器，甚至新的值和现在的值相同的时候也不例外。可以为除了延迟存储属性之外的其他存储属性添加属性观察器，也可以通过重载属性的方式为继承的属性（包括存储属性和计算属性）添加属性观察器。</p>
<p>注意：不需要为无法重载的计算属性添加属性观察器，因为可以通过 setter 直接监控和响应值的变化。</p>
<p>可以为属性添加如下的一个或全部观察器：</p>
<ul>
<li><code>willSet</code>在设置新的值之前调用</li>
<li><code>didSet</code>在新的值被设置之后立即调用</li>
<li>willSet和didSet观察器在属性初始化过程中不会被调用</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gqz4yplmdmj30p40rcn1z.jpg"></p>
<h3 id="全局变量和局部变量"><a href="#全局变量和局部变量" class="headerlink" title="全局变量和局部变量"></a>全局变量和局部变量</h3><p>计算属性和属性观察器所描述的模式也可以用于全局变量和局部变量</p>
<table>
<thead>
<tr>
<th align="left"><strong>局部变量</strong></th>
<th align="left"><strong>全局变量</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">在函数、方法或闭包内部定义的变量。</td>
<td align="left">函数、方法、闭包或任何类型之外定义的变量。</td>
</tr>
<tr>
<td align="left">用于存储和检索值。</td>
<td align="left">用于存储和检索值。</td>
</tr>
<tr>
<td align="left">存储属性用于获取和设置值。</td>
<td align="left">存储属性用于获取和设置值。</td>
</tr>
<tr>
<td align="left">也用于计算属性。</td>
<td align="left">也用于计算属性。</td>
</tr>
</tbody></table>
<h3 id="类型属性"><a href="#类型属性" class="headerlink" title="类型属性"></a>类型属性</h3><p>属性可以直接用于类型本身，这种属性称为类型属性</p>
<p>类型属性是作为类型定义的一部分写在类型最外层的花括号<code>&#123;&#125;</code>内。</p>
<p>使用关键字 static 来定义值类型的类型属性，关键字 class 来为类定义类型属性。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Structname</span> </span>&#123;</span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">var</span> storedTypeProperty = <span class="string">&quot; &quot;</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">var</span> computedTypeProperty: <span class="type">Int</span> &#123;</span><br><span class="line">      <span class="comment">// 这里返回一个 Int 值</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Enumname</span> </span>&#123;</span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">var</span> storedTypeProperty = <span class="string">&quot; &quot;</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">var</span> computedTypeProperty: <span class="type">Int</span> &#123;</span><br><span class="line">      <span class="comment">// 这里返回一个 Int 值</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Classname</span> </span>&#123;</span><br><span class="line">   <span class="class"><span class="keyword">class</span> <span class="title">var</span> <span class="title">computedTypeProperty</span>: <span class="title">Int</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 这里返回一个 Int 值</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意：例子中的计算型类型属性是只读的，但也可以定义可读可写的计算型类型属性，跟实例计算属性的语法类似。</span></span><br></pre></td></tr></table></figure>

<h3 id="获取和设置类型属性的值"><a href="#获取和设置类型属性的值" class="headerlink" title="获取和设置类型属性的值"></a>获取和设置类型属性的值</h3><p>类似于实例的属性，类型属性的访问也是通过点运算符(.)来进行。但是，类型属性是通过类型本身来获取和设置，而不是通过实例。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StudMarks</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">let</span> markCount = <span class="number">97</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">var</span> totalCount = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">   <span class="keyword">var</span> <span class="type">InternalMarks</span>: <span class="type">Int</span> = <span class="number">0</span> &#123;</span><br><span class="line">      <span class="keyword">didSet</span> &#123;</span><br><span class="line">         <span class="keyword">if</span> <span class="type">InternalMarks</span> &gt; <span class="type">StudMarks</span>.markCount &#123;</span><br><span class="line">            <span class="type">InternalMarks</span> = <span class="type">StudMarks</span>.markCount</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> <span class="type">InternalMarks</span> &gt; <span class="type">StudMarks</span>.totalCount &#123;</span><br><span class="line">            <span class="type">StudMarks</span>.totalCount = <span class="type">InternalMarks</span></span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> stud1Mark1 = <span class="type">StudMarks</span>()</span><br><span class="line"><span class="keyword">var</span> stud1Mark2 = <span class="type">StudMarks</span>()</span><br><span class="line"></span><br><span class="line">stud1Mark1.<span class="type">InternalMarks</span> = <span class="number">98</span></span><br><span class="line"><span class="built_in">print</span>(stud1Mark1.<span class="type">InternalMarks</span>)  <span class="comment">//97</span></span><br><span class="line"><span class="built_in">print</span>(<span class="type">StudMarks</span>.markCount)  <span class="comment">//97</span></span><br><span class="line"><span class="built_in">print</span>(<span class="type">StudMarks</span>.totalCount)  <span class="comment">//97</span></span><br><span class="line"></span><br><span class="line">stud1Mark2.<span class="type">InternalMarks</span> = <span class="number">87</span></span><br><span class="line"><span class="built_in">print</span>(stud1Mark2.<span class="type">InternalMarks</span>)  <span class="comment">//87</span></span><br><span class="line"><span class="built_in">print</span>(<span class="type">StudMarks</span>.markCount)  <span class="comment">//97❓</span></span><br><span class="line"><span class="built_in">print</span>(<span class="type">StudMarks</span>.totalCount)  <span class="comment">//97❓</span></span><br></pre></td></tr></table></figure>

<h2 id="Swift方法"><a href="#Swift方法" class="headerlink" title="Swift方法"></a>Swift方法</h2>]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift数据类型</title>
    <url>/2020/12/30/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/Swift/Swift%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<p>在我们使用任何程序语言编程时，需要使用各种数据类型来存储不同的信息，变量的数据类型决定了如何将代表这些值的位存储到计算机的内存中，在声明变量时也可指定它的数据类型，所有变量都有数据类型，以决定能够存储哪种数据</p>
<h2 id="内置数据类型"><a href="#内置数据类型" class="headerlink" title="内置数据类型"></a>内置数据类型</h2><h3 id="Int"><a href="#Int" class="headerlink" title="Int"></a>Int</h3><p>一般来说，你不需要专门指定整数的长度，Swift提供了一个特殊的整数类型<code>Int</code>,长度与当前平台的原生字长相同，在32位平台上，<code>Int</code>和<code>Int32</code>长度相同，在64位平台上，<code>Int</code>和<code>Int64</code>长度相同</p>
<p>除非需要特定长度的整数，一般来说使用<code>Int</code>就够了，这可以提高代码一致性和可复用性</p>
<h3 id="UInt"><a href="#UInt" class="headerlink" title="UInt"></a>UInt</h3><p>Swift也提供了一个特殊的无符号类型<code>UInt</code>，长度与当前平台的原生字长相同，在32位平台上，<code>UInt</code>和<code>UInt32</code>长度相同，在64位平台上，<code>UInt</code>和<code>UInt64</code>长度相同</p>
<p>注意：尽量不要使用<code>UInt</code>，除非真的需要存储一个和当前平台原生字长相同的无符号整数，除了这种情况，最好使用<code>Int</code>，即使你要存储的值已知是非负的。统一使用<code>Int</code>可以提高代码的可复用性，避免不同类型数字之间的转换，并且匹配数字的类型推断</p>
<h3 id="浮点数：Float、Double"><a href="#浮点数：Float、Double" class="headerlink" title="浮点数：Float、Double"></a>浮点数：Float、Double</h3><p>浮点数是有小数部分的数字</p>
<p>浮点类型比整数类型表示的范围更大，可以存储比<code>Int</code>类型更大或者更小的数字</p>
<p><code>Double</code>：表示64位浮点数，当需要存储很大或者很高精度的浮点数时使用此类型</p>
<p><code>Float</code>：表示32位浮点数，精度要求不高的话可以使用此类型</p>
<p>注意：<code>Double</code>精确度很高，至少有15位数字，而<code>Float</code>最少只有6位数字</p>
<h3 id="布尔值：Bool"><a href="#布尔值：Bool" class="headerlink" title="布尔值：Bool"></a>布尔值：Bool</h3><p>布尔值指逻辑上的值，因为它们只能是真或者假。</p>
<p>Swift有两个布尔常量：<code>true</code>、<code>false</code></p>
<h3 id="字符串：String"><a href="#字符串：String" class="headerlink" title="字符串：String"></a>字符串：String</h3><p>字符串是字符的序列集合：<code>Hello,World!</code></p>
<h3 id="字符：Character"><a href="#字符：Character" class="headerlink" title="字符：Character"></a>字符：Character</h3><p>字符指的是单个字母：<code>C</code></p>
<h3 id="可选类型：Optional"><a href="#可选类型：Optional" class="headerlink" title="可选类型：Optional"></a>可选类型：Optional</h3><p>使用可选类型来处理值可能缺失的情况，可选类型表示有值或没有值</p>
<p>此外，Swift还提供了其他更强大的数据类型，<code>Array</code>、<code>Dictionary</code>、<code>Struct</code>、<code>Class</code></p>
<h2 id="数值范围"><a href="#数值范围" class="headerlink" title="数值范围"></a>数值范围</h2><p>不同变量类型内存的存储空间，及变量类型的最大最小值；</p>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">大小（字节）</th>
<th align="left">区间值</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Int8</td>
<td align="left">1 字节</td>
<td align="left">-128 到 127</td>
</tr>
<tr>
<td align="left">UInt8</td>
<td align="left">1 字节</td>
<td align="left">0 到 255</td>
</tr>
<tr>
<td align="left">Int32</td>
<td align="left">4 字节</td>
<td align="left">-2147483648 到 2147483647</td>
</tr>
<tr>
<td align="left">UInt32</td>
<td align="left">4 字节</td>
<td align="left">0 到 4294967295</td>
</tr>
<tr>
<td align="left">Int64</td>
<td align="left">8 字节</td>
<td align="left">-9223372036854775808 到 9223372036854775807</td>
</tr>
<tr>
<td align="left">UInt64</td>
<td align="left">8 字节</td>
<td align="left">0 到 18446744073709551615</td>
</tr>
<tr>
<td align="left">Float</td>
<td align="left">4 字节</td>
<td align="left">1.2E-38 到 3.4E+38 (~6 digits)</td>
</tr>
<tr>
<td align="left">Double</td>
<td align="left">8 字节</td>
<td align="left">2.3E-308 到 1.7E+308 (~15 digits)</td>
</tr>
</tbody></table>
<h2 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h2><p>类型别名对当前的类型定义了另一个名字，类型别名通过使用<code>typealias</code>关键字来定义</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="keyword">typealias</span> <span class="type">Feet</span> = <span class="type">Int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="built_in">distance</span>: <span class="type">Feet</span> = <span class="number">100</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">distance</span>)</span><br></pre></td></tr></table></figure>

<h2 id="类型安全"><a href="#类型安全" class="headerlink" title="类型安全"></a>类型安全</h2><p>Swift是一个类型安全<code>type safe</code>的语言，由于Swift是类型安全的，所以它会在编译你的代码时进行类型检查<code>type checks</code>，并把不匹配的类型标记为错误，这可以让你在开发的时候尽早发现并修复错误</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gqux9qf898j30v8050t9n.jpg"></p>
<h2 id="类型推断"><a href="#类型推断" class="headerlink" title="类型推断"></a>类型推断</h2><p>如果没有显式指定类型，Swift会使用类型推断<code>type inference</code>来选择合适的类型</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> meaningOfLine = <span class="number">42</span>  <span class="comment">// meaningOfLine会被推测为Int类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> pi = <span class="number">3.14159</span>  <span class="comment">// pi会被推测为Double类型，当推断浮点数的类型时，Swift总是会选择Double而不是Float</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果表达式中同时出现了整数和浮点数，会被推断为Double类型</span></span><br><span class="line"><span class="keyword">let</span> anotherPi = <span class="number">3</span> + <span class="number">0.14159</span></span><br></pre></td></tr></table></figure>

<p>但是：在Swift中，任何时候都不会做隐式转换，任何两个类型不同的变量或常量不允许直接计算</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gr1bmbsbmpj30y4068dgn.jpg"></p>
<h2 id="Swift变量"><a href="#Swift变量" class="headerlink" title="Swift变量"></a>Swift变量</h2><p>变量是一种使用方便的占位符，用于引用计算机内存地址，Swift每个变量都指定了特定的类型，该类型决定了变量占用内存的大小，不同的数据类型也决定可存储值的范围</p>
<h3 id="变量的声明"><a href="#变量的声明" class="headerlink" title="变量的声明"></a>变量的声明</h3><p>变量声明的意思是告诉编译器在内存中的哪个位置上为变量创建多大的存储空间，在使用变量前，你需要使用<code>var</code>关键字声明它</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> varA = <span class="number">42</span></span><br><span class="line"><span class="built_in">print</span>(varA)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> varB: <span class="type">Float</span> = <span class="number">3.14159</span></span><br><span class="line"><span class="built_in">print</span>(varB)</span><br></pre></td></tr></table></figure>

<h3 id="变量命名"><a href="#变量命名" class="headerlink" title="变量命名"></a>变量命名</h3><p>变量名可以由字母、数字和下划线组成，变量名需要以字母或下划线开始</p>
<p>Swift是一个区分大小写的语言，所以字母大写与小写是不一样的</p>
<p>变量名也可以使用简单的<code>Unicode</code>字符</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _var = <span class="string">&quot;Hello,Swift&quot;</span></span><br><span class="line"><span class="built_in">print</span>(_var)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> 你好 = <span class="string">&quot;你好世界&quot;</span></span><br><span class="line"><span class="built_in">print</span>(你好)</span><br></pre></td></tr></table></figure>

<h3 id="变量输出"><a href="#变量输出" class="headerlink" title="变量输出"></a>变量输出</h3><p>变量和常量可以使用<code>print</code>函数来输出，在字符串中可以使用括号与反斜线来插入变量</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;菜鸟教程&quot;</span></span><br><span class="line"><span class="keyword">var</span> site = <span class="string">&quot;http://www.runoob.com&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\(name)的官网地址为：\(site)&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="Swift可选类型-Optionals"><a href="#Swift可选类型-Optionals" class="headerlink" title="Swift可选类型(Optionals)"></a>Swift可选类型(Optionals)</h2><p>Swift的可选类型，用于处理值缺失的情况，可选表示“那儿有一个值，并且它等于x”或者“那儿没有值”</p>
<p>Swift语言定义后缀<code>?</code>作为命名类型Optional的简写，换句话说，以下两种声明是相等的</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> optionalInteger: <span class="type">Int?</span></span><br><span class="line"><span class="keyword">var</span> optionalInteger: <span class="type">Optional</span>&lt;<span class="type">Int</span>&gt;</span><br></pre></td></tr></table></figure>

<p>Optional是一个含有两种情况的枚举，用来表示可能有或可能没有值，任何类型都可以明确声明为可选类型</p>
<p>当声明一个可选类型的时候，要确保用括号给<code>?</code>操作符一个合适的范围，例如声明可选整数数组，应该写成<code>(Int[])?</code>，写成<code>Int[]?</code>会报错</p>
<p>当你声明一个可选变量或者可选属性的时候没有提供初始值，它的值会默认为nil</p>
<p>可选项遵照LogicValue协议，因此可以出现在布尔环境中，在这种情况下，如果可选类型<code>T?</code>包含类型为<code>T</code>的任何值，这个可选类型等于true，反之为false</p>
<p>如果一个可选类型的实例包含一个值，你可以用后缀操作符<code>!</code>来访问这个值，使用操作符<code>!</code>去获取值为nil的可选变量会有运行时错误</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myString: <span class="type">String?</span> = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> myString != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(myString)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;字符串为nil&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可选类型类似于Objective-C中指针的nil值，但是nil只对类(class)有用，而可选类型对所有的类型都可用，并且更安全</p>
<h3 id="强制解析"><a href="#强制解析" class="headerlink" title="强制解析"></a>强制解析</h3><p>当你确定可选类型确实包含值之后，你可以在可选的名字后面加一个感叹号<code>!</code>来获取值，这个感叹号表示“我知道这个可选有值，请使用它”，这被称为可选值的强制解析</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gqvm2jgb17j30j20fc415.jpg"></p>
<p>注意：使用<code>!</code>来获取一个不存在的可选值会导致运行时错误，使用<code>!</code>来强制解析值之前，一定要确定可选包含一个非nil的值</p>
<h3 id="自动解析❓"><a href="#自动解析❓" class="headerlink" title="自动解析❓"></a>自动解析❓</h3><p>可以在声明可选变量时使用感叹号<code>!</code>替换问号<code>?</code>，这样可选变量在使用时就不需要再加一个感叹号<code>!</code>来获取值，它会自动解析</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gqvn2j262kj30j20fcgo2.jpg"></p>
<h3 id="可选绑定"><a href="#可选绑定" class="headerlink" title="可选绑定"></a>可选绑定</h3><p>使用可选绑定来判断可选类型是否包含值，如果包含就把值赋给一个临时常量或变量，可选绑定可以用在if和while语句中来对可选类型的值进行判断并把值赋给一个常量或者变量</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gqvnbdghjjj30j20ecgnj.jpg"></p>
<h2 id="Swift常量"><a href="#Swift常量" class="headerlink" title="Swift常量"></a>Swift常量</h2><p>常量一旦设定，在程序运行时就无法改变其值</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> constA = <span class="number">12</span></span><br><span class="line"><span class="built_in">print</span>(constA)</span><br><span class="line"></span><br><span class="line"><span class="comment">//常量定义时必须初始值</span></span><br><span class="line"><span class="keyword">let</span> constB: <span class="type">Float</span> = <span class="number">3.14159</span></span><br><span class="line"><span class="built_in">print</span>(constB)</span><br></pre></td></tr></table></figure>

<h2 id="Swift字面量"><a href="#Swift字面量" class="headerlink" title="Swift字面量"></a>Swift字面量</h2><p>所谓字面量，就是指像特定的数字、字符串或者布尔值这样，能够直截了当的指出自己的类型并为变量进行赋值的值</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> aNumber = <span class="number">3</span>  <span class="comment">//整型字面量</span></span><br><span class="line"><span class="keyword">let</span> aString = <span class="string">&quot;Hello&quot;</span>  <span class="comment">//字符串字面量</span></span><br><span class="line"><span class="keyword">let</span> aBool = <span class="literal">true</span>  <span class="comment">//布尔值字面量</span></span><br></pre></td></tr></table></figure>

<h3 id="整型字面量"><a href="#整型字面量" class="headerlink" title="整型字面量"></a>整型字面量</h3><p>整型字面量可以是一个十进制<code>无前缀</code>、二进制<code>0b</code>、八进制<code>0o</code>或十六进制<code>0x</code>常量</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> decimalInteger = <span class="number">17</span>           <span class="comment">// 17 - 十进制表示</span></span><br><span class="line"><span class="keyword">let</span> binaryInteger = <span class="number">0b10001</span>       <span class="comment">// 17 - 二进制表示</span></span><br><span class="line"><span class="keyword">let</span> octalInteger = <span class="number">0o21</span>           <span class="comment">// 17 - 八进制表示</span></span><br><span class="line"><span class="keyword">let</span> hexadecimalInteger = <span class="number">0x11</span>     <span class="comment">// 17 - 十六进制表示</span></span><br></pre></td></tr></table></figure>

<h3 id="浮点型字面量"><a href="#浮点型字面量" class="headerlink" title="浮点型字面量"></a>浮点型字面量</h3><p>浮点型字面量有整数部分，小数点，小数部分及指数部分</p>
<p>除非特别指定，浮点型字面量的默认推导类型为 Swift 标准库类型中的 Double，表示64位浮点数</p>
<p>浮点型字面量默认用十进制表示（无前缀），也可以用十六进制表示（加前缀 0x）</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> decimalDouble = <span class="number">12.1875</span>       <span class="comment">//十进制浮点型字面量</span></span><br><span class="line"><span class="keyword">let</span> exponentDouble = <span class="number">1.21875e1</span>    <span class="comment">//十进制浮点型字面量  1.21875 * 10^1</span></span><br><span class="line"><span class="keyword">let</span> hexadecimalDouble = <span class="number">0xC.3p0</span>   <span class="comment">//十六进制浮点型字面量  12.3 * 2^0</span></span><br></pre></td></tr></table></figure>

<p>浮点型字面量允许使用下划线<code>_</code>来增强数字的可读性，下划线会被系统忽略，因此不会影响字面量的值</p>
<p>同样的，也可以在数字前加0，并不会影响字面量的值</p>
<h3 id="字符串型字面量"><a href="#字符串型字面量" class="headerlink" title="字符串型字面量"></a>字符串型字面量</h3><p>字符串型字面量由被包在双引号中的一串字符组成</p>
<p>字符串型字面量中不能包含未转义的双引号 （”）、未转义的反斜线（\）、回车符或换行符</p>
<table>
<thead>
<tr>
<th align="left">转义字符</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>\0</code></td>
<td align="left">空字符</td>
</tr>
<tr>
<td align="left"><code>\\</code></td>
<td align="left">反斜线 \</td>
</tr>
<tr>
<td align="left"><code>\b</code></td>
<td align="left">退格(BS) ，将当前位置移到前一列</td>
</tr>
<tr>
<td align="left"><code>\f</code></td>
<td align="left">换页(FF)，将当前位置移到下页开头</td>
</tr>
<tr>
<td align="left"><code>\n</code></td>
<td align="left">换行符</td>
</tr>
<tr>
<td align="left"><code>\r</code></td>
<td align="left">回车符</td>
</tr>
<tr>
<td align="left"><code>\t</code></td>
<td align="left">水平制表符</td>
</tr>
<tr>
<td align="left"><code>\v</code></td>
<td align="left">垂直制表符</td>
</tr>
<tr>
<td align="left"><code>\&#39;</code></td>
<td align="left">单引号</td>
</tr>
<tr>
<td align="left"><code>\&quot;</code></td>
<td align="left">双引号</td>
</tr>
<tr>
<td align="left"><code>\000</code></td>
<td align="left">1到3位八进制数所代表的任意字符</td>
</tr>
<tr>
<td align="left"><code>\xhh...</code></td>
<td align="left">1到2位十六进制所代表的任意字符</td>
</tr>
</tbody></table>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gqvogg93euj30vi0g2mzm.jpg"></p>
<h3 id="布尔型字面量"><a href="#布尔型字面量" class="headerlink" title="布尔型字面量"></a>布尔型字面量</h3><p>布尔型字面量的默认类型是<code>Bool</code></p>
<p>布尔值字面量有三个值，它们是Swift的保留关键字：<code>true表示真</code>、<code>false表示假</code>、<code>nil表示没有值</code></p>
]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift语句</title>
    <url>/2020/12/28/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/Swift/Swift%E8%AF%AD%E5%8F%A5/</url>
    <content><![CDATA[<h2 id="Swift条件语句"><a href="#Swift条件语句" class="headerlink" title="Swift条件语句"></a>Swift条件语句</h2><p>条件语句通过设定一个或多个条件来执行程序，在条件为真时执行指定的语句，在条件为false时执行另外指定的语句</p>
<ol>
<li>if 语句</li>
<li>if else 语句</li>
<li>if…else if…else 语句</li>
<li>内嵌 if 语句</li>
<li>switch 语句</li>
<li>a ? b : c</li>
</ol>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> oName: <span class="type">String?</span> = <span class="string">&quot;john&quot;</span></span><br><span class="line"><span class="keyword">let</span> oAge: <span class="type">Int?</span> = <span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> oName != <span class="literal">nil</span> &amp;&amp; oAge != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\(oName!), \(oAge!)&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//if let 可以设置数值，进入分支后，name、age可以保证一定有值</span></span><br><span class="line"><span class="comment">//if let 语句中不能使用&amp;&amp; ||条件</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> name = oName, <span class="keyword">let</span> age = oAge &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\(name), \(age)&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> oName: <span class="type">String?</span> = <span class="string">&quot;john&quot;</span></span><br><span class="line"><span class="keyword">let</span> oAge: <span class="type">Int?</span> = <span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">demo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//guard是和if let刚好相反的指令</span></span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> name = oName, <span class="keyword">let</span> age = oAge <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//代码执行到此，name和age一定有值</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\(name), \(age)&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">demo()</span><br></pre></td></tr></table></figure>

<h2 id="Swift循环语句"><a href="#Swift循环语句" class="headerlink" title="Swift循环语句"></a>Swift循环语句</h2><p>有的时候，我们可能需要多次执行同一块代码。一般情况下，语句是按顺序执行的：函数中的第一个语句先执行，接着是第二个语句，依此类推。编程语言提供了更为复杂执行路径的多种控制结构。循环语句允许我们多次执行一个语句或语句组</p>
<h3 id="循环类型"><a href="#循环类型" class="headerlink" title="循环类型"></a>循环类型</h3><ol>
<li>for in</li>
<li>for 循环：该循环方式在Swift3中已经弃用</li>
<li>while 循环</li>
<li>repeat while 循环：类似 while 语句，区别在于判断循环条件之前，先执行一次循环的代码块</li>
</ol>
<h3 id="循环控制语句"><a href="#循环控制语句" class="headerlink" title="循环控制语句"></a>循环控制语句</h3><p>循环控制语句改变你代码的执行顺序，通过它你可以实现代码的跳转</p>
<table>
<thead>
<tr>
<th align="left">控制语句</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="https://www.runoob.com/swift/swift-continue-statement.html">continue 语句</a></td>
<td align="left">告诉一个循环体立刻停止本次循环迭代，重新开始下次循环迭代。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/swift/swift-break-statement.html">break 语句</a></td>
<td align="left">中断当前循环。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/swift/swift-fallthrough-statement.html">fallthrough 语句</a></td>
<td align="left">如果在一个case执行完后，继续执行下面的case，需要使用fallthrough(贯穿)关键字。</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift运算符</title>
    <url>/2020/12/29/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/Swift/Swift%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    <content><![CDATA[<p>运算符是一个符号，用于告诉编译器执行一个数学或逻辑运算</p>
<h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><p><code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>、<code>%</code></p>
<p>注意：Swift3中已经取消了<code>++</code>、<code>--</code></p>
<h3 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h3><p><code>==</code>、<code>!=</code>、<code>&gt;</code>、<code>&lt;</code>、<code>&gt;=</code>、<code>&lt;=</code></p>
<h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p><code>&amp;&amp;</code>：逻辑与，如果运算符两侧都为TRUE则为TRUE</p>
<p><code>||</code>：逻辑或，如果运算符两侧至少有一个为TRUE则为TRUE</p>
<p><code>!</code>：逻辑非，布尔值取反</p>
<h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><p>位运算符用来对二进制位进行操作</p>
<p><code>~ 取反</code>、<code>&amp; 按位与</code>、<code>| 按位或</code>、<code>^ 按位异或</code>、<code>&lt;&lt; 按位左移</code>、<code>&gt;&gt; 按位右移</code></p>
<table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">描述</th>
<th align="left">图解</th>
</tr>
</thead>
<tbody><tr>
<td align="left">&amp;</td>
<td align="left">按位与。按位与运算符对两个数进行操作，然后返回一个新的数，这个数的每个位都需要两个输入数的同一位都为1时才为1。</td>
<td align="left"><img src="https://www.runoob.com/wp-content/uploads/2015/10/8370_140612144422_1.png" alt="img"></td>
</tr>
<tr>
<td align="left">|</td>
<td align="left">按位或。按位或运算符|比较两个数，然后返回一个新的数，这个数的每一位设置1的条件是两个输入数的同一位都不为0(即任意一个为1，或都为1)。</td>
<td align="left"><img src="https://www.runoob.com/wp-content/uploads/2015/10/8370_140612144511_1.png" alt="img"></td>
</tr>
<tr>
<td align="left">^</td>
<td align="left">按位异或. 按位异或运算符^比较两个数，然后返回一个数，这个数的每个位设为1的条件是两个输入数的同一位不同，如果相同就设为0。</td>
<td align="left"><img src="https://www.runoob.com/wp-content/uploads/2015/10/8370_140612144558_1.png" alt="img"></td>
</tr>
<tr>
<td align="left">~</td>
<td align="left">按位取反运算符~对一个操作数的每一位都取反。</td>
<td align="left"><img src="https://www.runoob.com/wp-content/uploads/2015/10/8370_140612144245_1.png" alt="img"></td>
</tr>
<tr>
<td align="left">&lt;&lt;</td>
<td align="left">按位左移。左移操作符（&lt;&lt;）将操作数的所有位向左移动指定的位数。</td>
<td align="left">下图展示了11111111 &lt;&lt; 1（11111111 左移一位）的结果。蓝色数字表示被移动位，灰色表示被丢弃位，空位用橙色的0填充。<img src="https://www.runoob.com/wp-content/uploads/2015/10/leftbit.jpg" alt="img"></td>
</tr>
<tr>
<td align="left">&gt;&gt;</td>
<td align="left">按位右移。右移操作符（&gt;&gt;）将操作数的所有位向右移动指定的位数。</td>
<td align="left">下图展示了11111111 &gt;&gt; 1（11111111 右移一位）的结果。蓝色数字表示被移动位，灰色表示被丢弃位，空位用橙色的0填充。<img src="https://www.runoob.com/wp-content/uploads/2015/10/rightbit.jpg" alt="img"></td>
</tr>
</tbody></table>
<h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">描述</th>
<th align="left">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">=</td>
<td align="left">简单的赋值运算，指定右边操作数赋值给左边的操作数。</td>
<td align="left">C = A + B 将 A + B 的运算结果赋值给 C</td>
</tr>
<tr>
<td align="left">+=</td>
<td align="left">相加后再赋值，将左右两边的操作数相加后再赋值给左边的操作数。</td>
<td align="left">C += A 相当于 C = C + A</td>
</tr>
<tr>
<td align="left">-=</td>
<td align="left">相减后再赋值，将左右两边的操作数相减后再赋值给左边的操作数。</td>
<td align="left">C -= A 相当于 C = C - A</td>
</tr>
<tr>
<td align="left">*=</td>
<td align="left">相乘后再赋值，将左右两边的操作数相乘后再赋值给左边的操作数。</td>
<td align="left">C *= A 相当于 C = C * A</td>
</tr>
<tr>
<td align="left">/=</td>
<td align="left">相除后再赋值，将左右两边的操作数相除后再赋值给左边的操作数。</td>
<td align="left">C /= A 相当于 C = C / A</td>
</tr>
<tr>
<td align="left">%=</td>
<td align="left">求余后再赋值，将左右两边的操作数求余后再赋值给左边的操作数。</td>
<td align="left">C %= A 相当于 C = C % A</td>
</tr>
<tr>
<td align="left">&lt;&lt;=</td>
<td align="left">按位左移后再赋值</td>
<td align="left">C &lt;&lt;= 2 相当于 C = C &lt;&lt; 2</td>
</tr>
<tr>
<td align="left">&gt;&gt;=</td>
<td align="left">按位右移后再赋值</td>
<td align="left">C &gt;&gt;= 2 相当于 C = C &gt;&gt; 2</td>
</tr>
<tr>
<td align="left">&amp;=</td>
<td align="left">按位与运算后赋值</td>
<td align="left">C &amp;= 2 相当于 C = C &amp; 2</td>
</tr>
<tr>
<td align="left">^=</td>
<td align="left">按位异或运算符后再赋值</td>
<td align="left">C ^= 2 相当于 C = C ^ 2</td>
</tr>
<tr>
<td align="left">|=</td>
<td align="left">按位或运算后再赋值</td>
<td align="left">C |= 2 相当于 C = C | 2</td>
</tr>
</tbody></table>
<h3 id="区间运算符"><a href="#区间运算符" class="headerlink" title="区间运算符"></a>区间运算符</h3><table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">描述</th>
<th align="left">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">闭区间运算符</td>
<td align="left">闭区间运算符（a…b）定义一个包含从a到b(包括a和b)的所有值的区间，b必须大于等于a。 ‌ 闭区间运算符在迭代一个区间的所有值时是非常有用的，如在for-in循环中：</td>
<td align="left">1…5 区间值为 1, 2, 3, 4 和 5</td>
</tr>
<tr>
<td align="left">半开区间运算符</td>
<td align="left">半开区间（a..&lt;b）定义一个从a到b但不包括b的区间。 之所以称为半开区间，是因为该区间包含第一个值而不包括最后的值。</td>
<td align="left">1..&lt; 5 区间值为 1, 2, 3, 和 4</td>
</tr>
</tbody></table>
<h3 id="其他运算符"><a href="#其他运算符" class="headerlink" title="其他运算符"></a>其他运算符</h3><ul>
<li><p>一元运算符对单一操作对象操作（如<code>-a</code>）。一元运算符分前置运算符和后置运算符，前置运算符需紧跟在操作对象之前（如<code>!b</code>），后置运算符需紧跟在操作对象之后（例如c!）</p>
<p><strong>备注：</strong>在Java／C没有类似c！的语法， 在Swift中用在Optional类型取值</p>
</li>
<li><p>二元运算符操作两个操作对象（如<code>2 + 3</code>），是中置的，因为它们出现在两个操作对象之间</p>
</li>
<li><p>三元运算符操作三个操作对象，和 C 语言一样，Swift 只有一个三元运算符，就是三目运算符（<code>a ? b : c</code>）</p>
</li>
</ul>
<h3 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h3><p>逗号操作符具有最低的优先级</p>
<p>相同优先级中，按结合顺序计算。大多数运算是从左至右计算，只有三个优先级是从右至左结合的，它们是单目运算符、条件运算符、赋值运算符</p>
<p>基本的优先级需要记住：</p>
<ul>
<li>指针最优，单目运算优于双目运算。如正负号。</li>
<li>先乘除（模），后加减。</li>
<li>先算术运算，后移位运算，最后位运算。请特别注意：1 &lt;&lt; 3 + 2 &amp; 7 等价于 (1 &lt;&lt; (3 + 2))&amp;7</li>
<li>逻辑运算最后计算</li>
</ul>
<p>优先级从高到低：</p>
<table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">位运算符</td>
<td align="left">&gt;&gt; &amp;&lt;&lt; &amp;&gt;&gt; &gt;&gt;</td>
</tr>
<tr>
<td align="left">乘法运算符</td>
<td align="left">&amp;* % &amp; * /</td>
</tr>
<tr>
<td align="left">加法运算符</td>
<td align="left">| &amp;+ &amp;- + -  ^</td>
</tr>
<tr>
<td align="left">区间运算符</td>
<td align="left">..&lt; …</td>
</tr>
<tr>
<td align="left">类型转换运算符</td>
<td align="left">is as</td>
</tr>
<tr>
<td align="left">nil 的聚合运算</td>
<td align="left">??</td>
</tr>
<tr>
<td align="left">比较运算符</td>
<td align="left">!= &gt; &lt; &gt;= &lt;= === ==</td>
</tr>
<tr>
<td align="left">逻辑与运算符</td>
<td align="left">&amp;&amp;</td>
</tr>
<tr>
<td align="left">逻辑或运算符</td>
<td align="left">||</td>
</tr>
<tr>
<td align="left">波浪箭头</td>
<td align="left">~&gt;</td>
</tr>
<tr>
<td align="left">三元运算符</td>
<td align="left">?:</td>
</tr>
<tr>
<td align="left">箭头函数</td>
<td align="left">( )</td>
</tr>
<tr>
<td align="left">赋值运算符</td>
<td align="left">|= %= /= &amp;&lt;&lt;= &amp;&gt;&gt;= &amp;= *= &gt;&gt;= &lt;&lt;= ^= += -=</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>开发语言</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>中断和异常</title>
    <url>/2020/10/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8/</url>
    <content><![CDATA[<h2 id="中断的作用"><a href="#中断的作用" class="headerlink" title="中断的作用"></a>中断的作用</h2><p>“中断”是让操作系统内核夺回CPU使用权的唯一途径，中断会让CPU由用户态变为内核态</p>
<p>如果没有“中断”机制，那么一旦应用程序上CPU运行，CPU就会一直运行这个应用程序，既如此，何来并发。</p>
<h2 id="中断的类型"><a href="#中断的类型" class="headerlink" title="中断的类型"></a>中断的类型</h2><h3 id="内中断（也称“异常”）"><a href="#内中断（也称“异常”）" class="headerlink" title="内中断（也称“异常”）"></a>内中断（也称“异常”）</h3><ol>
<li>陷阱、陷入（trap）：由陷入指令引发，是应用程序故意引发的</li>
<li>故障（fault）：由错误条件引起的，可能被内核程序修复。内核程序修复故障后会把CPU使用权还给应用程序，让它继续执行下去（缺页故障）</li>
<li>终止（abort）：由致命错误引起，内核程序无法修复该错误，因此一般不再将CPU使用权还给引发终止的应用程序（整数除0，非法使用特权指令）</li>
</ol>
<p>与当前执行的指令有关，中断信号来源于CPU内部</p>
<p>若当前执行的指令是非法的，则会引发一个中断信号</p>
<ul>
<li>试图在用户态下执行特权指令</li>
<li>执行除法指令时发现除数为0</li>
<li>有时候应用程序想请求操作系统内核的服务，此时会执行一条特殊的指令：陷入指令，该指令会引发一个内部中断信号，执行陷入指令，意味着应用程序主动的将CPU控制权还给操作系统内核，“系统调用”就是通过陷入指令完成的（注意陷入指令并不是特权指令）（陷入指令 = trap指令 = 访管指令）</li>
</ul>
<h3 id="外中断（也称“中断”）"><a href="#外中断（也称“中断”）" class="headerlink" title="外中断（也称“中断”）"></a>外中断（也称“中断”）</h3><p>与当前执行的指令无关，中断信号来源于CPU外部</p>
<ul>
<li>时钟中断：由时钟部件发来的中断信号，时钟部件每隔一个时间片会给CPU发送一个时钟中断信号（多个应用程序的并发运行）</li>
<li>I/O中断：由输入/输出设备发来的中断信号（打印机）</li>
</ul>
<h2 id="中断机制的基本原理"><a href="#中断机制的基本原理" class="headerlink" title="中断机制的基本原理"></a>中断机制的基本原理</h2><p>检查中断信号：</p>
<p>内中断：CPU在执行指令时会检查是否有异常发生</p>
<p>外中断：每一条指令执行结束时，CPU都会例行检查是否有外中断信号需要处理</p>
<p>不同的中断信号，需要用不同的中断处理程序来处理。当CPU检测到中断信号后，会根据中断信号的类型去查询“中断向量表”，以此来找到相应的中断处理程序在内存中的存放位置</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gr2vu3rw3ej30qq0fwjz5.jpg"></p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>操作系统原理</tag>
      </tags>
  </entry>
  <entry>
    <title>处理机调度概念、层次</title>
    <url>/2020/10/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%E6%A6%82%E5%BF%B5%E3%80%81%E5%B1%82%E6%AC%A1/</url>
    <content><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>当有一堆任务要处理，但由于资源有限，这些事情没法同时处理。这就需要确定某种规则来决定处理这些任务的顺序，这就是“调度”研究的问题</p>
<h2 id="三个层次"><a href="#三个层次" class="headerlink" title="三个层次"></a>三个层次</h2><h3 id="高级调度（作业调度）"><a href="#高级调度（作业调度）" class="headerlink" title="高级调度（作业调度）"></a>高级调度（作业调度）</h3><p>作业：一个具体的任务</p>
<p>用户向系统提交一个作业 = 用户让操作系统启动一个程序（来处理一个具体的任务）</p>
<p>内存空间有限，有时无法将用户提交的作业全部放入内存？</p>
<p>高级调度（作业调度）：按一定的原则从外存的作业后备队列中挑选一个作业调入内存，并创建进程。每个作业只调入一次，调出一次，作业调入时会建立PCB，调出时才撤销PCB</p>
<h3 id="中级调度（内存调度）"><a href="#中级调度（内存调度）" class="headerlink" title="中级调度（内存调度）"></a>中级调度（内存调度）</h3><p>内存不够时，可将某些进程的数据调出外存，等内存空闲或者进程需要运行时再重新调入内存，暂时调到外存等待的进程状态为挂起状态，被挂起的进程PCB会被组织成挂起队列（为减轻系统负载，提高资源利用率）</p>
<p>中级调度：按照某种策略决定将哪个处于挂起状态的进程重新调入内存，一个进程可能会被多次调出、调入内存，因此中级调度发生的频率要比高级调度更高</p>
<h4 id="进程的挂起态与七状态模型"><a href="#进程的挂起态与七状态模型" class="headerlink" title="进程的挂起态与七状态模型"></a>进程的挂起态与七状态模型</h4><p>暂时调到外存等待的进程状态为挂起状态（挂起态，suspend），挂起状态又可以进一步细分为就绪挂起、阻塞挂起两种状态</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gr45rbraq4j30wm0cwwpl.jpg"></p>
<h3 id="低级调度（进程调度-处理机调度）"><a href="#低级调度（进程调度-处理机调度）" class="headerlink" title="低级调度（进程调度/处理机调度）"></a>低级调度（进程调度/处理机调度）</h3><p>按照某种策略从就绪队列中选取一个进程，将处理机分配给它</p>
<p>进程调度是操作系统中最基本的一种调度，在一般的操作系统中都必须配置进程调度，进程调度的频率很高，一般几十毫秒一次</p>
<h2 id="三层调度的联系、对比"><a href="#三层调度的联系、对比" class="headerlink" title="三层调度的联系、对比"></a>三层调度的联系、对比</h2><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gr45th3bwkj30s20a4gun.jpg"></p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>操作系统原理</tag>
      </tags>
  </entry>
  <entry>
    <title>信号量机制</title>
    <url>/2020/10/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>1965年，荷兰学者Dijkstra提出了一种卓有成效的实现进程互斥、同步的方法：信号量机制</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gr687eyo3vj30um0d0gwa.jpg"></p>
<h2 id="整型信号量"><a href="#整型信号量" class="headerlink" title="整型信号量"></a>整型信号量</h2><p>用一个整数型的变量作为信号量，用来表示系统中某种资源的数量</p>
<p>与普通整数变量的区别：对信号量的操作只有三种，初始化、P操作、V操作</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gr68hvkdi5j30wm0dwgxt.jpg"></p>
<h2 id="记录型信号量"><a href="#记录型信号量" class="headerlink" title="记录型信号量"></a>记录型信号量</h2><p>整型信号量的缺陷是存在“忙等”问题，因此人们又提出了“记录型信号量”，即用记录型数据结构表示的信号量</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gr68or113ej60x80e0ani02.jpg"></p>
<p>⭐️有多少资源就把信号量初始值设为多少</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gr68sxn0t6j30xu0g47h5.jpg"></p>
<p>执行signal原语时：</p>
<ul>
<li>S.value + 1 后 &lt;= 0，说明有进程在等待资源</li>
<li>S.value + 1 后 &gt; 0，说明已经没有进程在等待资源</li>
</ul>
<p>注意：要能够自己推断在什么条件下需要执行block或wakeup</p>
<p>⭐️记录型信号量遵循了“让权等待”原则，不会出现“忙等”现象</p>
<h2 id="用信号量机制实现进程互斥"><a href="#用信号量机制实现进程互斥" class="headerlink" title="用信号量机制实现进程互斥"></a>用信号量机制实现进程互斥</h2><p>一个信号量对应一种资源</p>
<p>信号量的值 = 这种资源的剩余数量（信号量的值如果小于0，说明此时有进程在等待这种资源）</p>
<p>P(S)：申请一个资源S，如果资源不够就阻塞等待</p>
<p>V(S)：释放一个资源S，如果有进程在等待该资源，则唤醒一个进程</p>
<p>注意：</p>
<ul>
<li>对不同的临界资源需要设置不同的互斥信号量，如打印机这个临界资源设置mutex1 = 1，另一个摄像头临界资源设置mutex2 = 1</li>
<li>P、V操作必须成对出现，缺少P(mutex)就不能保证临界资源的互斥访问。缺少V(mutex)会导致资源永不被释放，等待进程永不被唤醒</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gr69lp2p57j30cs0ekdiu.jpg"></p>
<h2 id="用信号量机制实现进程同步"><a href="#用信号量机制实现进程同步" class="headerlink" title="用信号量机制实现进程同步"></a>用信号量机制实现进程同步</h2><p>进程同步：要让各并发进程按要求有序的推进</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gr69t0ky0hj30vi0bc43b.jpg"></p>
<p>❗️在“前操作”之后执行V(S)，在“后操作”之前执行P(V)</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gr69y11ehjj30uy0cwtk9.jpg"></p>
<h2 id="用信号量机制实现进程的前驱关系（进程同步）"><a href="#用信号量机制实现进程的前驱关系（进程同步）" class="headerlink" title="用信号量机制实现进程的前驱关系（进程同步）"></a>用信号量机制实现进程的前驱关系（进程同步）</h2><p>前驱关系问题，本质上就是多级同步问题</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gr6a4ohg3tj30xs0fik3d.jpg"></p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>操作系统原理</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统的体系结构</title>
    <url>/2020/10/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<p>操作系统：</p>
<ul>
<li>非内核功能（GUI）</li>
<li>内核（时钟管理、中断处理、原语(设备驱动、CPU切换等)、进程管理、存储器管理、设备管理等）</li>
</ul>
<p>原语是一种特殊的程序，具有原子性，也就是说，这段程序的运行必须一气呵成，不可被“中断”</p>
<h2 id="操作系统的内核"><a href="#操作系统的内核" class="headerlink" title="操作系统的内核"></a>操作系统的内核</h2><p>内核是操作系统最基本、最核心的部分，实现操作系统内核功能的那些程序就是内核程序</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gr2x8rbcdlj30xa0dwdqq.jpg"></p>
<p>现在，应用程序想要请求操作系统的服务，这个服务的处理同时涉及到进程管理、存储管理、设备管理（变态的过程是有成本的，要消耗不少时间，频繁的变态会降低系统性能）：</p>
<h3 id="大内核-单内核-宏内核（Linux、UNIX）"><a href="#大内核-单内核-宏内核（Linux、UNIX）" class="headerlink" title="大内核/单内核/宏内核（Linux、UNIX）"></a>大内核/单内核/宏内核（Linux、UNIX）</h3><p>将操作系统的主要功能模块都作为系统内核，运行在核心态</p>
<p>优点：高性能</p>
<p>缺点：内核代码庞大，结构混乱，难以维护</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gr2xdcuacxj30fo0dajv4.jpg"></p>
<h3 id="微内核（Windows-NT）"><a href="#微内核（Windows-NT）" class="headerlink" title="微内核（Windows NT）"></a>微内核（Windows NT）</h3><p>只把最基本的功能保留在内核</p>
<p>优点：内核功能少，结构清晰，方便维护</p>
<p>缺点：需要频繁的在核心态和用户态之间切换，性能低</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gr4xr89kv7j30fo0dajs5.jpg"></p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>操作系统原理</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统的四个特征</title>
    <url>/2020/10/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9B%9B%E4%B8%AA%E7%89%B9%E5%BE%81/</url>
    <content><![CDATA[<h2 id="操作系统的特征"><a href="#操作系统的特征" class="headerlink" title="操作系统的特征"></a>操作系统的特征</h2><ol>
<li>并发</li>
<li>共享</li>
<li>虚拟</li>
<li>异步</li>
</ol>
<p>并发和共享是操作系统两个最基本的特征，二者互为存在条件</p>
<h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><p>并发是指两个或多个事件在同一时间间隔内发生，这些事件宏观上是同时发生的，但微观上是交替发生的</p>
<p>并行是指两个或多个事件在同一时刻同时发生</p>
<p>操作系统的并发性是指计算机系统中“同时”运行着多个程序，这些程序宏观上看是同时运行着的，而微观上看是交替运行的，操作系统就是伴随着“多道程序技术”而出现的，因此操作系统和程序并发是一起诞生的</p>
<p>单核CPU同一时刻只能执行一个程序，各个程序只能并发的执行</p>
<p>多核CPU同一时刻可以同时执行多个程序，多个程序可以并行的执行</p>
<p>即使是对于4核CPU来说，只要有4个以上的程序需要“同时”运行，那么并发性依然是必不可少的，因此并发性是操作系统一个最基本的特性</p>
<h3 id="共享"><a href="#共享" class="headerlink" title="共享"></a>共享</h3><p>共享即资源共享，是指系统中的资源可供内存中多个并发执行的进程共同使用</p>
<ul>
<li>互斥共享方式：系统中的某些资源，虽然可以提供给多个进程使用，但一个时间段内只允许一个进程访问该资源【摄像头】</li>
<li>同时共享方式：系统中的某些资源，允许一个时间段内由多个进程“同时”对它们进行访问，所谓的“同时”往往是宏观上的，而在微观上，这些进程可能是交替的对该资源进行访问（即分时共享）【硬盘资源】</li>
</ul>
<h3 id="并发和共享的关系"><a href="#并发和共享的关系" class="headerlink" title="并发和共享的关系"></a>并发和共享的关系</h3><p>并发性指计算机系统中同时存在着多个运行着的程序</p>
<p>共享性是指系统中的资源可供内存中多个并发执行的进程共同使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">使用QQ发送文件A，同时使用微信发送文件B</span><br><span class="line">1.两个进程正在并发执行（并发性）</span><br><span class="line">2.需要共享的访问硬盘资源（共享性）</span><br><span class="line"></span><br><span class="line">如果失去并发性，则系统中只有一个程序正在运行，则共享性失去存在的意义</span><br><span class="line">如果失去共享性，则QQ和微信不能同时访问硬盘资源，就无法实现同时发送文件，也就无法并发</span><br></pre></td></tr></table></figure>

<h3 id="虚拟"><a href="#虚拟" class="headerlink" title="虚拟"></a>虚拟</h3><p>虚拟是指把一个物理上的实体变成若干个逻辑上的对应物，物理实体是实际存在的，而逻辑上对应物是用户感受到的</p>
<ul>
<li>空分复用技术：如虚拟存储器技术</li>
<li>时分复用技术：如虚拟处理器技术</li>
<li>显然，如果失去了并发性，则一个时间段内系统中只需运行一道程序，那么就失去了实现虚拟性的意义了，因此，没有并发性，就谈不上虚拟性</li>
</ul>
<h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><p>异步是指，在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底的，而是走走停停，以不可预知的速度向前推进，这就是进程的异步性</p>
<p>如果失去了并发性，即系统只能串行的运行各个程序，，那么每个程序的执行会一贯到底，只有系统拥有并发性，才有可能导致异步性</p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>操作系统原理</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统的概念、功能和目标</title>
    <url>/2020/10/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%A6%82%E5%BF%B5%E3%80%81%E5%8A%9F%E8%83%BD%E5%92%8C%E7%9B%AE%E6%A0%87/</url>
    <content><![CDATA[<h2 id="操作系统的概念"><a href="#操作系统的概念" class="headerlink" title="操作系统的概念"></a>操作系统的概念</h2><p>操作系统是指控制和管理整个计算机系统的硬件和软件资源，并合理的组织调度计算机的工作和资源的分配；以提供给用户和其他软件方便的接口和环境；它是计算机系统中最基本的系统软件</p>
<ul>
<li>操作系统是系统资源的管理者</li>
<li>向上层提供方便易用的服务</li>
<li>是最接近硬件的一层软件</li>
</ul>
<h2 id="操作系统的功能和目标"><a href="#操作系统的功能和目标" class="headerlink" title="操作系统的功能和目标"></a>操作系统的功能和目标</h2><ol>
<li>作为系统资源的管理者(目标：安全、高效)<ul>
<li>处理机管理</li>
<li>存储器管理</li>
<li>文件管理</li>
<li>设备管理</li>
</ul>
</li>
<li>向上层提供方便易用的服务<ul>
<li>封装思想：操作系统把一些丑陋的硬件功能封装成简单易用的服务，使用户能更方便的使用计算机，用户无需关心底层硬件的原理，只需要对操作系统发出命令即可</li>
<li>GUI：图形化用户接口，很多现代操作系统都提供GUI，用户可以使用形象的图形界面进行操作，而不再需要记忆复杂的命令、参数</li>
<li>命令接口<ul>
<li>联机命令接口，联机命令接口 = 交互式命令接口，特点是用户说一句，系统跟着做一句</li>
<li>脱机命令接口，脱机命令接口 = 批处理命令接口，特点是用户说一堆，系统跟着做一堆</li>
</ul>
</li>
<li>程序接口：可以在程序中进行系统调用来使用程序接口，普通用户不能直接使用程序接口，只能通过程序代码间接使用，系统调用类似于函数调用，是应用程序请求操作系统服务的唯一方式</li>
</ul>
</li>
<li>作为最接近硬件的层次<ul>
<li>需要实现对硬件机器的拓展，没有任何软件支持的计算机称为裸机，在裸机上安装的操作系统可以提供资源管理功能和方便用户的服务功能，将裸机改造成功能更强、使用更方便的机器，通常把覆盖了软件的机器称为扩充机器，又称为虚拟机</li>
<li>操作系统对硬件机器的扩展：将CPU、内存、磁盘、显示器、键盘等硬件合理的组织起来，让各种硬件能够相互协调配合，实现更多更复杂的功能</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>操作系统原理</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统的运行机制</title>
    <url>/2020/10/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>一条高级语言的代码翻译过来可能会对应多条机器指令</p>
<p>程序运行的过程其实就是CPU执行一条一条的机器指令的过程</p>
<p>二进制机器指令就是处理器CPU能识别、执行的最基本命令</p>
<h2 id="内核程序、应用程序"><a href="#内核程序、应用程序" class="headerlink" title="内核程序、应用程序"></a>内核程序、应用程序</h2><p>我们普通程序员写的程序就是“应用程序”</p>
<p>微软、苹果有一帮人负责实现操作系统，他们写的是“内核程序”</p>
<p>有很多内核程序组成了“操作系统内核”，或简称“内核（Kernel）”，内核是操作系统最重要最核心的部分，也是最接近硬件的部分，甚至可以说，一个操作系统只要有内核就够了，操作系统的功能未必都在内核中，如图形化用户界面GUI</p>
<h2 id="两种指令"><a href="#两种指令" class="headerlink" title="两种指令"></a>两种指令</h2><h3 id="特权指令"><a href="#特权指令" class="headerlink" title="特权指令"></a>特权指令</h3><p>操作系统内核作为“管理者”，有时会让CPU执行一些“特权指令”，如“内存清零指令”。这些指令影响重大，只允许“管理者”，即操作系统内核来使用</p>
<h3 id="非特权指令"><a href="#非特权指令" class="headerlink" title="非特权指令"></a>非特权指令</h3><p>应用程序只能使用“非特权指令”，如加法指令、减法指令等</p>
<p>在CPU设计和生产的时候就划分了特权指令和非特权指令，因此CPU执行一条指令前就能判断出其类型</p>
<p>问题：CPU能判断出指令类型，但是它怎么区分此时正在运行的是内核程序还是应用程序？</p>
<h2 id="两种处理器状态"><a href="#两种处理器状态" class="headerlink" title="两种处理器状态"></a>两种处理器状态</h2><h3 id="内核态（核心态、管态）"><a href="#内核态（核心态、管态）" class="headerlink" title="内核态（核心态、管态）"></a>内核态（核心态、管态）</h3><p>处于内核态时，说明此时正在运行的是内核程序，此时可以执行特权指令</p>
<h3 id="用户态（目态）"><a href="#用户态（目态）" class="headerlink" title="用户态（目态）"></a>用户态（目态）</h3><p>处于用户态时，说明此时正在运行的是应用程序，此时只能执行非特权指令</p>
<p>CPU中有一个寄存器叫程序状态字寄存器（PSW），其中有个二进制位，1表示“内核态”，0表示“用户态”</p>
<h2 id="内核态、用户态的切换"><a href="#内核态、用户态的切换" class="headerlink" title="内核态、用户态的切换"></a>内核态、用户态的切换</h2><blockquote>
<ol>
<li><p>刚开机时，CPU为“内核态”，操作系统内核程序先上CPU运行</p>
</li>
<li><p>开机完成后，用户可以启动某个应用程序，操作系统内核程序在合适的时候主动让出CPU，让该应用程序上CPU运行，应用程序运行在“用户态”（操作系统内核在让出CPU之前，会用一条特权指令把PSW的标志位设置为“用户态”）</p>
</li>
<li><p>此时，一位黑客在应用程序中植入了一条特权指令，企图破坏系统</p>
</li>
<li><p>CPU发现接下来要执行的这条指令是特权指令，但是自己又处于“用户态”，这个非法事件会引发一个中断信号，CPU检测到中断信号后，会立即变为“核心态”，并停止运行当前的应用程序，转而运行处理中断信号的内核程序</p>
</li>
<li><p>“中断”使操作系统再次夺回CPU的控制权，操作系统会对引发中断的事件进行处理，处理完了再把CPU使用权交给别的应用程序</p>
</li>
</ol>
</blockquote>
<p>内核态 -&gt; 用户态：执行一条特权指令，修改PSW的标志位为“用户态”，这个动作意味着操作系统将主动让出CPU使用权</p>
<p>用户态 -&gt; 内核态：由“中断”引发，硬件自动完成变态过程，触发中断信号意味着操作系统将强行夺回CPU的使用权（除了非法使用特权指令之外，还有很多事件会触发中断信号，一个共性是，但凡需要操作系统介入的地方，都会触发中断信号）</p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>操作系统原理</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统的发展与分类</title>
    <url>/2020/10/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8F%91%E5%B1%95%E4%B8%8E%E5%88%86%E7%B1%BB/</url>
    <content><![CDATA[<h2 id="手工操作阶段"><a href="#手工操作阶段" class="headerlink" title="手工操作阶段"></a>手工操作阶段</h2><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gr2l26qae6j30z80gc132.jpg"></p>
<h2 id="批处理阶段"><a href="#批处理阶段" class="headerlink" title="批处理阶段"></a>批处理阶段</h2><ul>
<li><p>单道批处理系统（操作系统的雏形）</p>
<p>引入脱机输入/输出技术（用外围机+磁带完成），并由监督程序负责控制作业的输入、输出</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gr2l7vhqayj30rg0c4afi.jpg"></p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gr2lekfqvaj30zc0ey79h.jpg"></p>
<p>主要优点：缓解了一定程度的人机速度矛盾，资源利用率有所提升</p>
<p>主要缺点：内存中仅能有一道程序运行，只有该程序运行结束之后才能调入下一道程序，CPU有大量的时间是在空闲等待I/O完成，资源利用率依然很低</p>
</li>
<li><p>多道批处理系统（操作系统开始出现）</p>
<p>每次往内存中读入多道程序，操作系统正式诞生，用于支持多道程序并发运行</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gr2liwmhb9j30y40f67do.jpg"></p>
</li>
</ul>
<h2 id="分时操作系统"><a href="#分时操作系统" class="headerlink" title="分时操作系统"></a>分时操作系统</h2><p>计算机以时间片为单位轮流为各个用户/作业服务，各个用户可通过终端与计算机进行交互</p>
<p>主要优点：用户请求可以被即时响应，解决了人机交互问题，允许多个用户同时使用一台计算机，并且用户对计算机的操作相互独立，感受不到别人的存在</p>
<p>主要缺点：不能优先处理一些紧急任务，操作系统对各个用户/作业都是完全公平的，循环的为每个用户/作业服务一个时间片，不区分任务的紧急性</p>
<h2 id="实时操作系统"><a href="#实时操作系统" class="headerlink" title="实时操作系统"></a>实时操作系统</h2><p>主要优点：能够优先响应一些紧急任务，某些紧急任务不需时间片排队</p>
<p>在实时操作系统的控制下，计算机系统接收到外部信号后及时进行处理，并且要在严格的时限内处理完事件，实时操作系统的主要特点是及时性和可靠性</p>
<ul>
<li>硬实时系统：必须在绝对严格的规定时间内完成处理（导弹控制系统、自动驾驶系统）</li>
<li>软实时系统：能接受偶尔违反时间规定（12306火车订票系统）</li>
</ul>
<h2 id="网络操作系统"><a href="#网络操作系统" class="headerlink" title="网络操作系统"></a>网络操作系统</h2><p>是伴随着计算机网络的发展而诞生的，能把网络中各个计算机有机的结合起来，实现数据传送等功能，实现网络中各种资源的共享（如文件共享）和各台计算机之间的通信</p>
<p>Windows NT就是一种典型的网络操作系统，网站服务器可以使用</p>
<h2 id="分布式操作系统"><a href="#分布式操作系统" class="headerlink" title="分布式操作系统"></a>分布式操作系统</h2><p>主要特点是分布性和并行性，系统中的各台计算机地位相同，任何工作都可以分布在这些计算机上，由它们并行、协同完成这个任务</p>
<h2 id="个人计算机操作系统"><a href="#个人计算机操作系统" class="headerlink" title="个人计算机操作系统"></a>个人计算机操作系统</h2><p>方便个人使用</p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>操作系统原理</tag>
      </tags>
  </entry>
  <entry>
    <title>管程</title>
    <url>/2020/10/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%AE%A1%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="为什么要引入管程"><a href="#为什么要引入管程" class="headerlink" title="为什么要引入管程"></a>为什么要引入管程</h2><p>信号量机制存在的问题：编写程序困难，易出错</p>
<p>能不能设计一种机制，让程序员写程序时不需要再关注复杂的PV操作，让写代码更轻松呢？</p>
<p>1973年，Brinch Hansen首次在程序设计语言（Pascal）中引入了“管程”成分：一种高级同步机制</p>
<h2 id="管程的定义和基本特征"><a href="#管程的定义和基本特征" class="headerlink" title="管程的定义和基本特征"></a>管程的定义和基本特征</h2><p>管程是一种特殊的软件模块，有这些部分组成：</p>
<ol>
<li>局部于管程的共享数据结构说明</li>
<li>对该数据结构进行操作的一组过程（过程其实就是“函数”）</li>
<li>对局部于管程的共享数据设置初始值的语句</li>
<li>管程有一个名字</li>
</ol>
<p>管程的基本特征：</p>
<ol>
<li>局部于管程的数据只能被局部于管程的过程所访问</li>
<li>一个进程只有通过调用管程内的过程才能进入管程访问共享数据</li>
<li>每次仅允许一个进程在管程内执行某个内部过程</li>
</ol>
<h2 id="用管程解决生产者消费者问题"><a href="#用管程解决生产者消费者问题" class="headerlink" title="用管程解决生产者消费者问题"></a>用管程解决生产者消费者问题</h2><p>每次仅允许一个进程在管程内执行某个内部过程：</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gr7k7bsyymj30g80es454.jpg"></p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gr7kbuudt7j30c00bcmzu.jpg"></p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gr7kkxz0emj30u80f4dtr.jpg"></p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>操作系统原理</tag>
      </tags>
  </entry>
  <entry>
    <title>系统调用</title>
    <url>/2020/10/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/</url>
    <content><![CDATA[<h2 id="什么是系统调用，有何作用？"><a href="#什么是系统调用，有何作用？" class="headerlink" title="什么是系统调用，有何作用？"></a>什么是系统调用，有何作用？</h2><p>操作系统作为用户和计算机硬件之间的接口，需要向上提供一些简单易用的服务，主要包括命令接口和程序接口，其中程序接口由一组系统调用组成</p>
<p>“系统调用”是操作系统提供给应用程序（程序员/编程人员）使用的接口，可以理解为一种可供应用程序调用的特殊函数，应用程序可以通过系统调用来请求获得操作系统内核的服务</p>
<h2 id="系统调用与库函数的区别"><a href="#系统调用与库函数的区别" class="headerlink" title="系统调用与库函数的区别"></a>系统调用与库函数的区别</h2><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gr2w9yjwn9j30xy0csaju.jpg"></p>
<h2 id="系统调用（按功能分类）"><a href="#系统调用（按功能分类）" class="headerlink" title="系统调用（按功能分类）"></a>系统调用（按功能分类）</h2><ol>
<li>设备管理：完成设备的请求/释放/启动等功能</li>
<li>文件管理：完成文件的读/写/创建/删除等功能</li>
<li>进程控制：完成进程的创建/撤销/阻塞/唤醒等功能</li>
<li>进程通信：完成进程之间的消息传递/信号传递等功能</li>
<li>内存管理：完成内存的分配/回收等功能</li>
</ol>
<h2 id="什么功能要用到系统调用（Word和WPS同时使用打印机）"><a href="#什么功能要用到系统调用（Word和WPS同时使用打印机）" class="headerlink" title="什么功能要用到系统调用（Word和WPS同时使用打印机）"></a>什么功能要用到系统调用（Word和WPS同时使用打印机）</h2><p>应用程序通过系统调用请求操作系统的服务，而系统中的各种共享资源都由操作系统内核统一掌管，因此凡是与共享资源有关的操作（如存储分配、I/O操作、文件管理等），都必须通过系统调用的方式向操作系统内核提出服务请求，由操作系统内核代为完成，这样可以保证系统的稳定性和安全性，防止用户进行非法操作</p>
<h2 id="系统调用的过程"><a href="#系统调用的过程" class="headerlink" title="系统调用的过程"></a>系统调用的过程</h2><ol>
<li>传递系统调用参数</li>
<li>执行陷入指令（用户态）</li>
<li>执行相应的内请求核程序处理系统调用（核心态）</li>
<li>返回应用程序</li>
</ol>
<p>注意：</p>
<ul>
<li>陷入指令是在用户态执行的，执行陷入指令之后立即引发一个内中断，使CPU进入核心态</li>
<li>发出系统调用请求是在用户态，而对系统调用的相应处理在核心态下进行</li>
</ul>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>操作系统原理</tag>
      </tags>
  </entry>
  <entry>
    <title>线程概念、多线程模型</title>
    <url>/2020/10/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%BA%BF%E7%A8%8B%E6%A6%82%E5%BF%B5%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="什么是线程，为什么要引入线程"><a href="#什么是线程，为什么要引入线程" class="headerlink" title="什么是线程，为什么要引入线程"></a>什么是线程，为什么要引入线程</h2><ul>
<li>还没引入进程之前，系统中各个程序只能串行执行</li>
<li>引入进程之后，可以边听音乐边玩QQ</li>
<li>引入线程之后，在QQ里可以边聊天边传送文件等</li>
</ul>
<p>传统的进程是程序执行流的最小单位，引入线程后，线程成为了程序执行流的最小单位</p>
<p>线程是一个基本的CPU执行单元，也是程序执行流的最小单位，引入线程之后，不仅是进程之间可以并发，进程内的各线程之间也可以并发，从而进一步提升了系统的并发度，使得一个进程内也可以并发处理各种任务</p>
<p>引入线程后，进程只作为除CPU之外的系统资源的分配单元（如打印机、内存地址空间等都是分配给进程的）</p>
<h2 id="引入线程机制后，有什么变化"><a href="#引入线程机制后，有什么变化" class="headerlink" title="引入线程机制后，有什么变化"></a>引入线程机制后，有什么变化</h2><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gr3zbx340pj60xk0ba7ch02.jpg"></p>
<h2 id="线程有哪些重要的属性"><a href="#线程有哪些重要的属性" class="headerlink" title="线程有哪些重要的属性"></a>线程有哪些重要的属性</h2><ul>
<li>线程是处理机调度的单位</li>
<li>多CPU计算机中，各个线程可占用不同的CPU</li>
<li>每一个线程都有一个线程ID、线程控制块TCB</li>
<li>线程也有就绪、阻塞、运行三种基本状态</li>
<li>线程几乎不拥有系统资源</li>
<li>同一进程的不同线程间共享进程的资源</li>
<li>由于共享内存地址空间，同一进程中的线程间通信甚至无需系统干预</li>
<li>同一进程中的线程切换，不会引起进程切换</li>
<li>不同进程中的线程切换，会引起进程切换</li>
<li>切换同进程内的线程，系统开销很小</li>
<li>切换进程，系统开销较大</li>
</ul>
<h2 id="线程的实现方式"><a href="#线程的实现方式" class="headerlink" title="线程的实现方式"></a>线程的实现方式</h2><h3 id="用户级线程ULT（从用户视角能看到的线程）"><a href="#用户级线程ULT（从用户视角能看到的线程）" class="headerlink" title="用户级线程ULT（从用户视角能看到的线程）"></a>用户级线程ULT（从用户视角能看到的线程）</h3><p>早期的操作系统（早期Unix）只支持进程，不支持线程，当时的“线程”是由线程库实现的</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gr3zyfvjskj60xk0eegw902.jpg"></p>
<h3 id="内核级线程KLT（从操作系统视角看到的线程）"><a href="#内核级线程KLT（从操作系统视角看到的线程）" class="headerlink" title="内核级线程KLT（从操作系统视角看到的线程）"></a>内核级线程KLT（从操作系统视角看到的线程）</h3><p>由操作系统支持的线程，内核级线程才是处理机分配的单位</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gr403s76pij30w60datkd.jpg"></p>
<h2 id="多线程模型"><a href="#多线程模型" class="headerlink" title="多线程模型"></a>多线程模型</h2><p>在支持内核级线程的系统下，通过用户级线程和内核级线程的映射关系，可以划分为几种多线程模型</p>
<h3 id="一对一模型"><a href="#一对一模型" class="headerlink" title="一对一模型"></a>一对一模型</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gr409ngqtrj30w80dggte.jpg"></p>
<h3 id="多对一模型（相当于用户级线程ULT）"><a href="#多对一模型（相当于用户级线程ULT）" class="headerlink" title="多对一模型（相当于用户级线程ULT）"></a>多对一模型（相当于用户级线程ULT）</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gr40bo1wnlj30we0dwdof.jpg"></p>
<h3 id="多对多模型（集二者之所长）"><a href="#多对多模型（集二者之所长）" class="headerlink" title="多对多模型（集二者之所长）"></a>多对多模型（集二者之所长）</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gr40eanmmtj30xy0g4dvr.jpg"></p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>操作系统原理</tag>
      </tags>
  </entry>
  <entry>
    <title>调度算法</title>
    <url>/2020/10/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>饥饿：某进程/作业长期得不到服务</p>
<h2 id="先来先服务FCFS"><a href="#先来先服务FCFS" class="headerlink" title="先来先服务FCFS"></a>先来先服务FCFS</h2><p>按照作业/进程到达的先后顺序进行服务，事实上就是等待时间越久的越优先得到服务</p>
<p>用于作业调度时，考虑的是哪个作业先到达后备队列（外存中）；用于进程调度时，考虑的是哪个进程先到达就绪队列（内存中）</p>
<p>非抢占式算法</p>
<p>优点：公平、算法实现简单</p>
<p>缺点：排在长作业（进程）后面的短作业需要等待很长时间，带权周转时间很大，对短作业来说用户体验不好，即FCFS算法对长作业有利，对短作业不利</p>
<p>不会导致饥饿</p>
<h2 id="最短作业优先SJF"><a href="#最短作业优先SJF" class="headerlink" title="最短作业优先SJF"></a>最短作业优先SJF</h2><p>追求最少的平均等待时间、最少的平均周转时间、最少的平均带权周转时间</p>
<p>最短的作业/进程优先得到服务（所谓最短是指要求服务时间最短），每次调度时选择当前已到达的且运行时间最短的作业/进程</p>
<p>既可用于作业调度，也可用于进程调度，用于进程调度时称为“短进程优先算法SPF”</p>
<p>SJF和SPF是非抢占式的算法，但是也有抢占式的版本：最短剩余时间优先算法SRTN</p>
<p>最短剩余时间优先算法：每当有进程加入就绪队列改变时就需要调度，如果新到达的进程剩余时间比当前运行的进程剩余时间更短，则由新进程抢占处理机，当前运行进程重新回到就绪队列。另外，当一个进程完成时也需要调度</p>
<p>优点：“最短的”平均等待时间、平均周转时间</p>
<p>缺点：不公平，对短作业有利，对长作业不利。作业/进程的运行时间是由用户提供的，并不一定真实，不一定能做到真正的短作业优先</p>
<p>可能产生饥饿现象，如果源源不断的有短作业/进程到来，可能使长作业/进程长时间得不到服务，产生饥饿现象，如果一直得不到服务，则称为饿死</p>
<p>平均等待时间、平均周转时间、平均带权周转时间由小到大：SRTN、SJF/SPF、FCFS</p>
<h2 id="最高响应比优先HRRN"><a href="#最高响应比优先HRRN" class="headerlink" title="最高响应比优先HRRN"></a>最高响应比优先HRRN</h2><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gr4ugd2evkj30hs0ck45s.jpg"></p>
<p>在每次调度时先计算各个作业/进程的响应比，选择响应比最高的作业/进程为其服务</p>
<p>响应比 = （等待时间+要求服务时间）/ 要求服务时间【响应比 &gt;= 1】</p>
<p>即可用于作业调度，也可用于进程调度</p>
<p>非抢占式的算法，因此只有当前运行的作业/进程主动放弃处理机时，才需要调度，才需要计算响应比</p>
<p>综合考虑了等待时间和运行时间（要求服务时间），等待时间相同时，要求服务时间短的优先（SJF的优点），要求服务时间相同时，等待时间长的优先（FCFS的优点），对于长作业来说，随着等待时间越来越久，其响应比也会越来越大，从而避免了长作业饥饿的问题</p>
<p>⭐️以上三种算法主要关心对用户的公平性、平均周转时间、平均等待时间等评价系统整体性能的指标，但是不关心“响应时间”，也并不区分任务的紧急程度，因此对于用户来说，交互性很糟糕，因此这三种算法一般适合用于早期的批处理系统，当然，FCFS算法也常结合其他的算法来使用，在现在也扮演着很重要的角色</p>
<h2 id="时间片轮转RR"><a href="#时间片轮转RR" class="headerlink" title="时间片轮转RR"></a>时间片轮转RR</h2><p>公平的、轮流的为各个进程服务，让每个进程在一定时间间隔内都可以得到响应</p>
<p>按照各进程到达就绪队列的顺序，轮流让各个进程执行一个时间片（如100ms），若进程未在一个时间片内执行完，则剥夺处理机，将进程重新放到就绪队列队尾重新排队</p>
<p>用于进程调度（只有作业放入内存建立了相应的进程后，才能被分配处理机时间片）</p>
<p>若进程未能在时间片内运行完，将被强行剥夺处理机使用权，因此时间片轮转调度算法属于抢占式的算法，由时钟装置发出时钟中断来通知CPU时间片已到</p>
<p>如果时间片太大，使得每个进程都可以在一个时间片内就完成，则时间片轮转调度算法退化为先来先服务调度算法，并且会增大进程响应时间，因此时间片不能太大</p>
<p>另一方面，进程调度、切换是有时间代价的（保存、恢复运行环境），因此如果时间片太小，会导致进程切换过于频繁，系统会花大量的时间来处理进程切换，从而导致实际用于进程执行的时间比例减少，可见时间片也不能太小</p>
<p>优点：公平、响应快、适用于分时操作系统</p>
<p>缺点：由于高频率的进程切换，因此有一定的开销；不区分任务的紧急程度</p>
<p>不会导致饥饿</p>
<h2 id="优先级调度"><a href="#优先级调度" class="headerlink" title="优先级调度"></a>优先级调度</h2><p>随着计算机的发展，特别是实时操作系统的出现，越来越多的应用场景需要根据任务的紧急程度来决定处理顺序</p>
<p>每个作业/进程有各自的优先级，调度时选择优先级最高的作业/进程</p>
<p>既可用于作业调度，也可用于进程调度，甚至还会用于I/O调度中</p>
<p>抢占式、非抢占式都有，非抢占式只需在进程主动放弃处理机时进行调度即可，而抢占式还需在就绪队列变化时，检查是否会发生抢占</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gr4w8jzpvcj30x20f2dw7.jpg"></p>
<p>优点：用优先级区分紧急程度、重要程度，适用于实时操作系统。可灵活的调整对各种作业/进程的偏好程度</p>
<p>缺点：若源源不断的有高优先级进程到来，则可能导致饥饿</p>
<h2 id="多级反馈队列"><a href="#多级反馈队列" class="headerlink" title="多级反馈队列"></a>多级反馈队列</h2><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gr4wdcc4oxj30ee0cytey.jpg"></p>
<p>对其他调度算法的折中权衡</p>
<p>设置多级就绪队列，各级队列优先级从高到低，时间片从小到大；新进程到达时先进入第1级队列，按FCFS原则排队等待被分配时间片，若用完时间片进程还不结束，则进程进入下一级队列队尾，如果此时已经是在最下级的队列，则重新放回该队列队尾；只有第k级队列为空时，才会为k+1级队头的进程分配时间片</p>
<p>用于进程调度</p>
<p>抢占式的算法，在k级队列的进程运行过程中，若更上级的队列（1～k-1级）中进入了一个新进程，则由于新进程处于优先级更高的队列中，因此新进程会抢占处理机，原来运行的进程放回k级队列队尾</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gr4wrcgzm1j30wg08g43w.jpg"></p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gr4wswq556j30wg09cdll.jpg"></p>
<p>优点：</p>
<ul>
<li>对各类型进程相对公平（FCFS的优点）</li>
<li>每个新到达的进程都可以很快就得到响应（RR的优点）</li>
<li>短进程只用较少的时间就可完成（SPF的优点）</li>
<li>不必实现估计进程的运行时间（避免用户作假）</li>
<li>可灵活的调整对各类进程的偏好程度，比如CPU密集型进程、I/O密集型进程（可以将因I/O而阻塞的进程重新放回原队列，而不放回下一级队列，这样I/O型进程就可以保持较高优先级）</li>
</ul>
<p>会导致饥饿，如果源源不断的有短进程到达的话，这种进程在第一级队列中就可以被处理完，已经被降级的进程就有可能导致饥饿</p>
<p>⭐️比起早期的批处理操作系统来说，由于计算机造价大幅降低，因此之后出现的交互式操作系统（包括分时操作系统、实时操作系统等）更注重系统的响应时间、公平性、平衡性等指标。而以上这三种算法恰好也能较好的满足交互式系统的需求。因此这三种算法适合用于交互式系统（比如UNIX使用的就是多级反馈队列调度算法）</p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>操作系统原理</tag>
      </tags>
  </entry>
  <entry>
    <title>经典进程同步互斥问题</title>
    <url>/2020/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%BB%8F%E5%85%B8%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%BA%92%E6%96%A5%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="生产者-消费者问题（互斥、同步综合问题）"><a href="#生产者-消费者问题（互斥、同步综合问题）" class="headerlink" title="生产者-消费者问题（互斥、同步综合问题）"></a>生产者-消费者问题（互斥、同步综合问题）</h2><p>系统中有一组生产者进程和一组消费者进程，生产者进程每次生产一个产品放入缓冲区，消费者进程每次从缓冲区中取出一个产品并使用</p>
<ul>
<li>生产者、消费者共享一个初始为空、大小为n的缓冲区</li>
<li>只有缓冲区没满时，生产者才能把产品放入缓冲区，否则必须等待（进程同步：缓冲区没满 -&gt; 生产者生产）</li>
<li>只有缓冲区不空时，消费者才能从中取出产品，否则必须等待（进程同步：缓冲区没空 -&gt; 消费者消费）</li>
<li>缓冲区是临界资源，各进程必须互斥访问（如果两个生产者进程并发运行，同时往缓冲区的同一块区域放入数据，会出现问题）（互斥关系）</li>
</ul>
<p>❗️互斥信号量初值一般为1，同步信号量的初始值要看对应资源的初始值是多少</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gr6laawr80j30sq09e432.jpg"></p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gr6lq5y0m3j30zi08s10u.jpg"></p>
<p>能否改变相邻P、V操作的顺序？</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gr6m1k0or9j30uo0g8wpp.jpg"></p>
<p>“生产一个产品”、“使用产品”这两句话逻辑上是可以放到PV操作之间，但是这样会增加临界区的代码，会导致进程的并发度降低，对系统的效能产生影响，造成不便</p>
<h2 id="多生产者-多消费者问题"><a href="#多生产者-多消费者问题" class="headerlink" title="多生产者-多消费者问题"></a>多生产者-多消费者问题</h2><ul>
<li>桌子上有一只盘子，每次只能向其中放入一个水果。（大小为1，初始为空的缓冲区）</li>
<li>爸爸专向盘子中放苹果，妈妈专向盘子中放橘子，儿子专等着吃盘子中的橘子，女儿专等着吃盘子中的苹果。</li>
<li>只有盘子空时，爸爸或妈妈才可向盘子中放一个水果。仅当盘子中有自己需要的水果时，儿子或女儿可以从盘子中取出水果。用PV操作实现上述过程</li>
</ul>
<blockquote>
<p>互斥关系：对缓冲区（盘子）的访问要互斥的进行</p>
<p>同步关系（一前一后）：</p>
<ol>
<li>盘子中有苹果，女儿才能取苹果</li>
<li>盘子中有橘子，儿子才能取橘子</li>
<li>只有盘子为空时，父亲或母亲才能放入水果（“盘子为空”这个事件可以由儿子或女儿触发，事件发生后才允许父亲或母亲放水果）</li>
</ol>
</blockquote>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gr74k8k33bj30lk03otac.jpg"></p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gr74kxspraj30yc08k0y4.jpg"></p>
<p>问题：可不可以不用互斥信号量</p>
<p>分析：刚开始，儿子、女儿进程即使上处理机运行也会被阻塞，如果刚开始是父亲进程先上处理机运行，则父亲P(plate)，可以访问盘子 -&gt; 母亲P(plate)，阻塞等待盘子 -&gt; 父亲放入苹果V(apple)，女儿进程被唤醒，其他进程即使运行也都会阻塞，暂时不能访问临界资源（盘子） -&gt; 女儿P(apple)，访问盘子，V(plate)，等待盘子的母亲进程被唤醒 -&gt; 母亲进程访问盘子（其他进程暂时无法进入临界区） -&gt; …</p>
<p>结论：即使不设置专门的互斥变量mutex，也不会出现多个进程同时访问盘子的现象</p>
<p>原因：本题中的缓冲区大小为1，在任何时刻，apple、orange、plate三个同步信号量中最多只有一个是1，因此在任何时刻，最多只有一个进程的P操作不会被阻塞，并顺利的进入临界区</p>
<p>如果盘子的容量（缓冲区）设为2，可能出现两个进程同时访问缓冲区的情况，有可能导致两个进程写入缓冲区的数据相互覆盖的情况</p>
<p>❗️因此，如果缓冲区大小大于1，就必须专门设置一个互斥信号量mutex来保证互斥访问缓冲区</p>
<h2 id="吸烟者问题（可生产多种产品的单生产者-多消费者）"><a href="#吸烟者问题（可生产多种产品的单生产者-多消费者）" class="headerlink" title="吸烟者问题（可生产多种产品的单生产者-多消费者）"></a>吸烟者问题（可生产多种产品的单生产者-多消费者）</h2><p>假设一个系统有三个抽烟者进程和一个供应者进程。每个抽烟者不停的卷烟并抽掉它，但是要卷起并抽掉一支烟，抽烟者需要有三种材料：烟草、纸和胶水。三个抽烟者中，第一个拥有烟草、第二个拥有纸、第三个拥有胶水。供应者进程无限的提供三种材料，供应者每次将两种材料放桌子上，拥有剩下那种材料的抽烟者卷一根烟并抽掉它，并给供应者进程一个信号告诉它完成了，供应者就会放另外两种材料在桌上，这个过程一直重复（让三个抽烟者轮流的抽烟）</p>
<blockquote>
<p>互斥关系：桌子可以抽象为容量为1的缓冲区，要互斥访问（这个容量为1表示组合）</p>
<ul>
<li>组合一：纸+胶水</li>
<li>组合二：烟草+胶水</li>
<li>组合三：烟草+纸</li>
</ul>
<p>同步关系（从事件的角度来分析）：</p>
<ul>
<li>桌上有组合一，第一个抽烟者取走东西</li>
<li>桌上有组合二，第二个抽烟者取走东西</li>
<li>桌上有组合三，第三个抽烟者取走东西</li>
<li>发出完成信号，供应者将下一个组合放到桌上</li>
</ul>
</blockquote>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gr75zlril5j30m804g0ut.jpg"></p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gr760fec1kj309u0ccmyx.jpg"></p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gr760yojo9j30pi06wtcj.jpg"></p>
<h2 id="读者-写者问题（复杂的互斥问题）"><a href="#读者-写者问题（复杂的互斥问题）" class="headerlink" title="读者-写者问题（复杂的互斥问题）"></a>读者-写者问题（复杂的互斥问题）</h2><p>有读者和写者两组并发进程，共享一个文件，当两个或两个以上的读进程同时访问共享数据时不会产生副作用，但若某个写进程和其他进程（读进程或写进程）同时访问共享数据时则可能导致数据不一致的错误，因此要求：</p>
<ol>
<li>允许多个读者可以同时对文件执行读操作（与消费者进程不同，读者进程在读数据后并不会将数据清空，并不会改变数据。因此多个读者进程可同时访问共享数据）</li>
<li>只允许一个写者往文件中写信息</li>
<li>任一写者在完成写操作之前不允许其他读者或写者工作（两个写进程同时共享数据，可能导致数据错误覆盖的问题）（读进程与写进程同时共享数据，可能导致读出的数据不一致的问题）</li>
<li>写者执行写操作前，应让已有的读者和写者全部退出</li>
</ol>
<blockquote>
<p>两类进程：写进程、读进程</p>
<p>互斥关系：写进程-写进程、写进程-读进程（读进程-读进程不存在互斥问题）</p>
</blockquote>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gr76qrlmtuj30x602wmzl.jpg"></p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gr76r4cgpuj30e0064ab7.jpg"></p>
<p>思考：若两个读进程并发执行，则count=0时两个进程也许都能满足if条件，都会执行P(rw)，从而使第二个读进程阻塞的情况</p>
<p>如何解决：出现上述问题的原因在于对count变量的检查和赋值无法一气呵成，因此可以设置另一个互斥信号量来保证各读者进程对count的访问是互斥的</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gr76rhfoihj30i00cmjw7.jpg"></p>
<p>潜在的问题：只要有读进程还在读，写进程就要一直阻塞等待，可能“饿死”。因此这种算法中，读进程是优先的</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gr77xgaynfj30ko03owh8.jpg"></p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gr77xwelc1j306u07u751.jpg"></p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gr77y8mjfaj30by0ecmzv.jpg"></p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gr77yv8mrwj60a405k75t02.jpg"></p>
<p>结论；在这种算法中，连续进入的多个读者可以同时读文件；写者和其他进程不能同时访问文件；写者不会饥饿，但也并不是真正的“写优先”，而是相对公平的先来先服务原则。有的书上把这种算法称为“读写公平法”</p>
<h2 id="哲学家进餐问题（解决进程死锁）"><a href="#哲学家进餐问题（解决进程死锁）" class="headerlink" title="哲学家进餐问题（解决进程死锁）"></a>哲学家进餐问题（解决进程死锁）</h2><p>一张圆桌上坐着5名哲学家，每两个哲学家之间的桌上摆一根筷子，桌子的中间是一碗米饭。哲学家们倾注毕生的精力用于思考和进餐，哲学家在思考时，并不影响其他人。只有当哲学家饥饿时，才试图拿起左、右两根筷子（一根一根的拿起）。如果筷子已在他人手上，则需等待。饥饿的哲学家只有同时拿起两根筷子才可以开始进餐，当进餐完毕后，放下筷子继续思考</p>
<blockquote>
<p>系统中有5个哲学家进程，5位哲学家与左右邻居对其中间筷子的访问是互斥关系</p>
<p>这个问题中只有互斥关系，但与之前遇到的问题不同的是，每个哲学家进程需要同时持有两个临界资源才能开始吃饭。如何避免临界资源分配不当造成的死锁现象，是哲学家问题的精髓</p>
<p>定义互斥信号量数组chopstick[5] = {1,1,1,1,1}，用于实现对5个筷子的互斥访问，并对哲学家按0～4编号，哲学家i左边的筷子编号为i，右边的筷子编号为(i+1) % 5</p>
</blockquote>
<p>如果5个哲学家并发的拿起了自己左手边的筷子，每位哲学家循环等待右边的人放下筷子（阻塞），发生“死锁”</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gr7iaeeswoj30fm098tb3.jpg"></p>
<p>解决方法：</p>
<ol>
<li><p>可以对哲学家进程施加一些限制条件，比如最多只允许四个哲学家同时进餐。这样可以保证至少有一个哲学家是可以拿到左右两只筷子的</p>
</li>
<li><p>要求奇数号哲学家先拿左边的筷子，然后再拿右边的筷子，而偶数号哲学家刚好相反。用这种方法可以保证如果相邻的两个奇偶号哲学家都想吃饭，那么只会有其中一个可以拿起第一支筷子，另一个会直接阻塞。这就避免了占有一支后再等待另一只的情况</p>
</li>
<li><p>仅当一个哲学家左右两支筷子都可用时才允许他抓起筷子</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gr7im97i56j30gg0bsmzw.jpg"></p>
</li>
</ol>
<p>画图可知，进程分别调度哲学家0、1、2时可发现，哲学家0可正常吃饭，哲学家1被阻塞，哲学家2虽然左右都有筷子，但是他也被阻塞</p>
<p>进程分别调度0、4时，哲学家0可正常吃饭，哲学家4右边的筷子不可用，但是4仍然可以拿起左边的筷子，因此这种方法并不能保证只有两边的筷子都可用时，才允许哲学家拿起筷子</p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>操作系统原理</tag>
      </tags>
  </entry>
  <entry>
    <title>调度算法的评价指标</title>
    <url>/2020/10/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E7%9A%84%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/</url>
    <content><![CDATA[<h2 id="CPU利用率"><a href="#CPU利用率" class="headerlink" title="CPU利用率"></a>CPU利用率</h2><p>由于早期的CPU造价极其昂贵，因此人们会希望让CPU尽可能多的工作</p>
<p>CPU利用率：指CPU“忙碌”的时间占总时间的比例</p>
<h2 id="系统吞吐量"><a href="#系统吞吐量" class="headerlink" title="系统吞吐量"></a>系统吞吐量</h2><p>对于计算机来说，希望能用尽可能少的时间处理完尽可能多的作业</p>
<p>系统吞吐量：单位时间内完成作业的数量（总共完成了多少道作业/总共花了多少时间）</p>
<h2 id="周转时间"><a href="#周转时间" class="headerlink" title="周转时间"></a>周转时间</h2><h3 id="周转时间-1"><a href="#周转时间-1" class="headerlink" title="周转时间"></a>周转时间</h3><p>对于计算机的用户来说，他很关心自己的作业从提交到完成花了多少时间</p>
<p>周转时间：是指从作业被提交给系统开始，到作业完成为止的这段时间间隔，它包括四个部分，作业在外存后备队列上等待作业调度（高级调度）的时间、进程在就绪队列上等待进程调度（低级调度）的时间、进程在CPU上执行的时间、进程等待I/O操作完成的时间。后三项在一个作业的整个处理过程中，可能发生多次</p>
<p>（作业）周转时间 = 作业完成时间 - 作业提交时间（对于用户来说，更关心自己的单个作业的周转时间）</p>
<h3 id="平均周转时间"><a href="#平均周转时间" class="headerlink" title="平均周转时间"></a>平均周转时间</h3><p>平均周转时间 = 各作业周转时间之和 / 作业数（对于操作系统来说，更关心系统的整体表现，因此更关心所有作业周转时间的平均值）</p>
<h3 id="带权周转时间"><a href="#带权周转时间" class="headerlink" title="带权周转时间"></a>带权周转时间</h3><p>有的作业运行时间短，有的作业运行时间长，因此在周转时间相同的情况下，运行时间不同的作业，给用户的感觉肯定是不一样的</p>
<p>带权周转时间 = 作业周转时间 / 作业实际运行的时间</p>
<p>带权周转时间必然 &gt;= 1，带权周转时间与周转时间都是越小越好</p>
<p>对于周转时间相同的两个作业，实际运行时间长的作业在相同时间内被服务的时间更多，带权周转时间更小，用户满意度更高</p>
<p>对于实际运行时间相同的两个作业，周转时间短的带权周转时间更小，用户满意度更高</p>
<h3 id="平均带权周转时间"><a href="#平均带权周转时间" class="headerlink" title="平均带权周转时间"></a>平均带权周转时间</h3><p>平均带权周转时间 = 各作业带权周转时间之和 / 作业数</p>
<h2 id="等待时间：周转时间-运行时间（如果有I-O操作的过程，还要减去I-O操作的时间）"><a href="#等待时间：周转时间-运行时间（如果有I-O操作的过程，还要减去I-O操作的时间）" class="headerlink" title="等待时间：周转时间 - 运行时间（如果有I/O操作的过程，还要减去I/O操作的时间）"></a>等待时间：周转时间 - 运行时间（如果有I/O操作的过程，还要减去I/O操作的时间）</h2><p>计算机的用户希望自己的作业尽可能少的等待处理机</p>
<p>等待时间，指进程/作业处于等待处理机状态时间之和，等待时间越长，用户满意度越低</p>
<p>对于进程来说，等待时间就是指进程建立后等待被服务的时间之和，在等待I/O完成的期间其实进程也是在被服务的，所以不计入等待时间</p>
<p>对于作业来说，不仅要考虑建立进程后的等待时间，还要加上作业在外存后备队列中等待的时间</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gr4s7qq3cwj30vy07wn6q.jpg"></p>
<p>一个作业总共需要被CPU服务多久、被I/O设备服务多久一般是确定不变的，因此调度算法其实只会影响作业/进程的等待时间</p>
<p>与前面的指标类似，也有“平均等待时间”来评价整体性能</p>
<h2 id="响应时间"><a href="#响应时间" class="headerlink" title="响应时间"></a>响应时间</h2><p>对于计算机用户来说，会希望自己的提交的请求（比如通过键盘输入了一个调试命令）尽早的开始被系统服务、回应</p>
<p>响应时间，指从用户提交请求到首次产生响应所用的时间</p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>操作系统原理</tag>
      </tags>
  </entry>
  <entry>
    <title>进程的概念、组成、特征</title>
    <url>/2020/10/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5%E3%80%81%E7%BB%84%E6%88%90%E3%80%81%E7%89%B9%E5%BE%81/</url>
    <content><![CDATA[<h2 id="进程的概念"><a href="#进程的概念" class="headerlink" title="进程的概念"></a>进程的概念</h2><p>程序：是静态的，就是个存放在磁盘里的可执行文件，就是一系列的指令集合</p>
<p>进程（Process）：是动态的，是程序的一次执行过程，同一个程序多次执行会对应多个进程</p>
<p>进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位（一个进程被调度，就是指操作系统决定让这个进程上CPU运行）</p>
<h2 id="进程的组成：PCB、程序段、数据段"><a href="#进程的组成：PCB、程序段、数据段" class="headerlink" title="进程的组成：PCB、程序段、数据段"></a>进程的组成：PCB、程序段、数据段</h2><p>操作系统是进程的管理者，当进程被创建时，操作系统会为该进程分配一个唯一的、不重复的“身份证号”：PID（Process ID，进程ID）</p>
<ul>
<li>操作系统要记录PID、进程所属用户ID（UID）：基本的进程描述信息，可以让操作系统区分各个进程</li>
<li>还要记录给进程分配了哪些资源（分配了多少内存、正在使用哪些I/O设备、正在使用哪些文件）：可用于实现操作系统对资源的管理</li>
<li>还要记录进程的运行情况（CPU使用时间、磁盘使用情况、网络流量使用情况、进程当前的状态：就绪态/阻塞态/运行态）：可用于实现操作系统对进程的控制、调度</li>
<li>处理机相关信息：PSW、PC等各种寄存器的值，用于实现进程切换</li>
</ul>
<p>这些信息都被保存在一个数据结构PCB（Process Control Block）中，即进程控制块，操作系统需要对各个并发运行的进程进行管理，但凡管理时所需要的信息，都会被放在PCB中</p>
<p>PCB是进程存在的唯一标志，当进程被创建时，操作系统为其创建PCB，当进程结束时，会回收其PCB</p>
<p>程序段：程序的代码（指令序列）</p>
<p>数据段：运行过程中产生的各种数据（如程序中定义的变量）</p>
<p>PCB是给操作系统用的，程序段和数据段是给进程自己用的，与进程自身的运行逻辑有关</p>
<p>一个进程实体（进程映像）由PCB、程序段、数据段组成，进程是动态的，进程实体（进程映像）是静态的，进程实体反映了进程在某一时刻的状态</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gr3o9azpgxj30wc0fyqd1.jpg"></p>
<h2 id="进程的特征"><a href="#进程的特征" class="headerlink" title="进程的特征"></a>进程的特征</h2><p>程序是静态的，进程是动态的，相比于程序，进程拥有以下特征：</p>
<ul>
<li>动态性：进程是程序的一次执行过程，是动态的产生、变化和消亡的，动态性是进程最基本的特征</li>
<li>并发性：内存中有多个进程实体，各进程可并发执行</li>
<li>独立性：进程是能独立运行、独立获得资源、独立接受调度的基本单位</li>
<li>异步性：各进程按各自独立的、不可预知的速度向前推进，操作系统要提供“进程同步机制”来解决异步问题</li>
<li>结构性：每个进程都会配置一个PCB，结构上看，进程由程序段、数据段、PCB组成</li>
</ul>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>操作系统原理</tag>
      </tags>
  </entry>
  <entry>
    <title>进程控制</title>
    <url>/2020/10/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<p>进程控制的主要功能是对系统中的所有进程实施有效的管理，它具有创建新进程、撤销已有进程、实现进程状态转换等功能</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gr3q0kpcv2j30vo08a77r.jpg"></p>
<p>如何实现进程控制：用“原语”实现，原语的执行具有“原子性”，一气呵成</p>
<p>如果不能“一气呵成”，就有可能导致操作系统中的某些关键数据结构信息不统一的情况，这会影响操作系统进行别的管理工作</p>
<p>假设此时进程2等待的事件发生，则操作系统中，负责进程控制的内核程序至少需要做两件事</p>
<ul>
<li>将PCB2的state设为1</li>
<li>将PCB2从阻塞队列放到就绪队列</li>
</ul>
<p>完成了第一步后收到中断信号，那么PCB2的state = 1，但是它却被放在阻塞队列里</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gr3q90gc5nj30py080q6h.jpg"></p>
<h3 id="如何实现原语的“原子性”"><a href="#如何实现原语的“原子性”" class="headerlink" title="如何实现原语的“原子性”"></a>如何实现原语的“原子性”</h3><p>可以用“关中断指令”和“开中断指令”这两个特权指令实现原子性，CPU执行了关中断指令之后，就不再例行检查中断信号，直到执行开中断指令之后才会恢复检查，这样，关中断、开中断之间的这些指令序列就是不可被中断的，这就实现了“原子性”</p>
<h2 id="进程控制相关的原语"><a href="#进程控制相关的原语" class="headerlink" title="进程控制相关的原语"></a>进程控制相关的原语</h2><h3 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gr3qm1xonqj30yq0c6dpg.jpg"></p>
<h3 id="进程的终止"><a href="#进程的终止" class="headerlink" title="进程的终止"></a>进程的终止</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gr3qt7pvdaj30ww0ekgx1.jpg"></p>
<h3 id="进程的阻塞和唤醒"><a href="#进程的阻塞和唤醒" class="headerlink" title="进程的阻塞和唤醒"></a>进程的阻塞和唤醒</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gr3qy2vsl5j30z00daals.jpg"></p>
<h3 id="进程的切换"><a href="#进程的切换" class="headerlink" title="进程的切换"></a>进程的切换</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gr3qzmsaihj30rw0eqjzx.jpg"></p>
<p>无论哪个进程控制原语，要做的无非三类事情：</p>
<ul>
<li>更新PCB中的信息：修改进程状态state、保存/恢复运行环境</li>
<li>将PCB插入合适的队列</li>
<li>分配/回收资源</li>
</ul>
<h2 id="程序是如何运行的"><a href="#程序是如何运行的" class="headerlink" title="程序是如何运行的"></a>程序是如何运行的</h2><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gr3r1hyv0pj30ws0fuwn1.jpg"></p>
<ul>
<li>PSW程序状态字寄存器</li>
<li>PC程序计数器：存放下一条指令的地址</li>
<li>IR指令寄存器：存放当前正在执行的指令</li>
<li>通用寄存器：其他一些必要信息</li>
</ul>
<p>指令顺序执行的过程中，很多中间结果是放在各种寄存器中的</p>
<p>假设执行完某条指令后，另一个进程开始上CPU运行，另一个进程在运行过程中也会使用各个寄存器</p>
<p>在进程切换时，先在PCB中保存这个进程的运行环境，保存一些必要的寄存器信息，当原来的进程再次投入运行时，可以通过PCB恢复它的运行环境</p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>操作系统原理</tag>
      </tags>
  </entry>
  <entry>
    <title>进程同步、进程互斥</title>
    <url>/2020/10/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E3%80%81%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5/</url>
    <content><![CDATA[<h2 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h2><p>进程具有异步性的特征，异步性是指，各并发执行的进程以各自独立的、不可预知的速度向前推进</p>
<p>但是有时候我们需要进程确定性的顺序向前推进，操作系统提供“进程同步机制”来实现需求</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gr5z7aho40j30wg06waet.jpg"></p>
<p>同步亦称直接制约关系，它是指为完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上协调它们的工作次序而产生的制约关系。进程间的直接制约关系就是源于它们之间的相互合作</p>
<h2 id="进程互斥"><a href="#进程互斥" class="headerlink" title="进程互斥"></a>进程互斥</h2><p>进程的“并发”需要“共享”的支持，各个并发执行的进程不可避免的需要共享一些系统资源（内存、打印机、摄像头）</p>
<p>两种资源共享方式：</p>
<ul>
<li>互斥共享方式：系统中的某些资源，虽然可以提供给多个进程使用，但一个时间段内只允许一个进程访问该资源</li>
<li>同时共享方式：系统中的某些资源，允许一个时间段内由多个进程“同时”对它们进行访问</li>
</ul>
<p>我们把一个时间段内只允许一个进程使用的资源称为临界资源，许多物理设备（摄像头、打印机）都属于临界资源，此外还有许多变量、数据、内存缓冲区等都属于临界资源。对临界资源的访问，必须互斥的进行</p>
<p>互斥，亦称间接制约关系，进程互斥指当一个进程访问某临界资源时，另一个想要访问该临界资源的进程必须等待。当前访问临界资源的进程访问结束，释放该资源后，另一个进程才能去访问临界资源</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gr5zq7dd5yj30sg0e8124.jpg"></p>
<p>如果一个进程暂时不能进入临界区，那么该进程是否应该一直占着处理机？该进程有没有可能一直进不了临界区？</p>
<p>为了实现对临界资源的互斥访问，同时保证系统整体性能，需要遵循以下原则：</p>
<ol>
<li>空闲让进：临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区</li>
<li>忙着等待：当已有进程进入临界区时，其他试图进入临界区的进程必须等待</li>
<li>有限等待：对请求访问的进程，应保证能在有限时间内进入临界区（保证不会饥饿）</li>
<li>让权等待：当进程不能进入临界区时，应立即释放处理机，防止进程忙等待</li>
</ol>
<h2 id="进程互斥的软件实现方法"><a href="#进程互斥的软件实现方法" class="headerlink" title="进程互斥的软件实现方法"></a>进程互斥的软件实现方法</h2><p>如果没有注意进程互斥：</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gr60a9hhndj60tm0d442g02.jpg"></p>
<h3 id="单标志法"><a href="#单标志法" class="headerlink" title="单标志法"></a>单标志法</h3><p>⭐️在进入区只做检查，不上锁</p>
<p>算法思想：两个进程在访问完临界区后会把使用临界区的权限转交给另一个进程。也就是说每个进程进入临界区的权限只能被另一个进程赋予</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gr60jl4dp6j30vu0c648z.jpg"></p>
<p>因此，该算法可以实现“同一时刻最多只允许一个进程访问临界区”</p>
<p>只能轮流访问，这种必须轮流访问带来的问题是，如果此时允许进入临界区的进程是P0，而P0一直不访问临界区，那么虽然此时临界区空闲，但是并不允许P1访问，因此单标志法存在的主要问题是：违背了“空闲让进”原则</p>
<h3 id="双标志先检查"><a href="#双标志先检查" class="headerlink" title="双标志先检查"></a>双标志先检查</h3><p>⭐️在进入区先检查后上锁</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gr60v4u2adj30x60bkam5.jpg"></p>
<p>若按照1、5、2、6、3、7的顺序执行，P0和P1将会同时访问临界区，因此双标志先检查法的主要问题是：违反“忙则等待”原则</p>
<p>原因在于，进入区的“检查”和“上锁”两个处理不是一气呵成的，检查后，上锁前可能发生进程切换</p>
<p>❗️双标志先检查法其实是很好的，唯一的缺点就在于检查和上锁不是一气呵成的，如果能通过硬件方式改进这点就好了！</p>
<h3 id="双标志后检查"><a href="#双标志后检查" class="headerlink" title="双标志后检查"></a>双标志后检查</h3><p>⭐️在进入区先上锁后检查</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gr615adxgjj30wc0f8h0k.jpg"></p>
<h3 id="Peterson算法"><a href="#Peterson算法" class="headerlink" title="Peterson算法"></a>Peterson算法</h3><p>⭐️在进入区“主动争取–主动谦让–检查对方是否想进、己方是否谦让”</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gr618esu6bj30wc0g4dqv.jpg"></p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gr61drlt8rj30mk0c2k0p.jpg"></p>
<p>Peterson算法用软件方法解决了进程互斥的问题，遵循了空闲让进、忙则等待、有限等待三个原则，但是依然未遵循让权等待的原则，会发生“忙等”</p>
<p>Peterson算法相较于之前三种软件解决方案来说是最好的，但依然不够好</p>
<h2 id="进程互斥的硬件实现方法"><a href="#进程互斥的硬件实现方法" class="headerlink" title="进程互斥的硬件实现方法"></a>进程互斥的硬件实现方法</h2><h3 id="中断屏蔽方法"><a href="#中断屏蔽方法" class="headerlink" title="中断屏蔽方法"></a>中断屏蔽方法</h3><p>利用“开/关中断指令”实现（与原语的实现思想相同，即在某进程开始访问临界区到结束访问为止都不允许被中断，也就不能发生进程切换，因此也不可能发生两个同时访问临界区的情况）</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gr62ka1ylpj30fm06oadw.jpg"></p>
<p>优点：简单、高效</p>
<p>缺点：不适用于多处理机；只适用于操作系统内核进程，不适用于用户进程（因为开/关中断指令只能运行在内核态，这组指令如果能让用户随意使用会很危险）</p>
<h3 id="TestAndSet（TS指令-TSL指令）"><a href="#TestAndSet（TS指令-TSL指令）" class="headerlink" title="TestAndSet（TS指令/TSL指令）"></a>TestAndSet（TS指令/TSL指令）</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gr62sv2eibj30x80dc13r.jpg"></p>
<p>优点：实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞；适用于多处理机环境</p>
<p>缺点：不满足“让权等待”原则，暂时无法进入临界区的进程会占用CPU并循环执行TSL指令，从而导致“忙等”</p>
<h3 id="Swap指令（XCHG指令）"><a href="#Swap指令（XCHG指令）" class="headerlink" title="Swap指令（XCHG指令）"></a>Swap指令（XCHG指令）</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gr6322gj0uj30um0f0k2i.jpg"></p>
<p>❗️目前，所有的解决方案都无法实现“让权等待”</p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>操作系统原理</tag>
      </tags>
  </entry>
  <entry>
    <title>进程的状态与转换</title>
    <url>/2020/10/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E4%B8%8E%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<h2 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h2><p>创建状态：进程正在被创建时，它的状态是“创建态”，在这个阶段操作系统会为进程分配资源、初始化PCB</p>
<p>就绪状态：当进程创建完成后，便进入了“就绪态”，处于就绪态的进程已经具备运行条件，但由于没有空闲CPU，就暂时不能运行</p>
<p>运行状态：如果一个进程此时在CPU上运行，那么这个进程处于“运行态”，CPU会执行该进程对应的程序（执行指令序列）</p>
<p>阻塞状态（等待态）：在进程运行过程中，可能会请求等待某个事件的发生（如等待某种系统资源的分配，或者等待其他进程的响应），在这个事件发生之前，进程无法继续往下执行，此时操作系统会让这个进程下CPU，并让它进入“阻塞态”，如果等待的某个事件发生了，进程就会由“阻塞态”变为“就绪态”，当CPU空闲时，会选择一个“就绪态”进程上CPU运行</p>
<p>终止状态：一个进程可以执行exit系统调用，请求操作系统终止该进程，此时该进程会进入“终止态”，操作系统会让该进程下CPU，并回收内存空间等资源，最后还要回收该进程的PCB，当终止进程的工作完成之后，这个进程就彻底消失了（进程运行结束，或运行过程中遇到不可修复的错误）</p>
<h2 id="状态间的转换"><a href="#状态间的转换" class="headerlink" title="状态间的转换"></a>状态间的转换</h2><p>就绪态 -&gt; 运行态</p>
<p>运行态 -&gt; 就绪态（时间片到，或处理机被抢占）</p>
<p>运行态 -&gt; 阻塞态</p>
<p>阻塞态 -&gt; 就绪态</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gr3peb968kj30q80ecajc.jpg"></p>
<p>注意：不能由阻塞态直接转换为运行态，也不能由就绪态直接转换为阻塞态，因为进入阻塞态是进程主动请求的，必然需要进程在运行时才能发出这种请求</p>
<p>三种基本状态：就绪态、运行态、阻塞态，进程的整个生命周期中大部分时间都处于三种基本状态</p>
<p>单核CPU情况下，同一时刻只会有一个进程处于运行态，多核CPU情况下，可能有多个进程处于运行态</p>
<p>进程PCB中，会有一个变量state来表示进程的当前状态：如1表示创建态、2表示就绪态、3表示运行态…为了对同一状态下的各个进程进行统一的管理，操作系统会将各个进程的PCB组织起来</p>
<h2 id="进程的组织方式（各个进程PCB的组织方式）"><a href="#进程的组织方式（各个进程PCB的组织方式）" class="headerlink" title="进程的组织方式（各个进程PCB的组织方式）"></a>进程的组织方式（各个进程PCB的组织方式）</h2><h3 id="链接方式"><a href="#链接方式" class="headerlink" title="链接方式"></a>链接方式</h3><p>很多操作系统还会根据阻塞原因不同，再分为多个阻塞队列</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gr3pswev9sj30tu0eo10e.jpg"></p>
<h3 id="索引方式"><a href="#索引方式" class="headerlink" title="索引方式"></a>索引方式</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gr3pu5xndaj30o00ew78h.jpg"></p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>操作系统原理</tag>
      </tags>
  </entry>
  <entry>
    <title>进程调度的时机、切换与进程调度方式</title>
    <url>/2020/10/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%9A%84%E6%97%B6%E6%9C%BA%E3%80%81%E5%88%87%E6%8D%A2%E4%B8%8E%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="进程调度的时机"><a href="#进程调度的时机" class="headerlink" title="进程调度的时机"></a>进程调度的时机</h2><p>进程调度（低级调度），就是按照某种算法从就绪队列中选择一个进程为其分配处理机</p>
<h3 id="需要进行进程调度与切换的情况"><a href="#需要进行进程调度与切换的情况" class="headerlink" title="需要进行进程调度与切换的情况"></a>需要进行进程调度与切换的情况</h3><ol>
<li>当前运行的进程主动放弃处理机<ul>
<li>进程正常终止</li>
<li>运行过程中发生异常而终止</li>
<li>进程主动请求阻塞（如等待I/O）</li>
</ul>
</li>
<li>当前运行的进程被动放弃处理机<ul>
<li>分给进程的时间片用完</li>
<li>有更紧急的事需要处理（如I/O中断）</li>
<li>有更高优先级的进程进入就绪队列</li>
</ul>
</li>
</ol>
<h3 id="不能进行进程调度与切换的情况"><a href="#不能进行进程调度与切换的情况" class="headerlink" title="不能进行进程调度与切换的情况"></a>不能进行进程调度与切换的情况</h3><ol>
<li>在处理中断的过程中，中断处理过程复杂，与硬件密切相关，很难做到在中断处理过程中进行进程切换</li>
<li>进程在操作系统内核程序临界区中</li>
<li>在原子操作过程中（原语），原子操作不可中断，要一气呵成（如修改PCB中进程状态标志，并把PCB放到相应队列）</li>
</ol>
<p>进程在操作系统内核程序临界区中不能进行调度与切换✅</p>
<p>进程处于临界区时不能进行处理机调度❌</p>
<p>临界资源：一个时间段内只允许一个进程使用的资源，各进程需要互斥的访问临界资源</p>
<p>临界区：访问临界资源的那段代码</p>
<p>内核程序临界区一般是用来访问某种内核数据结构的，比如进程的就绪队列（由各就绪进程的PCB组成）</p>
<p>假设就绪队列被上锁，进程还没有退出就绪队列（还没解锁）就进行进程调度，但是进程调度相关的程序也需要访问就绪队列，但此时就绪队列被锁住了，因此又无法顺利进行进程调度</p>
<p>内核程序临界区访问的临界资源如果不尽快释放的话，极有可能影响到操作系统内核的其他管理工作，因此在访问内核程序临界区期间不能进行调度与切换</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gr46w9ngh8j30dw098aee.jpg"></p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gr46wtgjh2j30dw098jvi.jpg"></p>
<p>有的系统中，只允许进程主动放弃处理机</p>
<p>有的系统中，进程可以主动放弃处理机，当有更紧急的任务需要处理时，也会强行剥夺处理机（被动放弃）</p>
<h2 id="进程调度的方式"><a href="#进程调度的方式" class="headerlink" title="进程调度的方式"></a>进程调度的方式</h2><ol>
<li>非剥夺调度方式，又称非抢占方式，即只允许进程主动放弃处理机，在运行过程中即便有更紧迫的任务到达，当前进程依然会继续使用处理机，直到该进程终止或主动要求进入阻塞态<ul>
<li>实现简单，系统开销小但是无法及时处理紧急任务，适合于早期的批处理系统</li>
</ul>
</li>
<li>剥夺调度方式，又称抢占方式，可由操作系统剥夺当前进程的CPU使用权，当一个进程正在处理机上执行时，如果有一个更重要或更紧急的进程需要使用处理机，则立即暂停正在执行的进程，将处理机分配给更重要紧迫的那个进程<ul>
<li>可以优先处理更紧急的进程，也可实现让各进程按时间片轮流执行的功能（通过时钟中断），适合于分时操作系统、实时操作系统</li>
</ul>
</li>
</ol>
<h2 id="进程的切换与过程"><a href="#进程的切换与过程" class="headerlink" title="进程的切换与过程"></a>进程的切换与过程</h2><p>“狭义的进程调度”：从就绪队列中选中一个要运行的进程（这个进程可以是刚刚被暂停执行的进程，也可能是另一个进程，后一种情况就需要进程切换）</p>
<p>进程切换：一个进程让出处理机，由另一个进程占用处理机的过程</p>
<p>“广义的进程调度”：包含了选择一个进程和进程切换两个步骤</p>
<p>进程切换的过程主要完成了：</p>
<ol>
<li>对原来运行进程各种数据的保存</li>
<li>对新的进程各种数据的恢复（如程序计数器、程序状态字、各种数据寄存器等处理机现场信息，这些信息一般保存在进程控制块）</li>
</ol>
<p>注意：进程切换、调度是有代价的，因此如果过于频繁的进行进程调度、切换，必然会使整个系统的效率降低，使系统大部分时间都花在了进程切换上，而真正用于执行进程的时间减少，并不是调度越频繁，并发度就越高</p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>操作系统原理</tag>
      </tags>
  </entry>
  <entry>
    <title>I-O控制器</title>
    <url>/2020/09/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/I-O%E6%8E%A7%E5%88%B6%E5%99%A8/</url>
    <content><![CDATA[<p>I/O设备：</p>
<ul>
<li>机械部件</li>
<li>电子部件（I/O控制器或称设备控制器）</li>
</ul>
<p>I/O设备的机械部件主要用来执行具体I/O操作，如我们看得见摸得着的鼠标/键盘的按钮、显示器的LED屏、移动硬盘的磁臂、磁盘盘面</p>
<p>I/O设备的电子部件通常是一块插入主板扩充槽的印刷电路板</p>
<h2 id="I-O控制器（用于实现对I-O设备的控制）"><a href="#I-O控制器（用于实现对I-O设备的控制）" class="headerlink" title="I/O控制器（用于实现对I/O设备的控制）"></a>I/O控制器（用于实现对I/O设备的控制）</h2><p>CPU无法直接控制I/O设备的机械部件，因此I/O设备还要有一个电子部件作为CPU和I/O设备机械部件之间的中介，用于实现CPU对设备的控制，这个电子部件就是I/O控制器，又称设备控制器，CPU可控制I/O控制器，又由I/O控制器来控制设备的机械部件</p>
<h3 id="I-O控制器的功能"><a href="#I-O控制器的功能" class="headerlink" title="I/O控制器的功能"></a>I/O控制器的功能</h3><ol>
<li>接受和识别CPU发出的命令：如CPU发来的read/write命令，I/O控制器中会有相应的控制寄存器来存放命令和参数</li>
<li>向CPU报告设备的状态：I/O控制器中会有相应的状态寄存器，用于记录I/O设备的当前状态，如1表示空闲，0表示忙碌</li>
<li>数据交换：I/O控制器会设置相应的数据寄存器，输出时，数据寄存器用于暂存CPU发来的数据，之后再由控制器传送设备。输入时，数据寄存器用于暂存设备发来的数据，之后CPU从数据寄存器中取走数据</li>
<li>地址识别：类似于内存的地址，为了区分设备控制器中的各个寄存器，也需要给各个寄存器设置一个特定的地址，I/O控制器通过CPU提供的地址来判断CPU要读/写的是哪个寄存器（由I/O逻辑实现）</li>
</ol>
<h3 id="I-O控制器的组成"><a href="#I-O控制器的组成" class="headerlink" title="I/O控制器的组成"></a>I/O控制器的组成</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grjuvqy1djj60ye0i6hcy02.jpg"></p>
<p>注意：</p>
<ol>
<li><p>一个I/O控制器可能会对应多个设备</p>
</li>
<li><p>数据寄存器、控制寄存器、状态寄存器可能有多个（如每个控制/状态寄存器对应一个具体的设备），且这些寄存器都要有相应的地址，才能方便CPU操作。有的计算机会让这些寄存器占用内存地址的一部分，称为内存映像I/O，另一些计算机则采用I/O专用地址，即寄存器独立编址</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grjv3bkg7bj30wc0gkaok.jpg"></p>
</li>
</ol>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>操作系统原理</tag>
      </tags>
  </entry>
  <entry>
    <title>I-O控制方式</title>
    <url>/2020/09/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/I-O%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p>用什么样的方式来控制I/O设备的数据读/写</p>
<h2 id="程序直接控制方式"><a href="#程序直接控制方式" class="headerlink" title="程序直接控制方式"></a>程序直接控制方式</h2><p>完成一次读/写操作的流程（以读操作为例）</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grjvjwclo9j60zg0jcnnu02.jpg"></p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grjvokzb6xj30eg0is0zc.jpg"></p>
<p>CPU干预的频率：很频繁，I/O操作开始之前、完成之后需要CPU介入，并且在等待I/O完成的过程中CPU需要不断的轮询检查</p>
<p>数据传送的单位：每次读/写一个字</p>
<p>数据的流向：（每个字的读/写都需要CPU的帮助）</p>
<ul>
<li>读操作（数据输入）：I/O设备 -&gt; CPU寄存器 -&gt; 内存</li>
<li>写操作（数据输出）：内存 -&gt; CPU寄存器 -&gt; I/O设备</li>
</ul>
<p>主要缺点和主要优点：</p>
<ul>
<li>优点：实现简单，在读/写指令之后，加上实现循环检查的一系列指令即可（因此才称为程序直接控制方式）</li>
<li>缺点：CPU和I/O设备只能串行工作，CPU需要一直轮询检查，长期处于“忙等”状态，CPU利用率低</li>
</ul>
<h2 id="中断驱动方式"><a href="#中断驱动方式" class="headerlink" title="中断驱动方式"></a>中断驱动方式</h2><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grjw1jtlkej30wo0h4k1f.jpg"></p>
<p>CPU干预的频率：每次I/O操作开始之前、完成之后需要CPU介入，等待I/O完成的过程中CPU可以切换到别的进程执行</p>
<p>数据传送的单位：每次读/写一个字</p>
<p>数据的流向：（每个字的读/写都需要CPU的帮助）</p>
<ul>
<li>读操作（数据输入）：I/O设备 -&gt; CPU寄存器 -&gt; 内存</li>
<li>写操作（数据输出）：内存 -&gt; CPU寄存器 -&gt; I/O设备</li>
</ul>
<p>主要缺点和主要优点：</p>
<ul>
<li>优点：与程序直接控制方式相比，在中断驱动方式中，I/O控制器会通过中断信号主动报告I/O已完成，CPU不再需要不停的轮询，CPU和I/O设备可并行的工作，CPU利用率得到明显提升</li>
<li>缺点：每个字在I/O设备与内存之间的传输，都需要经过CPU，而频繁的中断处理会消耗较多的CPU时间</li>
</ul>
<h2 id="DMA方式"><a href="#DMA方式" class="headerlink" title="DMA方式"></a>DMA方式</h2><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grjwe157taj30uc0fidw6.jpg"></p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grjwh5whf2j30ve0gc7jx.jpg"></p>
<p>CPU干预的频率：仅在传送一个或多个数据块的开始和结束时，才需要CPU干预</p>
<p>数据传送的单位：每次读/写一个或多个块（注意：每次读写的只能是连续的多个块，且这些块读入内存后在内存中也必须是连续的）</p>
<p>数据的流向：（不再需要经过CPU）</p>
<ul>
<li>读操作（数据输入）：I/O设备 -&gt; 内存</li>
<li>写操作（数据输出）：内存 -&gt; I/O设备</li>
</ul>
<p>主要缺点和主要优点：</p>
<ul>
<li>优点：数据传输以块为单位，CPU介入频率进一步降低，数据的传输不再需要先经过CPU再写入内存，数据传输效率进一步增加，CPU和I/O设备的并行性得到提升</li>
<li>缺点：CPU每发出一条I/O指令，只能读/写一个或多个连续的数据块，如果要读/写多个离散存储的数据块，或者要将数据分别写到不同的内存区域时，CPU要分别发出多条I/O指令，进行多次中断处理才能完成</li>
</ul>
<h2 id="通道控制方式"><a href="#通道控制方式" class="headerlink" title="通道控制方式"></a>通道控制方式</h2><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grjwvq5qbgj30y00g8qln.jpg"></p>
<p>与CPU相比，通道可以执行的指令很单一，并且通道程序是放在主机内存中的，也就是说通道与CPU共享内存</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grjwztiejjj30we0c2am4.jpg"></p>
<p>总结：</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grjx1mjk6qj30uo0eswyf.jpg"></p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>操作系统原理</tag>
      </tags>
  </entry>
  <entry>
    <title>I-O设备的基本概念和分类</title>
    <url>/2020/09/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/I-O%E8%AE%BE%E5%A4%87%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8C%E5%88%86%E7%B1%BB/</url>
    <content><![CDATA[<h2 id="什么是I-O设备"><a href="#什么是I-O设备" class="headerlink" title="什么是I/O设备"></a>什么是I/O设备</h2><p>I/O就是输入/输出（Input/Output）</p>
<p>I/O设备就是可以将数据输入到计算机，或者可以接收计算机输出数据的外部设备，属于计算机中的硬件部件</p>
<p>鼠标、键盘：典型的输入型设备</p>
<p>显示器：输出型设备</p>
<p>移动硬盘：既可输入又可输出的设备</p>
<p>UNIX系统将外部设备抽象为一种特殊的文件，用户可以使用与文件操作相同的方式对外部设备进行操作【write操作：向外部设备写出数据，read操作：从外部设备读入数据】</p>
<h2 id="按使用特性分类"><a href="#按使用特性分类" class="headerlink" title="按使用特性分类"></a>按使用特性分类</h2><p>人机交互类外部设备：鼠标、键盘、打印机（数据传输速度慢）</p>
<p>存储设备：移动硬盘、光盘（数据传输速度快）</p>
<p>网络通信设备：调制解调器（数据传输速度介于上述二者之间）</p>
<h2 id="按传输速率分类"><a href="#按传输速率分类" class="headerlink" title="按传输速率分类"></a>按传输速率分类</h2><p>低速设备：鼠标、键盘，传输速率为每秒几个到几百字节</p>
<p>中速设备：激光打印机，传输速率为每秒数千至上万个字节</p>
<p>高速设备：磁盘，传输速率为每秒数千字节至千兆字节</p>
<h2 id="按信息交换的单位分类"><a href="#按信息交换的单位分类" class="headerlink" title="按信息交换的单位分类"></a>按信息交换的单位分类</h2><p>块设备：磁盘，数据传输的基本单位是块（传输速率较高，可寻址，即对它可随机的读/写任一块）</p>
<p>字符设备：鼠标、键盘，数据传输的基本单位是字符（传输速率较慢，不可寻址，在输入/输出时常采用中断驱动方式）</p>
<p>中断驱动方式：I/O控制方式的一种</p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>操作系统原理</tag>
      </tags>
  </entry>
  <entry>
    <title>I-O软件层次结构</title>
    <url>/2020/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/I-O%E8%BD%AF%E4%BB%B6%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grkyf37aslj30tm0eqth6.jpg"></p>
<h2 id="用户层软件"><a href="#用户层软件" class="headerlink" title="用户层软件"></a>用户层软件</h2><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grkykb983cj30xu0c04f4.jpg"></p>
<h2 id="设备独立性软件"><a href="#设备独立性软件" class="headerlink" title="设备独立性软件"></a>设备独立性软件</h2><p>设备独立性软件又称设备无关性软件，与设备的硬件特性无关的功能几乎都在这一层实现</p>
<p>主要实现的功能：</p>
<ol>
<li><p>向上层提供统一的调用接口（如read/write系统调用）</p>
</li>
<li><p>设备的保护，原理类似于文件保护，设备被看作是一种特殊的文件，不同用户对各个文件的访问权限是不一样的，同理，对设备的访问权限也不一样</p>
</li>
<li><p>差错处理：设备独立性软件需要对一些设备的错误进行处理</p>
</li>
<li><p>设备的分配与回收</p>
</li>
<li><p>数据缓冲区管理，可以通过缓冲技术屏蔽设备之间数据交换单位大小和传输速度的差异</p>
</li>
<li><p>建立逻辑设备名到物理设备名的映射关系，根据设备类型选择调用相应的驱动程序</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grkyvs4eqpj30iw05yagg.jpg"></p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grkyxsz36uj30iw07e44f.jpg"></p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grkyyhsmgrj30ta04igsl.jpg"></p>
<p>为什么不同的I/O设备需要有不同的驱动程序处理？</p>
<p>各式各样的设备，外形不同，其内部的电子部件（I/O控制器）也有可能不同，不同设备的内部硬件特性也不同，这些特性只有厂家才知道，因此厂家需提供与设备相对应的驱动程序，CPU执行驱动程序的指令序列，来完成设置设备寄存器，检查设备状态等工作</p>
</li>
</ol>
<h2 id="设备驱动程序"><a href="#设备驱动程序" class="headerlink" title="设备驱动程序"></a>设备驱动程序</h2><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grkz7w26eij30ky05sagu.jpg"></p>
<p>驱动程序一般会以一个独立进程的方式存在</p>
<p>⭐️直接涉及到硬件具体细节、且与中断无关的操作肯定是在设备驱动程序层完成的；没有涉及硬件的、对各种设备都需要进行的管理工作都是在设备独立性软件层完成的</p>
<h2 id="中断处理程序"><a href="#中断处理程序" class="headerlink" title="中断处理程序"></a>中断处理程序</h2><p>当I/O任务完成时，I/O控制器会发送一个中断信号，系统会根据中断信号类型找到相应的中断处理程序并执行，中断处理程序的处理流程如下：</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grkzdvs5jjj30wo0c2amf.jpg"></p>
<p>⭐️设备独立性软件和用户层软件都不会和硬件打交道，设备驱动程序和中断处理程序会和硬件打交道</p>
<h2 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h2><p>执行I/O操作，有机械部件、电子部件组成</p>
<h2 id="I-O核心子系统的功能"><a href="#I-O核心子系统的功能" class="headerlink" title="I/O核心子系统的功能"></a>I/O核心子系统的功能</h2><p>用户层软件实现：假脱机技术（SPOOLing技术）</p>
<p>假脱机技术（SPOOLing技术）需要请求“磁盘设备”的设备独立性软件的服务，因此一般来说假脱机技术是在用户层软件实现的</p>
<p>设备独立性软件实现：I/O调度、设备保护、设备分配与回收、缓冲区管理（缓冲与高速缓存）</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grkzyzp5qkj30s4060n3o.jpg"></p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grl01eru3gj30sc04m780.jpg"></p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>操作系统原理</tag>
      </tags>
  </entry>
  <entry>
    <title>假脱机技术SPOOLing</title>
    <url>/2020/09/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E5%81%87%E8%84%B1%E6%9C%BA%E6%8A%80%E6%9C%AFSPOOLing/</url>
    <content><![CDATA[<h2 id="什么是脱机技术，脱机技术可以解决什么问题"><a href="#什么是脱机技术，脱机技术可以解决什么问题" class="headerlink" title="什么是脱机技术，脱机技术可以解决什么问题"></a>什么是脱机技术，脱机技术可以解决什么问题</h2><p>手工操作阶段：主机直接从I/O设备获得数据，由于设备速度慢，主机速度很快，人机速度矛盾明显，主机要浪费很多时间来等待设备</p>
<p>批处理阶段引入了脱机输入/输出技术（外围控制机+磁带）：脱离主机的控制进行的输入/输出操作</p>
<p>引入脱机技术后，缓解了CPU与慢速I/O设备的速度矛盾。另一方面，即使CPU在忙碌，也可以提前将数据输入到磁带，即使慢速的输出设备正在忙碌，也可以提前将数据输出到磁带</p>
<h2 id="假脱机技术的实现原理"><a href="#假脱机技术的实现原理" class="headerlink" title="假脱机技术的实现原理"></a>假脱机技术的实现原理</h2><p>假脱机技术又称SPOOLing技术，是用软件的方式模拟脱机技术</p>
<h3 id="输入井和输出井"><a href="#输入井和输出井" class="headerlink" title="输入井和输出井"></a>输入井和输出井</h3><p>在磁盘上开辟出两个存储区域：输入井和输出井</p>
<p>“输入井”模拟脱机输入时的磁带，用于收容I/O设备输入的数据</p>
<p>“输出井”模拟脱机输出时的磁带，用于收容用户进程输出的数据</p>
<h3 id="输入进程和输出进程"><a href="#输入进程和输出进程" class="headerlink" title="输入进程和输出进程"></a>输入进程和输出进程</h3><p>要实现SPOOLing技术，必须要有多道程序技术的支持，系统会建立“输入进程”和“输出进程”</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grl0x8vnoej30mu0c8n62.jpg"></p>
<h3 id="输入缓冲区和输出缓冲区"><a href="#输入缓冲区和输出缓冲区" class="headerlink" title="输入缓冲区和输出缓冲区"></a>输入缓冲区和输出缓冲区</h3><p>注意，输入缓冲区和输出缓冲区是在内存中的缓冲区</p>
<p>在输入进程的控制下，输入缓冲区用于暂存从输入设备输入的数据，之后再转存到输入井中</p>
<p>在输出进程的控制下，输出缓冲区用于暂存从输出井送来的数据，之后再传送到输出设备上</p>
<h2 id="共享打印机的原理分析"><a href="#共享打印机的原理分析" class="headerlink" title="共享打印机的原理分析"></a>共享打印机的原理分析</h2><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grl14sroebj30ri0ai7eu.jpg"></p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grl18w27wtj30wk0gy1ck.jpg"></p>
<p>虽然系统中只有一台打印机，但每个进程提出打印请求时，系统都会在输出井中为其分配一个存储区（相当于分配了一个逻辑设备），使每个用户进程都觉得自己在独占一台打印机，从而实现对打印机的共享</p>
<p>SPOOLing技术可以把一台物理设备虚拟成逻辑上的多台设备，可将独占式设备改造成共享设备</p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>操作系统原理</tag>
      </tags>
  </entry>
  <entry>
    <title>内存的基础知识</title>
    <url>/2020/10/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E5%86%85%E5%AD%98%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h2 id="什么是内存，有何作用"><a href="#什么是内存，有何作用" class="headerlink" title="什么是内存，有何作用"></a>什么是内存，有何作用</h2><p>内存可存放数据，程序执行前需要先放到内存中才能被CPU处理：缓和CPU与硬盘之间的速度矛盾</p>
<p>在多道程序环境下，系统中会有多个程序并发执行，也就是说会有多个程序的数据需要同时放到内存中。那么，如何区分各个程序的数据是放在什么地方的呢？</p>
<p>方案：给内存的存储单元编地址</p>
<p>内存中有一个一个的“小房间”，每个小房间就是一个存储单元，内存地址从0开始，每个地址对应一个存储单元</p>
<p>如果计算机按“字节编址”，则每个存储单元大小为1字节，即1B，即8个二进制位；如果字长为16位的计算机“按字编址”，则每个存储单元大小为1个字，每个字的大小为16个二进制位</p>
<p>1B = 8bit；1KB = 2^10^B；1M = 2^10^KB；1GB = 2^10^MB</p>
<p>一台手机有4GB内存，是指该内存中可以存放（4 * 2^30^）个字节，如果是按字节编址的话，也就是有2^32^个“小房间”，所以地址需要用32个二进制位</p>
<h2 id="进程运行的基本原理"><a href="#进程运行的基本原理" class="headerlink" title="进程运行的基本原理"></a>进程运行的基本原理</h2><h3 id="指令的工作原理（逻辑地址-VS-物理地址）"><a href="#指令的工作原理（逻辑地址-VS-物理地址）" class="headerlink" title="指令的工作原理（逻辑地址 VS 物理地址）"></a>指令的工作原理（逻辑地址 VS 物理地址）</h3><p>指令的工作基于“地址”，每个地址对应一个数据的存储单元</p>
<p>我们写的代码要翻译成CPU能识别的指令，这些指令会告诉CPU应该去内存的哪个地址读/写数据，这个数据应该做什么样的处理。这个例子中，我们默认让这个进程的相关内容从地址#0开始连续存放，指令中的地址参数直接给出了变量x的实际存放地址（物理地址）</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gr9es7mk1kj30wg0cu4ej.jpg"></p>
<p>如果这个进程不是从地址#0开始存放的，会影响指令的正常执行吗？</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gr9eyhtpvcj60y60gutv302.jpg"></p>
<h3 id="如何实现地址转换"><a href="#如何实现地址转换" class="headerlink" title="如何实现地址转换"></a>如何实现地址转换</h3><p>如何将指令中的逻辑地址转换为物理地址？</p>
<p>三种装入方式：</p>
<ol>
<li><p>绝对装入（换个电脑装入模块就作废了）（编译时）（单道程序阶段，此时还没产生操作系统，由编译器实现）</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gr9f41psdlj30ww0fyk5i.jpg"></p>
</li>
<li><p>可重定位装入（静态重定位）（装入内存时）（用于早期的多道批处理）</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gr9f869xltj30vm0geqj3.jpg"></p>
</li>
<li><p>动态运行时装入（动态重定位）（程序运行时）（现代）</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gr9fb4xsrkj30xi0gehax.jpg"></p>
</li>
</ol>
<h3 id="从写程序到程序运行的过程"><a href="#从写程序到程序运行的过程" class="headerlink" title="从写程序到程序运行的过程"></a>从写程序到程序运行的过程</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gr9feyopr0j30y80f0dqh.jpg"></p>
<p>链接的三种方式：</p>
<ol>
<li>静态链接：在程序运行之前，先将各目标模块及它们所需的库函数连接成一个完整的可执行文件（装入模块），之后不再拆开</li>
<li>装入时动态链接：将各目标模块装入内存时，边装入边链接的链接方式</li>
<li>运行时动态链接：在程序执行中需要该目标模块时，才对它进行链接。其优点是便于修改和更新，便于实现对目标模块的共享（用不到的模块不需要装入内存）</li>
</ol>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>操作系统原理</tag>
      </tags>
  </entry>
  <entry>
    <title>内存空间的分配与回收</title>
    <url>/2020/10/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6/</url>
    <content><![CDATA[<h2 id="连续分配管理方式"><a href="#连续分配管理方式" class="headerlink" title="连续分配管理方式"></a>连续分配管理方式</h2><p>连续分配：指为用户进程分配的必须是一个连续的内存空间</p>
<h3 id="单一连续分配"><a href="#单一连续分配" class="headerlink" title="单一连续分配"></a>单一连续分配</h3><p>在单一连续分配方式中，内存被分为系统区和用户区。</p>
<p>系统区通常位于内存的低地址部分，用于存放操作系统相关数据；用户区用于存放用户进程相关数据，内存中只能有一道用户程序，用户程序独占整个用户区空间</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gr9qcckbvej30dq0eatew.jpg"></p>
<p>优点：实现简单，无外部碎片，可以采用覆盖技术扩充内存，不一定需要采取内存保护（MS-DOS）</p>
<p>缺点：只能用于单用户、单任务的操作系统中，有内部碎片，存储器利用率极低（分配给某进程的内存区域中，如果有些部分没有用上，就是“内部碎片”）</p>
<h3 id="固定分区分配"><a href="#固定分区分配" class="headerlink" title="固定分区分配"></a>固定分区分配</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gr9qjw6ej7j30uw0fqkf1.jpg"></p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gr9qnmb5w7j30vc0f8qos.jpg"></p>
<h3 id="动态分区分配"><a href="#动态分区分配" class="headerlink" title="动态分区分配"></a>动态分区分配</h3><p>动态分区分配又称为可变分区分配，这种分配方式不会预先划分内存分区，而是在进程装入内存时，根据进程的大小动态的建立分区，并使分区的大小正好适合进程的需要。因此系统分区的大小和数目是可变的</p>
<p>假设某计算机内存大小为64MB，系统区8MB，用户区共56MB</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gr9qt3bidbj307o0cm77p.jpg"></p>
<blockquote>
<ol>
<li><p>系统要用什么样的数据结构记录内存的使用情况？</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gr9qxxmtflj30w80e8ql7.jpg"></p>
</li>
<li><p>当很多个空闲分区都能满足需求时，应该选择哪个分区进行分配？</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gr9qzlvgqdj30uk0cqn8x.jpg"></p>
</li>
<li><p>如何进行分区的分配与回收操作？（假设系统采用的数据结构是“空闲分区表”）</p>
<p>1）如何分配？</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gr9r21x40wj30r20d6wq3.jpg"></p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gr9r2xi71vj30r20d6akv.jpg"></p>
<p>2）如何回收？（总之，相邻的空闲分区要合并）</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gr9r5644xkj30r20ccjyp.jpg"></p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gr9r5pwl2lj30r20ccqdt.jpg"></p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gr9r6eyxgwj30r20cc13z.jpg"></p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gr9r7f75k0j30rm0ccdnv.jpg"></p>
</li>
</ol>
</blockquote>
<p>动态分区分配没有内部碎片，但是有外部碎片</p>
<p>内部碎片：分配给某进程的内存区域中，如果有些部分没有用上</p>
<p>外部碎片；是指内存中的某些空闲分区由于太小而难以利用</p>
<p>如果内存中空闲空间的总和本来可以满足某进程的要求，但由于进程需要的是一整块连续的内存空间，因此这些“碎片”不能满足进程的需求。可以通过紧凑（拼凑）技术来解决外部碎片</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gr9rfzt5fvj30cq0cejwn.jpg"></p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gr9rgfv4thj307o0cejtq.jpg"></p>
<h4 id="动态分区分配算法"><a href="#动态分区分配算法" class="headerlink" title="动态分区分配算法"></a>动态分区分配算法</h4><p>在动态分区分配方式中，当很多个空闲分区都能满足需求时，应该选择哪个分区进行分配？</p>
<blockquote>
<ol>
<li><p>首次适应算法（First Fit）</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gr9rzi4gejj30t80g2nel.jpg"></p>
</li>
<li><p>最佳适应算法（Best Fit）</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gr9s3xsooej60t80g2k6002.jpg"></p>
</li>
<li><p>最坏适应算法（Worst Fit）</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gr9s5yukpwj30t80g2avc.jpg"></p>
</li>
<li><p>邻近适应算法（Next Fit）</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gr9sf54f45j30tu0g2h9g.jpg"></p>
</li>
</ol>
<p>⭐️首次适应算法和邻近适应算法比最佳适应算法和最坏适应算法好的一点：不用每次都更新空闲分区链/表的排列顺序，减少开销</p>
<p>❗️综合来看，四种算法中，首次适应算法的效果反而更好</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gr9skmiivij30uo0f67r5.jpg"></p>
</blockquote>
<h2 id="非连续分配管理方式"><a href="#非连续分配管理方式" class="headerlink" title="非连续分配管理方式"></a>非连续分配管理方式</h2><p>非连续分配：为用户进程分配的可以是一些分散的内存空间</p>
<h3 id="基本分页存储管理"><a href="#基本分页存储管理" class="headerlink" title="基本分页存储管理"></a>基本分页存储管理</h3><h4 id="什么是分页存储"><a href="#什么是分页存储" class="headerlink" title="什么是分页存储"></a>什么是分页存储</h4><p>将内存空间分为一个个大小相等的分区，每个分区就是一个“页框”（页框、页帧、内存块、物理块、物理页面），每个页框有一个编号，即“页框号”，页框号从0开始</p>
<p>将进程的逻辑地址空间也分为与页框大小相等的一个个部分，每个部分称为一个“页”或“页面”。每个页面也有一个编号，即“页号”，页号也是从0开始</p>
<p>操作系统以页框为单位为各个进程分配内存空间。进程的每个页面分别放入一个页框中。也就是说，进程的页面与内存的页框有一一对应的关系，各个页面不必连续存放，可以放到不相邻的各个页框中</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1granazofnjj30ey0gmk1z.jpg"></p>
<h4 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h4><p>为了能知道进程的每个页面在内存中存放的位置，操作系统要为每个进程建立一张页表，页表通常存在PCB（进程控制块）中</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1granfhmgsoj30vq0eck5o.jpg"></p>
<blockquote>
<ol>
<li><p>每个页表项多大，占几个字节？</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grannoss6kj30mu07a10z.jpg"></p>
<p>页表项连续存放，因此页号可以是隐含的，不占存储空间（类比数组）</p>
<p>假设页表中的各页表项从内存地址为X的地方开始连续存放，如何找到页号为i的页表项：X + 3*i</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1granzj5rb9j30ac07076s.jpg"></p>
<p>由于页号是隐含的，因此每个页表项占3B，存储整个页表至少需要3*(n+1)B</p>
<p>注意；页表记录的只是内存块号，而不是内存块的其实地址：J号内存块的起始地址 = J * 内存块大小</p>
</li>
<li><p>如何通过页表实现逻辑地址到物理地址的转换？（逻辑地址结构可拆分为页号P和页内偏移量W）</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1graocgnqc7j30wk0f4kba.jpg"></p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1graogawladj30xa0egn6k.jpg"></p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1graomtt11jj30wa0h21kx.jpg"></p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1graoujpqdwj30yq0de1ia.jpg"></p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1graoxeovrnj30ty07c13e.jpg"></p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grap0k8zhnj30x60byao3.jpg"></p>
</li>
</ol>
</blockquote>
<h4 id="基本地址变换机构（用于实现逻辑地址到物理地址转换的一组硬件机构）"><a href="#基本地址变换机构（用于实现逻辑地址到物理地址转换的一组硬件机构）" class="headerlink" title="基本地址变换机构（用于实现逻辑地址到物理地址转换的一组硬件机构）"></a>基本地址变换机构（用于实现逻辑地址到物理地址转换的一组硬件机构）</h4><p>基本地址变换机构可以借助进程的页表将逻辑地址转换为物理地址</p>
<p>通常会在系统中设置一个页表寄存器PTR，存放页表在内存中的起始地址F和页表长度M。进程未执行时，页表的始址和页表长度放在进程控制块PCB中，当进程被调度时，操作系统内核会把它们放到页表寄存器中</p>
<p>注意：假设页面大小是2的整数幂，设页面大小为L，逻辑地址A到物理地址E的变换过程如下：</p>
<p>CPU第一次访问内存：查页表</p>
<p>CPU第二次访问内存：访问目标内存单元</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grapqb7pirj30ya0i61fn.jpg"></p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1graptaq5rlj30sq09ctnm.jpg"></p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grapwhn046j30v00dgap1.jpg"></p>
<p>对页表项大小的进一步探讨：</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1graq4eqv42j30xc0gce68.jpg"></p>
<h4 id="具有快表的地址变换机构（是基本地址变换机构的改进版本）"><a href="#具有快表的地址变换机构（是基本地址变换机构的改进版本）" class="headerlink" title="具有快表的地址变换机构（是基本地址变换机构的改进版本）"></a>具有快表的地址变换机构（是基本地址变换机构的改进版本）</h4><h5 id="什么是快表TLB"><a href="#什么是快表TLB" class="headerlink" title="什么是快表TLB"></a>什么是快表TLB</h5><p>快表，又称联想寄存器TLB，是一种访问速度比内存快很多的高速缓存，用来存放最近访问的一部分页表项的副本，可以加速地址变换的速度，与此对应，内存中的页表常称为慢表</p>
<p>❗️TLB不是内存</p>
<p>❗️TLB和普通Cache的区别：TLB中只有一部分页表项的副本，而普通Cache中可能会有其他各种数据的副本</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grascxlpeij30eo0dsn3e.jpg"></p>
<h5 id="引入快表后，地址的变换过程"><a href="#引入快表后，地址的变换过程" class="headerlink" title="引入快表后，地址的变换过程"></a>引入快表后，地址的变换过程</h5><p>刚开始快表是为空的，当访问完慢表后，会把最近使用过的页表项放入快表中，下次若快表命中就不需要再访问内存了：</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grash269e8j60ys0ja7rv02.jpg"></p>
<p>❗️快表中存放的是页表的一部分副本，因为TLB造价比内存高</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grass0m7gtj30ui0707il.jpg"></p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grastl023ej30ui08kds4.jpg"></p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grasvyfmlpj30yk09qdon.jpg"></p>
<h5 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h5><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1graszaactwj30v80eqqm6.jpg"></p>
<h4 id="两级页表"><a href="#两级页表" class="headerlink" title="两级页表"></a>两级页表</h4><h5 id="单极页表存在什么问题，如何解决？"><a href="#单极页表存在什么问题，如何解决？" class="headerlink" title="单极页表存在什么问题，如何解决？"></a>单极页表存在什么问题，如何解决？</h5><p>1）页表必须连续存放，因此当页表很大时，需要占用很多个连续的页框</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gratl08s44j30vk0goamm.jpg"></p>
<p>2）根据局部性原理可知：很多时候，进程在一段时间内只需要访问某几个页面就可以正常运行了。因此没必要让整个页表都常驻内存</p>
<p>第一个问题的解决方法：</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grats76drej60uw0aetnj02.jpg"></p>
<h5 id="两级页表的原理，逻辑地址结构（一级页号、二级页号、页内偏移量）"><a href="#两级页表的原理，逻辑地址结构（一级页号、二级页号、页内偏移量）" class="headerlink" title="两级页表的原理，逻辑地址结构（一级页号、二级页号、页内偏移量）"></a>两级页表的原理，逻辑地址结构（一级页号、二级页号、页内偏移量）</h5><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gratz65d7rj30ws0h4ap9.jpg"></p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grau409000j30x20gy4hh.jpg"></p>
<h5 id="如何实现地址变换？"><a href="#如何实现地址变换？" class="headerlink" title="如何实现地址变换？"></a>如何实现地址变换？</h5><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grauo26twkj30xe0e0nds.jpg"></p>
<p>第二个问题的解决方法：可以在需要访问页面时才把页面调入内存（虚拟存储技术），可以在页表项中增加一个标志位，用于表示该页面是否已经调入内存</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grauzy1mimj30va0aeqeg.jpg"></p>
<h5 id="两级页表问题需要注意的几个细节？"><a href="#两级页表问题需要注意的几个细节？" class="headerlink" title="两级页表问题需要注意的几个细节？"></a>两级页表问题需要注意的几个细节？</h5><ol>
<li><p>若采用多级页表机制，则各级页表的大小不能超过一个页面，若两级页表不够，可以分更多级</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grav6rsrh8j30uq0emk8d.jpg"></p>
</li>
<li><p>两级页表的访存次数分析（假设没有快表机构）（N级页表访问一个逻辑地址需要N+1次访存）</p>
<ul>
<li>第一次访存：访问内存中的页目录表</li>
<li>第二次访存：访问内存中的二级页表</li>
<li>第三次访存：访问目标内存单元</li>
</ul>
</li>
</ol>
<h3 id="基本分段存储管理"><a href="#基本分段存储管理" class="headerlink" title="基本分段存储管理"></a>基本分段存储管理</h3><p>与“分页”最大的区别就是离散分配时所分配地址空间的基本单位不同</p>
<h4 id="什么是分段"><a href="#什么是分段" class="headerlink" title="什么是分段"></a>什么是分段</h4><p>进程的地址空间：按照程序自身的逻辑关系划分为若干个段，每个段都有一个段名（在低级语言中，程序员使用段名来编程），每段从0开始编址</p>
<p>内存分配规则：以段为单位进行分配，每个段在内存中占据连续空间，但各段之间可以不相邻</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grayphvmhdj30wi0d07kc.jpg"></p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1graysw4bxtj30wk0g4e02.jpg"></p>
<h4 id="什么是段表"><a href="#什么是段表" class="headerlink" title="什么是段表"></a>什么是段表</h4><p>程序分多个段，各段离散的装入内存，为了保证程序能正常运行，就必须能从物理内存中找到各个逻辑段的存放位置。为此，需为每个进程建立一张段映射表，简称“段表”</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grayzmrysfj30uc0ec1cy.jpg"></p>
<h4 id="如何实现地址变换"><a href="#如何实现地址变换" class="headerlink" title="如何实现地址变换"></a>如何实现地址变换</h4><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1graz30j0soj30t60f21aa.jpg"></p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1graz9vsu7bj30yo0js1kx.jpg"></p>
<h4 id="分段、分页管理的对比"><a href="#分段、分页管理的对比" class="headerlink" title="分段、分页管理的对比"></a>分段、分页管理的对比</h4><ol>
<li><p>页是信息的物理单位，分页的主要目的是为了实现离散分配，提高内存利用率。分页仅仅是系统管理上的需要，完全是系统行为，对用户是不可见的</p>
<p>段是信息的逻辑单位，分段的主要目的是更好的满足用户需求，一个段通常包含着一组属于一个逻辑模块的信息。分段对用户是可见的，用户编程时需要显式的给出段名</p>
</li>
<li><p>页的大小固定且由系统决定，段的长度却不固定，决定于用户编写的程序</p>
</li>
<li><p>分页的用户进程地址空间是一维的，程序员只需给出一个记忆符即可表示一个地址</p>
<p>分段的用户进程地址空间是二维的，程序员在标识一个地址时，既要给出段名，也要给出段内地址</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1graznm0llzj30x009atjg.jpg"></p>
</li>
<li><p>分段比分页更容易实现信息的共享和保护</p>
<p>不能被修改的代码称为纯代码或可重入代码（不属于临界资源），这样的代码是可以共享的。可修改的代码是不能共享的（比如有一个代码段中有很多变量，各进程并发的同时访问可能造成数据不一致）</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1graztcxy9nj30vg0d27ks.jpg"></p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grazvbfih6j30vm0f87pm.jpg"></p>
</li>
<li><p>访问一个逻辑地址需要几次访存？</p>
<p>分页（单级页表）：第一次访存查内存中的页表，第二次访存访问目标内存单元，总共两次访存</p>
<p>分段：第一次访存查内存中的段表，第二次访存访问目标内存单元，总共两次访存。与分页系统类似，分段系统中也可以引入快表机构，将近期访问过的段表项放到快表中，这样可以少一次访问，加快地址变换速度</p>
</li>
</ol>
<h3 id="段页式存储管理"><a href="#段页式存储管理" class="headerlink" title="段页式存储管理"></a>段页式存储管理</h3><h4 id="分页、分段的优缺点"><a href="#分页、分段的优缺点" class="headerlink" title="分页、分段的优缺点"></a>分页、分段的优缺点</h4><p>分页管理：</p>
<ul>
<li>优点：内存空间利用率高，不会产生外部碎片，只会有少量的页内碎片</li>
<li>缺点：不方便按照逻辑模块实现信息的共享和保护</li>
</ul>
<p>分段管理：</p>
<ul>
<li>优点：很方便按照逻辑模块实现信息的共享和保护</li>
<li>缺点：如果段长过大，为其分配很大的连续空间会很不方便。另外，段式管理会产生外部碎片（分段管理中产生的外部碎片也可以用“紧凑”来解决，只是需要付出较大的时间代价）</li>
</ul>
<h4 id="分段-分页-段页式管理"><a href="#分段-分页-段页式管理" class="headerlink" title="分段 + 分页 = 段页式管理"></a>分段 + 分页 = 段页式管理</h4><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grbqzq718xj30vc0g4h2f.jpg"></p>
<h4 id="段页式管理的逻辑地址结构"><a href="#段页式管理的逻辑地址结构" class="headerlink" title="段页式管理的逻辑地址结构"></a>段页式管理的逻辑地址结构</h4><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grbr2t0fp4j30vi0fq4k1.jpg"></p>
<h4 id="段表、页表"><a href="#段表、页表" class="headerlink" title="段表、页表"></a>段表、页表</h4><p>一个进程对应一个段表，一个进程对应多个页表</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grbr6lskdkj60v80i2e4302.jpg"></p>
<h4 id="地址变换"><a href="#地址变换" class="headerlink" title="地址变换"></a>地址变换</h4><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grbrbhedd2j30zo0j84qp.jpg"></p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>操作系统原理</tag>
      </tags>
  </entry>
  <entry>
    <title>内存空间的扩充</title>
    <url>/2020/10/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E7%9A%84%E6%89%A9%E5%85%85/</url>
    <content><![CDATA[<h2 id="内存空间的扩充"><a href="#内存空间的扩充" class="headerlink" title="内存空间的扩充"></a>内存空间的扩充</h2><p>在传统存储管理方式的基础上引入了交换技术、覆盖技术，使得内存利用率有所提升，并且能从逻辑上扩充内存容量</p>
<h3 id="覆盖技术"><a href="#覆盖技术" class="headerlink" title="覆盖技术"></a>覆盖技术</h3><p>早期的计算机内存很小，比如IBM推出的第一台PC机最大只支持1MB大小的内存。因此经常会出现内存大小不够的情况</p>
<p>后来人们引入了覆盖技术，用来解决“程序大小超过物理内存总和”的问题</p>
<blockquote>
<p>覆盖技术的思想：将程序分为多个段（多个模块），常用的段常驻内存，不常用的段在需要时调入内存</p>
<p>内存中分为一个“固定区”和若干个“覆盖区”</p>
<p>需要常驻内存的段放在“固定区”中，调入后就不再调出（除非运行结束）</p>
<p>不常用的段放在“覆盖区”，需要用到时调入内存，用不到时调出内存</p>
</blockquote>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gr9hdlq8snj30vo0eyh24.jpg"></p>
<h3 id="交换技术"><a href="#交换技术" class="headerlink" title="交换技术"></a>交换技术</h3><p>交换（对换）技术的设计思想：内存空间紧张时，系统将内存中某些进程暂时换出外存，把外存中某些已具备运行条件的进程换入内存（进程在内存与磁盘间动态调度）</p>
<p>虽然不常用的进程被调出内存了，但是该进程的PCB还在内存中保存着：</p>
<p>![image-20210607101828325](/Users/liaojialong/Library/Application Support/typora-user-images/image-20210607101828325.png)</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gr9hlvalnij30vs0e44cy.jpg"></p>
<blockquote>
<ol>
<li>应该在外存（磁盘）的什么位置保存被换出的进程？</li>
<li>什么时候应该交换？</li>
<li>应该换出哪些进程？</li>
</ol>
</blockquote>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gr9hs0zcgtj30vg0a8dz0.jpg"></p>
<p>覆盖与交换的区别：</p>
<ol>
<li>覆盖是在同一程序或进程中的</li>
<li>交换是在不同进程（或作业）之间的</li>
</ol>
<h3 id="虚拟存储技术"><a href="#虚拟存储技术" class="headerlink" title="虚拟存储技术"></a>虚拟存储技术</h3><h4 id="传统存储管理方式的特征、缺点"><a href="#传统存储管理方式的特征、缺点" class="headerlink" title="传统存储管理方式的特征、缺点"></a>传统存储管理方式的特征、缺点</h4><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grbskf76sjj30vs0f87nh.jpg"></p>
<h4 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h4><p>时间局部性：现在访问的指令、数据在不久后很可能会被再次访问</p>
<p>空间局部性：现在访问的内存单元周围的内存空间，很可能在不久后会被访问</p>
<p>高速缓存技术：使用频繁的数据放到更高速的存储器中</p>
<h4 id="虚拟内存的定义和特征"><a href="#虚拟内存的定义和特征" class="headerlink" title="虚拟内存的定义和特征"></a>虚拟内存的定义和特征</h4><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grbspj8jnqj30x60ecdxc.jpg"></p>
<p>虚拟内存的三个主要特征：</p>
<ol>
<li>多次性：无需在作业运行时一次性全部装入内存，而是允许被分成多次调入内存</li>
<li>对换性：在作业运行时无需一直常驻内存，而是允许在作业运行过程中，将作业换入、换出</li>
<li>虚拟性：从逻辑上扩充了内存的容量，使用户看到的内存容量，远大于实际的容量</li>
</ol>
<h4 id="如何实现虚拟内存技术"><a href="#如何实现虚拟内存技术" class="headerlink" title="如何实现虚拟内存技术"></a>如何实现虚拟内存技术</h4><p>虚拟内存技术，允许一个作业分多次调入内存，如果采用连续分配方式，会不方便实现。因此虚拟内存的实现需要建立在离散分配的内存管理方式基础上</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grbsyumkpbj30vq0d8tpt.jpg"></p>
<h4 id="请求分页管理方式"><a href="#请求分页管理方式" class="headerlink" title="请求分页管理方式"></a>请求分页管理方式</h4><h5 id="页表机制"><a href="#页表机制" class="headerlink" title="页表机制"></a>页表机制</h5><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grbtcnm5nfj30wk0g8nhb.jpg"></p>
<h5 id="缺页中断机构"><a href="#缺页中断机构" class="headerlink" title="缺页中断机构"></a>缺页中断机构</h5><p>如果内存中有空闲块：修改内存号为a，状态位为1</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grbtfwf1uoj30um0imtua.jpg"></p>
<p>如果内存中没有空闲块：将c换出内存，将x号块放进c号块</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grbtngt24vj30um0imnl3.jpg"></p>
<p>缺页中断是因为当前执行的指令想要访问的目标页面未调入内存而产生的，因此属于内中断</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grbtut3d98j30se0ai7gc.jpg"></p>
<p>一条指令在执行期间，可能产生多次缺页中断：将逻辑地址A中的数据复制到逻辑地址B，而A、B属于不同的页面，则有可能产生两次中断</p>
<h5 id="地址变换机构"><a href="#地址变换机构" class="headerlink" title="地址变换机构"></a>地址变换机构</h5><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grbtvumb67j30r80acwn7.jpg"></p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grbtxvclqoj30y00iwdxs.jpg"></p>
<p>在具有快表机构的请求分页系统中，访问一个逻辑地址时，若发生缺页，则地址变换步骤是</p>
<ol>
<li>查快表（未命中）</li>
<li>查慢表（发现未调入内存）</li>
<li>调页（调入的页面对应的表项不仅会加入慢表，也会加入快表中）</li>
<li>查快表（命中）</li>
<li>访问目标内存单元</li>
</ol>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grbuc2d8oqj30yq0jyhdt.jpg"></p>
<h4 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h4><p>页面的换入、换出需要磁盘I/O，会有较大的开销，因此好的页面置换算法应该追求更少的缺页率</p>
<h5 id="最佳置换算法OPT（性能最好）"><a href="#最佳置换算法OPT（性能最好）" class="headerlink" title="最佳置换算法OPT（性能最好）"></a>最佳置换算法OPT（性能最好）</h5><p>每次选择淘汰的页面将是以后永不使用，或者在最长时间内不再被访问的页面，这样可以保证最低的缺页率</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grbv2remymj30vc0dodzr.jpg"></p>
<p>最佳置换算法可以保证最低的缺页率，但实际上，只有在进程执行的过程中才能知道接下来会访问到的是哪个页面。操作系统无法提前预判页面访问序列。因此，最佳置换算法是无法实现的</p>
<h5 id="先进先出置换算法FIFO"><a href="#先进先出置换算法FIFO" class="headerlink" title="先进先出置换算法FIFO"></a>先进先出置换算法FIFO</h5><p>每次选择淘汰的页面是最早进入内存的页面</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grbv8plu0xj60v20ek4fe02.jpg"></p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grbv9t10xqj30xc0d0h4u.jpg"></p>
<h5 id="最近最久未使用置换算法LRU"><a href="#最近最久未使用置换算法LRU" class="headerlink" title="最近最久未使用置换算法LRU"></a>最近最久未使用置换算法LRU</h5><p>该算法性能最接近最佳置换算法：</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grbve8mndnj30vs0fktxy.jpg"></p>
<h5 id="时钟置换算法CLOCK（NRU）"><a href="#时钟置换算法CLOCK（NRU）" class="headerlink" title="时钟置换算法CLOCK（NRU）"></a>时钟置换算法CLOCK（NRU）</h5><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grc0jymx25j30wa0fuqsi.jpg"></p>
<p>实现简单，算法开销小，但未考虑页面是否被修改过</p>
<h5 id="改进型的时钟置换算法NRU"><a href="#改进型的时钟置换算法NRU" class="headerlink" title="改进型的时钟置换算法NRU"></a>改进型的时钟置换算法NRU</h5><p>第一优先级：最近没访问，且没修改的页面</p>
<p>第二优先级：最近没访问，但修改过的页面</p>
<p>第三优先级：最近访问过，但没修改的页面</p>
<p>第四优先级：最近访问过，且修改过的页面</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grc0stxgt9j30x60g6x59.jpg"></p>
<p>算法开销较小，性能也不错</p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>操作系统原理</tag>
      </tags>
  </entry>
  <entry>
    <title>内存管理的概念</title>
    <url>/2020/10/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<p>操作系统作为系统资源的管理者，当然也需要对内存进行管理</p>
<ol>
<li><p>操作系统负责内存空间的分配与回收</p>
<blockquote>
<ol>
<li>操作系统要怎么记录哪些内存区域已经被分配出去了，哪些又还空闲？</li>
<li>内存中很多位置都可以存放，那新来的进程应该放在哪里？</li>
<li>当进程运行结束之后，如何将进程占用的内存空间回收？</li>
</ol>
</blockquote>
</li>
<li><p>操作系统需要提供某种技术从逻辑上对内存空间进行扩充（虚拟性）</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gr9goghkbvj30u208an6n.jpg"></p>
</li>
<li><p>操作系统需要提供地址转换功能，负责程序的逻辑地址与物理地址的转换</p>
<blockquote>
<p>为了使编程更方便，程序员写程序时应该只需要关注指令、数据的逻辑地址。而逻辑地址到物理地址的转换（这个过程称为地址重定位）应该由操作系统负责，这样就保证了程序员写程序时不需要关注物理内存的实际情况（三种装入方式）</p>
</blockquote>
</li>
<li><p>操作系统需要提供内存保护功能，保证各进程在各自存储空间内运行，互不干扰</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gr9gln6rgbj30w20esk6e.jpg"></p>
</li>
</ol>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gr9gnoyq7gj30wy0fk15p.jpg"></p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>操作系统原理</tag>
      </tags>
  </entry>
  <entry>
    <title>减少延迟时间的方法</title>
    <url>/2020/09/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E5%87%8F%E5%B0%91%E5%BB%B6%E8%BF%9F%E6%97%B6%E9%97%B4%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gris7782ivj30ve0b6k8u.jpg"></p>
<h3 id="方法1：交替编号"><a href="#方法1：交替编号" class="headerlink" title="方法1：交替编号"></a>方法1：交替编号</h3><p>若采用交替编号的策略，即让逻辑上相邻的扇区在物理上有一定的间隔，可以使读取连续的逻辑扇区所需要的延迟时间更小</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grisam1wnrj30c00bqth1.jpg"></p>
<h3 id="磁盘地址结构的设计"><a href="#磁盘地址结构的设计" class="headerlink" title="磁盘地址结构的设计"></a>磁盘地址结构的设计</h3><p>为什么磁盘的物理地址是（柱面号，盘面号，扇区号），而不是（盘面号，柱面号，扇区号）？</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grisfrt28jj30c00d4th8.jpg"></p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grisg7zvifj30iq0ak7cy.jpg"></p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grisht1oe5j30eu0ck14j.jpg"></p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grisicqn8bj30j4080wmb.jpg"></p>
<p>读取地址连续的磁盘块时，采用（柱面号，盘面号，扇区号）的地址结构可以减少磁头移动消耗的时间</p>
<h3 id="方法2：错位命名"><a href="#方法2：错位命名" class="headerlink" title="方法2：错位命名"></a>方法2：错位命名</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grispm4294j30yg0gk1kx.jpg"></p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grisrfi4x5j30y40f27v4.jpg"></p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>操作系统原理</tag>
      </tags>
  </entry>
  <entry>
    <title>初识文件管理</title>
    <url>/2020/10/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E5%88%9D%E8%AF%86%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<p>文件就是一组有意义的信息/数据集合</p>
<blockquote>
<ol>
<li><p>计算机中存放了各种各样的文件，一个文件有哪些属性？</p>
<ul>
<li>文件名：由创建文件的用户决定文件名，主要是为了方便用户找到文件，同一目录下不允许有重名文件</li>
<li>标识符：一个系统内的各文件标识符唯一，对用户来说毫无可读性，因此标识符只是操作系统用于区分各个文件的一种内部名称</li>
<li>类型：指明文件的类型</li>
<li>位置：文件存放的路径（让用户使用）、在外存中的地址（操作系统使用，对用户不可见）</li>
<li>大小：指明文件大小</li>
<li>创建时间、上次修改时间</li>
<li>文件所有者信息</li>
<li>保护信息：对文件进行保护的访问控制信息</li>
</ul>
</li>
<li><p>文件内部的数据应该怎样组织起来？（文件的逻辑结构）</p>
<ul>
<li><p>无结构文件：如文本文件，由一些二进制或字符流组成，又称“流式文件”</p>
</li>
<li><p>有结构文件：如数据库表，由一组相似的记录组成，又称“记录式文件”，记录是一组相关数据项的集合，数据项是文件系统中最基本的数据单位</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gre1zb64e4j30uy0e014r.jpg"></p>
</li>
</ul>
</li>
<li><p>文件之间又应该怎么组织起来？</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gre21gn61tj30xc0e84ee.jpg"></p>
</li>
<li><p>从下往上看，OS应提供哪些功能，才能方便用户、应用程序使用文件？</p>
<ul>
<li>可以创建文件：点击新建后，图形化交互进程在背后调用了“create系统调用”</li>
<li>可以删除文件：点了删除之后，图形化交互进程通过操作系统提供的删除文件功能，即delete系统调用，将文件数据从外存中删除</li>
<li>可以读文件：将文件数据读入内存，才能让CPU处理，双击后，记事本应用程序通过操作系统提供的读文件功能，即read系统调用，将文件数据从外存读入内存，并显示在屏幕上</li>
<li>可以写文件：将更改过的文件数据写回外存，我们在记事本应用程序中编辑文件内容，点击保存后，记事本应用程序通过操作系统提供的写文件功能，即write系统调用，将文件数据从内存写回外存</li>
<li>打开文件：open系统调用</li>
<li>关闭文件：close系统调用</li>
</ul>
<p>❗️读/写文件之前，需要“打开文件”，读/写文件结束之后，需要“关闭文件”</p>
<p>可用几个基本操作完成更复杂的操作，比如复制文件，先创建一个新的空文件，再把源文件读入内存，再将内存中的数据写到新文件中</p>
</li>
<li><p>从上往下看，文件数据应该怎么存放在外存（磁盘）上？（文件的物理结构）</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gre2kfcyngj30y20iswwe.jpg"></p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gre2o88099j30mq0eq7iv.jpg"></p>
<p>操作系统又应该怎么管理空闲磁盘块？</p>
</li>
<li><p>其他需要由操作系统实现的文件管理功能</p>
<ul>
<li>文件共享：使多个用户可以共享使用一个文件</li>
<li>文件保护：如何保证不同的用户对文件有不同的操作权限</li>
</ul>
</li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>操作系统原理</tag>
      </tags>
  </entry>
  <entry>
    <title>文件保护</title>
    <url>/2020/09/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%96%87%E4%BB%B6%E4%BF%9D%E6%8A%A4/</url>
    <content><![CDATA[<p>操作系统需要保护文件数据的安全</p>
<h2 id="口令保护"><a href="#口令保护" class="headerlink" title="口令保护"></a>口令保护</h2><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grhw4w64rfj30rq0aqk0a.jpg"></p>
<h2 id="加密保护"><a href="#加密保护" class="headerlink" title="加密保护"></a>加密保护</h2><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grhw72rqm9j30y20ccqer.jpg"></p>
<p>优点：保密性强，不需要在系统中存储密码</p>
<p>缺点：编码/译码，或者说加密/解密要花费一定时间</p>
<h2 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h2><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grhwdfa9gjj30x20fm13d.jpg"></p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grhwgh6hbsj30vu0b6aoi.jpg"></p>
<p>实现灵活，可以实现复杂的文件保护功能</p>
<p>如果对某个目录进行了访问权限的控制，那也要对目录下的所有文件进行相同的访问权限控制</p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>操作系统原理</tag>
      </tags>
  </entry>
  <entry>
    <title>文件共享</title>
    <url>/2020/09/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB/</url>
    <content><![CDATA[<p>操作系统为用户提供文件共享功能，可以让多个用户共享的使用同一个文件</p>
<p>多个用户共享同一个文件，意味着系统中只有一份文件数据，并且只要某个用户修改了该文件的数据，其他用户也可以看到文件数据的变化</p>
<p>如果是多个用户都复制了同一个文件，那么系统中会有好几份文件数据，其中一个用户修改了自己的那份文件数据，对其他用户的文件数据并没有影响</p>
<h2 id="基于索引结点的共享方式（硬链接）"><a href="#基于索引结点的共享方式（硬链接）" class="headerlink" title="基于索引结点的共享方式（硬链接）"></a>基于索引结点的共享方式（硬链接）</h2><p>各个用户的目录项指向同一个索引结点：</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grhvbdnft6j30uq0eiapt.jpg"></p>
<p>若count &gt; 0，说明还有别的用户要使用该文件，暂时不能把文件数据删除，否则会导致指针悬空</p>
<p>当count = 0时，系统负责删除文件</p>
<h2 id="基于符号链的共享方式（软链接、符号链接）"><a href="#基于符号链的共享方式（软链接、符号链接）" class="headerlink" title="基于符号链的共享方式（软链接、符号链接）"></a>基于符号链的共享方式（软链接、符号链接）</h2><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grhvfomo7bj30us0g2dy0.jpg"></p>
<p>即使软链接指向的共享文件已被删除，Link型文件依然存在，只是通过Link型文件中的路径去查找共享文件会失败（找不到对应目录项）</p>
<p>由于用软链接的方式访问共享文件时要查询多级目录，会有多次磁盘I/O，因此用软链接访问共享文件的速度要比硬链接更慢</p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>操作系统原理</tag>
      </tags>
  </entry>
  <entry>
    <title>文件存储空间管理</title>
    <url>/2020/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h2 id="存储空间的划分与初始化"><a href="#存储空间的划分与初始化" class="headerlink" title="存储空间的划分与初始化"></a>存储空间的划分与初始化</h2><p>目录区包含文件目录、空闲表、位示图、超级块等用于文件管理的数据</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grhl46pjuoj60y00gah6n02.jpg"></p>
<h2 id="几种管理方法"><a href="#几种管理方法" class="headerlink" title="几种管理方法"></a>几种管理方法</h2><h3 id="空闲表法（适用于“连续分配方式”）"><a href="#空闲表法（适用于“连续分配方式”）" class="headerlink" title="空闲表法（适用于“连续分配方式”）"></a>空闲表法（适用于“连续分配方式”）</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grhl7pafypj60ac0eetg702.jpg"></p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grhl838162j30ky08aq8a.jpg"></p>
<p>如何分配磁盘块，与内存管理中的动态分区分配很类似，为一个文件分配连续的存储空间。同样可采用首次适应、最佳适应、最坏适应等算法来决定要为文件分配哪个区间</p>
<p>如何回收磁盘块：与内存管理中的动态分区分配很类似，当回收某个存储区时需要有四种情况：回收区的前后都没有相邻空闲区、回收区的前后都是空闲区、回收区前面是空闲区、回收区后面是空闲区，总之，回收时需要注意表项的合并问题</p>
<h3 id="空闲链表法"><a href="#空闲链表法" class="headerlink" title="空闲链表法"></a>空闲链表法</h3><h4 id="空闲盘块链"><a href="#空闲盘块链" class="headerlink" title="空闲盘块链"></a>空闲盘块链</h4><p>以盘块为单位组成一条空闲链</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grhllchra0j30aa0d2n58.jpg"></p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grhlofh3naj30wg0dmwoz.jpg"></p>
<h4 id="空闲盘区链"><a href="#空闲盘区链" class="headerlink" title="空闲盘区链"></a>空闲盘区链</h4><p>以盘区为单位组成一条空闲链</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grhllzf16fj60gc0dek2j02.jpg"></p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grhlq9ap8aj30y20f0apb.jpg"></p>
<h3 id="位示图法（连续分配、离散分配都适用）"><a href="#位示图法（连续分配、离散分配都适用）" class="headerlink" title="位示图法（连续分配、离散分配都适用）"></a>位示图法（连续分配、离散分配都适用）</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grhltgxgfaj30x80gu1c1.jpg"></p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grhlvd8ksyj30mi05ujw4.jpg"></p>
<h3 id="成组链接法（理解即可）"><a href="#成组链接法（理解即可）" class="headerlink" title="成组链接法（理解即可）"></a>成组链接法（理解即可）</h3><p>空闲表法、空闲链表法不适用于大型文件系统，因为空闲表或空闲链表可能过大</p>
<p>UNIX系统中采用了成组链接法对磁盘空闲块进行管理，适合大型文件系统</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grhm0jpm2qj30v20d2aiu.jpg"></p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grhm51ti51j30yu0hc4jq.jpg"></p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grhmdsjrifj30zg0iqh6j.jpg"></p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grhmil6qh3j30y40iqnj2.jpg"></p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>操作系统原理</tag>
      </tags>
  </entry>
  <entry>
    <title>文件的基本操作</title>
    <url>/2020/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%96%87%E4%BB%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p>向上提供的几个最基本的功能：</p>
<ul>
<li><p>创建文件（create系统调用）：可以创建文件，点击新建后，图形化交互进程在背后调用了create系统调用</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grhtz6fpvaj30g40c0n7l.jpg"></p>
</li>
<li><p>删除文件（delete系统调用）：可以删除文件，点了删除之后，图形化交互进程通过操作系统提供的删除文件功能，即delete系统调用，将文件数据从外存中删除</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grhu31safwj30g40c0qc2.jpg"></p>
</li>
<li><p>打开文件（open系统调用）</p>
<p>❗️打开文件时并不会把文件数据直接读入内存，只是将目录项中的信息复制到内存中的打开文件表中，并将打开文件表的索引号返回给用户</p>
<p>索引号也称“文件描述符”</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grhu7iaypbj30ya0h2kgx.jpg"></p>
<p>每个进程有自己的打开文件表，系统中也有一张总的打开文件表：</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grhub554sgj30vq0ik4oy.jpg"></p>
</li>
<li><p>关闭文件（close系统调用）</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grhuctcfbwj30xk0i8tt1.jpg"></p>
</li>
<li><p>读文件（read系统调用）：可以读文件，将文件数据读入内存，才能让CPU处理，双击后，记事本应用程序通过操作系统提供的读文件功能，即read系统调用，将文件数据从外存读入内存，并显示在屏幕上</p>
<p>❗️读/写文件用文件描述符即可指明文件，不再需要用到“文件名”</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grhujn77dxj30g20d848j.jpg"></p>
</li>
<li><p>写文件（write系统调用）：可以写文件，将更改过的文件数据写回外存，，我们在记事本应用程序中编辑文件内容，点击保存后，记事本应用程序通过操作系统提供的写文件功能，即write系统调用，将文件数据从内存写回外存</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grhukyiymqj60g20d8k0q02.jpg"></p>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>操作系统原理</tag>
      </tags>
  </entry>
  <entry>
    <title>文件的物理结构(文件分配方式)</title>
    <url>/2020/10/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%96%87%E4%BB%B6%E7%9A%84%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84(%E6%96%87%E4%BB%B6%E5%88%86%E9%85%8D%E6%96%B9%E5%BC%8F)/</url>
    <content><![CDATA[<p>操作系统需要对磁盘块进行哪些管理：</p>
<ul>
<li>对非空闲磁盘块的管理（存放了文件数据的磁盘块）：“文件的物理结构/文件分配方式要探讨的问题”</li>
<li>对空闲磁盘块的管理：“文件存储空间管理要探讨的问题”</li>
</ul>
<p>类似于内存分页，磁盘中的存储单元也会被分为一个个“块/磁盘块/物理块”，很多操作系统中，磁盘块的大小与内存块、页面的大小相同</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grgr5orivhj60li0d8dqh02.jpg"></p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grgr99x1ngj30x00hkhaj.jpg"></p>
<h2 id="连续分配"><a href="#连续分配" class="headerlink" title="连续分配"></a>连续分配</h2><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grgresoarsj30ws0fye08.jpg"></p>
<p>连续分配的优点：</p>
<ol>
<li><p>连续分配支持顺序访问和直接访问（即随机访问）</p>
</li>
<li><p>读取某个磁盘块时，需要移动磁头，访问的两个磁盘块相隔越远，移动磁头所需时间就越长，连续分配的文件在顺序读/写时速度最快</p>
</li>
</ol>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grgrjog296j30ao0bwwj4.jpg"></p>
<p>连续分配的缺点：</p>
<ol>
<li><img src="https://tva1.sinaimg.cn/large/008i3skNly1grgro74letj30w40dgh13.jpg"></li>
<li><img src="https://tva1.sinaimg.cn/large/008i3skNly1grgrpgtt4qj30s00bqk39.jpg"></li>
</ol>
<h2 id="链接分配"><a href="#链接分配" class="headerlink" title="链接分配"></a>链接分配</h2><p>链接分配采取离散分配的方式，可以为文件分配离散的磁盘块，分为隐式链接和显式链接两种</p>
<h3 id="隐式链接"><a href="#隐式链接" class="headerlink" title="隐式链接"></a>隐式链接</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grgrud0rwpj30xq0f21ir.jpg"></p>
<p>是否方便拓展文件：若此时要拓展文件，则可以随便找一个空闲磁盘块，挂到文件的磁盘块链尾，并修改文件的的FCB</p>
<p>结论：采用隐式链接的链接分配方式，很方便文件拓展，另外，所有的空闲磁盘块都可以被利用，不会有碎片问题，外存利用率高</p>
<h3 id="显式链接"><a href="#显式链接" class="headerlink" title="显式链接"></a>显式链接</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grgs3el8kvj30wc0g8dva.jpg"></p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grgs7tq269j30va0g8ttg.jpg"></p>
<p>缺点：文件分配表需要占用一定的存储空间</p>
<h2 id="索引分配"><a href="#索引分配" class="headerlink" title="索引分配"></a>索引分配</h2><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grgsix3kbmj30wi0gkno0.jpg"></p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grgslqtlopj30do0do44l.jpg"></p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grgsnpidgfj30eu0cgq7t.jpg"></p>
<h3 id="链接方案"><a href="#链接方案" class="headerlink" title="链接方案"></a>链接方案</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grgss224amj30vy0g04j6.jpg"></p>
<h3 id="多层索引"><a href="#多层索引" class="headerlink" title="多层索引"></a>多层索引</h3><p>![image-20210613181255832](/Users/liaojialong/Library/Application Support/typora-user-images/image-20210613181255832.png)</p>
<p>采用K层索引结构，且顶级索引表未调入内存，则访问一个数据块只需要K+1次读磁盘操作</p>
<p>缺点：即使是小文件，访问一个数据块依然需要K+1次读磁盘</p>
<h3 id="混合索引"><a href="#混合索引" class="headerlink" title="混合索引"></a>混合索引</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grgt76cljzj30xa0gkh6q.jpg"></p>
<p>优点：对于小文件来说，访问一个数据块所需的读磁盘次数更少</p>
<p>总结：</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grgthhizxbj30wy0dmh8d.jpg"></p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>操作系统原理</tag>
      </tags>
  </entry>
  <entry>
    <title>文件的逻辑结构</title>
    <url>/2020/10/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%96%87%E4%BB%B6%E7%9A%84%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<p>所谓的“逻辑结构”，就是指在用户看来，文件内部的数据应该是如何组织起来的。而“物理结构”指的是在操作系统看来，文件的数据是如何存放在外存中的（类比于数据结构中的“逻辑结构”、“物理结构”）</p>
<h2 id="无结构文件"><a href="#无结构文件" class="headerlink" title="无结构文件"></a>无结构文件</h2><p>文件内部的数据就是一系列二进制流或字符流组成，又称“流式文件”</p>
<p>文件内部的数据其实就是一系列字符流，没有明显的结构特性。因此也不用探讨无结构文件的“逻辑结构”问题</p>
<h2 id="有结构文件"><a href="#有结构文件" class="headerlink" title="有结构文件"></a>有结构文件</h2><p>由一组相似的记录组成，又称“记录式文件”，每条记录由若干个数据项组成，一般来说，每条记录有一个数据项可作为关键字（作为识别不同记录的ID）</p>
<p>根据各条记录的长度（占用的存储空间）是否相等，又可分为定长记录和可变长记录两种</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gre3kxkwskj30x609qh02.jpg"></p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gre3m7fi66j30w609kqd4.jpg"></p>
<p>根据有结构文件中的各条记录在逻辑上如何组织，可以分为三类：</p>
<h3 id="顺序文件"><a href="#顺序文件" class="headerlink" title="顺序文件"></a>顺序文件</h3><p>文件中的记录一个接一个的顺序排列（逻辑上），记录可以是定长的或可变长的。各个记录在物理上可以是顺序存储或链式存储</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gre42zaewdj30vm04k7a0.jpg"></p>
<ul>
<li>串结构：记录之间的顺序与关键字无关，通常按照记录存入的时间决定记录的顺序</li>
<li>顺序结构：记录之间的顺序按关键字顺序排列</li>
</ul>
<blockquote>
<p>假设已经知道了文件的起始地址，也就是第一个记录存放的位置</p>
<ol>
<li><p>能否快速找到第i个记录对应的地址？（即能否实现随机存取）</p>
</li>
<li><p>能否快速找到某个关键字对应的记录存放的位置？</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gre4lt2aazj30ye07i47j.jpg"></p>
<p>顺序文件的缺点是增加/删除一个记录比较困难，如果是串结构则相对简单</p>
</li>
</ol>
</blockquote>
<h3 id="索引文件"><a href="#索引文件" class="headerlink" title="索引文件"></a>索引文件</h3><p>对于可变长记录文件，要找到第i个记录，必须先顺序的查找前i-1个记录，但是很多应用场景中又必须使用可变长记录，如何解决这个问题？</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gre53mj668j30wc0b2qjf.jpg"></p>
<p>解决了顺序文件不方便增/删记录的问题，同时让不定长记录的文件实现了随机存取，但索引表可能占用很多空间</p>
<h3 id="索引顺序文件（多级索引顺序文件）"><a href="#索引顺序文件（多级索引顺序文件）" class="headerlink" title="索引顺序文件（多级索引顺序文件）"></a>索引顺序文件（多级索引顺序文件）</h3><p>索引文件的缺点：每个记录对应一个索引表项，因此索引表可能会很大，比如文件的每个记录平均只占8B，而每个索引表项占32个字节，那么索引表都要比文件内容本身大4倍，这样对存储空间的利用率就太低了</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gre5b23386j30wu0buar8.jpg"></p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gre5g4jstej30wc06uk2n.jpg"></p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gre5ijpkozj30wc0gcqid.jpg"></p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>操作系统原理</tag>
      </tags>
  </entry>
  <entry>
    <title>文件目录</title>
    <url>/2020/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95/</url>
    <content><![CDATA[<ul>
<li>文件之间的组织结构清晰，易于查找</li>
<li>编程时也可以很方便的用文件路径找到一个文件，用户可以轻松实现“按名存取”</li>
</ul>
<p>从操作系统的角度来看，这些目录结构应该是如何实现的？</p>
<h2 id="文件控制块（实现文件目录的关键数据结构）"><a href="#文件控制块（实现文件目录的关键数据结构）" class="headerlink" title="文件控制块（实现文件目录的关键数据结构）"></a>文件控制块（实现文件目录的关键数据结构）</h2><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grgfygq2e3j30my0f0ws8.jpg"></p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grgg043dm1j30lu0fkwur.jpg"></p>
<p>FCB实现了文件名和文件之间的映射，使用户（用户程序）可以实现“按名存取”</p>
<p>需要对目录进行哪些操作：</p>
<ul>
<li>搜索：当用户要使用一个文件时，系统要根据文件名搜索目录，找到该文件对应的目录项</li>
<li>创建文件：创建一个新文件时，需要在其所属的目录中增加一个目录项</li>
<li>删除文件：当删除一个文件时，需要在目录中删除相应的目录项</li>
<li>显示目录：用户可以请求显示目录的内容，如显示该目录中的所有文件及相应属性</li>
<li>修改目录：某些文件属性保存在目录中，因此这些属性变化时需要修改相应的目录项（如文件重命名）</li>
</ul>
<h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><h3 id="单级目录结构"><a href="#单级目录结构" class="headerlink" title="单级目录结构"></a>单级目录结构</h3><p>早期操作系统并不支持多级目录，整个系统中只建立一张目录表，每个文件占一个目录项</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grggckm8hhj30v60b0497.jpg"></p>
<h3 id="两级目录结构"><a href="#两级目录结构" class="headerlink" title="两级目录结构"></a>两级目录结构</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grggfr45pij30y20gonkt.jpg"></p>
<h3 id="多级目录结构（树形目录结构）"><a href="#多级目录结构（树形目录结构）" class="headerlink" title="多级目录结构（树形目录结构）"></a>多级目录结构（树形目录结构）</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grggj412iij30vu0gkwv3.jpg"></p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grggkplkclj30vu0587e3.jpg"></p>
<p>树形目录结构可以很方便的对文件进行分类，层次结构清晰，也能够更有效的进行文件的管理和保护。但是，树形结构不便于实现文件的共享。为此，提出了“无环图目录结构”</p>
<h3 id="无环图目录结构"><a href="#无环图目录结构" class="headerlink" title="无环图目录结构"></a>无环图目录结构</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grggqfjjk6j60x40e04gh02.jpg"></p>
<p>❗️只有共享计数器减为0时，才删除结点</p>
<p>❗️共享文件不同于复制文件，在共享文件中，由于各用户指向的是同一个文件，因此只要其中一个用户修改了文件数据，那么所有用户都可以看到文件数据的变化</p>
<h2 id="索引结点（对文件控制块的优化）"><a href="#索引结点（对文件控制块的优化）" class="headerlink" title="索引结点（对文件控制块的优化）"></a>索引结点（对文件控制块的优化）</h2><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grggyfj0dlj30vi0geh42.jpg"></p>
<p>由于目录项长度减小，因此每个磁盘块可以存放更多个目录项，因此检索文件时磁盘I/O的次数就少了很多</p>
<p>当找到文件名对应的目录项时，才需要将索引结点调入内存，索引结点中记录了文件的各种信息，包括文件在外存中的存放位置，根据“存放位置”即可找到文件</p>
<p>存放在外存中的索引结点称为“磁盘索引结点”，当索引结点放入内存后称为“内存索引结点”，相比之下内存索引结点中需要增加一些信息，比如文件是否被修改、此时有几个进程正在访问该文件等</p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>操作系统原理</tag>
      </tags>
  </entry>
  <entry>
    <title>文件系统的层次结构</title>
    <url>/2020/09/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grhwyrjjxfj30z80h41kx.jpg"></p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>操作系统原理</tag>
      </tags>
  </entry>
  <entry>
    <title>磁盘的管理</title>
    <url>/2020/09/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%A3%81%E7%9B%98%E7%9A%84%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h2 id="磁盘初始化"><a href="#磁盘初始化" class="headerlink" title="磁盘初始化"></a>磁盘初始化</h2><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grit0ej5noj30wo0be4cw.jpg"></p>
<h2 id="引导块"><a href="#引导块" class="headerlink" title="引导块"></a>引导块</h2><p>计算机开机时需要进行一系列初始化的工作，这些初始化的工作是通过执行初始化程序（自举程序）完成的</p>
<p>初始化程序可以放在ROM（只读存储器）中，ROM中的数据在出厂时就写入了，并且以后不能再修改（ROM一般是出厂时就集成在主板上的）</p>
<p>问题：万一需要更新自举程序，将会很不方便，因为ROM中的数据无法更改</p>
<p>ROM中只存放很小的“自举装入程序”，完整的自举程序放在磁盘的启动块（即引导块/启动分区）上，启动块位于磁盘的固定位置，拥有启动分区的磁盘称为启动磁盘或系统磁盘（C:盘）</p>
<p>开机时计算机先运行“自举装入程序”，通过执行该程序就可以找到引导块，并将完整的“自举程序”读入内存，完成初始化</p>
<h2 id="坏块的管理"><a href="#坏块的管理" class="headerlink" title="坏块的管理"></a>坏块的管理</h2><p>坏了、无法正常使用的扇区就是“坏块”，这属于硬件故障，操作系统是无法修复的。应该将坏块标记出来，以免错误的使用到它</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grithfvydhj30vq0be1am.jpg"></p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>操作系统原理</tag>
      </tags>
  </entry>
  <entry>
    <title>磁盘的结构</title>
    <url>/2020/09/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%A3%81%E7%9B%98%E7%9A%84%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h2 id="磁盘、磁道、扇区的概念"><a href="#磁盘、磁道、扇区的概念" class="headerlink" title="磁盘、磁道、扇区的概念"></a>磁盘、磁道、扇区的概念</h2><p>磁盘的表面由一些磁性物质组成，可以用这些磁性物质来记录二进制数据</p>
<p>磁盘的盘面被划分成一个个磁道，这样的一个圈就是一个磁道</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1griq471n3qj30w80d8qrz.jpg"></p>
<h2 id="如何在磁盘中读-写数据"><a href="#如何在磁盘中读-写数据" class="headerlink" title="如何在磁盘中读/写数据"></a>如何在磁盘中读/写数据</h2><p>需要把“磁头”移动到想要读/写的扇区所在的磁道，磁盘会转起来，让目标扇区从磁头下面划过，才能完成对扇区的读/写操作</p>
<h2 id="盘面、柱面的概念"><a href="#盘面、柱面的概念" class="headerlink" title="盘面、柱面的概念"></a>盘面、柱面的概念</h2><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1griqajdet5j30ly0gu4i7.jpg"></p>
<h2 id="磁盘的物理地址"><a href="#磁盘的物理地址" class="headerlink" title="磁盘的物理地址"></a>磁盘的物理地址</h2><p>可用（柱面号，盘面号，扇区号）来定位任意一个磁盘块，在文件的物理结构中，我们经常提到文件数据存放在外存中的几号块，这个块号就可以转换成（柱面号，盘面号，扇区号）的地址形式</p>
<p>可根据该地址读取一个块：</p>
<ol>
<li>根据柱面号移动磁臂，让磁头指向指定柱面</li>
<li>激活指定盘面对应的磁头</li>
<li>磁盘旋转的过程中，指定的扇区会从磁头下面划过，这样就完成了对指定扇区的读/写</li>
</ol>
<h2 id="磁盘的分类"><a href="#磁盘的分类" class="headerlink" title="磁盘的分类"></a>磁盘的分类</h2><p>磁头可以移动的称为活动头磁盘。磁臂可以来回伸缩来带动磁头定位磁道，每个盘面只有一个磁头</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1griqlweb9qj30d40cegwq.jpg"></p>
<p>磁头不可移动的称为固定头磁盘，这种磁盘中每个磁道有一个磁头</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1griqmd82cyj30d40ceqdz.jpg"></p>
<p>盘片可以更换的称为可换盘磁盘，盘片不可更换的称为固定盘磁盘</p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>操作系统原理</tag>
      </tags>
  </entry>
  <entry>
    <title>磁盘调度算法</title>
    <url>/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="一次磁盘读-写操作需要的时间"><a href="#一次磁盘读-写操作需要的时间" class="headerlink" title="一次磁盘读/写操作需要的时间"></a>一次磁盘读/写操作需要的时间</h2><p>寻找时间：（磁盘调度算法影响的指标）</p>
<ul>
<li><img src="https://tva1.sinaimg.cn/large/008i3skNly1grir0cwgx5j60iw08s7b802.jpg"></li>
</ul>
<p>延迟时间：</p>
<ul>
<li><img src="https://tva1.sinaimg.cn/large/008i3skNly1grir203z72j30kk05i7a6.jpg"></li>
</ul>
<p>传输时间：</p>
<ul>
<li><img src="https://tva1.sinaimg.cn/large/008i3skNly1grir49b40gj30iw0727b1.jpg"></li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grir56qxjoj30ci01qgm6.jpg"></p>
<p>延迟时间和传输时间都与磁盘转速相关，且为线性相关。而转速是硬件的固有属性，因此操作系统也无法优化延迟时间和传输时间</p>
<p>但是操作系统的磁盘调度算法会直接影响寻道时间</p>
<h2 id="磁盘调度算法"><a href="#磁盘调度算法" class="headerlink" title="磁盘调度算法"></a>磁盘调度算法</h2><h3 id="先来先服务FCFS"><a href="#先来先服务FCFS" class="headerlink" title="先来先服务FCFS"></a>先来先服务FCFS</h3><p>根据进程请求访问磁盘的先后顺序进行调度</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grircksch7j30v40e2qfb.jpg"></p>
<h3 id="最短寻找时间优先SSTF"><a href="#最短寻找时间优先SSTF" class="headerlink" title="最短寻找时间优先SSTF"></a>最短寻找时间优先SSTF</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grirfxcgxkj30ue0f6tpt.jpg"></p>
<h3 id="扫描算法SCAN"><a href="#扫描算法SCAN" class="headerlink" title="扫描算法SCAN"></a>扫描算法SCAN</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grirlg6djyj30us0gch82.jpg"></p>
<h3 id="LOOK调度算法（解决SCAN算法的第一个缺点）"><a href="#LOOK调度算法（解决SCAN算法的第一个缺点）" class="headerlink" title="LOOK调度算法（解决SCAN算法的第一个缺点）"></a>LOOK调度算法（解决SCAN算法的第一个缺点）</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1griromjpp1j30us0f8tq6.jpg"></p>
<h3 id="循环扫描算法C-SCAN（解决SCAN算法的第二个缺点）"><a href="#循环扫描算法C-SCAN（解决SCAN算法的第二个缺点）" class="headerlink" title="循环扫描算法C-SCAN（解决SCAN算法的第二个缺点）"></a>循环扫描算法C-SCAN（解决SCAN算法的第二个缺点）</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grirqflq52j30vw0f8158.jpg"></p>
<h3 id="C-LOOK调度算法（解决C-SCAN算法的缺点）"><a href="#C-LOOK调度算法（解决C-SCAN算法的缺点）" class="headerlink" title="C-LOOK调度算法（解决C-SCAN算法的缺点）"></a>C-LOOK调度算法（解决C-SCAN算法的缺点）</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grirsetfs1j30vw0eqtqk.jpg"></p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>操作系统原理</tag>
      </tags>
  </entry>
  <entry>
    <title>缓冲区管理</title>
    <url>/2020/09/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E7%BC%93%E5%86%B2%E5%8C%BA%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h2 id="什么是缓冲区？有什么作用？"><a href="#什么是缓冲区？有什么作用？" class="headerlink" title="什么是缓冲区？有什么作用？"></a>什么是缓冲区？有什么作用？</h2><p>缓冲区是一个存储区域，可以由专门的硬件寄存器组成，也可利用内存作为缓冲区</p>
<p>使用硬件作为缓冲区的成本较高，容量也较小，一般仅用在对速度要求非常高的场合（如存储器管理中所用的联想寄存器，由于对页表的访问频率极高，因此使用速度很快的联想寄存器来存放页表项的副本）</p>
<p>一般情况下，更多的是利用内存作为缓冲区，“设备独立性软件”的缓冲区管理就是要组织管理好这些缓冲区</p>
<p>缓冲区的作用：（内存作为缓冲区）</p>
<ol>
<li><p>缓和CPU与I/O设备之间速度不匹配的矛盾</p>
</li>
<li><p>减少对CPU的中断频率，放宽对CPU中断相应时间的限制</p>
</li>
<li><p>解决数据粒度不匹配的问题：如输出进程每次可以生成一块数据，但I/O设备每次只能输出一个字符</p>
</li>
<li><p>提高CPU与I/O设备之间的并行性</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grlbyvkdv1j30xq0a0drm.jpg"></p>
</li>
</ol>
<h2 id="单缓冲"><a href="#单缓冲" class="headerlink" title="单缓冲"></a>单缓冲</h2><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grlct25qudj30um0gctob.jpg"></p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grlcvuwv4tj30yi0ce7c0.jpg"></p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grlcy51cg4j30zg0cetlt.jpg"></p>
<h2 id="双缓冲"><a href="#双缓冲" class="headerlink" title="双缓冲"></a>双缓冲</h2><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grld2rbwlhj30ym0g2nd8.jpg"></p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grld75xowoj30v20dqdtu.jpg"></p>
<p>使用单/双缓冲在通信时的区别：</p>
<p>两台机器之间通信时，可以配置缓冲区用于数据的发送和接收，若两个相互通信的机器只设置单缓冲区，在任一时刻只能实现数据的单向传输，若两个相互通信的机器设置双缓冲区，则同一时刻可以实现双向的数据传输</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grlddejc0zj60qi098grq02.jpg"></p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grldg17yvhj30ha0ag442.jpg"></p>
<p>管道通信中的“管道”其实就是缓冲区，要实现数据的双向传输，必须设置两个管道</p>
<h2 id="循环缓冲"><a href="#循环缓冲" class="headerlink" title="循环缓冲"></a>循环缓冲</h2><p>将多个大小相等的缓冲区链接成一个循环队列</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grldlbqbuuj30m60cu7be.jpg"></p>
<h2 id="缓冲池"><a href="#缓冲池" class="headerlink" title="缓冲池"></a>缓冲池</h2><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grldohqngej30u00gq7j0.jpg"></p>
<ol>
<li>输入进程请求输入数据：从空缓冲队列中取出一块作为收容输入数据的工作缓冲区，充满数据后将缓冲区挂到输入队列队尾</li>
<li>计算进程想要取得一块输入数据：从输入队列中取得一块充满输入数据的缓冲区作为“提取输入数据的工作缓冲区”，缓冲区读空后挂到空缓冲区队列</li>
<li>计算进程想要将准备好的数据冲入缓冲区：从空缓冲队列中取出一块作为“收容输出数据的工作缓冲区”，数据充满后将缓冲区挂到输出队列队尾</li>
<li>输出进程请求输出数据：从输出队列中取得一块充满输出数据的缓冲区作为“提取输出数据的工作缓冲区”，缓冲区读空后挂到空缓冲区队列</li>
</ol>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>操作系统原理</tag>
      </tags>
  </entry>
  <entry>
    <title>设备的分配与回收</title>
    <url>/2020/09/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E8%AE%BE%E5%A4%87%E7%9A%84%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6/</url>
    <content><![CDATA[<h2 id="设备分配时应考虑的因素"><a href="#设备分配时应考虑的因素" class="headerlink" title="设备分配时应考虑的因素"></a>设备分配时应考虑的因素</h2><ol>
<li><p>设备的固有属性</p>
<ul>
<li>独占设备：一个时段只能分配给一个进程（打印机）</li>
<li>共享设备：可同时分配给多个进程使用（磁盘），各个进程往往是宏观上同时共享使用设备，而微观上交替使用</li>
<li>虚拟设备：采用SPOOLing技术将独占设备改造成虚拟的共享设备，可同时分配给多个进程使用（共享打印机）</li>
</ul>
</li>
<li><p>设备分配算法：先来先服务、优先级高者优先、短任务优先。。</p>
</li>
<li><p>设备分配中的安全性</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grla5xsurnj30v80a847t.jpg"></p>
</li>
</ol>
<h2 id="静态分配与动态分配"><a href="#静态分配与动态分配" class="headerlink" title="静态分配与动态分配"></a>静态分配与动态分配</h2><p>静态分配：进程运行前为其分配全部所需资源，运行结束后归还资源（破坏了“请求和保持”条件，不会发生死锁）</p>
<p>动态分配：进程运行过程中动态申请设备资源</p>
<h2 id="设备分配管理中的数据结构"><a href="#设备分配管理中的数据结构" class="headerlink" title="设备分配管理中的数据结构"></a>设备分配管理中的数据结构</h2><p>设备、控制器、通道之间的关系：一个通道可控制多个设备控制器，每个设备控制器可控制多个设备</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grlacyync0j30mi09in2f.jpg"></p>
<p>设备控制表DCT：系统为每个设备配置一张DCT，用于记录设备情况</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grlahu0z4jj30uy0aw16e.jpg"></p>
<p>控制器控制表COCT：每个设备控制器都会对应一张COCT，操作系统根据COCT的信息对控制器进行操作和管理</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grlakk33rqj30rw07gtgt.jpg"></p>
<p>通道控制表CHCT：每个通道都会对应一张CHCT，操作系统根据CHCT的信息对通道进行操作和管理</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grlaovlb2cj30su07g469.jpg"></p>
<p>系统设备表SDT：记录了系统中全部设备的情况，每个设备对应一个表目</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grlar03lbtj30pk07gdl6.jpg"></p>
<h2 id="设备分配的步骤"><a href="#设备分配的步骤" class="headerlink" title="设备分配的步骤"></a>设备分配的步骤</h2><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grlatg0ayej30tk05etfz.jpg"></p>
<p>只有设备、控制器、通道三者都分配成功时，这次设备分配才算成功，之后便可启动I/O设备进行数据传送</p>
<h2 id="设备分配步骤的改进方法"><a href="#设备分配步骤的改进方法" class="headerlink" title="设备分配步骤的改进方法"></a>设备分配步骤的改进方法</h2><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grlawotufzj30ji05en1p.jpg"></p>
<p>改进方法：建立逻辑设备名与物理设备名的映射机制，用户编程时只需提供逻辑设备名</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grlb2vr22ej30va0egng6.jpg"></p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grlb5eqevgj30vs0dadwd.jpg"></p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>操作系统原理</tag>
      </tags>
  </entry>
  <entry>
    <title>页面分配策略</title>
    <url>/2020/10/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/</url>
    <content><![CDATA[<h2 id="驻留集"><a href="#驻留集" class="headerlink" title="驻留集"></a>驻留集</h2><p>驻留集：指请求分页存储管理中给进程分配的物理块（内存块）的集合，在采用了虚拟存储技术的系统中，驻留集大小一般小于进程的总大小</p>
<p>假设某进程共有100个页面，则该进程的驻留集大小为100时进程可以全部放入内存，运行期间不可能再发生缺页。若驻留集大小为1，则进程运行期间必定会极频繁的缺页</p>
<p>若驻留集太小，会导致缺页频繁，系统要花大量的时间来处理缺页，实际用于进程推进的时间很少</p>
<p>若驻留集太大，又会导致多道程序并发度下降，资源利用率降低。所以应该选择一个合适的驻留集大小</p>
<h2 id="页面分配、置换策略"><a href="#页面分配、置换策略" class="headerlink" title="页面分配、置换策略"></a>页面分配、置换策略</h2><p>固定分配：操作系统为每个进程分配一组固定数目的物理块，在进程运行期间不再改变，即驻留集大小不变</p>
<p>可变分配：先为每个进程分配一定数目的物理块，在进程运行期间，可根据情况做适当的增加或减少，即驻留集大小可变</p>
<p>局部置换：发生缺页时只能选进程自己的物理块进行置换</p>
<p>全局置换：可以将操作系统保留的空闲物理块分配给缺页进程，也可以将别的进程持有的物理块置换到外存，再分配给缺页进程</p>
<p>⭐️没有固定分配的全局置换：全局置换意味着一个进程拥有的物理块数量必然会改变，因此不可能是固定分配</p>
<h3 id="固定分配局部置换"><a href="#固定分配局部置换" class="headerlink" title="固定分配局部置换"></a>固定分配局部置换</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grc51pv674j30v203kaev.jpg"></p>
<h3 id="可变分配全局置换"><a href="#可变分配全局置换" class="headerlink" title="可变分配全局置换"></a>可变分配全局置换</h3><p>系统会锁定一些页面，这些页面中的内容不能置换出外存（如重要的内核数据可以设为“锁定”）</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grc52aftxtj30v204qqcm.jpg"></p>
<h3 id="可变分配局部置换（该策略最好）"><a href="#可变分配局部置换（该策略最好）" class="headerlink" title="可变分配局部置换（该策略最好）"></a>可变分配局部置换（该策略最好）</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grc562tifaj30v2040n36.jpg"></p>
<p>可变分配全局置换：只要缺页就给分配新物理块</p>
<p>可变分配局部置换：要根据发生缺页的频率来动态的增加或减少进程的物理块</p>
<h2 id="何时调入页面"><a href="#何时调入页面" class="headerlink" title="何时调入页面"></a>何时调入页面</h2><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grc5d19692j30vw0bu4h1.jpg"></p>
<h2 id="从何处调入页面"><a href="#从何处调入页面" class="headerlink" title="从何处调入页面"></a>从何处调入页面</h2><ol>
<li><p>系统拥有足够的对换区空间：页面的调入、调出都是在内存与对换区之间进行，这样可以保证页面的调入、调出速度很快。在进程运行前，需将进程相关的数据从文件区复制到对换区</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grc5hckzxqj30h40ckqbe.jpg"></p>
</li>
<li><p>系统缺少足够的对换区空间：凡是不会被修改的数据都直接从文件区调入，由于这些页面不会被修改，因此换出时不必写回磁盘，下次需要时再从文件区调入即可。对于可能被修改的部分，换出时需写回磁盘对换区，下次需要时再从对换区调入</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grc5om9ta6j30gc0dodpi.jpg"></p>
</li>
<li><p>UNIX方式：运行之前进程有关的数据全部放在文件区，故未使用过的页面，都可从文件区调入。若被使用过的页面需要换出，则写回对换区，下次需要时从对换区调入</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grc5tegmw9j30gc0dethb.jpg"></p>
</li>
</ol>
<h2 id="抖动（颠簸）现象"><a href="#抖动（颠簸）现象" class="headerlink" title="抖动（颠簸）现象"></a>抖动（颠簸）现象</h2><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grc5vgfoq7j30v808kqer.jpg"></p>
<h2 id="工作集"><a href="#工作集" class="headerlink" title="工作集"></a>工作集</h2><p>根据工作集来分配驻留集：</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1grc61ciabrj30v80fktl8.jpg"></p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>操作系统原理</tag>
      </tags>
  </entry>
  <entry>
    <title>KMP算法</title>
    <url>/2020/01/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/KMP%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<hr>
<p>朴素模式匹配算法的缺点：当某些子串与模式串能部分匹配时，主串的扫描指针i经常回溯，导致时间开销增加</p>
<p>改进思路：主串指针不回溯，只有模式串指针回溯</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gooexhl0i6j31970u0wi9.jpg"></p>
<p>求模式串的next数组：当模式串的第j个字符匹配失败时，令模式串跳到next[j]再继续匹配</p>
<p>串的前缀：包含第一个字符，且不包含最后一个字符的子串<br>串的后缀：包含最后一个字符，且不包含第一个字符的子串</p>
<p>手写求next：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1googecuxk4j30ny0ev74q.jpg"></p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goohhr9anej30i20r30uz.jpg"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;stdbool.h&gt;</span><br><span class="line"></span><br><span class="line">#define MAXIEN 255  &#x2F;&#x2F;预定义最大串长为255</span><br><span class="line"></span><br><span class="line">typedef struct&#123;</span><br><span class="line">    char ch[MAXIEN];  &#x2F;&#x2F;每个分量存储一个字符</span><br><span class="line">    int length;  &#x2F;&#x2F;串的实际长度</span><br><span class="line">&#125;SString;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;求模式串T的next数组</span><br><span class="line">void get_next(SString *T,int next[])&#123;</span><br><span class="line">    int i&#x3D;1,j&#x3D;0;</span><br><span class="line">    next[1]&#x3D;0;</span><br><span class="line">    while(i&lt;T-&gt;length)&#123;</span><br><span class="line">        if(j&#x3D;&#x3D;0 || T-&gt;ch[i] &#x3D;&#x3D; T-&gt;ch[j])&#123;</span><br><span class="line">            ++i;</span><br><span class="line">            ++j;</span><br><span class="line">            &#x2F;&#x2F;若pi&#x3D;pj，则next[j+1]&#x3D;next[j]+1</span><br><span class="line">            next[i]&#x3D;j;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            &#x2F;&#x2F;否则令j&#x3D;next[j]，循环继续</span><br><span class="line">            j&#x3D;next[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;KMP算法代码【平均时间复杂度O(n+m)】</span><br><span class="line">int Index_KMP(SString *S,SString *T)&#123;</span><br><span class="line">    int i&#x3D;1,j&#x3D;1;</span><br><span class="line">    int next[T-&gt;length+1];</span><br><span class="line">    get_next(T, next);  &#x2F;&#x2F;求模式串的next数组</span><br><span class="line">    while(i&lt;&#x3D;S-&gt;length &amp;&amp; j&lt;&#x3D;T-&gt;length)&#123;</span><br><span class="line">        if(j&#x3D;&#x3D;0 || S-&gt;ch[i] &#x3D;&#x3D; T-&gt;ch[i])&#123;</span><br><span class="line">            ++i;</span><br><span class="line">            ++j;  &#x2F;&#x2F;继续比较后继字符</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            j&#x3D;next[j];  &#x2F;&#x2F;模式串向右移动</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(j&gt;T-&gt;length)&#123;</span><br><span class="line">        return i-T-&gt;length;  &#x2F;&#x2F;匹配成功</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    SString S;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>KMP算法存在的问题：多进行了一次无意义的对比</p>
<p>KMP算法进一步优化：nextval数组<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gooihh0098j30u00zbwh9.jpg"></p>
]]></content>
      <categories>
        <category>数据结构、算法笔记</category>
      </categories>
  </entry>
  <entry>
    <title>B树</title>
    <url>/2019/12/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/B%E6%A0%91/</url>
    <content><![CDATA[<hr>
<p>B树的定义：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goxg6fuohhj30ua0u07a0.jpg"></p>
<p>查找：B树的查找类似于二叉排序树的查找，不同的是B树的每个结点是多关键码的有序表，在到达某个结点时，先在有序表中查找，若找到则查找成功；否则按照指针到相应的子树中查找，到达空指针(即外部结点)时，查找失败</p>
<p>在B树上的查找过程是一个顺指针查找结点和在结点中查找关键码交叉进行的过程。由于B树通常存储在磁盘上，则前一个查找操作是在磁盘上进行，而后一个查找操作是在内存中进行，即在磁盘上找到某结点后，先将结点的信息读入内存,然后再查找等于k的关键码。显然,在磁盘上进行一次查找比在内存中进行一次查找耗费的时间多得多，因此，在磁盘上进行查找的次数，即待查关键码所在结点在B树的层数，是决定B树查找效率的首要因素。</p>
<p>插入：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goxhby9inij30u00vxjx5.jpg"></p>
<p>删除：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goxne0vn82j30xf0u042c.jpg"></p>
]]></content>
      <categories>
        <category>数据结构、算法笔记</category>
      </categories>
  </entry>
  <entry>
    <title>B+树</title>
    <url>/2019/12/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/B+%E6%A0%91/</url>
    <content><![CDATA[<hr>
<p>B+树的定义：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goxost4zmwj30zs0u0te3.jpg"></p>
]]></content>
      <categories>
        <category>数据结构、算法笔记</category>
      </categories>
  </entry>
  <entry>
    <title>串的定义和基本操作</title>
    <url>/2020/01/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E4%B8%B2%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<hr>
<p>串：即字符串(String)，是由零个或多个字符组成的有限序列，串中字符的个数n称为串的长度，n=0时的串称为空串</p>
<p><code>S=&quot;Hello World!&quot;</code>，有的地方用双引号(Java、C)，有的地方用单引号(Python)，注意里面包含空格，空格也是字符</p>
<p>子串：串中任意个连续的字符组成的子序列<br>主串：包含子串的串<br>字符在主串中的位置：字符在串中的序号<br>子串在主串中的位置：子串的第一个字符在主串中的位置【注意位序从1开始，而不是从0开始】</p>
<p>空串：M=””<br>空格串：N=”  “，[每个空格字符占1B]</p>
<p>串是一种特殊的线性表，数据元素之间呈线性关系，串的数据对象限定为字符集(如中文字符、英文字符、数字字符、标点字符)</p>
<p>串的基本操作。如增删改查等通常以子串为操作对象</p>
<p>串的基本操作：</p>
<ol>
<li><p><code>StrAssign(&amp;T,chars)</code>：赋值操作，把串T赋值为chars</p>
</li>
<li><p><code>StrCopy(&amp;T,S)</code>：复制操作，由串S复制得到串T</p>
</li>
<li><p><code>StrEmpty(S)</code>：判空操作，若S为空串，则返回true，否则返回False</p>
</li>
<li><p><code>StrLength(S)</code>：求串长，返回串S的元素个数</p>
</li>
<li><p><code>ClearString(&amp;S)</code>：清空操作，将S清为空串</p>
</li>
<li><p><code>DestroyString(&amp;S)</code>：销毁串，将串S销毁(回收存储空间)</p>
</li>
<li><p><code>Concat(&amp;T,S1,S2)</code>：串联接，用T返回由S1和S2联接而成的新串【问题：存储空间扩展？】</p>
</li>
<li><p><code>SubString(&amp;Sub,S,pos,len)</code>：求子串，用Sub返回串S的第pos个字符起长度为len的子串</p>
</li>
<li><p><code>Index(S,T)</code>：定位操作，若主串S中存在与串T值相同的子串，则返回它在主串S中第一次出现的位置；否则函数值为0</p>
</li>
<li><p><code>StrCompare(S,T)</code>：比较操作，若S&gt;T，则返回值&gt;0；若S=T，则返回值=0；若S&lt;T，则返回值&lt;0【从第一个字符开始往后依次对比，先出现更大字符的串就更大；长串的前缀与短串相同时，长串更大；只有两个串完全相同时才相等】</p>
</li>
</ol>
<p>字符集：英文字符(ASCII字符)、中英文(Unicode字符集，UIF-8,UIF-16)</p>
]]></content>
      <categories>
        <category>数据结构、算法笔记</category>
      </categories>
  </entry>
  <entry>
    <title>二叉排序树</title>
    <url>/2019/12/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/</url>
    <content><![CDATA[<hr>
<p>二叉排序树：BST，也称二叉查找树</p>
<p>二叉排序树或者为空树，或者为非空树，当为非空树时有如下特点：<br>1）若左子树非空，则左子树上所有结点关键字值均小于根结点的关键字<br>2）若右子树非空，则右子树上所有结点关键字值均大于根结点的关键字<br>3）左、右子树本身也分别是一棵二叉排序树<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gou53m3s0kj30ys0lcmxy.jpg"></p>
<p>二叉排序树的查找：二叉树非空时，查找根结点，若相等则查找成功；若不等，则当小于根结点值时查找左子树，当大于根结点的值时，查找右子树，当查找到叶结点仍没查找到相应的值，则查找失败<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gou5av09hij30zj0b974t.jpg"></p>
<p>二叉排序树的插入：若二叉排序树为空，则直接插入结点；若二叉排序树非空，当值小于根结点时，插入左子树；当值大于根结点时，插入右子树；当值等于根结点时不进行插入<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gou5fqb17zj30wl0c7wf8.jpg"></p>
<p>构造二叉排序树：读入一个元素并建立结点，若二叉树为空将其作为根结点；若二叉排序树非空，当值小于根结点时，插入左子树；当值大于根结点时，插入右子树；当值等于根结点时不进行插入<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gou5ldmn02j30mk07n0su.jpg"></p>
<p>二叉排序树的删除：<br>1）若被删除结点z是叶子结点，则直接删除<br>2）若被删除结点z只有一棵子树，则让z的子树成为z父结点的子树，代替z结点<br>3）若被删除结点z有两棵子树，则让z的‘中序序列直接后继’代替z，并删去直接后继结点</p>
<p>在二叉排序树中删除并插入某结点，得到的二叉排序树与原来不一定相同</p>
<p>二叉排序树的查找效率：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gou61x1ebyj30p40fjt94.jpg"></p>
]]></content>
      <categories>
        <category>数据结构、算法笔记</category>
      </categories>
  </entry>
  <entry>
    <title>串的存储结构</title>
    <url>/2020/01/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E4%B8%B2%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<hr>
<p>串的顺序存储：【默认使用方案四】<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gonwq62wcbj31ac0r1juc.jpg"></p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gonwryrdbvj30f20fgwgm.jpg"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">#define MAXIEN 255  &#x2F;&#x2F;预定义最大串长为255</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;静态数组实现(定长顺序存储)</span><br><span class="line">typedef struct&#123;</span><br><span class="line">    char ch[MAXIEN];  &#x2F;&#x2F;每个分量存储一个字符</span><br><span class="line">    int length;  &#x2F;&#x2F;串的实际长度</span><br><span class="line">&#125;SString;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;动态数组实现(堆分配存储)</span><br><span class="line">typedef struct&#123;</span><br><span class="line">    char *ch;  &#x2F;&#x2F;按串长分配存储区，ch指向串的基地址</span><br><span class="line">    int length;  &#x2F;&#x2F;串的长度</span><br><span class="line">&#125;HString;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;初始化动态数组</span><br><span class="line">void Init(HString *S)&#123;</span><br><span class="line">    </span><br><span class="line">    S-&gt;ch&#x3D;(char *)malloc(MAXIEN * sizeof(char));  &#x2F;&#x2F;用完需要手动free</span><br><span class="line">    S-&gt;length&#x3D;0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    </span><br><span class="line">    HString S;</span><br><span class="line">    Init(&amp;S);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>串的基本操作实现：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goob7yygk1j30ik0xoadi.jpg"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;stdbool.h&gt;</span><br><span class="line"></span><br><span class="line">#define MAXIEN 255  &#x2F;&#x2F;预定义最大串长为255</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;静态数组实现(定长顺序存储)</span><br><span class="line">typedef struct&#123;</span><br><span class="line">    char ch[MAXIEN];  &#x2F;&#x2F;每个分量存储一个字符</span><br><span class="line">    int length;  &#x2F;&#x2F;串的实际长度</span><br><span class="line">&#125;SString;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;基本操作的实现</span><br><span class="line">&#x2F;&#x2F;1.求子串：用Sub返回串S的第pos个字符起长度为len的子串</span><br><span class="line">bool SubString(SString *Sub,SString *S,int pos,int len)&#123;</span><br><span class="line">    &#x2F;&#x2F;子串范围越界</span><br><span class="line">    if(pos+len-1 &gt; S-&gt;length)&#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i&#x3D;pos-1;i&lt;pos+len-1;i++)&#123;</span><br><span class="line">        Sub-&gt;ch[i-pos+1]&#x3D;S-&gt;ch[i];</span><br><span class="line">    &#125;</span><br><span class="line">    Sub-&gt;length&#x3D;len;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;2.比较操作：若S&gt;T，则返回值&gt;0；若S&#x3D;T，则返回值&#x3D;0；若S&lt;T，则返回值&lt;0</span><br><span class="line">int StrCompare(SString *S,SString *T)&#123;</span><br><span class="line">    for(int i&#x3D;1;i&lt;&#x3D;S-&gt;length &amp;&amp; i&lt;&#x3D;T-&gt;length;i++)&#123;</span><br><span class="line">        if(S-&gt;ch[i] !&#x3D; T-&gt;ch[i])&#123;</span><br><span class="line">            return S-&gt;ch[i]-T-&gt;ch[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;扫描过的所有字符都相同，则长度长的串更大</span><br><span class="line">    return S-&gt;length-T-&gt;length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;求串长，返回串S的元素个数[未完成代码]</span><br><span class="line">int StrLength(SString *S)&#123;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;3.定位操作，若主串S中存在与串T值相同的子串，则返回它在主串S中第一次出现的位置，否则函数值为0</span><br><span class="line">int Index(SString *S,SString *T)&#123;</span><br><span class="line">    int i&#x3D;1,n&#x3D;StrLength(S),m&#x3D;StrLength(T);</span><br><span class="line">    SString sub;  &#x2F;&#x2F;用于暂存字符串</span><br><span class="line">    while(i&lt;&#x3D;n-m+1)&#123;</span><br><span class="line">        SubString(&amp;sub, S, i, m);</span><br><span class="line">        if(StrCompare(&amp;sub, T) !&#x3D; 0)&#123;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return i;  &#x2F;&#x2F;返回子串在主串中的位置</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;  &#x2F;&#x2F;S中不存在与T相等的子串</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    SString S&#x3D;&#123;&quot;hello world!&quot;,12&#125;;</span><br><span class="line">    </span><br><span class="line">    SString Sub&#x3D;&#123;&quot;&quot;,0&#125;;  &#x2F;&#x2F;初始化时清空数组</span><br><span class="line">    if(SubString(&amp;Sub, &amp;S, 3, 5))&#123;</span><br><span class="line">        printf(&quot;%s\n&quot;,Sub.ch);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>串的链式存储：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gonwzq5qfqj30dp076jsb.jpg"></p>
]]></content>
      <categories>
        <category>数据结构、算法笔记</category>
      </categories>
  </entry>
  <entry>
    <title>串的朴素模式匹配算法</title>
    <url>/2020/01/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E4%B8%B2%E7%9A%84%E6%9C%B4%E7%B4%A0%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<hr>
<p>一定是主串中存在的才叫“子串”</p>
<p>模式串：想尝试在主串中找到的串，未必存在</p>
<p>串的模式匹配：在主串中找到与模式串相同的子串，并返回其所在位置【就是定位操作】</p>
<p>朴素模式匹配算法：</p>
<p>【比较好的情况：每个子串的第一个字符就与模式串不匹配，若模式串长度为m，主串长度为n，则匹配成功的最好时间复杂度：O(m)，匹配失败的最好时间复杂度：O(n-m+1)=O(n-m)=O(n)】</p>
<p>【若模式串长度为m，主串长度为n，则直接匹配成功/匹配失败最多需要(n-m+1)*m次比较，最坏时间复杂度：O(nm)，这种情况就是每个子串的前m-1个字符都和模式串匹配，只有第m个字符不匹配，所以指针需要回溯重新来匹配】<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goodb75sqfj310t0dm3zc.jpg"></p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goocyb6bt9j30g70i2go0.jpg"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;stdbool.h&gt;</span><br><span class="line"></span><br><span class="line">#define MAXIEN 255  &#x2F;&#x2F;预定义最大串长为255</span><br><span class="line"></span><br><span class="line">typedef struct&#123;</span><br><span class="line">    char ch[MAXIEN];  &#x2F;&#x2F;每个分量存储一个字符</span><br><span class="line">    int length;  &#x2F;&#x2F;串的实际长度</span><br><span class="line">&#125;SString;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;只要有一个字符不同，就可以停止检查当前子串，所有对应位置的字符都相同，则匹配成功，返回k</span><br><span class="line">int Index(SString *S,SString *T)&#123;</span><br><span class="line">    int k&#x3D;1;  &#x2F;&#x2F;k记录当前检查的子串起始位置</span><br><span class="line">    int i&#x3D;k,j&#x3D;1;</span><br><span class="line">    while(i&lt;&#x3D;S-&gt;length &amp;&amp; j&lt;&#x3D;S-&gt;length)&#123;</span><br><span class="line">        if(S-&gt;ch[i] &#x3D;&#x3D; T-&gt;ch[i])&#123;</span><br><span class="line">            ++i;</span><br><span class="line">            ++j;  &#x2F;&#x2F;继续比较后继字符</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            k++;  &#x2F;&#x2F;检查下一个子串</span><br><span class="line">            i&#x3D;k;</span><br><span class="line">            j&#x3D;1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(j&lt;T-&gt;length)&#123;</span><br><span class="line">        return k;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    SString S;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构、算法笔记</category>
      </categories>
  </entry>
  <entry>
    <title>二叉树的遍历</title>
    <url>/2019/12/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<hr>
<p>二叉树的遍历：按某条搜索路径访问树中的每个结点，树的每个结点均被访问一次，而且只访问一次</p>
<p>先序遍历(递归实现)：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gopd2tyr52j31830u0ac3.jpg"></p>
<p>中序遍历(递归实现)：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gopd38ntk9j31ac0mtdhj.jpg"></p>
<p>中序遍历非递归算法：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gopd59z6y6j30u00v4n0s.jpg"></p>
<p>后序遍历(递归实现)：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gopd3wuuajj31ac0komyv.jpg"></p>
<p>层次遍历：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gopd5qwrfvj30v30u0whs.jpg"></p>
<p>由遍历序列构造二叉树：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gopd79baymj31ac0i00u5.jpg"></p>
]]></content>
      <categories>
        <category>数据结构、算法笔记</category>
      </categories>
  </entry>
  <entry>
    <title>二叉树的概念</title>
    <url>/2019/12/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<hr>
<p>二叉树是n(n&gt;=0)个结点的有限集合<br>1）n=0时，二叉树为空<br>2）n&gt;0时，由根结点和两个互不相交的被称为根的左子树和右子树组成，左子树和右子树也分别是一棵二叉树</p>
<p>特点：</p>
<ol>
<li>每个结点最多有两颗子树，所以二叉树中不存在度大于2的结点</li>
<li>二叉树的左右子树不能任意颠倒，如果某结点只有一棵子树，一定要指明它是左子树还是右子树</li>
</ol>
<p>二叉树 VS 度为2的有序树：<br>1）二叉树可以为空，而度为2的有序树至少有三个结点<br>2）二叉树的孩子结点始终有左右之分，而度为2的有序树的孩子结点次序是相对的</p>
<p>斜树：所有结点都只有左子树的二叉树称为左斜树，所有结点都只有右子树的二叉树称为右斜树</p>
<ol>
<li>每一层只有一个结点</li>
<li>斜树的结点个数与其深度相同</li>
</ol>
<p>满二叉树：一棵高度为h，且含有2^h-1个结点的二叉树为满二叉树【在一棵二叉树中，所有分支结点都存在左子树和右子树，并且所有叶子都在同一层上】</p>
<ol>
<li>叶子只能出现在最下一层</li>
<li>只有度为0和度为2的结点</li>
</ol>
<p>完全二叉树：设一个高度为h、有n个结点的二叉树，当且仅当其每个结点都与高度为h的满二叉树中编号1～n的结点一一对应时，称为完全二叉树</p>
<ol>
<li>深度为k的完全二叉树在k-1层是满二叉树</li>
<li>叶子结点只能出现在最下两层，且最下层的叶子结点都集中在左侧连续的位置</li>
<li>如果有度为1的结点，只可能有一个，且该结点只有左孩子<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gooy3q1zfpj31ex0gawfe.jpg"></li>
</ol>
<p>完全二叉树的性质：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gooy8enjvwj30sh0ct3zp.jpg"></p>
<p>二叉排序树：一棵二叉树，若树非空则具有如下性质：对任意结点若存在左子树或右子树，则其左子树上所有结点的关键字均小于该结点，右子树上所有结点的关键字均大于该结点<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gooyenczv9j30k20gbdfz.jpg"></p>
<p>平衡二叉树：树上任意结点的左子树和右子树的高度差不超过1</p>
<p>二叉树的性质：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gop2wubrjzj31100u0jvq.jpg"></p>
]]></content>
      <categories>
        <category>数据结构、算法笔记</category>
      </categories>
  </entry>
  <entry>
    <title>内部排序算法的比较及应用</title>
    <url>/2019/11/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%86%85%E9%83%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E6%AF%94%E8%BE%83%E5%8F%8A%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<hr>
<p>冒泡排序、直接选择排序、快速排序、堆排序：一趟排序可以确定一个元素的位置<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gozsn4w62ej30se0codhh.jpg"></p>
<p>应用：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gozsnd3xprj30pf0c20u0.jpg"></p>
]]></content>
      <categories>
        <category>数据结构、算法笔记</category>
      </categories>
  </entry>
  <entry>
    <title>二叉树的存储结构</title>
    <url>/2019/12/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<hr>
<p>二叉树的顺序存储：用一组连续的存储单元依次自上而下、自左至右存储完全二叉树上的结点元素<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gop5yj8qyqj30y80u0ad0.jpg"></p>
<p>二叉树的链式存储：用链表来存放一棵二叉树，二叉树中每个结点用链表的一个链结点来存储<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gop6b68tj1j31ac0ni0ue.jpg"></p>
]]></content>
      <categories>
        <category>数据结构、算法笔记</category>
      </categories>
  </entry>
  <entry>
    <title>关键路径</title>
    <url>/2019/12/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<hr>
<p>在一个表示工程的带权有向图中，用顶点表示事件，用有向边表示活动，边上的权值表示活动的持续时间，称这样的有向图为边表示活动的网，简称AOE网</p>
<p>在AOE网中，所有活动都完成才能到达终点，因此完成整个工程所必须花费的时间(即最短工期)应该为源点到终点的最大路径长度，具有最大路径长度的路径称为关键路径，关键路径上的活动称为关键活动<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gox69o7az9j30u00wltdl.jpg"></p>
<p>缩短关键活动时间可以加快整个工程，但缩短到一定大小时关键路径会发生改变</p>
<p>当网中关键路径不唯一时，只有加快的关键活动或关键活动组合包括在所有的关键路径上才能缩短工期</p>
]]></content>
      <categories>
        <category>数据结构、算法笔记</category>
      </categories>
  </entry>
  <entry>
    <title>分块查找</title>
    <url>/2019/12/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%88%86%E5%9D%97%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<hr>
<p>分块查找：又称索引顺序查找，其查找性能介于折半查找和顺序查找之间</p>
<p>分块查找的使用前提是将线性表进行分块，并使其分块有序，所谓分块有序是指将线性表划分为若干块，每一块内不要求有序(即块内无序)，但要求第二块中所有记录的关键码均大于第一块中所有记录的关键码，第三块中所有记录的关键码均大于第二块中所有记录的关键码，以此类推(即块间有序)</p>
<p>分块查找还需要建立一个索引表，每块对应一个索引项，各索引项按关键码有序排序</p>
<p>分块查找需要分两步进行：第一步在索引表中确定待查关键码所在的块；第二步在相应块中查找待查关键码。由于索引表是按关键码有序排列，可使用顺序查找，也可使用折半查找；在块内进行查找时，由于块内是无序的，只能使用顺序查找<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goxetlfqoaj314c0pnwfx.jpg"></p>
]]></content>
      <categories>
        <category>数据结构、算法笔记</category>
      </categories>
  </entry>
  <entry>
    <title>十字链表</title>
    <url>/2019/12/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%8D%81%E5%AD%97%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<hr>
<p>十字链表：有向图的一种链式存储结构<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1govxr00ilej30u00yrn2e.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1govxrlmiedj30gu0czmxs.jpg"></p>
]]></content>
      <categories>
        <category>数据结构、算法笔记</category>
      </categories>
  </entry>
  <entry>
    <title>单链表的定义</title>
    <url>/2020/01/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AE%9A%E4%B9%89/</url>
    <content><![CDATA[<hr>
<p>单链表：用链式存储的方式实现线性表，每个结点除了存放数据元素外，还要存储指向下个节点的指针</p>
<p>单链表的特点：</p>
<ol>
<li>不要求大片连续空间，改变容量方便</li>
<li>不可随机存取，要耗费一定空间存放指针</li>
</ol>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gohac74t4mj30jn0zudj2.jpg"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdbool.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">typedef struct LNode&#123;  &#x2F;&#x2F;LNode:结点</span><br><span class="line">    int data;  &#x2F;&#x2F;数据域：每个结点存放一个数据元素</span><br><span class="line">    struct LNode *next;  &#x2F;&#x2F;指针域：指针指向下一个结点</span><br><span class="line">&#125;LNode,*LinkList;  &#x2F;&#x2F;typedef struct LNode *LinkList;  要表示一个单链表时，只需声明一个头指针L，指向单链表的第一个结点</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;初始化一个空的链表(不带头结点)</span><br><span class="line">&#x2F;&#x2F;bool InitList(LinkList *L)&#123;</span><br><span class="line">&#x2F;&#x2F;    (*L)&#x3D;NULL;  &#x2F;&#x2F;空表，暂时还没有任何结点，防止脏数据</span><br><span class="line">&#x2F;&#x2F;    return true;</span><br><span class="line">&#x2F;&#x2F;&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;判断单链表是否为空(不带头结点)</span><br><span class="line">&#x2F;&#x2F;bool Empty(LinkList *L)&#123;</span><br><span class="line">&#x2F;&#x2F;    if((*L) &#x3D;&#x3D; NULL)&#123;</span><br><span class="line">&#x2F;&#x2F;        return true;</span><br><span class="line">&#x2F;&#x2F;    &#125;</span><br><span class="line">&#x2F;&#x2F;    else&#123;</span><br><span class="line">&#x2F;&#x2F;        return false;</span><br><span class="line">&#x2F;&#x2F;    &#125;</span><br><span class="line">&#x2F;&#x2F;&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;这里LNode *和LinkList是等价的，LinkList强调这是一个单链表，LNode *强调这是一个结点</span><br><span class="line">&#x2F;&#x2F;LNode * GetElem(LinkList L,int i)&#123;</span><br><span class="line">&#x2F;&#x2F;    int j&#x3D;1;</span><br><span class="line">&#x2F;&#x2F;    LNode *p&#x3D;L-&gt;next;</span><br><span class="line">&#x2F;&#x2F;    if(i &#x3D;&#x3D; 0)&#123;</span><br><span class="line">&#x2F;&#x2F;        return L;</span><br><span class="line">&#x2F;&#x2F;    &#125;</span><br><span class="line">&#x2F;&#x2F;    if(i&lt;1)&#123;</span><br><span class="line">&#x2F;&#x2F;        return NULL;</span><br><span class="line">&#x2F;&#x2F;    &#125;</span><br><span class="line">&#x2F;&#x2F;    while(p !&#x3D; NULL &amp;&amp; j&lt;i)&#123;</span><br><span class="line">&#x2F;&#x2F;        p&#x3D;p-&gt;next;</span><br><span class="line">&#x2F;&#x2F;        j++;</span><br><span class="line">&#x2F;&#x2F;    &#125;</span><br><span class="line">&#x2F;&#x2F;    return p;</span><br><span class="line">&#x2F;&#x2F;&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;初始化一个单链表(带头结点)</span><br><span class="line">bool InitList(LinkList *L)&#123;</span><br><span class="line">    (*L)&#x3D;(LNode *)malloc(sizeof(LNode));  &#x2F;&#x2F;分配一个头结点,并使得头指针*L指向这个头结点</span><br><span class="line">    if((*L) &#x3D;&#x3D; NULL)&#123;  &#x2F;&#x2F;内存不足，分配失败</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    (*L)-&gt;data&#x3D;0;  &#x2F;&#x2F;头结点不存储数据</span><br><span class="line">    (*L)-&gt;next&#x3D;NULL;  &#x2F;&#x2F;头结点之后暂时还没有结点</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;判断单链表是否为空(带头结点)</span><br><span class="line">bool Empty(LinkList *L)&#123;</span><br><span class="line">    if((*L)-&gt;next &#x3D;&#x3D; NULL)&#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    </span><br><span class="line">    LinkList L;  &#x2F;&#x2F;等价于LNode *L;  声明一个指向单链表的第一个结点的指针，注意此处并没有创建一个结点</span><br><span class="line">    InitList(&amp;L);  &#x2F;&#x2F;初始化一个空表</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;...后续代码</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>不带头结点写代码更麻烦，带头结点写代码更方便<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gohyzib200j31050u0acm.jpg"></p>
]]></content>
      <categories>
        <category>数据结构、算法笔记</category>
      </categories>
  </entry>
  <entry>
    <title>单链表的建立</title>
    <url>/2020/01/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%BB%BA%E7%AB%8B/</url>
    <content><![CDATA[<hr>
<p>如果给你很多个数据元素，要把它们存到一个空单链表里？</p>
<h3 id="尾插法-带头结点-，时间复杂度为O-n-：将数据元素一个一个的插入到单链表的尾部"><a href="#尾插法-带头结点-，时间复杂度为O-n-：将数据元素一个一个的插入到单链表的尾部" class="headerlink" title="尾插法(带头结点)，时间复杂度为O(n)：将数据元素一个一个的插入到单链表的尾部"></a>尾插法(带头结点)，时间复杂度为O(n)：将数据元素一个一个的插入到单链表的尾部</h3><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goidt71zayj30ln0oymzy.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goie4bjwkej31ag0bm74w.jpg"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdbool.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">typedef struct LNode&#123;  &#x2F;&#x2F;LNode:结点</span><br><span class="line">    int data;  &#x2F;&#x2F;数据域：每个结点存放一个数据元素</span><br><span class="line">    struct LNode *next;  &#x2F;&#x2F;指针域：指针指向下一个结点</span><br><span class="line">&#125;LNode,*LinkList;  &#x2F;&#x2F;typedef struct LNode *LinkList;  要表示一个单链表时，只需声明一个头指针L，指向单链表的第一个结点</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;初始化一个单链表(带头结点)</span><br><span class="line">bool InitList(LinkList *L)&#123;</span><br><span class="line">    (*L)&#x3D;(LNode *)malloc(sizeof(LNode));  &#x2F;&#x2F;分配一个头结点,并使得头指针*L指向这个头结点</span><br><span class="line">    if((*L) &#x3D;&#x3D; NULL)&#123;  &#x2F;&#x2F;内存不足，分配失败</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    (*L)-&gt;data&#x3D;0;  &#x2F;&#x2F;头结点不存储数据</span><br><span class="line">    (*L)-&gt;next&#x3D;NULL;  &#x2F;&#x2F;头结点之后暂时还没有结点</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;尾插法建立单链表</span><br><span class="line">LinkList List_TailInsert(LinkList *L)&#123;</span><br><span class="line">    int x;</span><br><span class="line"></span><br><span class="line">    LNode *s,*r&#x3D;*L;  &#x2F;&#x2F;r为表尾指针</span><br><span class="line">    scanf(&quot;%d\n&quot;,&amp;x);  &#x2F;&#x2F;输入结点的值</span><br><span class="line">    </span><br><span class="line">    while(x !&#x3D; 9999)&#123;  &#x2F;&#x2F;输入9999表示结束</span><br><span class="line">        s&#x3D;(LNode *)malloc(sizeof(LNode));</span><br><span class="line">        s-&gt;data&#x3D;x;</span><br><span class="line">        r-&gt;next&#x3D;s;</span><br><span class="line">        r&#x3D;s;  &#x2F;&#x2F;r指向新的表尾结点，永远保持r指向最后一个结点</span><br><span class="line">        scanf(&quot;%d\n&quot;,&amp;x);</span><br><span class="line">    &#125;</span><br><span class="line">    r-&gt;next&#x3D;NULL;  &#x2F;&#x2F;尾结点指针置空</span><br><span class="line">    return *L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    </span><br><span class="line">    LinkList L;  &#x2F;&#x2F;等价于LNode *L;  声明一个指向单链表的第一个结点的指针，注意此处并没有创建一个结点</span><br><span class="line">    InitList(&amp;L);  &#x2F;&#x2F;初始化一个空表</span><br><span class="line">    </span><br><span class="line">    LinkList a&#x3D;List_TailInsert(&amp;L);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;...后续代码</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="头插法-带头结点-：将数据元素一个一个的插入到头结点之后-逆向建立单链表-，注意是每一个数据元素都放到头结点后一个的位置"><a href="#头插法-带头结点-：将数据元素一个一个的插入到头结点之后-逆向建立单链表-，注意是每一个数据元素都放到头结点后一个的位置" class="headerlink" title="头插法(带头结点)：将数据元素一个一个的插入到头结点之后(逆向建立单链表)，注意是每一个数据元素都放到头结点后一个的位置"></a>头插法(带头结点)：将数据元素一个一个的插入到头结点之后(逆向建立单链表)，注意是每一个数据元素都放到头结点后一个的位置</h3><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goierxazy4j30lw0p3dim.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goieo6cgfhj31au08wwf1.jpg"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdbool.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">typedef struct LNode&#123;  &#x2F;&#x2F;LNode:结点</span><br><span class="line">    int data;  &#x2F;&#x2F;数据域：每个结点存放一个数据元素</span><br><span class="line">    struct LNode *next;  &#x2F;&#x2F;指针域：指针指向下一个结点</span><br><span class="line">&#125;LNode,*LinkList;  &#x2F;&#x2F;typedef struct LNode *LinkList;  要表示一个单链表时，只需声明一个头指针L，指向单链表的第一个结点</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;初始化一个单链表(带头结点)</span><br><span class="line">bool InitList(LinkList *L)&#123;</span><br><span class="line">    (*L)&#x3D;(LNode *)malloc(sizeof(LNode));  &#x2F;&#x2F;分配一个头结点,并使得头指针*L指向这个头结点</span><br><span class="line">    if((*L) &#x3D;&#x3D; NULL)&#123;  &#x2F;&#x2F;内存不足，分配失败</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    (*L)-&gt;data&#x3D;0;  &#x2F;&#x2F;头结点不存储数据</span><br><span class="line">    (*L)-&gt;next&#x3D;NULL;  &#x2F;&#x2F;头结点之后暂时还没有结点</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;头插法建立单链表</span><br><span class="line">LinkList List_HeadInsert(LinkList *L)&#123;</span><br><span class="line">    int x;</span><br><span class="line"></span><br><span class="line">    LNode *s;</span><br><span class="line">    scanf(&quot;%d\n&quot;,&amp;x);  &#x2F;&#x2F;输入结点的值</span><br><span class="line">    </span><br><span class="line">    while(x !&#x3D; 9999)&#123;  &#x2F;&#x2F;输入9999表示结束</span><br><span class="line">        s&#x3D;(LNode *)malloc(sizeof(LNode));</span><br><span class="line">        s-&gt;data&#x3D;x;</span><br><span class="line">        s-&gt;next&#x3D;(*L)-&gt;next;  &#x2F;&#x2F;s-&gt;next指向NULL</span><br><span class="line">        (*L)-&gt;next&#x3D;s;  &#x2F;&#x2F;将新结点插入表中，L为头指针</span><br><span class="line">        scanf(&quot;%d\n&quot;,&amp;x);</span><br><span class="line">    &#125;</span><br><span class="line">    return *L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    </span><br><span class="line">    LinkList L;  &#x2F;&#x2F;等价于LNode *L;  声明一个指向单链表的第一个结点的指针，注意此处并没有创建一个结点</span><br><span class="line">    InitList(&amp;L);  &#x2F;&#x2F;初始化一个空表</span><br><span class="line">    </span><br><span class="line">    LinkList a&#x3D;List_HeadInsert(&amp;L);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;...后续代码</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构、算法笔记</category>
      </categories>
  </entry>
  <entry>
    <title>单链表的查找</title>
    <url>/2020/01/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<hr>
<h3 id="单链表的按位查找-带头结点-：获取表L中第i个位置的元素的值，平均时间复杂度O-n"><a href="#单链表的按位查找-带头结点-：获取表L中第i个位置的元素的值，平均时间复杂度O-n" class="headerlink" title="单链表的按位查找(带头结点)：获取表L中第i个位置的元素的值，平均时间复杂度O(n)"></a>单链表的按位查找(带头结点)：获取表L中第i个位置的元素的值，平均时间复杂度O(n)</h3><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goib2xe0mbj30ls0oawh3.jpg"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdbool.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">typedef struct LNode&#123;  &#x2F;&#x2F;LNode:结点</span><br><span class="line">    int data;  &#x2F;&#x2F;数据域：每个结点存放一个数据元素</span><br><span class="line">    struct LNode *next;  &#x2F;&#x2F;指针域：指针指向下一个结点</span><br><span class="line">&#125;LNode,*LinkList;  &#x2F;&#x2F;typedef struct LNode *LinkList;  要表示一个单链表时，只需声明一个头指针L，指向单链表的第一个结点</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;初始化一个单链表(带头结点)</span><br><span class="line">bool InitList(LinkList *L)&#123;</span><br><span class="line">    (*L)&#x3D;(LNode *)malloc(sizeof(LNode));  &#x2F;&#x2F;分配一个头结点,并使得头指针*L指向这个头结点</span><br><span class="line">    if((*L) &#x3D;&#x3D; NULL)&#123;  &#x2F;&#x2F;内存不足，分配失败</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    (*L)-&gt;data&#x3D;0;  &#x2F;&#x2F;头结点不存储数据</span><br><span class="line">    (*L)-&gt;next&#x3D;NULL;  &#x2F;&#x2F;头结点之后暂时还没有结点</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;按位查找，返回第i个元素(带头结点)</span><br><span class="line">LNode * GetElem(LinkList *L,int i)&#123;</span><br><span class="line">    if(i&lt;0)&#123;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    LNode *p;  &#x2F;&#x2F;指针p指向当前扫描到的结点</span><br><span class="line">    int j&#x3D;0;  &#x2F;&#x2F;当前p指向的是第几个结点</span><br><span class="line">    p&#x3D;*L;  &#x2F;&#x2F;L指向头结点，头结点是第0个结点（不存数据）</span><br><span class="line">    while(p !&#x3D; NULL &amp;&amp; j&lt;i)&#123;  &#x2F;&#x2F;循环找到第i个结点</span><br><span class="line">        p&#x3D;p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    return p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    </span><br><span class="line">    LinkList L;  &#x2F;&#x2F;等价于LNode *L;  声明一个指向单链表的第一个结点的指针，注意此处并没有创建一个结点</span><br><span class="line">    InitList(&amp;L);  &#x2F;&#x2F;初始化一个空表</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;...后续代码</span><br><span class="line">    </span><br><span class="line">    LNode * a&#x3D;GetElem(&amp;L, 3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="单链表的按值查找-带头结点-：在表L中查找具有给定关键字值的元素-平均时间复杂度O-n"><a href="#单链表的按值查找-带头结点-：在表L中查找具有给定关键字值的元素-平均时间复杂度O-n" class="headerlink" title="单链表的按值查找(带头结点)：在表L中查找具有给定关键字值的元素,平均时间复杂度O(n)"></a>单链表的按值查找(带头结点)：在表L中查找具有给定关键字值的元素,平均时间复杂度O(n)</h3><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goic3zc0vij30m30sx0vx.jpg"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdbool.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">typedef struct LNode&#123;  &#x2F;&#x2F;LNode:结点</span><br><span class="line">    int data;  &#x2F;&#x2F;数据域：每个结点存放一个数据元素</span><br><span class="line">    struct LNode *next;  &#x2F;&#x2F;指针域：指针指向下一个结点</span><br><span class="line">&#125;LNode,*LinkList;  &#x2F;&#x2F;typedef struct LNode *LinkList;  要表示一个单链表时，只需声明一个头指针L，指向单链表的第一个结点</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;初始化一个单链表(带头结点)</span><br><span class="line">bool InitList(LinkList *L)&#123;</span><br><span class="line">    (*L)&#x3D;(LNode *)malloc(sizeof(LNode));  &#x2F;&#x2F;分配一个头结点,并使得头指针*L指向这个头结点</span><br><span class="line">    if((*L) &#x3D;&#x3D; NULL)&#123;  &#x2F;&#x2F;内存不足，分配失败</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    (*L)-&gt;data&#x3D;0;  &#x2F;&#x2F;头结点不存储数据</span><br><span class="line">    (*L)-&gt;next&#x3D;NULL;  &#x2F;&#x2F;头结点之后暂时还没有结点</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;按值查找，找到数据域&#x3D;&#x3D;e的结点(带头结点)</span><br><span class="line">LNode * LocateElem(LinkList *L,int e)&#123;</span><br><span class="line">    </span><br><span class="line">    LNode *p &#x3D;(*L)-&gt;next;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;从第1个结点开始查找数据域为e的结点</span><br><span class="line">    while(p !&#x3D; NULL &amp;&amp; p-&gt;data !&#x3D; e)&#123;</span><br><span class="line">        p&#x3D;p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return p;  &#x2F;&#x2F;找到后返回该结点指针，否则返回NULL</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;求表的长度（时间复杂度O(n)）</span><br><span class="line">int Length(LinkList *L)&#123;</span><br><span class="line">    int len&#x3D;0;  &#x2F;&#x2F;统计表长</span><br><span class="line">    LNode *p&#x3D;*L;</span><br><span class="line">    while(p-&gt;next !&#x3D; NULL)&#123;</span><br><span class="line">        p&#x3D;p-&gt;next;</span><br><span class="line">        len++;</span><br><span class="line">    &#125;</span><br><span class="line">    return len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    </span><br><span class="line">    LinkList L;  &#x2F;&#x2F;等价于LNode *L;  声明一个指向单链表的第一个结点的指针，注意此处并没有创建一个结点</span><br><span class="line">    InitList(&amp;L);  &#x2F;&#x2F;初始化一个空表</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;...后续代码</span><br><span class="line">    </span><br><span class="line">    LNode * a&#x3D;LocateElem(&amp;L, 3);  &#x2F;&#x2F;找到数据域为3的结点，并返回</span><br><span class="line">    </span><br><span class="line">    int b&#x3D;Length(&amp;L);  &#x2F;&#x2F;返回表的长度</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构、算法笔记</category>
      </categories>
  </entry>
  <entry>
    <title>单链表的插入和删除</title>
    <url>/2020/01/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4/</url>
    <content><![CDATA[<hr>
<h3 id="单链表的插入"><a href="#单链表的插入" class="headerlink" title="单链表的插入"></a>单链表的插入</h3><p>按位序插入（带头结点）：在表L中的第i个位置上插入指定元素e（最好O(1),最坏O(n),平均O(n)）<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gohzlzk9xmj31cr0icwg9.jpg"></p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goi0pgdl6pj30lh0uudj3.jpg"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdbool.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">typedef struct LNode&#123;  &#x2F;&#x2F;LNode:结点</span><br><span class="line">    int data;  &#x2F;&#x2F;数据域：每个结点存放一个数据元素</span><br><span class="line">    struct LNode *next;  &#x2F;&#x2F;指针域：指针指向下一个结点</span><br><span class="line">&#125;LNode,*LinkList;  &#x2F;&#x2F;typedef struct LNode *LinkList;  要表示一个单链表时，只需声明一个头指针L，指向单链表的第一个结点</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;初始化一个单链表(带头结点)</span><br><span class="line">bool InitList(LinkList *L)&#123;</span><br><span class="line">    (*L)&#x3D;(LNode *)malloc(sizeof(LNode));  &#x2F;&#x2F;分配一个头结点,并使得头指针*L指向这个头结点</span><br><span class="line">    if((*L) &#x3D;&#x3D; NULL)&#123;  &#x2F;&#x2F;内存不足，分配失败</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    (*L)-&gt;data&#x3D;0;  &#x2F;&#x2F;头结点不存储数据</span><br><span class="line">    (*L)-&gt;next&#x3D;NULL;  &#x2F;&#x2F;头结点之后暂时还没有结点</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;在第i个位置插入元素e(带头结点)</span><br><span class="line">bool ListInsert(LinkList *L,int i,int e)&#123;</span><br><span class="line">    if(i&lt;1)&#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    LNode *p;  &#x2F;&#x2F;指针p指向当前扫描到的结点</span><br><span class="line">    int j&#x3D;0;  &#x2F;&#x2F;当前p指向的是第几个结点</span><br><span class="line">    p&#x3D;*L;  &#x2F;&#x2F;L指向头结点，头结点是第0个结点(不存数据)</span><br><span class="line">    </span><br><span class="line">    while(p !&#x3D; NULL &amp;&amp; j&lt;i-1)&#123;  &#x2F;&#x2F;循环找到第i-1个结点</span><br><span class="line">        p&#x3D;p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    if(p &#x3D;&#x3D; NULL)&#123;  &#x2F;&#x2F;i值不合法</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    LNode *s&#x3D;(LNode *)malloc(sizeof(LNode));</span><br><span class="line">    s-&gt;data&#x3D;e;</span><br><span class="line">    s-&gt;next&#x3D;p-&gt;next;  &#x2F;&#x2F;这行代码跟下一行代码顺序不能调换</span><br><span class="line">    p-&gt;next&#x3D;s;  &#x2F;&#x2F;将结点s连到p之后</span><br><span class="line">    </span><br><span class="line">    return true;  &#x2F;&#x2F;插入成功</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    </span><br><span class="line">    LinkList L;  &#x2F;&#x2F;等价于LNode *L;  声明一个指向单链表的第一个结点的指针，注意此处并没有创建一个结点</span><br><span class="line">    InitList(&amp;L);  &#x2F;&#x2F;初始化一个空表</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;...后续代码</span><br><span class="line">    if(ListInsert(&amp;L, 2, 3))&#123;  &#x2F;&#x2F;在第2个位置插入元素3</span><br><span class="line">        printf(&quot;插入成功&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        printf(&quot;插入失败&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>按位序插入(不带头结点)：因为不存在“第0个”结点，因此i=1时需要特殊处理</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goi1f3rfltj30m30x5adg.jpg"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdbool.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">typedef struct LNode&#123;  &#x2F;&#x2F;LNode:结点</span><br><span class="line">    int data;  &#x2F;&#x2F;数据域：每个结点存放一个数据元素</span><br><span class="line">    struct LNode *next;  &#x2F;&#x2F;指针域：指针指向下一个结点</span><br><span class="line">&#125;LNode,*LinkList;  &#x2F;&#x2F;typedef struct LNode *LinkList;  要表示一个单链表时，只需声明一个头指针L，指向单链表的第一个结点</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;初始化一个空的链表(不带头结点)</span><br><span class="line">bool InitList(LinkList *L)&#123;</span><br><span class="line">    (*L)&#x3D;NULL;  &#x2F;&#x2F;空表，暂时还没有任何结点，防止脏数据</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;在第i个位置插入元素e(不带头结点)</span><br><span class="line">bool ListInsert(LinkList *L,int i,int e)&#123;</span><br><span class="line">    if(i&lt;1)&#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;如果不带头结点，则插入、删除第1个元素时，需要更改头指针L</span><br><span class="line">    if(i &#x3D;&#x3D; 1)&#123;  &#x2F;&#x2F;插入第1个结点的操作与其他结点操作不同</span><br><span class="line">        LNode *s &#x3D; (LNode *)malloc(sizeof(LNode));</span><br><span class="line">        s-&gt;data&#x3D;e;</span><br><span class="line">        s-&gt;next&#x3D;*L;</span><br><span class="line">        *L&#x3D;s;  &#x2F;&#x2F;头指针指向新结点</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    LNode *p;  &#x2F;&#x2F;指针p指向当前扫描到的结点</span><br><span class="line">    int j&#x3D;0;  &#x2F;&#x2F;当前p指向的是第几个结点</span><br><span class="line">    p&#x3D;*L;  &#x2F;&#x2F;L指向头结点，头结点是第0个结点(不存数据)</span><br><span class="line">    </span><br><span class="line">    while(p !&#x3D; NULL &amp;&amp; j&lt;i-1)&#123;  &#x2F;&#x2F;循环找到第i-1个结点</span><br><span class="line">        p&#x3D;p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    if(p &#x3D;&#x3D; NULL)&#123;  &#x2F;&#x2F;i值不合法</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    LNode *s&#x3D;(LNode *)malloc(sizeof(LNode));</span><br><span class="line">    s-&gt;data&#x3D;e;</span><br><span class="line">    s-&gt;next&#x3D;p-&gt;next;  &#x2F;&#x2F;这行代码跟下一行代码顺序不能调换</span><br><span class="line">    p-&gt;next&#x3D;s;  &#x2F;&#x2F;将结点s连到p之后</span><br><span class="line">    </span><br><span class="line">    return true;  &#x2F;&#x2F;插入成功</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    </span><br><span class="line">    LinkList L;  &#x2F;&#x2F;等价于LNode *L;  声明一个指向单链表的第一个结点的指针，注意此处并没有创建一个结点</span><br><span class="line">    InitList(&amp;L);  &#x2F;&#x2F;初始化一个空表</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;...后续代码</span><br><span class="line">    if(ListInsert(&amp;L, 2, 3))&#123;  &#x2F;&#x2F;在第2个位置插入元素3</span><br><span class="line">        printf(&quot;插入成功&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        printf(&quot;插入失败&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>指定结点的后插操作（O(1)）：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goi21zwbndj30m40s2gol.jpg"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdbool.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">typedef struct LNode&#123;  &#x2F;&#x2F;LNode:结点</span><br><span class="line">    int data;  &#x2F;&#x2F;数据域：每个结点存放一个数据元素</span><br><span class="line">    struct LNode *next;  &#x2F;&#x2F;指针域：指针指向下一个结点</span><br><span class="line">&#125;LNode,*LinkList;  &#x2F;&#x2F;typedef struct LNode *LinkList;  要表示一个单链表时，只需声明一个头指针L，指向单链表的第一个结点</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;初始化一个单链表(带头结点)</span><br><span class="line">bool InitList(LinkList *L)&#123;</span><br><span class="line">    (*L)&#x3D;(LNode *)malloc(sizeof(LNode));  &#x2F;&#x2F;分配一个头结点,并使得头指针*L指向这个头结点</span><br><span class="line">    if((*L) &#x3D;&#x3D; NULL)&#123;  &#x2F;&#x2F;内存不足，分配失败</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    (*L)-&gt;data&#x3D;0;  &#x2F;&#x2F;头结点不存储数据</span><br><span class="line">    (*L)-&gt;next&#x3D;NULL;  &#x2F;&#x2F;头结点之后暂时还没有结点</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;后插操作：在p结点之后插入元素e(带头结点)</span><br><span class="line">bool InsertNextNode(LNode *p,int e)&#123;</span><br><span class="line">    </span><br><span class="line">    if(p &#x3D;&#x3D; NULL)&#123;  &#x2F;&#x2F;i值不合法</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    LNode *s&#x3D;(LNode *)malloc(sizeof(LNode));</span><br><span class="line">    </span><br><span class="line">    if(s &#x3D;&#x3D; NULL)&#123;  &#x2F;&#x2F;内存分配失败，某些情况下有可能分配失败（如内存不足）</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    s-&gt;data&#x3D;e;  &#x2F;&#x2F;用结点s保存数据元素e</span><br><span class="line">    s-&gt;next&#x3D;p-&gt;next;  &#x2F;&#x2F;这行代码跟下一行代码顺序不能调换</span><br><span class="line">    p-&gt;next&#x3D;s;  &#x2F;&#x2F;将结点s连到p之后</span><br><span class="line">    </span><br><span class="line">    return true;  &#x2F;&#x2F;插入成功</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    </span><br><span class="line">    LinkList L;  &#x2F;&#x2F;等价于LNode *L;  声明一个指向单链表的第一个结点的指针，注意此处并没有创建一个结点</span><br><span class="line">    InitList(&amp;L);  &#x2F;&#x2F;初始化一个空表</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;...后续代码</span><br><span class="line">    if(InsertNextNode(L, 3))&#123;  &#x2F;&#x2F;在p结点位置后插入元素3</span><br><span class="line">        printf(&quot;插入成功&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        printf(&quot;插入失败&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>指定结点的前插操作：在p结点之前插入元素e（O(1)）</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goi2jgxe2lj30m10szad5.jpg"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdbool.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">typedef struct LNode&#123;  &#x2F;&#x2F;LNode:结点</span><br><span class="line">    int data;  &#x2F;&#x2F;数据域：每个结点存放一个数据元素</span><br><span class="line">    struct LNode *next;  &#x2F;&#x2F;指针域：指针指向下一个结点</span><br><span class="line">&#125;LNode,*LinkList;  &#x2F;&#x2F;typedef struct LNode *LinkList;  要表示一个单链表时，只需声明一个头指针L，指向单链表的第一个结点</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;初始化一个单链表(带头结点)</span><br><span class="line">bool InitList(LinkList *L)&#123;</span><br><span class="line">    (*L)&#x3D;(LNode *)malloc(sizeof(LNode));  &#x2F;&#x2F;分配一个头结点,并使得头指针*L指向这个头结点</span><br><span class="line">    if((*L) &#x3D;&#x3D; NULL)&#123;  &#x2F;&#x2F;内存不足，分配失败</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    (*L)-&gt;data&#x3D;0;  &#x2F;&#x2F;头结点不存储数据</span><br><span class="line">    (*L)-&gt;next&#x3D;NULL;  &#x2F;&#x2F;头结点之后暂时还没有结点</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;前插操作：在p结点之前插入元素e(带头结点)</span><br><span class="line">bool InsertPriorNode(LNode *p,int e)&#123;</span><br><span class="line">    </span><br><span class="line">    if(p &#x3D;&#x3D; NULL)&#123;  &#x2F;&#x2F;i值不合法</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    LNode *s&#x3D;(LNode *)malloc(sizeof(LNode));</span><br><span class="line">    </span><br><span class="line">    if(s &#x3D;&#x3D; NULL)&#123;  &#x2F;&#x2F;内存分配失败，某些情况下有可能分配失败（如内存不足）</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    s-&gt;next&#x3D;p-&gt;next;</span><br><span class="line">    p-&gt;next&#x3D;s;  &#x2F;&#x2F;新结点s连到p之后</span><br><span class="line">    s-&gt;data&#x3D;p-&gt;data;  &#x2F;&#x2F;将p中元素复制到s中</span><br><span class="line">    p-&gt;data&#x3D;e;  &#x2F;&#x2F;p中元素覆盖为e</span><br><span class="line">    </span><br><span class="line">    return true;  &#x2F;&#x2F;插入成功</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    </span><br><span class="line">    LinkList L;  &#x2F;&#x2F;等价于LNode *L;  声明一个指向单链表的第一个结点的指针，注意此处并没有创建一个结点</span><br><span class="line">    InitList(&amp;L);  &#x2F;&#x2F;初始化一个空表</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;...后续代码</span><br><span class="line">    if(InsertPriorNode(L, 3))&#123;  &#x2F;&#x2F;在p结点位置前插入元素3</span><br><span class="line">        printf(&quot;插入成功&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        printf(&quot;插入失败&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="单链表的删除"><a href="#单链表的删除" class="headerlink" title="单链表的删除"></a>单链表的删除</h3><p>按位序删除(带头结点，最坏、平均O(n),最好O(1))：删除表L中第i个位置的元素，并用e返回删除元素的值（找到第i-1个结点，并将其指针指向第i+1个结点，并释放第i个结点）</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goi3jbcdv2j30mc0xjadj.jpg"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdbool.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">typedef struct LNode&#123;  &#x2F;&#x2F;LNode:结点</span><br><span class="line">    int data;  &#x2F;&#x2F;数据域：每个结点存放一个数据元素</span><br><span class="line">    struct LNode *next;  &#x2F;&#x2F;指针域：指针指向下一个结点</span><br><span class="line">&#125;LNode,*LinkList;  &#x2F;&#x2F;typedef struct LNode *LinkList;  要表示一个单链表时，只需声明一个头指针L，指向单链表的第一个结点</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;初始化一个单链表(带头结点)</span><br><span class="line">bool InitList(LinkList *L)&#123;</span><br><span class="line">    (*L)&#x3D;(LNode *)malloc(sizeof(LNode));  &#x2F;&#x2F;分配一个头结点,并使得头指针*L指向这个头结点</span><br><span class="line">    if((*L) &#x3D;&#x3D; NULL)&#123;  &#x2F;&#x2F;内存不足，分配失败</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    (*L)-&gt;data&#x3D;0;  &#x2F;&#x2F;头结点不存储数据</span><br><span class="line">    (*L)-&gt;next&#x3D;NULL;  &#x2F;&#x2F;头结点之后暂时还没有结点</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;按位序删除(带头结点)</span><br><span class="line">bool ListDelete(LinkList *L,int i,int *e)&#123;</span><br><span class="line">    </span><br><span class="line">    if(i&lt;1)&#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    LNode *p;  &#x2F;&#x2F;指针p指向当前扫描到的结点</span><br><span class="line">    int j&#x3D;0;  &#x2F;&#x2F;当前p指向的是第几个结点</span><br><span class="line">    p&#x3D;*L;  &#x2F;&#x2F;L指向头结点，头结点是第0个结点(不存数据)</span><br><span class="line">    </span><br><span class="line">    while(p !&#x3D; NULL &amp;&amp; j&lt;i-1)&#123;  &#x2F;&#x2F;循环找到第i-1个结点</span><br><span class="line">        p&#x3D;p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    if(p &#x3D;&#x3D; NULL)&#123;  &#x2F;&#x2F;i值不合法</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if(p-&gt;next &#x3D;&#x3D; NULL)&#123;  &#x2F;&#x2F;在第i-1个结点之后已无其他结点</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    LNode *q&#x3D;p-&gt;next;  &#x2F;&#x2F;令q指向被删除结点</span><br><span class="line">    *e&#x3D;q-&gt;data;  &#x2F;&#x2F;用e返回元素的值</span><br><span class="line">    p-&gt;next&#x3D;q-&gt;next;  &#x2F;&#x2F;将*q结点从链中断开</span><br><span class="line">    free(q);  &#x2F;&#x2F;释放结点的存储空间</span><br><span class="line">    </span><br><span class="line">    return true;  &#x2F;&#x2F;删除成功</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    </span><br><span class="line">    LinkList L;  &#x2F;&#x2F;等价于LNode *L;  声明一个指向单链表的第一个结点的指针，注意此处并没有创建一个结点</span><br><span class="line">    InitList(&amp;L);  &#x2F;&#x2F;初始化一个空表</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;...后续代码</span><br><span class="line">    int e&#x3D;-1;  &#x2F;&#x2F;用变量e把删除的元素“带回来”</span><br><span class="line">    if(ListDelete(&amp;L, 2, &amp;e))&#123;</span><br><span class="line">        printf(&quot;已删除第2个元素，删除元素值为%d\n&quot;,e);</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        printf(&quot;删除失败\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>指定结点的删除（O(1)）：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goi4e7rdmaj30ll0riacy.jpg"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdbool.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">typedef struct LNode&#123;  &#x2F;&#x2F;LNode:结点</span><br><span class="line">    int data;  &#x2F;&#x2F;数据域：每个结点存放一个数据元素</span><br><span class="line">    struct LNode *next;  &#x2F;&#x2F;指针域：指针指向下一个结点</span><br><span class="line">&#125;LNode,*LinkList;  &#x2F;&#x2F;typedef struct LNode *LinkList;  要表示一个单链表时，只需声明一个头指针L，指向单链表的第一个结点</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;初始化一个单链表(带头结点)</span><br><span class="line">bool InitList(LinkList *L)&#123;</span><br><span class="line">    (*L)&#x3D;(LNode *)malloc(sizeof(LNode));  &#x2F;&#x2F;分配一个头结点,并使得头指针*L指向这个头结点</span><br><span class="line">    if((*L) &#x3D;&#x3D; NULL)&#123;  &#x2F;&#x2F;内存不足，分配失败</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    (*L)-&gt;data&#x3D;0;  &#x2F;&#x2F;头结点不存储数据</span><br><span class="line">    (*L)-&gt;next&#x3D;NULL;  &#x2F;&#x2F;头结点之后暂时还没有结点</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;删除指定结点p(带头结点)</span><br><span class="line">&#x2F;&#x2F;如果p是最后一个结点，这段代码就有点问题了，解决办法只能从表头开始依次寻找p的前驱，时间复杂度为O(n)</span><br><span class="line">&#x2F;&#x2F;单链表的局限性：无法逆向检索，有时候不太方便</span><br><span class="line">bool DeleteNode(LNode *p)&#123;</span><br><span class="line">    </span><br><span class="line">    if(p &#x3D;&#x3D; NULL)&#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    LNode *q&#x3D;p-&gt;next;  &#x2F;&#x2F;令q指向*p的后继结点</span><br><span class="line">    p-&gt;data&#x3D;p-&gt;next-&gt;data;  &#x2F;&#x2F;和后继结点交换数据域</span><br><span class="line">    p-&gt;next&#x3D;q-&gt;next;  &#x2F;&#x2F;将*q结点从链中“断开”</span><br><span class="line">    free(q);  &#x2F;&#x2F;释放后继结点的存储空间</span><br><span class="line">    </span><br><span class="line">    return true;  &#x2F;&#x2F;删除成功</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    </span><br><span class="line">    LinkList L;  &#x2F;&#x2F;等价于LNode *L;  声明一个指向单链表的第一个结点的指针，注意此处并没有创建一个结点</span><br><span class="line">    InitList(&amp;L);  &#x2F;&#x2F;初始化一个空表</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;...后续代码</span><br><span class="line">    </span><br><span class="line">    if(DeleteNode(L))&#123;</span><br><span class="line">        printf(&quot;删除成功\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        printf(&quot;删除失败\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构、算法笔记</category>
      </categories>
  </entry>
  <entry>
    <title>双端队列</title>
    <url>/2020/01/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<hr>
<p>双端队列：只允许从两端插入、两端删除的线性表【若只使用其中一端的插入、删除操作，则效果等同于栈】</p>
<p>输入受限的双端队列：只允许从一端插入、两端删除的线性表</p>
<p>输出受限的双端队列：只允许从两端插入、一端删除的线性表</p>
<p>在栈中合法的输出序列，在双端队列中必定合法</p>
]]></content>
      <categories>
        <category>数据结构、算法笔记</category>
      </categories>
  </entry>
  <entry>
    <title>冒泡排序</title>
    <url>/2019/11/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<hr>
<p>冒泡排序(稳定的算法)：假设待排序表长为n，从前往后(从后往前)两两比较相邻元素的值，若为逆序(即A[i-1]&gt;A[i])，则交换他们直到序列比较结束【一次冒泡会将一个元素放置到它最终的位置上】</p>
<p>适用于顺序存储和链式存储</p>
<p>最好时间复杂度为O(n)，最坏、平均时间复杂度为O(n^2)，空间复杂度为O(1)：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gozeoipkaej30g409p0t0.jpg"></p>
]]></content>
      <categories>
        <category>数据结构、算法笔记</category>
      </categories>
  </entry>
  <entry>
    <title>双链表</title>
    <url>/2020/01/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%8F%8C%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<hr>
<p>单链表：无法逆向检索，有时候不太方便<br>双链表：可进可退，但存储密度要更低一点</p>
<p>双链表的初始化、插入、删除(带头结点)：<br><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1gokbgqi3ilj20kd177ae2.jpg"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdbool.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">typedef struct DNode&#123;</span><br><span class="line">    int data;  &#x2F;&#x2F;数据域</span><br><span class="line">    struct DNode *prior,*next;  &#x2F;&#x2F;指针域</span><br><span class="line">&#125;DNode,*DLinklist;  &#x2F;&#x2F;DLinklist等价于DNode *</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;初始化双链表</span><br><span class="line">bool InitDLinkList(DLinklist *L)&#123;</span><br><span class="line">    (*L)&#x3D;(DNode *)malloc(sizeof(DNode));  &#x2F;&#x2F;分配一个头结点</span><br><span class="line">    if((*L) &#x3D;&#x3D; NULL)&#123;  &#x2F;&#x2F;内存不足，分配失败</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    (*L)-&gt;prior&#x3D;NULL;  &#x2F;&#x2F;头结点的prior永远指向NULL</span><br><span class="line">    (*L)-&gt;next&#x3D;NULL;  &#x2F;&#x2F;头结点之后暂时还没有结点</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;判断双链表是否为空(带头结点)</span><br><span class="line">bool Empty(DLinklist *L)&#123;</span><br><span class="line">    if((*L)-&gt;next &#x3D;&#x3D; NULL)&#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;双链表的插入</span><br><span class="line">&#x2F;&#x2F;在p结点之后插入s结点</span><br><span class="line">&#x2F;&#x2F;如果要按位序插入，只需要从头结点找到这个位序的前驱结点，然后对这个前驱结点进行后插操作</span><br><span class="line">&#x2F;&#x2F;前插操作也是找到该结点的前驱结点，然后对这个前驱结点进行后插操作</span><br><span class="line">bool InsertNextDNode(DNode *p,DNode *s)&#123;</span><br><span class="line">    if(p &#x3D;&#x3D; NULL || s &#x3D;&#x3D; NULL)&#123;  &#x2F;&#x2F;非法参数</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    s-&gt;next&#x3D;p-&gt;next;  &#x2F;&#x2F;将结点*s插入到结点*p之后</span><br><span class="line">    if(p-&gt;next !&#x3D; NULL)&#123;  &#x2F;&#x2F;如果p结点有后继结点[如果是循环双链表，没有这个条件判断也是正确的]</span><br><span class="line">        p-&gt;next-&gt;prior&#x3D;s;</span><br><span class="line">    &#125;</span><br><span class="line">    s-&gt;prior&#x3D;p;</span><br><span class="line">    p-&gt;next&#x3D;s;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;双链表的删除</span><br><span class="line">&#x2F;&#x2F;删除p结点的后继结点</span><br><span class="line">bool DeleteNextDNode(DNode *p)&#123;</span><br><span class="line">    if(p &#x3D;&#x3D; NULL)&#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    DNode *q&#x3D;p-&gt;next;  &#x2F;&#x2F;找到p的后继结点q</span><br><span class="line">    if(q &#x3D;&#x3D; NULL)&#123;</span><br><span class="line">        return false;  &#x2F;&#x2F;p没有后继</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    p-&gt;next&#x3D;q-&gt;next;</span><br><span class="line">    if(q-&gt;next !&#x3D; NULL)&#123;  &#x2F;&#x2F;q结点不是最后一个结点</span><br><span class="line">        q-&gt;next-&gt;prior&#x3D;p;</span><br><span class="line">    &#125;</span><br><span class="line">    free(q);  &#x2F;&#x2F;释放结点空间</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;销毁一个双链表</span><br><span class="line">void DestoryList(DLinklist *L)&#123;</span><br><span class="line">    &#x2F;&#x2F;循环释放各个数据结点</span><br><span class="line">    while((*L)-&gt;next !&#x3D; NULL)&#123;</span><br><span class="line">        DeleteNextDNode(*L);</span><br><span class="line">    &#125;</span><br><span class="line">    free(L);  &#x2F;&#x2F;释放头结点</span><br><span class="line">    L&#x3D;NULL;  &#x2F;&#x2F;头指针指向NULL</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    </span><br><span class="line">    DLinklist L;</span><br><span class="line">    InitDLinkList(&amp;L);  &#x2F;&#x2F;初始化双链表</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;...后续代码</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>双链表的遍历[双链表不可随机存取，按位查找，按值查找操作都只能用遍历的方式实现，时间复杂度O(n)]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;后向遍历</span><br><span class="line">while(p !&#x3D; NULL)&#123;</span><br><span class="line">    p&#x3D;p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;前向遍历</span><br><span class="line">while(p !&#x3D; NULL)&#123;</span><br><span class="line">    p&#x3D;p-&gt;prior;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;前向遍历，跳过头结点</span><br><span class="line">while(p-&gt;prior !&#x3D; NULL)&#123;</span><br><span class="line">    p&#x3D;p-&gt;prior;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构、算法笔记</category>
      </categories>
  </entry>
  <entry>
    <title>图的基本概念</title>
    <url>/2019/12/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<hr>
<p>图G由顶点集V和边集E组成，记为G=(V,E)，其中V(G)表示图G中顶点的有限非空集；E(G)表示图G中顶点之间的关系(边)集合<br>|V|表示图G中顶点的个数，也称图G的阶；|E|表示图G中边的条数<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gout3e8caxj31ac0egdgt.jpg"></p>
<p>无向图和有向图：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goutf7ahhzj31ac0nv75z.jpg"></p>
<p>简单图和多重图：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goutm3cwpij31ac0dm75k.jpg"></p>
<p>在图中，权通常是对边赋予的有意义的数值量，边上带权的图称为带权图或网图：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gouuu12czwj30wx0b2aag.jpg"></p>
<p>完全图：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gouttrttklj31ac0fogmy.jpg"></p>
<p>稠密图、稀疏图</p>
<p>顶点的度：以该顶点为一个端点的边的数目</p>
<p>无向图顶点v的度为以v为端点的边的个数，记为TD(v)；n顶点、e条边的无向图中度的总数为2e</p>
<p>有向图：出度指以v为起点的有向边的条数，记OD(v)；入度指以v为终点的有向边的条数，记ID(v)；TD(v)=OD(v)+ID(v)；n顶点、e条边的有向图中出度、入度为e</p>
<p>有向树：一个顶点的入度为0，其余顶点的入度均为1的有向图<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gouuysmqjpj30ok0d9dfv.jpg"></p>
<p>路径：图中顶点v到顶点w的顶点序列，序列中顶点不重复的路径称为简单路径</p>
<p>路径长度：路径上边的数目，若该路径最短则称其为距离</p>
<p>回路：第一个顶点和最后一个顶点相同的路径</p>
<p>除了第一个顶点和最后一个顶点之外，其余顶点不重复出现的回路称为简单回路</p>
<p>子图：设有两个图G=(V,E)和G’=(V’,E’)，若V’是V的子集，且E’是E的子集，则称G’为G的子图；且若V(G)=V(G’)则称G’为G的生成子图</p>
<p>无向图只有连通：若从顶点v到顶点w有路径存在，则称v和w是连通【连通图：任意两个结点之间都是连通的】【连通分量：极大连通子图】</p>
<p>有向图只有强连通：若从顶点v到顶点w和顶点w到顶点v都有路径存在，则称v和w是强连通【强连通图：任意两个结点之间都是强连通的】【强连通分量：极大强连通子图】<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gouu8hmcf9j31ac0eb0tb.jpg"></p>
<p>对于G的一个(强)连通子图G’，如果不存在G的另一个(强)连通子图G’’，使得G’属于G’’，则称G’为G的(强)连通分量</p>
<p>极小连通子图：连通子图且包含的边最少</p>
<p>生成树：连通图包含全部顶点的一个极小连通子图(n个顶点图的生成树有n-1条边)</p>
<p>生成森林：非连通图所有连通分量的生成树组成连通森林</p>
]]></content>
      <categories>
        <category>数据结构、算法笔记</category>
      </categories>
  </entry>
  <entry>
    <title>图的基本操作</title>
    <url>/2019/12/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<hr>
<ol>
<li><p><code>Adjacent(G,x,y)</code>：判断图G是否存在边&lt;x,y&gt;或(x,y)【邻接矩阵效率高】<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1govz59y8zpj30yi0ax3zc.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1govz5g8iq4j30vo0axgmc.jpg"></p>
</li>
<li><p><code>Neighbors(G,x)</code>：列出图G中与结点x邻接的边【无向图邻接表效率高，有向图邻接矩阵效率高】<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1govze732hgj30ys0alta5.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1govzefer7jj30vq0axt9k.jpg"></p>
</li>
<li><p><code>InsertVertex(G,x)</code>：在图G中插入顶点x<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1govzgx0q7gj30zb0cejsd.jpg"></p>
</li>
<li><p><code>DeleteVertex(G,x)</code>：从图G中删除顶点x<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1govzogix1xj30yy0bdmxt.jpg"></p>
</li>
<li><p><code>AddEdge(G,x,y)</code>：若无向边(x,y)或者有向边&lt;x,y&gt;不存在，则向图G中添加该边<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1govzpu4c2tj30yq0b0js8.jpg"></p>
</li>
<li><p><code>RemoveEdge(G,x,y)</code>：若无向边(x,y)或者有向边&lt;x,y&gt;存在，则在图G中删除该边【邻接矩阵效率高】<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1govzqe3r4gj30va0azt9f.jpg"></p>
</li>
<li><p><code>FirstNeighbor(G,x)</code>：求图G中顶点x的第一个邻接点，若有则返回顶点号，若没有邻接点或图不存在x，则返回-1<br><code>NextNeighbor(G,x)</code>：假设图G中顶点y是顶点x的一个邻接点，返回除y之外顶点x的下一个邻接点的顶点号，若y是x的最后一个邻接点，则返回-1<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1govzxm5sd7j30yo0at753.jpg"></p>
</li>
<li><p><code>Get_edge_value(G,x,y)</code>：获取图G中边(x,y)或&lt;x,y&gt;对应的权值v<br><code>Set_edge_value(G,x,y)</code>：设置图G中边(x,y)或&lt;x,y&gt;对应的权值为v<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gow0301r31j31030ajjs9.jpg"></p>
</li>
</ol>
]]></content>
      <categories>
        <category>数据结构、算法笔记</category>
      </categories>
  </entry>
  <entry>
    <title>基数排序</title>
    <url>/2019/11/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<hr>
<p>基数排序：不基于比较，借助“分配”和“收集”两种操作对单逻辑关键字进行排序，分为最高位优先(MSD)和最低位优先(LSD)</p>
<p>以r为基数的最低位优先基数排序的过程(稳定的算法)：【时间复杂度为O(d(n+r))】【空间复杂度为O(r)】<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gozs7xp2vyj31kw0r4tbu.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gozs86t7nmj31kw0nrju9.jpg"></p>
]]></content>
      <categories>
        <category>数据结构、算法笔记</category>
      </categories>
  </entry>
  <entry>
    <title>哈夫曼树</title>
    <url>/2019/12/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91/</url>
    <content><![CDATA[<hr>
<p>路径长度：路径上所经历边的个数<br>结点的权：结点被赋予的数值</p>
<p>树的带权路径长度：WPL，树中所有叶结点的带权路径长度之和</p>
<p>哈夫曼树：也称最优二叉树，含有n个带权叶子结点带权路径长度最小的二叉树</p>
<p>哈夫曼树的构造算法：<br>1）将n个结点作为n棵仅含有一个根结点的二叉树，构造森林F<br>2）生成一个新结点，并从F中找出根结点权值最小的两棵树作为它的左右子树，且新结点的权值为两棵子树根结点的权值之和<br>3）从F中删除这两棵树，并将新生成的树加入到F中<br>4）重复2，3步骤，直到F中只有一棵树为止<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gours4il6rj309a08aq2t.jpg"></p>
<p>哈夫曼树的性质：<br>1）每个初始结点都会成为叶结点，双支结点都为新生成的结点<br>2）权值越大离根结点越近，反之权值越小离根结点越远<br>3）哈夫曼树中没有结点的度为1<br>4）n个叶子结点的哈夫曼树的结点总数为2n-1，其中度为2的结点数为n-1</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gouspxqtltj30u011z0w6.jpg"></p>
]]></content>
      <categories>
        <category>数据结构、算法笔记</category>
      </categories>
  </entry>
  <entry>
    <title>堆排序</title>
    <url>/2019/11/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%A0%86%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<hr>
<p>堆：n个关键字序列L[1…n]称为堆，当且仅当该序列满足：(1&lt;=i&lt;=(n/2)(取下界))<br>1）若L(i)&lt;=L(2i)且L(i)&lt;=L(2i+1)，则称该堆为小根堆<br>2）若L(i)&gt;=L(2i)且L(i)&gt;=L(2i+1)，则称该堆为大根堆</p>
<p>在排序过程中将L[1…n]视为一棵完全二叉树的顺序存储结构<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gozon6y0k0j31kw0jt75q.jpg"></p>
<p>堆的初始化(以大根堆为例)：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gozpk9gnqcj315s0mgwh2.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gozpl69yu2j30ie0e1jrt.jpg"></p>
<p>堆排序(不稳定的算法)：不断的输出栈顶元素，并向下调整【时间复杂度为O(nlog2(n))】【空间复杂度为O(1)】</p>
<p>适用于顺序存储(链式存储)<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gozpkqt98zj31260hp0tm.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gozplrt5b4j30fm05xwel.jpg"></p>
<p>堆的插入：将新结点放置在末端然后进行向上调整<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gozpvv1lzij30zi0eqmxu.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gozpw6hfd8j30gm07y0su.jpg"></p>
]]></content>
      <categories>
        <category>数据结构、算法笔记</category>
      </categories>
  </entry>
  <entry>
    <title>外部排序的方法</title>
    <url>/2019/11/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%A4%96%E9%83%A8%E6%8E%92%E5%BA%8F%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<hr>
<p>外部排序通常采用归并排序的方法</p>
<p>首先根据缓冲区的大小将外存上含有n个记录的文件分成若干长度为h的子文件，依次读入内存并利用有限的内部排序算法对它们进行排序，并将排序后得到的有序子文件重新写回外存，通常称这些有序子文件为归并段或顺串</p>
<p>然后对这些归并段进行逐趟归并，使归并段逐渐由小到大直至得到整个有序文件<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goztcn2d3pj30yw0hwq3r.jpg"></p>
<p>外部排序的总时间：内部排序所需时间+外存信息读写时间+内部归并所需时间<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goztd01haaj30h60613ym.jpg"><br>如果变成4路归并：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goztqi5q48j308s048745.jpg"></p>
]]></content>
      <categories>
        <category>数据结构、算法笔记</category>
      </categories>
  </entry>
  <entry>
    <title>平衡二叉树</title>
    <url>/2019/12/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<hr>
<p>平衡二叉树：AVL，任意结点的平衡因子的绝对值不超过1（平衡因子：左子树高度-右子树高度）<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gou6840xspj30dk0aiaa1.jpg"></p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gou6bn8q64j30j10bvgls.jpg"></p>
<p>平衡二叉树的判断：利用递归的后续遍历过程<br>1）判断左子树是一棵平衡二叉树<br>2）判断右子树是一棵平衡二叉树<br>3）判断以该结点为根的二叉树为平衡二叉树【判断条件：若左子树和右子树均为平衡二叉树，且左子树与右子树高度差的绝对值小于等于1，则平衡】<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gou6lc5ruij30h70fv74s.jpg"></p>
<p>平衡二叉树的插入：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gouqd2fjabj30p20btdg3.jpg"></p>
<p>1）LL平衡旋转(右单旋转)<br>原因：在结点A的左孩子的左子树上插入了新结点<br>调整方法：右旋操作，将A的左孩子B代替A，将A结点称为B的右子树根结点，而B的原右子树则作为A的左子树<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gouqdd41lej30n90bkjro.jpg"></p>
<p>2）RR平衡旋转(左单旋转)<br>原因：在结点A的右孩子的右子树上插入了新结点<br>调整方法：左旋操作，将A的右孩子B代替A，将A结点称为B的左子树根结点，而B的原左子树则作为A的右子树<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gour4j4l4rj30og0bomxg.jpg"></p>
<p>3）LR平衡旋转(先左后右双旋转)<br>原因：在结点A的左孩子的右子树上插入了新结点<br>调整方法：先左旋后右旋操作，将A的左孩子B的右孩子结点C代替B，然后再将C结点向上代替A的位置<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gour4uj3wpj31ac0f6my1.jpg"></p>
<p>4）RL平衡旋转(先右后左双旋转)<br>原因：在结点A的右孩子的左子树上插入了新结点<br>调整方法：先右旋后左旋操作，将A的右孩子B的左孩子结点C代替B，然后再将C结点向上代替A的位置<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gour51jstfj31ac0e4my0.jpg">                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    </p>
]]></content>
      <categories>
        <category>数据结构、算法笔记</category>
      </categories>
  </entry>
  <entry>
    <title>希尔排序</title>
    <url>/2019/11/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<hr>
<p>希尔排序(不稳定算法)：缩小增量排序【最坏时间复杂度为O(n^2)，空间复杂度为O(1)】<br>只适用于顺序存储</p>
<p>基本思想：先将排序表分割成d个形如L[i,i+d,i+2d,…,i+kd]的特殊子表，分别进行直接插入排序，当整个表中的元素已呈“基本有序时”，再对全体记录进行一次直接插入排序【d1=n/2(取下界),d(i+1)=(di)/2(取下界)，直到最后一个dk=1】<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goyorlio5yj30qk08a74p.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goyorto248j30i807u3yo.jpg"></p>
]]></content>
      <categories>
        <category>数据结构、算法笔记</category>
      </categories>
  </entry>
  <entry>
    <title>广度优先搜索</title>
    <url>/2019/12/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/</url>
    <content><![CDATA[<hr>
<p>图的遍历：从图中某一顶点出发，按照某种搜索方法沿着图中的边对图中的所有顶点访问一次且仅访问一次</p>
<p>广度优先搜索(BFS)：<br>1）首先访问起始顶点v<br>2）接着由v出发依次访问v的各个未被访问过的邻接顶点w1，w2…wi<br>3）然后依次访问w1，w2…wi的所有未被访问过的邻接顶点<br>4）从这些访问过的顶点出发，访问它们所有未被访问过的邻接顶点，以此类推<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gow8s8unjej318x0u0dim.jpg"></p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gow8sjduhyj30nc0gtjs4.jpg"></p>
<p>BFS算法的性能分析：<br>1）空间复杂度：O(|V|)<br>2）时间复杂度：邻接矩阵法O(|V|^2)，邻接表法O(|V|+|E|)</p>
<p>无权图单源最短路径问题：定义从顶点u到顶点v的最短路径d(u,v)为从u到v的任何路径中最少的边数，若从u到v没有通路，则d(u,v)=正无穷<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gow9abckurj30nm0bnt96.jpg"></p>
<p>广度优先生成树：在广度遍历过程中，我们可以得到一棵遍历树，称为广度优先生成树(生成森林)【邻接矩阵法的广度优先生成树唯一，邻接表法的不唯一】<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gow9ajudnoj30tk0a2mxb.jpg"></p>
]]></content>
      <categories>
        <category>数据结构、算法笔记</category>
      </categories>
  </entry>
  <entry>
    <title>快速排序</title>
    <url>/2019/11/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<hr>
<p>快速排序(不稳定的算法)：【时间复杂度为O(high-low+1)】【最好、平均空间复杂度为O(log2(n))、最坏空间复杂度O(n)】【最好、平均时间复杂度为O(nlog2(n))、最坏时间复杂度为O(n^2)】<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gozftmtympj31ps0it0uo.jpg"></p>
<p>初始基本有序或逆序的情况下时间、空间复杂度最坏</p>
<p>适用于顺序存储(链式存储)</p>
<p>Partition基本思路：初始化标记low为划分部分第一个元素的位置，high为最后一个元素的位置，然后不断的移动两标记并交换元素：<br>1）high向前移动找到第一个比pivot小的元素<br>2）low向后移动找到第一个比pivot大的元素<br>3）交换当前两个位置的元素<br>4）继续移动标记，执行1、2、3过程，直到low大于等于high为止<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gozfua3w2wj30k40gvgmm.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gozfunedfuj30g30fp74y.jpg"></p>
]]></content>
      <categories>
        <category>数据结构、算法笔记</category>
      </categories>
  </entry>
  <entry>
    <title>循环链表</title>
    <url>/2020/01/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<hr>
<p>单链表：表尾结点的next指针指向NULL，从一个结点出发只能找到后续的各个结点<br>循环单链表：表尾结点的next指针指向头结点，从一个结点出发可以找到其他任何一个结点</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdbool.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">typedef struct LNode&#123;</span><br><span class="line">    int data;  &#x2F;&#x2F;数据域</span><br><span class="line">    struct LNode *next;  &#x2F;&#x2F;指针域</span><br><span class="line">&#125;LNode,*LinkList;  &#x2F;&#x2F;LinkList等价于LNode *</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;初始化一个循环单链表</span><br><span class="line">bool InitList(LinkList *L)&#123;</span><br><span class="line">    (*L)&#x3D;(LNode *)malloc(sizeof(LNode));  &#x2F;&#x2F;分配一个头结点</span><br><span class="line">    if((*L) &#x3D;&#x3D; NULL)&#123;</span><br><span class="line">        return false;  &#x2F;&#x2F;内存不足，分配失败</span><br><span class="line">    &#125;</span><br><span class="line">    (*L)-&gt;next&#x3D;(*L);  &#x2F;&#x2F;头结点next指针指向头结点</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;判断循环单链表是否为空</span><br><span class="line">bool Empty(LinkList *L)&#123;</span><br><span class="line">    if((*L)-&gt;next &#x3D;&#x3D; (*L))&#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;判断结点p是否为循环单链表的表尾结点</span><br><span class="line">bool isTail(LinkList *L,LNode *p)&#123;</span><br><span class="line">    if(p-&gt;next &#x3D;&#x3D; (*L))&#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    </span><br><span class="line">    LinkList L;</span><br><span class="line">    InitList(&amp;L);  &#x2F;&#x2F;初始化双链表</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;...后续代码</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>双链表：表头结点的prior指向NULL，表尾结点的next指向NULL<br>循环双链表：表头结点的prior指向表尾结点，表尾结点的next指向头结点</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdbool.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">typedef struct DNode&#123;</span><br><span class="line">    int data;  &#x2F;&#x2F;数据域</span><br><span class="line">    struct DNode *prior,*next;  &#x2F;&#x2F;指针域</span><br><span class="line">&#125;DNode,*DLinklist;  &#x2F;&#x2F;DLinklist等价于DNode *</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;初始化空的循环双链表</span><br><span class="line">bool InitDLinkList(DLinklist *L)&#123;</span><br><span class="line">    (*L)&#x3D;(DNode *)malloc(sizeof(DNode));  &#x2F;&#x2F;分配一个头结点</span><br><span class="line">    if((*L) &#x3D;&#x3D; NULL)&#123;  &#x2F;&#x2F;内存不足，分配失败</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    (*L)-&gt;prior&#x3D;(*L);  &#x2F;&#x2F;头结点的prior指向头结点</span><br><span class="line">    (*L)-&gt;next&#x3D;(*L);  &#x2F;&#x2F;头结点的next指向头结点</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;判断循环双链表是否为空(带头结点)</span><br><span class="line">bool Empty(DLinklist *L)&#123;</span><br><span class="line">    if((*L)-&gt;next &#x3D;&#x3D; (*L))&#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;判断结点p是否为循环双链表的表尾结点</span><br><span class="line">bool isTail(DLinklist *L,DNode *p)&#123;</span><br><span class="line">    if(p-&gt;next &#x3D;&#x3D; (*L))&#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    </span><br><span class="line">    DLinklist L;</span><br><span class="line">    InitDLinkList(&amp;L);  &#x2F;&#x2F;初始化循环双链表</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;...后续代码</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构、算法笔记</category>
      </categories>
  </entry>
  <entry>
    <title>归并排序</title>
    <url>/2019/11/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<hr>
<p>2路归并排序：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gozpzyca5oj30zr0cftaa.jpg"></p>
<p>合并两个有序线性表：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gozq555fk3j30rt0eowff.jpg"></p>
<p>归并排序(稳定的算法)：【时间复杂度O(nlog2(n))】【空间复杂度为O(n)】</p>
<p>适用于顺序存储和链式存储<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gozqfs3nrzj30ka06774h.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gozqw1354kj318d0fk74z.jpg"></p>
]]></content>
      <categories>
        <category>数据结构、算法笔记</category>
      </categories>
  </entry>
  <entry>
    <title>折半插入排序</title>
    <url>/2019/11/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%8A%98%E5%8D%8A%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<hr>
<p>折半插入排序(稳定的算法)：【时间复杂度为O(n^2)】【空间复杂度为O(1)】<br>只适用于顺序存储<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goynwdduxkj30iz0ejq3l.jpg"></p>
]]></content>
      <categories>
        <category>数据结构、算法笔记</category>
      </categories>
  </entry>
  <entry>
    <title>排序的基本概念</title>
    <url>/2019/12/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%8E%92%E5%BA%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<hr>
<p>排序：重新排列表中的元素，使表中的元素满足按关键字递增或递减</p>
<p>算法的稳定性：若待排序表中有两个元素Ri和Rj，其对应的关键字Ki=Kj，且在排序前Ri在Rj前面，若使用某排序算法后，Ri仍然在Rj前面，则称这个排序算法是稳定的，否则称排序算法不稳定</p>
<p>算法的稳定性是算法的性质，并不能衡量一个算法的优劣</p>
<p>时空复杂度决定内部排序算法的性能</p>
<p>内部排序：指在排序期间元素全部存放在内存中的排序<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goylwtq39kj315h0o5tbh.jpg"></p>
<p>外部排序：指在排序期间元素无法全部同时存放在内存中，必须在排序的过程中根据要求不断的在内、外存之间进行移动</p>
]]></content>
      <categories>
        <category>数据结构、算法笔记</category>
      </categories>
  </entry>
  <entry>
    <title>拓扑排序</title>
    <url>/2019/12/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<hr>
<p>有向无环图：不存在环的有向图，简称DAG图</p>
<p>在一个表示工程的有向图中，用顶点表示活动，用弧表示活动之间的优先关系，称这样的有向图为顶点表示活动的网，简称AOV网</p>
<p>在AOV网中，不能出现回路</p>
<p>若从顶点vi到vj有一条路径，则在顶点序列中顶点vi必在vj之前，对一个有向图构造拓扑序列的过程称为拓扑排序</p>
<p>基本思想：<br>1）从AOV网中选择一个没有前驱的顶点并输出<br>2）从AOV网中删去该顶点以及所有以该顶点为尾的弧<br>3）重复上述两步，直到全部顶点都被输出，或AOV网中不存在没有前驱的顶点<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gowln5hklwj315v0u0gp7.jpg"></p>
<p>算法结束时没有访问所有顶点，则存在以剩下顶点组成的环</p>
<p>拓扑排序的结果不一定唯一</p>
<p>时间复杂度：O(|V|+|E|)<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gowlq1g686j30mt0g1t9e.jpg"></p>
<p>若邻接矩阵为三角矩阵，则存在拓扑排序，反之不一定成立</p>
]]></content>
      <categories>
        <category>数据结构、算法笔记</category>
      </categories>
  </entry>
  <entry>
    <title>散列函数的设计和冲突处理</title>
    <url>/2019/12/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%92%8C%E5%86%B2%E7%AA%81%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<hr>
<p>散列函数的设计：</p>
<p>设计散列函数一般遵循以下基本原则:<br>1）计算简单。散列函数不应该有很大的计算量，否则会降低查找效率;<br>2）函数值(即散列地址)分布均匀中，希望散列函数能够把记录以相同的概率“散列”到散列表的所有地址空间中，这样才能保证存储空间的有效利用,并减少冲突。</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goxq3jz43rj315i0u0q6z.jpg"></p>
<p>冲突处理：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goxqxk707ij30u00vkwl8.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goxr85cypej316g0u00vb.jpg"></p>
]]></content>
      <categories>
        <category>数据结构、算法笔记</category>
      </categories>
  </entry>
  <entry>
    <title>折半查找</title>
    <url>/2019/12/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%8A%98%E5%8D%8A%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<hr>
<p>折半查找：又称二分查找，仅适用于有序的顺序表</p>
<p>算法思想：<br>1）首先将给定值key与表中中间位置元素的关键字比较<br>2）若相等，则返回该元素的位置；若不等，则在前半部分或者是后半部分进行查找<br>3）查找序列升序时，若key小于中间元素，则查找前半部分；若key大于中间元素，则查找后半部分<br>4）重复该过程，直到找到查找的元素为止，或查找失败</p>
<p>注意low&lt;=high：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goxc6ce9blj30qy0ixq3o.jpg"></p>
<p>折半查找的判定树：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goxcflpscmj31190eet9l.jpg"></p>
<p>查找成功的平均比较次数：[log2(n+1)]-1，折半查找的时间复杂度为O(log2n)</p>
<p>顺序查找适用于顺序存储和链式存储，序列有序无序皆可；折半查找只适用于顺序存储，且要求序列一定有序</p>
]]></content>
      <categories>
        <category>数据结构、算法笔记</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构和算法的基本概念</title>
    <url>/2020/01/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<hr>
<p>数据：数据是信息的载体，是描述客观事物属性的数、字符及所有能输入到计算机中并被计算机程序识别和处理的符号的集合，数据是计算机程序加工的原料</p>
<p>数据元素和数据项：数据元素是数据的基本单位，通常作为一个整体进行考虑和处理；一个数据元素可由若干数据项组成，数据项是构成数据元素的不可分割的最小单位</p>
<p>结构：各个元素之间的关系</p>
<p>数据结构：是相互之间存在一种或多种特定关系的数据元素的集合<br>数据对象：是具有相同性质的数据元素的集合，是数据的一个子集</p>
<p>数据结构的三要素：</p>
<ol>
<li>逻辑结构：数据元素之间的逻辑关系是什么【集合、线性结构、树形结构、图状结构(网状结构)】</li>
<li>物理结构(存储结构)：各个数据元素在内存中如何存储，如何用计算机表示数据元素的逻辑关系【顺序存储、链式存储、索引存储、散列存储】</li>
<li>数据的运算：施加在数据上的运算包括运算的定义和实现，运算的定义是针对逻辑结构的，指出运算的功能；运算的实现是针对存储结构的，指出运算的具体操作步骤</li>
</ol>
<p>线性结构：<br>1）顺序存储：把逻辑上相邻的元素存储在物理位置上也相邻的存储单元中，元素之间的关系由存储单元的邻接关系来体现<br>2）链式存储：逻辑上相邻的元素在物理位置上可以不相邻，借助指示元素存储地址的指针来表示元素之间的逻辑关系<br>3）索引存储：在存储元素信息的同时，还建立附加的索引表，索引表的每项称为索引项，索引项的一般形式是（关键字，地址）<br>4）散列存储：根据元素的关键字直接计算出该元素的存储地址，又称哈希存储</p>
<p>数据类型：一个值的集合和定义在此集合上的一组操作的总称<br>1）原子类型【bool、int】<br>2）结构类型【struct】</p>
<p>抽象数据类型（ADT）：是抽象数据组织及与之相关的操作</p>
<p>程序=数据结构+算法</p>
<p>算法的特性：<br>1）有穷性：一个算法必须总在执行有穷步之后结束，且每一步都可在有穷时间内完成【算法必须是有穷的，而程序可以是无穷的】<br>2）确定性：算法中每条指令必须有确切的含义，对于相同的输入只能得出相同的输出<br>3）可行性：算法中描述的操作都可以通过已经实现的基本运算执行有限次来实现<br>4）输入和输出</p>
<p>好算法的特质：<br>1）正确性：算法应能够正确的解决求解问题<br>2）可读性：算法应具有良好的可读性，以帮助人们理解<br>3）健壮性：输入非法数据时，算法能适当的做出反应或进行处理，而不会产生莫名其妙的输出结果<br>4）高效率与低存储量需求</p>
]]></content>
      <categories>
        <category>数据结构、算法笔记</category>
      </categories>
  </entry>
  <entry>
    <title>散列表的基本概念</title>
    <url>/2019/12/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%95%A3%E5%88%97%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<hr>
<p>散列函数：一个把查找表中的关键字映射成该关键字对应的地址的函数</p>
<p>散列表：根据关键字而直接进行访问的数据结构，它建立了关键字与存储地址之间的一种直接映射关系</p>
<p>在散列技术中，由于记录的定位主要基于散列函数的计算,不需要进行关键码的多次比较，所以，一般情况下,散列技术的查找速度要比基于比较的查找技术的查找速度快。但是，散列技术-般不适用于多个记录有相同关键码的情况，也不适用于范围查找。散列技术最适合回答的问题是:如果有的话，哪个记录的关键码等于待查值。</p>
<p>冲突(碰撞)：散列函数可能会把多个不同的关键字映射到同一地址下的情况，同一地址下的多个关键字称为同义词</p>
]]></content>
      <categories>
        <category>数据结构、算法笔记</category>
      </categories>
  </entry>
  <entry>
    <title>最短路径</title>
    <url>/2019/12/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<hr>
<p>最短路径：两个顶点之间带权路径长度最短的路径为最短路径</p>
<p>在带权图当中，把从一个顶点v到另一个顶点u所经历的边的权值之和称为路径的带权路径长度</p>
<p>Dijkstra算法：带权图单源最短路径<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gowjaudro9j31030u0n0s.jpg"></p>
<p>时间复杂度：O(|V|^2)<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gowjb45bhuj30gs0dawey.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gowjh8y76uj30p80f7dgh.jpg"></p>
<p>Dijkstra算法并不适用于含有负权边的图</p>
<p>Floyd算法：各顶点之间的最短路径<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gowk6v7wodj315i0u0q5r.jpg"></p>
<p>时间复杂度：O(|V|^3)<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gowjwpdsq2j30lc0a60td.jpg"></p>
]]></content>
      <categories>
        <category>数据结构、算法笔记</category>
      </categories>
  </entry>
  <entry>
    <title>查找的基本概念</title>
    <url>/2019/12/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%9F%A5%E6%89%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<hr>
<p>查找：在数据集合中寻找满足某种条件的数据元素的过程，查找结果分为查找成功和查找失败</p>
<p>查找表：用于查找的数据集合，由同一种数据类型(或记录)组成，可以是一个数组或链表等数据类型</p>
<p>查找表的操作：<br>1）查询某个特定的数据元素是否在查找表中<br>2）检索满足条件的某个特定的数据元素的各种属性<br>3）从查找表中插入一个数据元素<br>4）从查找表中删除一个数据元素</p>
<p>不涉及插入和删除操作的查找称为静态查找，涉及插入和删除操作的查找称为动态查找</p>
<p>关键字：数据元素中唯一标识该元素的某个数据项的值，使用基于关键字的查找，查找结果应该是唯一的</p>
<p>平均查找长度：查找时，关键字比较次数的平均值</p>
<p>线性表：适用于静态查找，主要采用顺序查找技术、折半查找技术<br>树表：适用于动态查找，主要采用二叉排序树、平衡二叉树、B树等查找技术<br>散列表：静态查找和动态查找均适用，主要采用散列查找技术</p>
]]></content>
      <categories>
        <category>数据结构、算法笔记</category>
      </categories>
  </entry>
  <entry>
    <title>最小生成树</title>
    <url>/2019/12/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</url>
    <content><![CDATA[<hr>
<p>生成树：连通图包含全部顶点的一个极小连通子图</p>
<p>最小生成树：对于带权无向连通图G=(V,E)，G的所有生成树当中边的权值之和最小的生成树为G的最小生成树（MST）</p>
<p>性质：<br>1）最小生成树不一定唯一，即最小生成树的树形不一定唯一，当带权无向连通图G的各边权值不等时或G只有结点数-1条边时，MST唯一<br>2）最小生成树的权值是唯一的，且是最小<br>3）最小生成树的边数为顶点数-1</p>
<p>Prim算法：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gowhea9abpj30w40u0god.jpg"></p>
<p>时间复杂度：O(|V|^2)，适用于稠密图<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gowhfo3re7j30md0gq3za.jpg"></p>
<p>Kruskal算法：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gowi1mjjyoj30we0u0gos.jpg"></p>
<p>时间复杂度：O(|E|log|E|)，适用于稀疏图<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gowi59pmhwj30l50bamxo.jpg"></p>
]]></content>
      <categories>
        <category>数据结构、算法笔记</category>
      </categories>
  </entry>
  <entry>
    <title>栈在括号匹配中的应用</title>
    <url>/2020/01/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%A0%88%E5%9C%A8%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<hr>
<p>括号匹配问题：<br><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1gomone1p69j20yl0ff3zd.jpg"></p>
<p>遇到左括号就入栈，遇到右括号就消耗一个左括号</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gomp183stjj31400u076v.jpg"></p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gomw17pzozj30u80q9gn4.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gomr7os02jj30jw12odjb.jpg"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdbool.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;万一存满了，可以用链栈</span><br><span class="line">#define MaxSize 10  &#x2F;&#x2F;定义栈中元素的最大个数</span><br><span class="line"></span><br><span class="line">typedef struct&#123;</span><br><span class="line">    char data[MaxSize];  &#x2F;&#x2F;静态数组存放栈中元素</span><br><span class="line">    int top;  &#x2F;&#x2F;栈顶指针</span><br><span class="line">&#125;SqStack;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;初始化栈</span><br><span class="line">void InitStack(SqStack *S)&#123;</span><br><span class="line">    S-&gt;top&#x3D;-1;  &#x2F;&#x2F;初始化栈顶指针</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;判断栈空</span><br><span class="line">bool StackEmpty(SqStack *S)&#123;</span><br><span class="line">    if(S-&gt;top &#x3D;&#x3D; -1)&#123;</span><br><span class="line">        return true;  &#x2F;&#x2F;栈空</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        return false;  &#x2F;&#x2F;不空</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;新元素入栈</span><br><span class="line">bool Push(SqStack *S,char x)&#123;</span><br><span class="line">    if(S-&gt;top&#x3D;&#x3D;MaxSize-1)&#123;</span><br><span class="line">        return false;  &#x2F;&#x2F;栈满，报错</span><br><span class="line">    &#125;</span><br><span class="line">    S-&gt;top&#x3D;S-&gt;top+1;  &#x2F;&#x2F;指针先+1</span><br><span class="line">    S-&gt;data[S-&gt;top]&#x3D;x;  &#x2F;&#x2F;新元素入栈</span><br><span class="line">    </span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;栈顶元素出栈，用x返回</span><br><span class="line">bool Pop(SqStack *S,char *x)&#123;</span><br><span class="line">    if(S-&gt;top&#x3D;&#x3D;-1)&#123;</span><br><span class="line">        return false;  &#x2F;&#x2F;栈空，报错</span><br><span class="line">    &#125;</span><br><span class="line">    (*x)&#x3D;S-&gt;data[S-&gt;top];  &#x2F;&#x2F;栈顶元素先出栈</span><br><span class="line">    S-&gt;top&#x3D;S-&gt;top-1;  &#x2F;&#x2F;指针再-1，数据还残留在内存中，只是逻辑上被删除了</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool bracketCheck(char str[],int length)&#123;</span><br><span class="line">    SqStack S;</span><br><span class="line">    InitStack(&amp;S);  &#x2F;&#x2F;初始化一个栈</span><br><span class="line">    for(int i&#x3D;0;i&lt;length;i++)&#123;</span><br><span class="line">        if(str[i]&#x3D;&#x3D;&#39;(&#39; || str[i]&#x3D;&#x3D;&#39;[&#39; || str[i]&#x3D;&#x3D;&#39;&#123;&#39;)&#123;</span><br><span class="line">            Push(&amp;S,str[i]);  &#x2F;&#x2F;扫描到左括号，入栈</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            if(StackEmpty(&amp;S))&#123;  &#x2F;&#x2F;扫描到右括号，且当前栈空</span><br><span class="line">                return false;  &#x2F;&#x2F;匹配失败</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            char topElem;</span><br><span class="line">            Pop(&amp;S,&amp;topElem);  &#x2F;&#x2F;栈顶元素出栈</span><br><span class="line">            if(str[i]&#x3D;&#x3D;&#39;)&#39; &amp;&amp; topElem !&#x3D; &#39;)&#39;)&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            if(str[i]&#x3D;&#x3D;&#39;]&#39; &amp;&amp; topElem !&#x3D; &#39;[&#39;)&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            if(str[i]&#x3D;&#x3D;&#39;&#125;&#39; &amp;&amp; topElem !&#x3D; &#39;&#123;&#39;)&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return StackEmpty(&amp;S);  &#x2F;&#x2F;检索完全部括号后，栈空说明匹配成功</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构、算法笔记</category>
      </categories>
  </entry>
  <entry>
    <title>栈在表达式求值中的应用</title>
    <url>/2020/01/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%A0%88%E5%9C%A8%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<hr>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gomx4a52isj30yk0g3jse.jpg"></p>
<p>可以不用界限符也能无歧义的表达运算顺序？【逆波兰表达式=后缀表达式，波兰表达式=前缀表达式】</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gon07fc37kj30wt0u0adt.jpg"></p>
<p>中缀表达式转后缀表达式：<br>初始化一个栈，用于保存暂时还不能确定运算顺序的运算符<br>从左到右处理各个元素，直到末尾，可能遇到三种情况：<br>1.遇到操作数，直接加入后缀表达式<br>2.遇到界限符，遇到“(”直接入栈，遇到“)”则依次弹出栈内运算符并加入后缀表达式，直到弹出”(“为止，注意：”(“不加入后缀表达式<br>3.遇到运算符，依次弹出栈中优先级高于或等于当前运算符的所有运算符，并加入后缀表达式，若碰到“(”或栈空则停止，之后再把当前运算符入栈<br>按上述方法处理完所有字符后，将栈中剩余运算符依次弹出，并加入后缀表达式</p>
<p>用栈实现后缀表达式的计算：【栈是用于存放当前暂时还不能确定运算次序的操作数】<br>1.从左到右扫描下一个元素，直到处理完所有元素<br>2.若扫描到操作数则压入栈，并回到1；否则执行3<br>3.若扫描到运算符，则弹出两个栈顶元素，执行相应运算[注意先出栈的是右操作数]，运算结果压回栈底，回到1<br>若表达式合法，则最后栈中只会留下一个元素，就是最终结果</p>
<p>用栈实现中缀表达式的计算：（中缀转后缀+后缀表达式求值，两个算法的结合）<br>初始化两个栈，操作数栈和运算符栈<br>若扫描到操作数，压入操作数栈<br>若扫描到运算符或界限符，则按照“中缀转后缀”相同相同的逻辑压入运算符栈（期间也会弹出运算符，每当弹出一个运算符时，就需要再弹出两个操作数栈的栈顶元素并执行相应运算，运算结果再压回操作数栈）</p>
<p>用栈实现前缀表达式的计算：<br>1.从右往左扫描下一个元素，直到处理完所有元素<br>2.若扫描到操作数则压入栈，并回到1，否则执行3<br>3.若扫描到运算符，则弹出两个栈顶元素，执行相应运算[先出栈的是左操作数]，运算结果压回栈底，回到1</p>
]]></content>
      <categories>
        <category>数据结构、算法笔记</category>
      </categories>
  </entry>
  <entry>
    <title>最佳归并树</title>
    <url>/2019/11/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%9C%80%E4%BD%B3%E5%BD%92%E5%B9%B6%E6%A0%91/</url>
    <content><![CDATA[<hr>
<p>m路归并排序可用一棵m叉树描述</p>
<p>归并树：用来描述m归并，并只有度为0和度为m的结点的严格m叉树</p>
<p>带权路径长度之和为归并过程中的总读记录数：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gp03flvxxnj30oi0ent9f.jpg"></p>
<p>用哈夫曼树构造的叫最佳归并树：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gp03fuqiqaj30oy0ghgmb.jpg"></p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gp03o8407ij30qi0gngmh.jpg"></p>
]]></content>
      <categories>
        <category>数据结构、算法笔记</category>
      </categories>
  </entry>
  <entry>
    <title>栈在递归中的应用</title>
    <url>/2020/01/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%A0%88%E5%9C%A8%E9%80%92%E5%BD%92%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<hr>
<p>递归函数调用的特点：最后被调用的函数最先执行结束(LIFO)</p>
<p>函数调用时，需要用一个栈存储：调用返回地址、实参、局部变量</p>
<p>适合用“递归”算法解决：可以把原始问题转换为属性相同，但规模较小的问题</p>
<p>递归调用时，函数调用栈可称为“递归工作栈”，每进入一层递归，就将递归调用所需信息压入栈顶，每退出一层递归，就从栈顶弹出相应信息【缺点：效率低，太多层递归可能会导致栈溢出，可能包含很多重复计算】</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gon58v3uluj308k0bcgmi.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gon5d1zbqdj308l0bzaay.jpg"></p>
]]></content>
      <categories>
        <category>数据结构、算法笔记</category>
      </categories>
  </entry>
  <entry>
    <title>栈的基本概念</title>
    <url>/2020/01/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%A0%88%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<hr>
<p>栈(Stack)是只允许在一端进行插入或删除操作的线性表【空栈、栈顶：允许插入和删除的一端、栈底：不允许插入和删除的一端】</p>
<p>特点：后进先出【Last In First Out(LIFO)】</p>
<p>栈的基本操作：</p>
<ol>
<li><p><code>InitStack(&amp;S)</code>：初始化栈，构造一个空栈S，分配内存空间</p>
</li>
<li><p><code>DestroyStack(&amp;L)</code>：销毁栈，销毁并释放栈S所占用的内存空间</p>
</li>
<li><p><code>Push(&amp;S,x)</code>：进栈，若栈S未满，则将x加入使之成为新栈顶</p>
</li>
<li><p><code>Pop(&amp;S,&amp;x)</code>：出栈，若栈S非空，则弹出栈顶元素，并用x返回【删除栈顶元素】</p>
</li>
<li><p><code>GetTop(S,&amp;x)</code>：读栈顶元素，若栈S非空，则用x返回栈顶元素【不删除栈顶元素，查栈的使用场景中大多只访问栈顶元素】</p>
</li>
<li><p><code>StackEmpty(S)</code>：判读一个栈S是否为空，若S为空，则返回true，否则返回false</p>
</li>
</ol>
]]></content>
      <categories>
        <category>数据结构、算法笔记</category>
      </categories>
  </entry>
  <entry>
    <title>栈的链式存储实现</title>
    <url>/2020/01/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%A0%88%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<hr>
<p>进栈操作：头插法建立单链表(对头结点的后插操作)</p>
<p>出栈操作：单链表的删除操作(对头结点的后删操作)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;链栈的定义(带头结点的初始化，不带头结点的初始化)</span><br><span class="line">typedef struct Linknode&#123;</span><br><span class="line">   int data;  &#x2F;&#x2F;数据域</span><br><span class="line">   struct Linknode *next;  &#x2F;&#x2F;指针域</span><br><span class="line">&#125;*Listack;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构、算法笔记</category>
      </categories>
  </entry>
  <entry>
    <title>树和森林</title>
    <url>/2019/12/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97/</url>
    <content><![CDATA[<hr>
<p>树与二叉树的转换：左孩子右兄弟<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gou2mauf1hj312c0u0mzz.jpg"></p>
<p>森林与二叉树的转换：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gou3jdpte1j31390u0n0c.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gou3jmsedkj30y60u0ad3.jpg"></p>
<p>树的遍历：按照某种方式访问树中的每个结点，且仅访问一次</p>
<ol>
<li>先根遍历：若树非空，则先访问根结点，再按从左到右的顺序遍历根结点的每棵子树</li>
<li>后根遍历：若树非空，则先按从左到右的顺序遍历根结点的每棵子树，再访问根结点</li>
<li>层次遍历<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gou401u3tyj30sc0lq752.jpg"></li>
</ol>
<p>森林的遍历：</p>
<ol>
<li>先序遍历：若森林非空，则访问森林中第一棵树的根结点，先序遍历第一棵树的子树森林，先序遍历除去第一棵树之后剩余的树构成的子树森林</li>
<li>后序遍历：若森林非空，则后序遍历第一棵树的根结点的子树森林，访问第一棵树的根结点，后序遍历除去第一棵树之后剩余的树构成的子树森林<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gou4d68vgij30s50gxq3l.jpg"></li>
</ol>
]]></content>
      <categories>
        <category>数据结构、算法笔记</category>
      </categories>
  </entry>
  <entry>
    <title>树的基本概念</title>
    <url>/2020/01/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<hr>
<p>树是n(n&gt;=0)个结点的有限集合，n=0时，称为空树</p>
<p>而任意非空树应满足：</p>
<ol>
<li>有且仅有一个特定的称为根的结点</li>
<li>当n&gt;1时，其余结点可分为m(m&gt;0)个互不相交的有限集合，其中每一个集合本身又是一棵树，称为根结点的子树</li>
</ol>
<p>基本术语：</p>
<p>祖先结点和子孙结点、双亲结点和孩子结点、兄弟结点</p>
<p>树中一个结点的子结点的个数称为该结点的度；<br>树中各结点度的最大值称为树的度</p>
<p>度大于0的结点称为分支结点<br>度为0的结点称为叶子结点</p>
<p>结点的层数【自顶向下】<br>结点的高度【自底向上】<br>结点的深度【自顶向下】<br>树的高度(深度)是树中结点的最大层数<br>树中每一层结点个数的最大值称为树的宽度</p>
<p>路径：树中两个结点之间的路径是由这两个结点之间所经过的结点序列构成的【树中的分支是有向的，即从双亲结点指向孩子结点，所以路径一定是自上而下的】</p>
<p>路径长度：路径上所经历边的个数</p>
<p>有序树：树中任意结点的子结点之间有顺序关系<br>无序树：树中任意结点的子结点之间没有顺序关系，也叫自由树</p>
<p>树的性质：</p>
<ol>
<li>n个结点的树中只有n-1条边</li>
<li>树中的结点数等于所有结点的度数+1</li>
<li>度为m的树中第i层上至多有m^(i-1)个结点(i&gt;=1)</li>
<li>高度为h的m叉树至多有(m^h-1)/(m-1)个结点</li>
<li>具有n个结点的m叉树的最小高度为<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goox9wo751j30bs03ca9w.jpg"></li>
</ol>
<p>森林：m(m&gt;=0)棵互不相交的树的集合</p>
]]></content>
      <categories>
        <category>数据结构、算法笔记</category>
      </categories>
  </entry>
  <entry>
    <title>深度优先搜索</title>
    <url>/2019/12/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/</url>
    <content><![CDATA[<hr>
<p>深度优先搜索DFS：【与树的先序遍历类似】<br>1）首先访问起始顶点v<br>2）接着由v出发访问v的任意一个邻接且未被访问的邻接顶点wi<br>3）然后再访问与wi邻接且未被访问的任意顶点yi<br>4）若wi没有邻接且未被访问的顶点时，退回到它的上一层顶点v<br>5）重复上述过程，直到所有顶点被访问为止</p>
<p>借助递归(栈)+辅助标记数组来实现：【邻接矩阵法的DFS(BFS)序列唯一，邻接表法的不唯一】<br>DFS序列：ACDEB<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gow9uakq4bj30vz0bwjs1.jpg"></p>
<p>DFS算法的性能分析：<br>1）空间复杂度：O(|V|)<br>2）时间复杂度：邻接矩阵法O(|V|^2)，邻接表法O(|V|+|E|)</p>
<p>深度优先生成树：在深度遍历过程中，我们可以得到一棵遍历树，称为深度优先生成树（生成森林）【邻接矩阵法的深度优先生成树唯一，邻接表法的不唯一】<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gowa1kzpwtj30l208t3yj.jpg"></p>
<p>遍历与连通性问题：<br>1）在无向图中，在任意结点出发进行一次遍历(调用一次BFS或DFS)，若能访问全部结点，说明该无向图是连通的<br>2）在无向图中，调用遍历函数(BFS或DFS)的次数为连通分量的个数<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gowa9mwx28j30ek0akt8p.jpg"><br>有向图中上面两个结论都不成立：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gowa9z735zj30mb0fsq39.jpg"></p>
]]></content>
      <categories>
        <category>数据结构、算法笔记</category>
      </categories>
  </entry>
  <entry>
    <title>树的存储结构</title>
    <url>/2019/12/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<hr>
<p>双亲表示法：采用一组连续的存储空间来存储每个结点，同时在每个结点中增设一个伪指针，指示双亲结点在数组中的位置，根结点的下标为0，其伪指针域为-1</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define MAX_TREE_SIZE 100</span><br><span class="line"></span><br><span class="line">typedef struct&#123;</span><br><span class="line">    int data;</span><br><span class="line">    int parent;</span><br><span class="line">&#125;PINode;</span><br><span class="line"></span><br><span class="line">typedef struct&#123;</span><br><span class="line">    PINode nodes[MAX_TREE_SIZE];</span><br><span class="line">    int n;</span><br><span class="line">&#125;PTree;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goq3k7mun6j30vm0kot9p.jpg"></p>
<p>孩子表示法：将每个结点的孩子结点都用单链表连接起来形成一个线性结构，n个结点具有n个孩子链表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define MAX_TREE_SIZE 100</span><br><span class="line"></span><br><span class="line">typedef struct&#123;</span><br><span class="line">    int child;</span><br><span class="line">    struct CNode *next;</span><br><span class="line">&#125;CNode;</span><br><span class="line"></span><br><span class="line">typedef struct&#123;</span><br><span class="line">    int data;</span><br><span class="line">    struct CNode *child;</span><br><span class="line">&#125;PNode;</span><br><span class="line"></span><br><span class="line">typedef struct&#123;</span><br><span class="line">    PNode nodes[MAX_TREE_SIZE];</span><br><span class="line">    int n;</span><br><span class="line">&#125;CTree;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goq40hujrgj31ac0ol3zu.jpg"></p>
<p>孩子兄弟表示法：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goq4czekfgj311z0u0gnq.jpg"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct CSNode&#123;</span><br><span class="line">    int data;</span><br><span class="line">    struct CSNode *firstchild,*nextsibling;</span><br><span class="line">&#125;CSNode,CSTRee;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>双亲表示法：寻找结点的双亲结点效率高，寻找结点的孩子结点效率低<br>孩子表示法：寻找结点的孩子结点效率高，寻找结点的双亲结点效率低<br>孩子兄弟表示法：寻找结点的孩子结点效率高，方便实现树转换为二叉树，寻找双亲结点的效率低</p>
]]></content>
      <categories>
        <category>数据结构、算法笔记</category>
      </categories>
  </entry>
  <entry>
    <title>直接插入排序</title>
    <url>/2019/12/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<hr>
<p>插入排序：每次将一个待排序的序列插入到一个前面已排好序的子序列当中</p>
<p>直接插入排序(稳定的算法)：【空间复杂度为O(1)】【最好时间复杂度为O(n)，最坏、平均复杂度为O(n^2)】<br>适用于顺序存储和链式存储<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goync8jwrlj31ac0lp40g.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goyncgeb6hj30g006vaa5.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goynas5xddj30fd0g1q3p.jpg"></p>
]]></content>
      <categories>
        <category>数据结构、算法笔记</category>
      </categories>
  </entry>
  <entry>
    <title>直接选择排序</title>
    <url>/2019/11/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E7%9B%B4%E6%8E%A5%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<hr>
<p>选择排序(不稳定的算法)：【时间复杂度为O(n^2)】【空间复杂度为O(1)】<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gozgfl6z9cj31h50iqacb.jpg"></p>
<p>时间复杂度与初始序列无关</p>
<p>适用于顺序存储和链式存储<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gozgfy2ldhj30i2096q37.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gozgg613j8j30dk0e8q3d.jpg"></p>
]]></content>
      <categories>
        <category>数据结构、算法笔记</category>
      </categories>
  </entry>
  <entry>
    <title>特殊矩阵的压缩存储</title>
    <url>/2020/01/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E7%89%B9%E6%AE%8A%E7%9F%A9%E9%98%B5%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%AD%98%E5%82%A8/</url>
    <content><![CDATA[<hr>
<p>普通矩阵的存储：可用二维数组存储【描述矩阵元素时，行、列号通常从1开始，而描述数组时通常下标从0开始】</p>
<p>特殊矩阵（某些特殊矩阵可以压缩存储空间）：</p>
<ol>
<li><p>对称矩阵<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gonri8rmdtj30u0113gro.jpg"></p>
</li>
<li><p>三角矩阵<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gons7x429jj30zi0u078o.jpg"></p>
</li>
<li><p>三对角矩阵<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gont4iafobj314h0u077w.jpg"></p>
</li>
<li><p>稀疏矩阵<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gonto99il3j30u00uzadx.jpg"></p>
</li>
</ol>
]]></content>
      <categories>
        <category>数据结构、算法笔记</category>
      </categories>
  </entry>
  <entry>
    <title>栈的顺序存储实现</title>
    <url>/2020/01/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%A0%88%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<hr>
<p>顺序栈的缺点：栈的大小不可变<br><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1gom26d6r2mj20fm0wfju1.jpg"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdbool.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">#define MaxSize 10  &#x2F;&#x2F;定义栈中元素的最大个数</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;顺序栈的定义</span><br><span class="line">typedef struct&#123;</span><br><span class="line">    int data[MaxSize];  &#x2F;&#x2F;静态数组存放栈中元素</span><br><span class="line">    int top;  &#x2F;&#x2F;栈顶指针，top指向当前栈顶元素</span><br><span class="line">&#125;SqStack;  &#x2F;&#x2F;Sq：sequence，顺序</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;初始化栈</span><br><span class="line">void InitStack(SqStack *S)&#123;</span><br><span class="line">    S-&gt;top&#x3D;-1;  &#x2F;&#x2F;初始化栈顶指针</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;判断栈空</span><br><span class="line">bool StackEmpty(SqStack *S)&#123;</span><br><span class="line">    if(S-&gt;top &#x3D;&#x3D; -1)&#123;</span><br><span class="line">        return true;  &#x2F;&#x2F;栈空</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        return false;  &#x2F;&#x2F;不空</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;进栈操作</span><br><span class="line">bool Push(SqStack *S,int x)&#123;</span><br><span class="line">    if(S-&gt;top&#x3D;&#x3D;MaxSize-1)&#123;</span><br><span class="line">        return false;  &#x2F;&#x2F;栈满，报错</span><br><span class="line">    &#125;</span><br><span class="line">    S-&gt;top&#x3D;S-&gt;top+1;  &#x2F;&#x2F;指针先+1</span><br><span class="line">    S-&gt;data[S-&gt;top]&#x3D;x;  &#x2F;&#x2F;新元素入栈</span><br><span class="line">    </span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;出栈操作,并用x返回</span><br><span class="line">bool Pop(SqStack *S,int *x)&#123;</span><br><span class="line">    if(S-&gt;top&#x3D;&#x3D;-1)&#123;</span><br><span class="line">        return false;  &#x2F;&#x2F;栈空，报错</span><br><span class="line">    &#125;</span><br><span class="line">    (*x)&#x3D;S-&gt;data[S-&gt;top];  &#x2F;&#x2F;栈顶元素先出栈</span><br><span class="line">    S-&gt;top&#x3D;S-&gt;top-1;  &#x2F;&#x2F;指针再-1，数据还残留在内存中，只是逻辑上被删除了</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;读栈顶元素操作</span><br><span class="line">bool GetTop(SqStack *S,int *x)&#123;</span><br><span class="line">    if(S-&gt;top&#x3D;&#x3D;-1)&#123;</span><br><span class="line">        return false;  &#x2F;&#x2F;栈空，报错</span><br><span class="line">    &#125;</span><br><span class="line">    (*x)&#x3D;S-&gt;data[S-&gt;top];  &#x2F;&#x2F;x记录栈顶元素</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    SqStack S;  &#x2F;&#x2F;声明一个顺序栈(分配空间)</span><br><span class="line">    InitStack(&amp;S);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;...后续操作</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>共享栈：<br><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1gom2dl9esmj20a40e10ud.jpg"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdbool.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">#define MaxSize 10  &#x2F;&#x2F;定义栈中元素的最大个数</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;共享栈：两个栈共享同一片空间</span><br><span class="line">typedef struct&#123;</span><br><span class="line">    int data[MaxSize];  &#x2F;&#x2F;静态数组存放栈中元素</span><br><span class="line">    int top0;  &#x2F;&#x2F;0号栈顶指针</span><br><span class="line">    int top1;  &#x2F;&#x2F;1号栈顶指针</span><br><span class="line">&#125;ShStack;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;初始化栈</span><br><span class="line">void InitStack(ShStack *S)&#123;</span><br><span class="line">    S-&gt;top0&#x3D;-1;  &#x2F;&#x2F;初始化栈顶指针</span><br><span class="line">    S-&gt;top1&#x3D;MaxSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;栈满条件：top0+1&#x3D;&#x3D;top1</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    ShStack S;  &#x2F;&#x2F;声明一个顺序栈(分配空间)</span><br><span class="line">    InitStack(&amp;S);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;...后续操作</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构、算法笔记</category>
      </categories>
  </entry>
  <entry>
    <title>算法的时间复杂度和空间复杂度</title>
    <url>/2020/01/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%92%8C%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</url>
    <content><![CDATA[<hr>
<h3 id="算法时间复杂度和空间复杂度"><a href="#算法时间复杂度和空间复杂度" class="headerlink" title="算法时间复杂度和空间复杂度"></a>算法时间复杂度和空间复杂度</h3><p>如何评估算法时间开销：<br>让算法先运行，事后统计运行时间？【存在问题：和机器性能有关；和编程语言有关，越高级的语言执行效率越低；和编译程序产生的机器指令质量有关；有些算法是不能事后再统计的(导弹控制算法)】</p>
<p>算法时间复杂度：事前预估算法时间开销T(n)与问题规模n的关系<br>1）最坏时间复杂度<br>2）平均时间复杂度<br>3）最好时间复杂度</p>
<p>O(1)&lt;O(log2n)&lt;O(n)&lt;O(nlog2n)&lt;O(n^2)&lt;O(n^3)&lt;O(2^n)&lt;O(n!)&lt;O(n^n)</p>
<h3 id="测试算法效率-时钟打点"><a href="#测试算法效率-时钟打点" class="headerlink" title="测试算法效率(时钟打点)"></a>测试算法效率(时钟打点)</h3><p>问题：<br><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gly1qehby1j30h702j76c.jpg"></p>
<p>源代码：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goftlp7nyuj30rr0x10wm.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goftm5v1nzj307g02hjrk.jpg"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F;clock():捕捉从程序开始运行到clock()被调用时所耗费的时间。这个时间单位是clock tick，即“时钟打点”</span><br><span class="line">&#x2F;&#x2F;常数CLK_TCK:机器时钟每秒所走的时钟打点数</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;让被测函数重复运行充分多次，使得测出的总的时钟打点间隔充分长，最后计算被测函数平均每次运行的时间即可</span><br><span class="line"></span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;time.h&gt;</span><br><span class="line">#include&lt;math.h&gt;</span><br><span class="line"></span><br><span class="line">#define MAXN 10</span><br><span class="line">#define MAXK 1e7&#x2F;&#x2F;被测函数最大重复调用次数</span><br><span class="line"></span><br><span class="line">clock_t start,stop;&#x2F;&#x2F;clock_t是clock()函数返回的变量类型</span><br><span class="line">double duration;&#x2F;&#x2F;记录被测函数运行时间，以秒为单位</span><br><span class="line"></span><br><span class="line">double f1(int n,double a[],double x)&#123;</span><br><span class="line">    int i;</span><br><span class="line">    double p&#x3D;a[0];</span><br><span class="line">    for(i&#x3D;1;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">        p +&#x3D; (a[i]*pow(x,i));</span><br><span class="line">    &#125;</span><br><span class="line">    return p;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">double f2(int n,double a[],double x)&#123;</span><br><span class="line">    int i;</span><br><span class="line">    double p&#x3D;a[0];</span><br><span class="line">    for(i&#x3D;1;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">        p+&#x3D;(a[i]*pow(x,i));</span><br><span class="line">    &#125;</span><br><span class="line">    return p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int i,CLK_TCK;</span><br><span class="line">    double a[MAXN];&#x2F;&#x2F;存储多项式的系数</span><br><span class="line">    for(i&#x3D;0;i&lt;MAXN;i++)&#123;</span><br><span class="line">        a[i]&#x3D;(double)i;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;不在测试范围内的准备工作写在clock()调用之前</span><br><span class="line">    </span><br><span class="line">    start&#x3D;clock();&#x2F;&#x2F;开始计时</span><br><span class="line">    for(i&#x3D;0;i&lt;MAXK;i++)&#123;</span><br><span class="line">        f1(MAXN-1,a,1.1);&#x2F;&#x2F;把被测函数加在这里</span><br><span class="line">    &#125;</span><br><span class="line">    stop&#x3D;clock();&#x2F;&#x2F;停止计时</span><br><span class="line">    duration&#x3D;((double)(stop-start))&#x2F;CLK_TCK&#x2F;MAXK;&#x2F;&#x2F;计算函数单次运行时间</span><br><span class="line">    printf(&quot;ticks1&#x3D;%f\n&quot;,(double)(stop-start));</span><br><span class="line">    printf(&quot;duration1&#x3D;%6.2e\n&quot;,duration);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;其他不在测试范围的处理写在后面，例如输出duration的值</span><br><span class="line">    </span><br><span class="line">    start&#x3D;clock();&#x2F;&#x2F;开始计时</span><br><span class="line">    for(i&#x3D;0;i&lt;MAXK;i++)&#123;</span><br><span class="line">        f2(MAXN-1,a,1.1);&#x2F;&#x2F;把被测函数加在这里</span><br><span class="line">    &#125;</span><br><span class="line">    stop&#x3D;clock();&#x2F;&#x2F;停止计时</span><br><span class="line">    duration&#x3D;((double)(stop-start))&#x2F;CLK_TCK&#x2F;MAXK;&#x2F;&#x2F;计算函数单次运行时间</span><br><span class="line">    printf(&quot;ticks2&#x3D;%f\n&quot;,(double)(stop-start));</span><br><span class="line">    printf(&quot;duration2&#x3D;%6.2e\n&quot;,duration);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构、算法笔记</category>
      </categories>
  </entry>
  <entry>
    <title>线性表的定义和基本操作</title>
    <url>/2020/01/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<hr>
<p>线性表：是具有相同数据类型的n(n&gt;=0)个数据元素的有限序列，其中n为表长，当n=0时线性表是一个空表【位序从1开始，数组下标从0开始】</p>
<p>线性表的基本操作：</p>
<ol>
<li><p><code>InitList(&amp;L)</code>：初始化表，构造一个空的线性表L，分配内存空间</p>
</li>
<li><p><code>DestroyList(&amp;L)</code>：销毁操作，销毁线性表，并释放线性表L所占用的内存空间</p>
</li>
<li><p><code>ListInsert(&amp;L,i,e)</code>：插入操作，在表L中的第i个位置上插入指定元素e</p>
</li>
<li><p><code>ListDelete(&amp;L,i,&amp;e)</code>：删除操作，删除表L中第i个位置的元素，并用e返回删除元素的值</p>
</li>
<li><p><code>LocateElem(L,e)</code>：按值查找操作，在表L中查找具有给定关键字值的元素</p>
</li>
<li><p><code>GetElem(L,i)</code>：按位查找操作，获取表L中第i个位置的元素的值</p>
</li>
<li><p><code>Length(L)</code>：求表长，返回线性表L的长度，即L中数据元素的个数</p>
</li>
<li><p><code>PrintList(L)</code>：输出操作，按前后顺序输出线性表L的所有元素值</p>
</li>
<li><p><code>Empty(L)</code>：判空操作，若L为空表，则返回true，否则返回false</p>
</li>
</ol>
]]></content>
      <categories>
        <category>数据结构、算法笔记</category>
      </categories>
  </entry>
  <entry>
    <title>线索二叉树</title>
    <url>/2019/12/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<hr>
<p>线索化：若无左子树，则将左指针指向其前驱结点；若无右子树，则将右指针指向其后继结点<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gopgr2lc96j30yz0u0n1a.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gopgs3t0jxj31780u0418.jpg"></p>
]]></content>
      <categories>
        <category>数据结构、算法笔记</category>
      </categories>
  </entry>
  <entry>
    <title>败者树</title>
    <url>/2019/11/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E8%B4%A5%E8%80%85%E6%A0%91/</url>
    <content><![CDATA[<hr>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gozucz5vqtj30jg0580sw.jpg"></p>
<p>失败树：树形选择排序的一种变体，可视为一棵完全二叉树</p>
<p>每个叶结点存放各归并段在归并过程中当前参加比较的记录，内部结点用来记忆左右子树中的‘失败者’，胜利者向上继续进行比较，直到根结点<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gozud6h4ztj31690i9abm.jpg"></p>
]]></content>
      <categories>
        <category>数据结构、算法笔记</category>
      </categories>
  </entry>
  <entry>
    <title>置换-选择排序</title>
    <url>/2019/11/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E7%BD%AE%E6%8D%A2-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<hr>
<p>置换-选择排序：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gp033jfxrfj30t70fntaq.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gp033renu7j30u80idgn5.jpg"></p>
]]></content>
      <categories>
        <category>数据结构、算法笔记</category>
      </categories>
  </entry>
  <entry>
    <title>邻接多重表</title>
    <url>/2019/12/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E9%82%BB%E6%8E%A5%E5%A4%9A%E9%87%8D%E8%A1%A8/</url>
    <content><![CDATA[<hr>
<p>用邻接表存储无向图，每条边的两个顶点分别在该边所依附的两个顶点的边表中，这种重复存储给图的某些操作带来不便，例如对已访问过的边做标记，或者要删除图中某一条边等，都需要找到表示同一条边的两个边表结点。</p>
<p>邻接多重表：主要用于存储无向图<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1govyq7k2ogj311s0u0gpe.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1govyqftxvwj30g10dt3z4.jpg"></p>
]]></content>
      <categories>
        <category>数据结构、算法笔记</category>
      </categories>
  </entry>
  <entry>
    <title>邻接矩阵法</title>
    <url>/2019/12/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E6%B3%95/</url>
    <content><![CDATA[<hr>
<p>图的邻接矩阵存储也称数组表示法，用一个一维数组存储图中的顶点，用一个二维数组存储图中的边，存储顶点之间邻接关系的二维数组称为邻接矩阵<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gov3c5t0isj30w90u0jur.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gov3ceke29j30l60ay0t8.jpg"></p>
<p>邻接矩阵的性质：<br>1）邻接矩阵的空间复杂度为O(n^2)，适用于稠密图<br>2）无向图的邻接矩阵为对称矩阵<br>3）无向图中第i行(或第i列)非0元素(非正无穷)的个数为第i个顶点的度<br>4）有向图中第i行(或第i列)非0元素(非正无穷)的个数为第i个顶点的出度(入度)</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gov42msmkcj31ac0qo76z.jpg"></p>
]]></content>
      <categories>
        <category>数据结构、算法笔记</category>
      </categories>
  </entry>
  <entry>
    <title>邻接表法</title>
    <url>/2019/12/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E9%82%BB%E6%8E%A5%E8%A1%A8%E6%B3%95/</url>
    <content><![CDATA[<hr>
<p>邻接矩阵法存储稀疏图会有许多空间浪费</p>
<p>邻接表法：为每一个顶点建立一个单链表存放与它相邻的边<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1govv2mmd3kj30yy0u0td3.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1govv2vt07ej30ka0dk0tf.jpg"></p>
<p>邻接表的特点：<br>1）若G为无向图，存储空间为O(|V|+2|E|)<br>若G为有向图，存储空间为O(|V|+|E|)<br>2）邻接表更加适用于稀疏图<br>3）若G为无向图，则结点的度为该结点边表的长度<br>若G为有向图，则结点的出度为该结点边表的长度，计算入度则要遍历整个邻接表<br>4）邻接表不唯一，边表结点的顺序根据算法和输入的不同可能会不同</p>
]]></content>
      <categories>
        <category>数据结构、算法笔记</category>
      </categories>
  </entry>
  <entry>
    <title>队列的应用</title>
    <url>/2020/01/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<hr>
<p>队列的应用：</p>
<ol>
<li>树的层次遍历</li>
<li>图的广度优先遍历</li>
<li>队列在操作系统中的应用：多个进程争抢着使用有限的系统资源时，FCFS（First Come First Service，先来先服务）是一种常用策略</li>
<li>打印数据缓冲区：打印机缓冲区用“队列”组织打印数据，可缓解主机与打印机速度不匹配的问题【先来先打印】</li>
</ol>
]]></content>
      <categories>
        <category>数据结构、算法笔记</category>
      </categories>
  </entry>
  <entry>
    <title>队列的基本概念</title>
    <url>/2020/01/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E9%98%9F%E5%88%97%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<hr>
<p>队列的定义：是只允许在一端进行插入，在另一端删除的线性表【空队列、队头：允许删除的一端、队尾：允许插入的一端】</p>
<p>特点：先进入队列的元素先出队【First In First Out(FIFO)】</p>
<p>队列的基本操作：</p>
<ol>
<li><p><code>InitQueue(&amp;Q)</code>：初始化队列，构造一个空队列Q</p>
</li>
<li><p><code>DestroyQueue(&amp;Q)</code>：销毁队列，销毁并释放队列Q所占用的内存空间</p>
</li>
<li><p><code>EnQueue(&amp;Q,x)</code>：入队，若队列Q未满，则将x加入使之成为新队尾</p>
</li>
<li><p><code>DeQueue(&amp;Q,&amp;x)</code>：出队，若队列Q非空，则删除队头元素，并用x返回【删除队头元素】</p>
</li>
<li><p><code>GetHead(Q,&amp;x)</code>：读队头元素，若队列Q非空，则用x返回队头元素【不删除队头元素，查队列的使用场景中大多只访问队头元素】</p>
</li>
<li><p><code>QueueEmpty(Q)</code>：判断一个队列是否为空，若Q为空，则返回true，否则返回false</p>
</li>
</ol>
]]></content>
      <categories>
        <category>数据结构、算法笔记</category>
      </categories>
  </entry>
  <entry>
    <title>队列的顺序实现</title>
    <url>/2020/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E9%98%9F%E5%88%97%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<hr>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1gom5pdlefmj20ms15kgq2.jpg"><br><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1gom5wuc6quj21400u0tc7.jpg"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdbool.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">#define MaxSize 10  &#x2F;&#x2F;定义队列中元素的最大个数</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;队列的顺序实现【front指向队头元素，rear指向队尾元素的后一个位置；还有一种情况是rear指向队尾元素】</span><br><span class="line">typedef struct&#123;</span><br><span class="line">    int data[MaxSize];  &#x2F;&#x2F;用静态数组存放队列元素</span><br><span class="line">    int front,rear;  &#x2F;&#x2F;队头指针和队尾指针</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;int size;  &#x2F;&#x2F;第二种判断队列已满&#x2F;已空的方法，定义一个size：队列当前长度</span><br><span class="line">    &#x2F;&#x2F;int tag;  &#x2F;&#x2F;第三种判断队列已满&#x2F;已空的方法：最近进行的是删除还是插入</span><br><span class="line">&#125;SqQueue;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;初始化队列</span><br><span class="line">void InitQueue(SqQueue *Q)&#123;</span><br><span class="line">    Q-&gt;front&#x3D;Q-&gt;rear&#x3D;0;  &#x2F;&#x2F;初始时队头、队尾指针指向0</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;Q-&gt;size&#x3D;0;  &#x2F;&#x2F;第二种判断队列已满&#x2F;已空的方法，插入成功size++，删除成功size--,队空条件:size&#x3D;&#x3D;0，队满条件：size&#x3D;&#x3D;MaxSize</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;Q-&gt;tag&#x3D;0;  &#x2F;&#x2F;第三种判断队列已满&#x2F;已空的方法：每次删除操作成功时，都令tag&#x3D;0,每次插入操作成功时都令tag&#x3D;1；只有删除操作，才可能导致队空，只有插入操作，才可能导致队满；队空条件：front&#x3D;&#x3D;rear &amp;&amp; tag&#x3D;&#x3D;0，队满条件：front&#x3D;&#x3D;rear &amp;&amp; tag&#x3D;&#x3D;1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;判断队列是否为空</span><br><span class="line">bool QueueEmpty(SqQueue *Q)&#123;</span><br><span class="line">    if(Q-&gt;rear&#x3D;&#x3D;Q-&gt;front)&#123;  &#x2F;&#x2F;队空条件</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;循环队列：入队操作</span><br><span class="line">bool EnQueue(SqQueue *Q,int x)&#123;</span><br><span class="line">    if((Q-&gt;rear+1)%MaxSize &#x3D;&#x3D; Q-&gt;front)&#123;  &#x2F;&#x2F;队列已满的条件：队尾指针的再下一个位置是队头，代价：牺牲一个存储单元</span><br><span class="line">        return false;  &#x2F;&#x2F;队满则报错</span><br><span class="line">    &#125;</span><br><span class="line">    Q-&gt;data[Q-&gt;rear]&#x3D;x;  &#x2F;&#x2F;新元素插入队尾</span><br><span class="line">    Q-&gt;rear&#x3D;(Q-&gt;rear+1)%MaxSize;  &#x2F;&#x2F;队尾指针+1取模,用模运算将存储空间在逻辑上变成了“环状”</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;这是rear指向队尾元素的情况</span><br><span class="line">    &#x2F;&#x2F;Q-&gt;rear&#x3D;(Q-&gt;rear+1)%MaxSize;</span><br><span class="line">    &#x2F;&#x2F;Q-&gt;data[Q-&gt;rear]&#x3D;x;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;循环队列：出队操作</span><br><span class="line">&#x2F;&#x2F;出队：删除一个队头元素，并用x返回</span><br><span class="line">bool DeQueue(SqQueue *Q,int *x)&#123;</span><br><span class="line">    if(Q-&gt;rear&#x3D;&#x3D;Q-&gt;front)&#123;</span><br><span class="line">        return false;  &#x2F;&#x2F;队空则报错</span><br><span class="line">    &#125;</span><br><span class="line">    (*x)&#x3D;Q-&gt;data[Q-&gt;front];</span><br><span class="line">    Q-&gt;front&#x3D;(Q-&gt;front+1)%MaxSize;  &#x2F;&#x2F;队头指针后移</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;获取队头元素的值，用x返回</span><br><span class="line">bool GetHead(SqQueue *Q,int *x)&#123;</span><br><span class="line">    if(Q-&gt;rear&#x3D;&#x3D;Q-&gt;front)&#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    (*x)&#x3D;Q-&gt;data[Q-&gt;front];</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;队列元素个数：(rear+MaxSize-front)%MaxSize</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    SqQueue Q;  &#x2F;&#x2F;声明一个队列，顺序存储</span><br><span class="line">    </span><br><span class="line">    InitQueue(&amp;Q);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;...后续操作</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构、算法笔记</category>
      </categories>
  </entry>
  <entry>
    <title>队列的链式实现</title>
    <url>/2020/01/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E9%98%9F%E5%88%97%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<hr>
<p>顺序存储：预分配的空间耗尽时队满<br>链式存储：一般不会队满，除非内存不足</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1gom7u5es8zj20k01jnq84.jpg"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdbool.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;队列的链式实现(带头结点和不带头结点)</span><br><span class="line">typedef struct LinkNode&#123;  &#x2F;&#x2F;链式队列结点</span><br><span class="line">    int data;</span><br><span class="line">    struct LinkNode *next;</span><br><span class="line">&#125;LinkNode;</span><br><span class="line"></span><br><span class="line">typedef struct&#123;  &#x2F;&#x2F;链式队列</span><br><span class="line">    LinkNode *front,*rear;  &#x2F;&#x2F;队列的队头和队尾指针</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;int length;  &#x2F;&#x2F;求队列的长度</span><br><span class="line">&#125;LinkQueue;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;初始化队列(带头结点)</span><br><span class="line">void InitQueue(LinkQueue *Q)&#123;</span><br><span class="line">    &#x2F;&#x2F;初始时，front、rear都指向头结点</span><br><span class="line">    Q-&gt;front&#x3D;Q-&gt;rear&#x3D;(LinkNode *)malloc(sizeof(LinkNode));</span><br><span class="line">    Q-&gt;front-&gt;next&#x3D;NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;判断队列是否为空</span><br><span class="line">bool IsEmpty(LinkQueue *Q)&#123;</span><br><span class="line">    if(Q-&gt;front&#x3D;&#x3D;Q-&gt;rear)&#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;初始化(不带头结点)</span><br><span class="line">&#x2F;&#x2F;void InitQueue(LinkQueue *Q)&#123;</span><br><span class="line">&#x2F;&#x2F;    &#x2F;&#x2F;初始时，front、rear都指向NULL</span><br><span class="line">&#x2F;&#x2F;    Q-&gt;front&#x3D;NULL;</span><br><span class="line">&#x2F;&#x2F;    Q-&gt;rear&#x3D;NULL;</span><br><span class="line">&#x2F;&#x2F;&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;判断队列是否为空(不带头结点)</span><br><span class="line">&#x2F;&#x2F;bool IsEmpty(LinkQueue *Q)&#123;</span><br><span class="line">&#x2F;&#x2F;    if(Q-&gt;front&#x3D;&#x3D;NULL)&#123;</span><br><span class="line">&#x2F;&#x2F;        return true;</span><br><span class="line">&#x2F;&#x2F;    &#125;</span><br><span class="line">&#x2F;&#x2F;    else&#123;</span><br><span class="line">&#x2F;&#x2F;        return false;</span><br><span class="line">&#x2F;&#x2F;    &#125;</span><br><span class="line">&#x2F;&#x2F;&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;新元素入队(带头结点)</span><br><span class="line">void EnQueue(LinkQueue *Q,int x)&#123;</span><br><span class="line">    LinkNode *s&#x3D;(LinkNode *)malloc(sizeof(LinkNode));</span><br><span class="line">    s-&gt;data&#x3D;x;</span><br><span class="line">    s-&gt;next&#x3D;NULL;</span><br><span class="line">    Q-&gt;rear-&gt;next&#x3D;s;  &#x2F;&#x2F;新结点插入到rear之后</span><br><span class="line">    Q-&gt;rear&#x3D;s;  &#x2F;&#x2F;修改表尾指针</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;新元素入队(不带头结点)</span><br><span class="line">&#x2F;&#x2F;void EnQueue(LinkQueue *Q,int x)&#123;</span><br><span class="line">&#x2F;&#x2F;    LinkNode *s&#x3D;(LinkNode *)malloc(sizeof(LinkNode));</span><br><span class="line">&#x2F;&#x2F;    s-&gt;data&#x3D;x;</span><br><span class="line">&#x2F;&#x2F;    s-&gt;next&#x3D;NULL;</span><br><span class="line">&#x2F;&#x2F;    if(Q-&gt;front &#x3D;&#x3D; NULL)&#123;  &#x2F;&#x2F;在空队列中插入第一个元素</span><br><span class="line">&#x2F;&#x2F;        Q-&gt;front&#x3D;s;  &#x2F;&#x2F;修改队头队尾指针</span><br><span class="line">&#x2F;&#x2F;        Q-&gt;rear&#x3D;s;  &#x2F;&#x2F;不带头结点的队列，第一个元素入队时需要特别处理</span><br><span class="line">&#x2F;&#x2F;    &#125;else&#123;</span><br><span class="line">&#x2F;&#x2F;        Q-&gt;rear-&gt;next&#x3D;s;  &#x2F;&#x2F;新结点插入到rear之后</span><br><span class="line">&#x2F;&#x2F;        Q-&gt;rear&#x3D;s;  &#x2F;&#x2F;修改rear指针</span><br><span class="line">&#x2F;&#x2F;    &#125;</span><br><span class="line">&#x2F;&#x2F;&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;队头元素出队(带头结点)</span><br><span class="line">bool DeQueue(LinkQueue *Q,int *x)&#123;</span><br><span class="line">    if(Q-&gt;front&#x3D;&#x3D;Q-&gt;rear)&#123;</span><br><span class="line">        return false;  &#x2F;&#x2F;空队</span><br><span class="line">    &#125;</span><br><span class="line">    LinkNode *p&#x3D;Q-&gt;front-&gt;next;</span><br><span class="line">    *x&#x3D;p-&gt;data;  &#x2F;&#x2F;用变量x返回队头元素</span><br><span class="line">    Q-&gt;front-&gt;next&#x3D;p-&gt;next;  &#x2F;&#x2F;修改头结点的next指针</span><br><span class="line">    if(Q-&gt;rear&#x3D;&#x3D;p)&#123;  &#x2F;&#x2F;此次是最后一个结点出队</span><br><span class="line">        Q-&gt;rear&#x3D;Q-&gt;front;  &#x2F;&#x2F;修改rear指针</span><br><span class="line">    &#125;</span><br><span class="line">    free(p);  &#x2F;&#x2F;释放结点空间</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;队头元素出队(不带头结点)</span><br><span class="line">&#x2F;&#x2F;bool DeQueue(LinkQueue *Q,int *x)&#123;</span><br><span class="line">&#x2F;&#x2F;    if(Q-&gt;front&#x3D;&#x3D;NULL)&#123;</span><br><span class="line">&#x2F;&#x2F;        return false;  &#x2F;&#x2F;空队</span><br><span class="line">&#x2F;&#x2F;    &#125;</span><br><span class="line">&#x2F;&#x2F;    LinkNode *p&#x3D;Q-&gt;front;  &#x2F;&#x2F;p指向此次出队的结点</span><br><span class="line">&#x2F;&#x2F;    *x&#x3D;p-&gt;data;  &#x2F;&#x2F;用变量x返回队头元素</span><br><span class="line">&#x2F;&#x2F;    Q-&gt;front&#x3D;p-&gt;next;  &#x2F;&#x2F;修改front指针</span><br><span class="line">&#x2F;&#x2F;    if(Q-&gt;rear&#x3D;&#x3D;p)&#123;  &#x2F;&#x2F;此次是最后一个结点出队</span><br><span class="line">&#x2F;&#x2F;        Q-&gt;front&#x3D;NULL;  &#x2F;&#x2F;front指向NULL</span><br><span class="line">&#x2F;&#x2F;        Q-&gt;rear&#x3D;NULL;  &#x2F;&#x2F;rear指向NULL</span><br><span class="line">&#x2F;&#x2F;    &#125;</span><br><span class="line">&#x2F;&#x2F;    free(p);  &#x2F;&#x2F;释放结点空间</span><br><span class="line">&#x2F;&#x2F;    return true;</span><br><span class="line">&#x2F;&#x2F;&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    LinkQueue Q;  &#x2F;&#x2F;声明一个队列</span><br><span class="line">    InitQueue(&amp;Q);  &#x2F;&#x2F;初始化队列</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;...后续操作</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构、算法笔记</category>
      </categories>
  </entry>
  <entry>
    <title>顺序查找</title>
    <url>/2019/12/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<hr>
<p>顺序查找：又称线性查找，主要用于在线性表中进行查找，从线性表的一端向另一端逐个将记录与给定值进行比较，若相等则查找成功，给出该记录在表中的位置；若整个表检测完仍未找到与给定值相等的记录，则查找失败，给出失败信息</p>
<p>对无序线性表进行查找：</p>
<p>对无序线性表进行顺序查找，查找失败时要遍历整个线性表</p>
<p>查找成功的比较次数为(n+1)/2，查找失败的比较次数为n+1【设置哨兵，哨兵就是待查值，存放在查找方向的尽头处，在查找过程中每次比较后，不用判断查找位置是否越界，从而提高了查找速度】<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goxbk9ygzxj30ne09oq3a.jpg"></p>
<p>对有序线性表进行查找：</p>
<p>对关键字有序线性表进行顺序查找，查找失败时不一定要遍历整个线性表<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goxbjs3lc6j30oa0n7t9h.jpg"></p>
<p>有序线性表查找失败的比较次数：n/2+n/(n+1)</p>
]]></content>
      <categories>
        <category>数据结构、算法笔记</category>
      </categories>
  </entry>
  <entry>
    <title>顺序表和链表的比较</title>
    <url>/2020/01/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%92%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E6%AF%94%E8%BE%83/</url>
    <content><![CDATA[<hr>
<p>逻辑结构：都属于线性表，都是线性结构</p>
<p>存储结构：</p>
<ol>
<li>顺序表：顺序存储，优点是支持随机存取，存储密度高；缺点是大片连续空间分配不方便，改变容量不方便</li>
<li>链表：链式存储，优点是离散的小空间分配方便，改变容量方便；缺点是不可随机存取，存储密度低</li>
</ol>
<p>使用场景：</p>
<ol>
<li>链表：表长难以预估，经常要增加/删除元素</li>
<li>顺序表：表长可预估，查询(搜索)操作较多</li>
</ol>
]]></content>
      <categories>
        <category>数据结构、算法笔记</category>
      </categories>
  </entry>
  <entry>
    <title>顺序表的查找</title>
    <url>/2020/01/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<hr>
<h3 id="顺序表的按位查找-时间复杂度：O-1"><a href="#顺序表的按位查找-时间复杂度：O-1" class="headerlink" title="顺序表的按位查找(时间复杂度：O(1))"></a>顺序表的按位查找(时间复杂度：O(1))</h3><p><code>GetElem(L,i)</code>：按位查找操作，获取表L中第i个位置的元素的值</p>
<p>静态分配：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gogv3tacjvj30cd0hxgo2.jpg"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;顺序表的按位查找（静态分配）</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">#define MaxSize 10  &#x2F;&#x2F;定义最大长度</span><br><span class="line"></span><br><span class="line">typedef struct&#123;</span><br><span class="line">    int data[MaxSize];  &#x2F;&#x2F;用静态的“数组”存放数据元素</span><br><span class="line">    int length;  &#x2F;&#x2F;顺序表的当前长度</span><br><span class="line">&#125;SqList;  &#x2F;&#x2F;顺序表的类型定义</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;基本操作：初始化一个顺序表</span><br><span class="line">void InitList(SqList *L)&#123;</span><br><span class="line">    for(int i&#x3D;0;i&lt;MaxSize;i++)&#123;</span><br><span class="line">        L-&gt;data[i]&#x3D;0;  &#x2F;&#x2F;将所有数据元素设置为默认初始值</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;length&#x3D;0;  &#x2F;&#x2F;顺序表初始长度为0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int GetElem(SqList *L,int i)&#123;</span><br><span class="line">    </span><br><span class="line">    return L-&gt;data[i-1];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    </span><br><span class="line">    SqList L;  &#x2F;&#x2F;声明一个顺序表</span><br><span class="line">    InitList(&amp;L);  &#x2F;&#x2F;初始化顺序表</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;...此处插入几个元素</span><br><span class="line">    </span><br><span class="line">    int num&#x3D;GetElem(&amp;L, 3); &#x2F;&#x2F;查找表L中第3个位置的元素的值</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>动态分配：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gogvfevleyj30cj0hbwgv.jpg"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;顺序表的按位查找（动态分配）</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">#define InitSize 10  &#x2F;&#x2F;默认的最大长度</span><br><span class="line"></span><br><span class="line">typedef struct&#123;</span><br><span class="line">    int *data;  &#x2F;&#x2F;指示动态分配数组的指针</span><br><span class="line">    int MaxSize;  &#x2F;&#x2F;顺序表的最大容量</span><br><span class="line">    int length;  &#x2F;&#x2F;顺序表的当前长度</span><br><span class="line">&#125;SeqList;</span><br><span class="line"></span><br><span class="line">void InitList(SeqList *L)&#123;</span><br><span class="line">    &#x2F;&#x2F;用malloc函数申请一片连续的存储空间</span><br><span class="line">    L-&gt;data&#x3D;(int *)malloc(InitSize*sizeof(int));</span><br><span class="line">    L-&gt;length&#x3D;0;</span><br><span class="line">    L-&gt;MaxSize&#x3D;InitSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int GetElem(SeqList *L,int i)&#123;</span><br><span class="line">    </span><br><span class="line">    return L-&gt;data[i-1];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    SeqList L;  &#x2F;&#x2F;声明一个顺序表</span><br><span class="line">    InitList(&amp;L);  &#x2F;&#x2F;初始化顺序表</span><br><span class="line">    &#x2F;&#x2F;...往顺序表加入几个元素</span><br><span class="line">    </span><br><span class="line">    int num&#x3D;GetElem(&amp;L, 3);  &#x2F;&#x2F;查找表L中第3个位置的元素的值</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="顺序表的按值查找-最好O-1-最坏O-n-平均O-n"><a href="#顺序表的按值查找-最好O-1-最坏O-n-平均O-n" class="headerlink" title="顺序表的按值查找(最好O(1),最坏O(n),平均O(n))"></a>顺序表的按值查找(最好O(1),最坏O(n),平均O(n))</h3><p><code>LocateElem(L,e)</code>：按值查找操作，在表L中查找具有给定关键字值的元素</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gogvssfntzj30ds0kawhn.jpg"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;顺序表的按值查找</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">#define InitSize 10  &#x2F;&#x2F;默认的最大长度</span><br><span class="line"></span><br><span class="line">typedef struct&#123;</span><br><span class="line">    int *data;  &#x2F;&#x2F;指示动态分配数组的指针</span><br><span class="line">    int MaxSize;  &#x2F;&#x2F;顺序表的最大容量</span><br><span class="line">    int length;  &#x2F;&#x2F;顺序表的当前长度</span><br><span class="line">&#125;SeqList;</span><br><span class="line"></span><br><span class="line">void InitList(SeqList *L)&#123;</span><br><span class="line">    &#x2F;&#x2F;用malloc函数申请一片连续的存储空间</span><br><span class="line">    L-&gt;data&#x3D;(int *)malloc(InitSize*sizeof(int));</span><br><span class="line">    L-&gt;length&#x3D;0;</span><br><span class="line">    L-&gt;MaxSize&#x3D;InitSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;在顺序表L中查找第一个元素值等于e的元素，并返回其位序</span><br><span class="line">int LocateElem(SeqList *L,int e)&#123;</span><br><span class="line">    </span><br><span class="line">    for(int i&#x3D;0;i&lt;L-&gt;length;i++)&#123;</span><br><span class="line">        if(L-&gt;data[i] &#x3D;&#x3D; e)&#123;</span><br><span class="line">            return i+1;  &#x2F;&#x2F;数组下标为i的元素值等于e，返回其位序i+1</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;  &#x2F;&#x2F;退出循环，说明查找失败</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    SeqList L;  &#x2F;&#x2F;声明一个顺序表</span><br><span class="line">    InitList(&amp;L);  &#x2F;&#x2F;初始化顺序表</span><br><span class="line">    &#x2F;&#x2F;...往顺序表加入几个元素</span><br><span class="line">    </span><br><span class="line">    int num&#x3D;LocateElem(&amp;L, 3);  &#x2F;&#x2F;查找表L中第3个位置的元素的值</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构、算法笔记</category>
      </categories>
  </entry>
  <entry>
    <title>顺序表的定义</title>
    <url>/2020/01/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E5%AE%9A%E4%B9%89/</url>
    <content><![CDATA[<hr>
<p>顺序表：用顺序存储的方式实现线性表，每个结点中只存放数据元素</p>
<p>顺序表的特点：</p>
<ol>
<li>随机访问，即可以在O(1)时间内找到第i个元素</li>
<li>存储密度高，每个节点只存储数据元素</li>
<li>拓展容量不方便（即便采用动态分配的方式实现，拓展长度的时间复杂度也比较高）</li>
<li>插入、删除操作不方便，需要移动大量元素</li>
</ol>
<p>顺序表的实现（静态分配）：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gog1rhd9k7j30cl0e440i.jpg"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;顺序表的静态分配</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">#define MaxSize 10  &#x2F;&#x2F;定义最大长度</span><br><span class="line"></span><br><span class="line">typedef struct&#123;</span><br><span class="line">    int data[MaxSize];  &#x2F;&#x2F;用静态的“数组”存放数据元素</span><br><span class="line">    int length;  &#x2F;&#x2F;顺序表的当前长度</span><br><span class="line">&#125;SqList;  &#x2F;&#x2F;顺序表的类型定义</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;基本操作：初始化一个顺序表</span><br><span class="line">void InitList(SqList *L)&#123;</span><br><span class="line">    for(int i&#x3D;0;i&lt;MaxSize;i++)&#123;</span><br><span class="line">        L-&gt;data[i]&#x3D;0;  &#x2F;&#x2F;将所有数据元素设置为默认初始值</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;length&#x3D;0;  &#x2F;&#x2F;顺序表初始长度为0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    </span><br><span class="line">    SqList L;  &#x2F;&#x2F;声明一个顺序表</span><br><span class="line">    InitList(&amp;L);  &#x2F;&#x2F;初始化顺序表</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;...未完待续，后续操作</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>顺序表的实现（动态分配）：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gog2ljhkusj30de0jgtby.jpg"><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gog3gkodvwj30u00v1tc2.jpg"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;顺序表的动态分配</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">#define InitSize 10  &#x2F;&#x2F;默认的最大长度</span><br><span class="line"></span><br><span class="line">typedef struct&#123;</span><br><span class="line">    int *data;  &#x2F;&#x2F;指示动态分配数组的指针</span><br><span class="line">    int MaxSize;  &#x2F;&#x2F;顺序表的最大容量</span><br><span class="line">    int length;  &#x2F;&#x2F;顺序表的当前长度</span><br><span class="line">&#125;SeqList;</span><br><span class="line"></span><br><span class="line">void InitList(SeqList *L)&#123;</span><br><span class="line">    &#x2F;&#x2F;用malloc函数申请一片连续的存储空间</span><br><span class="line">    L-&gt;data&#x3D;(int *)malloc(InitSize*sizeof(int));</span><br><span class="line">    L-&gt;length&#x3D;0;</span><br><span class="line">    L-&gt;MaxSize&#x3D;InitSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;增加动态数组的长度</span><br><span class="line">void IncreaseSize(SeqList *L,int len)&#123;</span><br><span class="line">    int *p&#x3D;L-&gt;data;</span><br><span class="line">    L-&gt;data&#x3D;(int *)malloc((L-&gt;MaxSize+len)*sizeof(int));</span><br><span class="line">    for(int i&#x3D;0;i&lt;L-&gt;length;i++)&#123;</span><br><span class="line">        L-&gt;data[i]&#x3D;p[i];  &#x2F;&#x2F;将数据复制到新区域</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;MaxSize&#x3D;L-&gt;MaxSize+len;  &#x2F;&#x2F;顺序表最大长度增加len</span><br><span class="line">    free(p);  &#x2F;&#x2F;释放原来的内存空间</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    SeqList L;  &#x2F;&#x2F;声明一个顺序表</span><br><span class="line">    InitList(&amp;L);  &#x2F;&#x2F;初始化顺序表</span><br><span class="line">    &#x2F;&#x2F;往顺序表加入几个元素，加满</span><br><span class="line">    IncreaseSize(&amp;L,5);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构、算法笔记</category>
      </categories>
  </entry>
  <entry>
    <title>顺序表的插入和删除</title>
    <url>/2020/01/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4/</url>
    <content><![CDATA[<hr>
<h3 id="顺序表的插入-最好O-1-最坏O-n-平均O-n"><a href="#顺序表的插入-最好O-1-最坏O-n-平均O-n" class="headerlink" title="顺序表的插入(最好O(1),最坏O(n),平均O(n))"></a>顺序表的插入(最好O(1),最坏O(n),平均O(n))</h3><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gogtua5x02j30ie0p10v4.jpg"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;顺序表的插入</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdbool.h&gt; &#x2F;&#x2F;可以使用bool了</span><br><span class="line"></span><br><span class="line">#define MaxSize 10  &#x2F;&#x2F;定义最大长度</span><br><span class="line"></span><br><span class="line">typedef struct&#123;</span><br><span class="line">    int data[MaxSize];  &#x2F;&#x2F;用静态的“数组”存放数据元素</span><br><span class="line">    int length;  &#x2F;&#x2F;顺序表的当前长度</span><br><span class="line">&#125;SqList;  &#x2F;&#x2F;顺序表的类型定义</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;基本操作：初始化一个顺序表</span><br><span class="line">void InitList(SqList *L)&#123;</span><br><span class="line">    for(int i&#x3D;0;i&lt;MaxSize;i++)&#123;</span><br><span class="line">        L-&gt;data[i]&#x3D;0;  &#x2F;&#x2F;将所有数据元素设置为默认初始值</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;length&#x3D;0;  &#x2F;&#x2F;顺序表初始长度为0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;i的取值：[1,length+1]，因为顺序表是连续排列的</span><br><span class="line">bool ListInsert(SqList *L,int i,int e)&#123;</span><br><span class="line">    </span><br><span class="line">    if(i&lt;1 || i&gt;L-&gt;length+1)&#123;  &#x2F;&#x2F;判断i的范围是否有效</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    if(L-&gt;length &gt;&#x3D; MaxSize)&#123;  &#x2F;&#x2F;当前存储空间已满，不能插入</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for(int j&#x3D;L-&gt;length;j&gt;&#x3D;i;j--)&#123;  &#x2F;&#x2F;将第i个元素及之后的元素后移</span><br><span class="line">        L-&gt;data[i]&#x3D;L-&gt;data[j-1];</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;data[i-1]&#x3D;e;  &#x2F;&#x2F;在位置i处放入e</span><br><span class="line">    L-&gt;length++;  &#x2F;&#x2F;长度加1</span><br><span class="line">    </span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    </span><br><span class="line">    SqList L;  &#x2F;&#x2F;声明一个顺序表</span><br><span class="line">    InitList(&amp;L);  &#x2F;&#x2F;初始化顺序表</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;...此处插入几个元素</span><br><span class="line">    bool b&#x3D;ListInsert(&amp;L, 3, 4);  &#x2F;&#x2F;在位置3处放入4</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="顺序表的删除-最好O-1-最坏O-n-平均O-n"><a href="#顺序表的删除-最好O-1-最坏O-n-平均O-n" class="headerlink" title="顺序表的删除(最好O(1),最坏O(n),平均O(n))"></a>顺序表的删除(最好O(1),最坏O(n),平均O(n))</h3><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gogupeoxndj30ih0u0go3.jpg"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;顺序表的删除</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdbool.h&gt; &#x2F;&#x2F;可以使用bool了</span><br><span class="line"></span><br><span class="line">#define MaxSize 10  &#x2F;&#x2F;定义最大长度</span><br><span class="line"></span><br><span class="line">typedef struct&#123;</span><br><span class="line">    int data[MaxSize];  &#x2F;&#x2F;用静态的“数组”存放数据元素</span><br><span class="line">    int length;  &#x2F;&#x2F;顺序表的当前长度</span><br><span class="line">&#125;SqList;  &#x2F;&#x2F;顺序表的类型定义</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;基本操作：初始化一个顺序表</span><br><span class="line">void InitList(SqList *L)&#123;</span><br><span class="line">    for(int i&#x3D;0;i&lt;MaxSize;i++)&#123;</span><br><span class="line">        L-&gt;data[i]&#x3D;0;  &#x2F;&#x2F;将所有数据元素设置为默认初始值</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;length&#x3D;0;  &#x2F;&#x2F;顺序表初始长度为0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool ListDelete(SqList *L,int i,int *e)&#123;</span><br><span class="line">    </span><br><span class="line">    if(i&lt;1 || i&gt;L-&gt;length)&#123;  &#x2F;&#x2F;判断i的范围是否有效</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    *e&#x3D;L-&gt;data[i-1];  &#x2F;&#x2F;将被删除的元素赋值给e</span><br><span class="line">    </span><br><span class="line">    for(int j&#x3D;i;j&lt;L-&gt;length;j++)&#123;  &#x2F;&#x2F;将第i个位置后的元素前移</span><br><span class="line">        L-&gt;data[j-1]&#x3D;L-&gt;data[j];</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;length--;  &#x2F;&#x2F;线性表长度减1</span><br><span class="line">    </span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    </span><br><span class="line">    SqList L;  &#x2F;&#x2F;声明一个顺序表</span><br><span class="line">    InitList(&amp;L);  &#x2F;&#x2F;初始化顺序表</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;...此处插入几个元素</span><br><span class="line">    int e&#x3D;-1;  &#x2F;&#x2F;用变量e把删除的元素“带回来”</span><br><span class="line">    if(ListDelete(&amp;L, 3, &amp;e))&#123;</span><br><span class="line">        printf(&quot;已删除第3个元素，删除元素值为%d\n&quot;,e);</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        printf(&quot;位序i不合法，删除失败\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构、算法笔记</category>
      </categories>
  </entry>
  <entry>
    <title>静态链表</title>
    <url>/2020/01/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<hr>
<p>静态链表：用数组的方式实现的链表</p>
<p>优点：增、删操作不需要大量移动元素<br>缺点：不能随机存取，只能从头结点开始依次往后查找；容量固定不可变</p>
<p>适用场景：不支持指针的低级语言；数据元素数量固定不变的场景(如操作系统的文件分配表FAT)</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1gokd8xoak8j20u00vg0vx.jpg"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdbool.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">#define MaxSize 10  &#x2F;&#x2F;静态链表的最大长度</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;用代码定义一个静态链表</span><br><span class="line">struct Node&#123;</span><br><span class="line">    int data;  &#x2F;&#x2F;存储数据元素</span><br><span class="line">    int next;  &#x2F;&#x2F;下一个元素的数组下标</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;初始化静态链表：把a[0]的next设为-1，把其他结点的next设为一个特殊值用来表示结点空闲，如-2</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;查找：从头结点出发挨个往后遍历结点（O(n)）</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;插入位序为i的结点：1.找到一个空的结点，存入数据元素【如何判断结点为空？通过特殊值来判断】 2.从头结点出发找到位序为i-1的结点 3.修改i-1号结点的next 4.修改新结点的next</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;删除某个结点：1.从头结点出发找到前驱结点 2.修改前驱结点的游标 3.被删除结点的next设为特殊值</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    </span><br><span class="line">    struct Node a[MaxSize];  &#x2F;&#x2F;数组a作为静态链表</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;...后续代码</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构、算法笔记</category>
      </categories>
  </entry>
  <entry>
    <title>Markdown教程</title>
    <url>/2020/10/25/Apple%E3%80%81Linux/macOS%E3%80%81Ubuntu%20Server/Markdown%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<p>——————————————————————————</p>
<h2 id="Markdown介绍"><a href="#Markdown介绍" class="headerlink" title="Markdown介绍"></a>Markdown介绍</h2><p>Markdown是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档</p>
<p>Markdown编写的文档可以导出HTML、Word、图像、PDF、Epub等多种格式的文档</p>
<p>Markdown编写的文档后缀为.md、.markdown</p>
<p>macOS系统推荐使用Typora编辑器</p>
<h2 id="Markdown标题"><a href="#Markdown标题" class="headerlink" title="Markdown标题"></a>Markdown标题</h2><p>使用<code>#</code>号可表示1～6级标题，一级标题对应一个<code>#</code>号，二级标题对应两个<code>#</code>号，以此类推</p>
<p><code># 一级标题</code></p>
<p><code>## 二级标题</code></p>
<p><code>### 三级标题</code></p>
<p><code>#### 四级标题</code></p>
<p><code>##### 五级标题</code></p>
<p><code>###### 六级标题</code></p>
<h2 id="Markdown段落格式"><a href="#Markdown段落格式" class="headerlink" title="Markdown段落格式"></a>Markdown段落格式</h2><h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><p>Markdown可以使用以下几种字体：</p>
<p><em>斜体文本</em><br><em>斜体文本</em><br><strong>粗体文本</strong><br><strong>粗体文本</strong><br><strong><em>粗斜体文本</em></strong><br><strong><em>粗斜体文本</em></strong></p>
<h3 id="分隔线"><a href="#分隔线" class="headerlink" title="分隔线"></a>分隔线</h3><p>可以在一行中用三个以上的星号、减号来建立一个分隔线，行内不能有其他东西</p>
<h3 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h3><p>如果段落上的文字要添加删除线，只需要在文字的两端加上两个波浪线<code>~~</code>即可：<del>删除的文本</del></p>
<h3 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h3><p>下划线可以通过HTML的<code>&lt;u&gt;</code>标签来实现：<u>带下划线文本</u></p>
<h3 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h3><p>脚注是对文本的补充说明</p>
<p>王者荣耀<a href="%E8%BF%99%E6%98%AF%E4%B8%80%E6%AC%BE%E6%89%8B%E6%B8%B8">^ 注释</a></p>
<h2 id="Markdown列表"><a href="#Markdown列表" class="headerlink" title="Markdown列表"></a>Markdown列表</h2><h3 id="Markdown支持有序列表和无序列表"><a href="#Markdown支持有序列表和无序列表" class="headerlink" title="Markdown支持有序列表和无序列表"></a>Markdown支持有序列表和无序列表</h3><p>无序列表使用星号<code>*</code>、加号<code>+</code>或者减号<code>-</code>作为列表标记，这些标记后面要添加一个空格，然后再填写内容</p>
<ul>
<li>第一项</li>
<li>第二项</li>
</ul>
<ul>
<li>第一项</li>
<li>第二项</li>
</ul>
<ul>
<li>第一项</li>
<li>第二项</li>
</ul>
<p>有序列表使用数字并加上<code>.</code>号来表示</p>
<ol>
<li>第一项</li>
<li>第二项</li>
</ol>
<h3 id="列表嵌套"><a href="#列表嵌套" class="headerlink" title="列表嵌套"></a>列表嵌套</h3><p>列表嵌套只需在子列表中的选项前面添加四个空格即可</p>
<ol>
<li>第一项<ul>
<li>第一项嵌套的第一个元素</li>
<li>第一项嵌套的第二个元素</li>
</ul>
</li>
<li>第二项<ul>
<li>第二项嵌套的第一个元素</li>
<li>第二项嵌套的第二个元素</li>
</ul>
</li>
</ol>
<h2 id="Markdown区块"><a href="#Markdown区块" class="headerlink" title="Markdown区块"></a>Markdown区块</h2><h3 id="区块引用"><a href="#区块引用" class="headerlink" title="区块引用"></a>区块引用</h3><p>Markdown区块引用是在段落开头使用<code>&gt;</code>符号，然后后面紧跟一个空格符号</p>
<blockquote>
<p>区块引用一</p>
<p>区块引用二</p>
</blockquote>
<h3 id="区块嵌套"><a href="#区块嵌套" class="headerlink" title="区块嵌套"></a>区块嵌套</h3><p>另外区块也是可以嵌套的，一个<code>&gt;</code>符号是最外层，两个<code>&gt;</code>符号是第一层嵌套，以此类推</p>
<blockquote>
<p>最外层</p>
<blockquote>
<p>第一层嵌套</p>
<blockquote>
<p>第二层嵌套</p>
</blockquote>
</blockquote>
</blockquote>
<h3 id="区块中使用列表"><a href="#区块中使用列表" class="headerlink" title="区块中使用列表"></a>区块中使用列表</h3><blockquote>
<p>区块中使用列表</p>
<ol>
<li>第一项</li>
<li>第二项</li>
</ol>
<ul>
<li>第一项</li>
<li>第二项</li>
</ul>
</blockquote>
<h3 id="列表中使用区块"><a href="#列表中使用区块" class="headerlink" title="列表中使用区块"></a>列表中使用区块</h3><p>如果要在列表项目内放进区块，那么就需要在<code>&gt;</code>前添加四个空格的缩进</p>
<ul>
<li><p>第一项</p>
<blockquote>
<p>区块一</p>
<p>区块二</p>
</blockquote>
</li>
<li><p>第二项</p>
</li>
</ul>
<h2 id="Markdown代码"><a href="#Markdown代码" class="headerlink" title="Markdown代码"></a>Markdown代码</h2><p>如果是段落上的一个函数或片段的代码可以用反引号把它包起来</p>
<p><code>print(&#39;hello&#39;)</code></p>
<h3 id="代码区块"><a href="#代码区块" class="headerlink" title="代码区块"></a>代码区块</h3><p>可以指定一种语言</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Markdown链接"><a href="#Markdown链接" class="headerlink" title="Markdown链接"></a>Markdown链接</h2><p><code>[链接名称](链接地址)</code></p>
<p><code>&lt;链接地址&gt;</code></p>
<p><a href="https://www.baidu.com/">百度</a></p>
<p><a href="https://www.baidu.com/">https://www.baidu.com</a></p>
<h3 id="高级链接"><a href="#高级链接" class="headerlink" title="高级链接"></a>高级链接</h3><p>我们可以通过变量来设置一个链接，变量赋值在文档末尾进行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">这个链接用 1 作为网址变量 [Google][1]</span><br><span class="line">这个链接用 runoob 作为网址变量 [Runoob][runoob]</span><br><span class="line">然后在文档的结尾为变量赋值（网址）</span><br><span class="line"></span><br><span class="line">  [1]: http:&#x2F;&#x2F;www.google.com&#x2F;</span><br><span class="line">  [runoob]: http:&#x2F;&#x2F;www.runoob.com&#x2F;</span><br></pre></td></tr></table></figure>

<p>这个链接用 1 作为网址变量 <a href="http://www.google.com/">Google</a><br>这个链接用 runoob 作为网址变量 <a href="http://www.runoob.com/">Runoob</a><br>然后在文档的结尾为变量赋值（网址）</p>
<h2 id="Markdown图片"><a href="#Markdown图片" class="headerlink" title="Markdown图片"></a>Markdown图片</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">![alt 属性文本](图片地址)</span><br><span class="line"></span><br><span class="line">![alt 属性文本](图片地址 &quot;可选标题&quot;)</span><br></pre></td></tr></table></figure>

<p><img src="/Users/liaojialong/Pictures/%E5%A3%81%E7%BA%B82.jpeg" alt="alt 汽车" title="跑车"></p>
<p>Markdown还没办法指定图片的高度和宽度，如果需要的话，可以使用普通的<img>标签</p>
<img src="/Users/liaojialong/Library/Application Support/typora-user-images/image-20210523195705235.png" width="25%">

<h2 id="Markdown表格"><a href="#Markdown表格" class="headerlink" title="Markdown表格"></a>Markdown表格</h2><p>Markdown制作表格使用<code>|</code>来分隔不同的单元格</p>
<p><code>| 表头 | 表头 |</code></p>
<table>
<thead>
<tr>
<th align="center">表头</th>
<th>表头</th>
</tr>
</thead>
<tbody><tr>
<td align="center">单元格</td>
<td>单元格</td>
</tr>
<tr>
<td align="center">单元格</td>
<td>单元格</td>
</tr>
</tbody></table>
<h2 id="Markdown高级技巧"><a href="#Markdown高级技巧" class="headerlink" title="Markdown高级技巧"></a>Markdown高级技巧</h2><h3 id="支持的HTML元素"><a href="#支持的HTML元素" class="headerlink" title="支持的HTML元素"></a>支持的HTML元素</h3><p>不在Markdown涵盖范围之内的标签，都可以直接在文档里面用HTML撰写，目前支持的HTML元素有<code>&lt;kbd&gt;</code>、<code>&lt;b&gt;</code>、<code>&lt;i&gt;</code>、<code>&lt;em&gt;</code>、<code>&lt;sup&gt;</code>、<code>&lt;sub&gt;</code>、<code>&lt;br&gt;</code>等</p>
<p>使用<kbd>Ctrl</kbd> + <kbd>Alt</kbd> + <kbd>Del</kbd> 重启电脑</p>
<h3 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h3><p>Markdown使用了很多特殊符号来表示特定的意义，如果需要显示特定的符号则需要使用转义字符，Markdown使用反斜杠转义特殊字符</p>
<p><strong>文本加粗</strong></p>
<p>** 正常显示星号 **</p>
<p>Markdown支持以下这些符号前面加上反斜杠来帮助插入普通的符号：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\   反斜线</span><br><span class="line">&#96;   反引号</span><br><span class="line">*   星号</span><br><span class="line">_   下划线</span><br><span class="line">&#123;&#125;  花括号</span><br><span class="line">[]  方括号</span><br><span class="line">()  小括号</span><br><span class="line">#   井字号</span><br><span class="line">+   加号</span><br><span class="line">-   减号</span><br><span class="line">.   英文句点</span><br><span class="line">!   感叹号</span><br></pre></td></tr></table></figure>

<h3 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h3><p>当你需要在编辑器中插入数学公式时，可以使用两个美元符<code>$$</code>包裹<code>TeX</code>或<code>LaTeX</code>格式的数学公式来实现，提交后，问答和文章页会根据需要加载<code>Mathjax</code>对数学公式进行渲染</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$$</span><br><span class="line">\mathbf&#123;V&#125;_1 \times \mathbf&#123;V&#125;_2 &#x3D;  \begin&#123;vmatrix&#125; </span><br><span class="line">\mathbf&#123;i&#125; &amp; \mathbf&#123;j&#125; &amp; \mathbf&#123;k&#125; \\</span><br><span class="line">\frac&#123;\partial X&#125;&#123;\partial u&#125; &amp;  \frac&#123;\partial Y&#125;&#123;\partial u&#125; &amp; 0 \\</span><br><span class="line">\frac&#123;\partial X&#125;&#123;\partial v&#125; &amp;  \frac&#123;\partial Y&#125;&#123;\partial v&#125; &amp; 0 \\</span><br><span class="line">\end&#123;vmatrix&#125;</span><br><span class="line">$&#123;$tep1&#125;&#123;\style&#123;visibility:hidden&#125;&#123;(x+1)(x+1)&#125;&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure>

<p>$$<br>\mathbf{V}_1 \times \mathbf{V}_2 =  \begin{vmatrix}<br>\mathbf{i} &amp; \mathbf{j} &amp; \mathbf{k} \<br>\frac{\partial X}{\partial u} &amp;  \frac{\partial Y}{\partial u} &amp; 0 \<br>\frac{\partial X}{\partial v} &amp;  \frac{\partial Y}{\partial v} &amp; 0 \<br>\end{vmatrix}<br>${$tep1}{\style{visibility:hidden}{(x+1)(x+1)}}<br>$$</p>
]]></content>
      <categories>
        <category>Apple、Linux</category>
      </categories>
      <tags>
        <tag>macOS、Ubuntu Server</tag>
      </tags>
  </entry>
  <entry>
    <title>macOS的一些使用小技巧：</title>
    <url>/2018/11/30/Apple%E3%80%81Linux/macOS%E3%80%81Ubuntu%20Server/macOS%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BD%BF%E7%94%A8%E5%B0%8F%E6%8A%80%E5%B7%A7%EF%BC%9A/</url>
    <content><![CDATA[<hr>
<ol>
<li>在任意输入框中按option+shift+K组合键会显示苹果logo</li>
<li>文本编辑中按Fn+Delete键可向后删除内容</li>
<li>Finder+菜单栏中的前往+一直按住option，打开资源库</li>
<li>终端输入sudo spctl —master-disable命令打开【安全性与隐私】中的【任何来源】</li>
<li>隐藏和恢复桌面文件：<br>隐藏桌面文件：defaults write com.apple.finder CreateDesktop -bool false;<br>killall Finder<br>恢复显示桌面文件：defaults write com.apple.finder CreateDesktop -bool true;<br>killall Finder</li>
<li>快速调用emoji表情：control+command+空格</li>
<li>CheatSheet:长按command键可显示当前应用所有的快捷键</li>
<li>调整launchpad图标大小： </li>
</ol>
<p>改行数：defaults write com.apple.dock springboard-rows -int 10<br>改列数：defaults write com.apple.dock springboard-columns int 7<br>killall Dock </p>
<p>恢复系统默认：<br>defaults write com.apple.dock springboard-rows Default<br>defaults write com.apple.dock springboard-columns Default<br>killall Dock</p>
<ol start="9">
<li>移动文件：打开源文件夹和目标文件夹，拖拽源文件到目标文件夹<br>拷贝文件：按住option，拖拽源文件到目标文件夹 </li>
<li>全屏截图：command+shift+3<br>截取部分屏幕：command+shift+4</li>
<li>回到桌面：command+F3</li>
</ol>
]]></content>
      <categories>
        <category>Apple、Linux</category>
      </categories>
      <tags>
        <tag>macOS、Ubuntu Server</tag>
      </tags>
  </entry>
  <entry>
    <title>macOS终端ssh远程连接Ubuntu server：</title>
    <url>/2018/11/29/Apple%E3%80%81Linux/macOS%E3%80%81Ubuntu%20Server/macOS%E7%BB%88%E7%AB%AFssh%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5Ubuntu%20server%EF%BC%9A/</url>
    <content><![CDATA[<hr>
<p>原因：</p>
<ol>
<li><p>Ubuntu server虚拟机界面实在是不如Mac终端好操作</p>
</li>
<li><p>Linux下的命令与UNIX很多不一样，无法直接在macOS下学习Linux</p>
</li>
</ol>
<hr>
<p>步骤：</p>
<ol>
<li><p>Ubuntu系统默认安装了openssh-client，但没有安装openssh-server，<br>先检查一下(ps -e | grep ssh)</p>
</li>
<li><p>安装openssh-server：sudo apt-get install openssh-server</p>
</li>
<li><p>如果出现sshd，代表安装成功【sudo /etc/init.d/ssh start启动服务】</p>
</li>
<li><p>ifconfig -a查看IP地址</p>
</li>
<li><p>ssh 用户名@IP地址 </p>
</li>
</ol>
]]></content>
      <categories>
        <category>Apple、Linux</category>
      </categories>
      <tags>
        <tag>macOS、Ubuntu Server</tag>
      </tags>
  </entry>
  <entry>
    <title>本地项目上传至GitHub</title>
    <url>/2021/05/11/Apple%E3%80%81Linux/macOS%E3%80%81Ubuntu%20Server/%E6%9C%AC%E5%9C%B0%E9%A1%B9%E7%9B%AE%E4%B8%8A%E4%BC%A0%E8%87%B3GitHub/</url>
    <content><![CDATA[<hr>
<h3 id="首次使用"><a href="#首次使用" class="headerlink" title="首次使用"></a>首次使用</h3><ol>
<li><p>配置SSH</p>
<p>⭐️cd 项目文件夹</p>
<p>⭐️git init</p>
<p>⭐️ssh-keygen -t rsa -C “<a href="mailto:&#x32;&#x36;&#54;&#x38;&#56;&#x30;&#x32;&#x35;&#x37;&#x30;&#x40;&#113;&#x71;&#46;&#99;&#x6f;&#109;">&#x32;&#x36;&#54;&#x38;&#56;&#x30;&#x32;&#x35;&#x37;&#x30;&#x40;&#113;&#x71;&#46;&#99;&#x6f;&#109;</a>“</p>
<p>⭐️pbcopy &lt; ~/.ssh/id_rsa.pub  #将ssh代码复制到剪贴板</p>
<p>⭐️回到GitHub界面，将刚才生成的ssh配置到GitHub里</p>
<p>⭐️ssh -T <a href="mailto:&#103;&#x69;&#116;&#64;&#x67;&#105;&#x74;&#104;&#x75;&#x62;&#46;&#x63;&#111;&#x6d;">&#103;&#x69;&#116;&#64;&#x67;&#105;&#x74;&#104;&#x75;&#x62;&#46;&#x63;&#111;&#x6d;</a>  #验证是否添加ssh成功了</p>
</li>
<li><p>开始上传代码</p>
<p>⭐️git clone 仓库地址</p>
<p>⭐️cd 仓库</p>
<p>⭐️git add –all</p>
<p>⭐️git commit -m “第1次上传”</p>
<p>⭐️git push</p>
</li>
</ol>
<h3 id="以后使用"><a href="#以后使用" class="headerlink" title="以后使用"></a>以后使用</h3><p>   ⭐️cd 项目文件夹</p>
<p>   ⭐️执行步骤2</p>
]]></content>
      <categories>
        <category>Apple、Linux</category>
      </categories>
      <tags>
        <tag>macOS、Ubuntu Server</tag>
      </tags>
  </entry>
</search>
